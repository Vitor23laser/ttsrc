/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/tform -Ipanda/src/tform -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libtform_igate.cxx -od built_Rocket/pandac/input/libtform.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/tform -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDA -module panda -library libtform buttonThrower.h config_tform.h driveInterface.h mouseInterfaceNode.h mouseSubregion.h mouseWatcher.h mouseWatcherGroup.h mouseWatcherParameter.h mouseWatcherRegion.h tform_composite.cxx trackball.h transform2sg.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libtform
#include "py_panda.h"  

#include "bitArray.h"
#include "buttonEventList.h"
#include "buttonHandle.h"
#include "buttonThrower.h"
#include "clockObject.h"
#include "configVariableDouble.h"
#include "config_tform.h"
#include "dataNode.h"
#include "displayRegion.h"
#include "driveInterface.h"
#include "eventHandler.h"
#include "eventParameter.h"
#include "linmath_events.h"
#include "luse.h"
#include "modifierButtons.h"
#include "mouseInterfaceNode.h"
#include "mouseSubregion.h"
#include "mouseWatcher.h"
#include "mouseWatcherGroup.h"
#include "mouseWatcherParameter.h"
#include "mouseWatcherRegion.h"
#include "notifyCategoryProxy.h"
#include "pandabase.h"
#include "pmap.h"
#include "pointerEvent.h"
#include "pointerEventList.h"
#include "pointerTo.h"
#include "pvector.h"
#include "textEncoder.h"
#include "trackball.h"
#include "transform2sg.h"
#include "transformState.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. ButtonThrower
//********************************************************************
typedef  ButtonThrower  ButtonThrower_localtype;
Define_Module_ClassRef(panda,ButtonThrower,ButtonThrower_localtype,ButtonThrower);
//********************************************************************
//*** prototypes for .. MouseInterfaceNode
//********************************************************************
typedef  MouseInterfaceNode  MouseInterfaceNode_localtype;
Define_Module_ClassRef(panda,MouseInterfaceNode,MouseInterfaceNode_localtype,MouseInterfaceNode);
//********************************************************************
//*** prototypes for .. DriveInterface
//********************************************************************
typedef  DriveInterface  DriveInterface_localtype;
Define_Module_ClassRef(panda,DriveInterface,DriveInterface_localtype,DriveInterface);
//********************************************************************
//*** prototypes for .. MouseSubregion
//********************************************************************
typedef  MouseSubregion  MouseSubregion_localtype;
Define_Module_ClassRef(panda,MouseSubregion,MouseSubregion_localtype,MouseSubregion);
//********************************************************************
//*** prototypes for .. MouseWatcherRegion
//********************************************************************
typedef  MouseWatcherRegion  MouseWatcherRegion_localtype;
Define_Module_ClassRef(panda,MouseWatcherRegion,MouseWatcherRegion_localtype,MouseWatcherRegion);
//********************************************************************
//*** prototypes for .. MouseWatcherGroup
//********************************************************************
typedef  MouseWatcherGroup  MouseWatcherGroup_localtype;
Define_Module_ClassRef(panda,MouseWatcherGroup,MouseWatcherGroup_localtype,MouseWatcherGroup);
//********************************************************************
//*** prototypes for .. MouseWatcher
//********************************************************************
typedef  MouseWatcher  MouseWatcher_localtype;
Define_Module_ClassRef(panda,MouseWatcher,MouseWatcher_localtype,MouseWatcher);
//********************************************************************
//*** prototypes for .. MouseWatcherParameter
//********************************************************************
typedef  MouseWatcherParameter  MouseWatcherParameter_localtype;
Define_Module_Class(panda,MouseWatcherParameter,MouseWatcherParameter_localtype,MouseWatcherParameter);
//********************************************************************
//*** prototypes for .. Trackball
//********************************************************************
typedef  Trackball  Trackball_localtype;
Define_Module_ClassRef(panda,Trackball,Trackball_localtype,Trackball);
//********************************************************************
//*** prototypes for .. Transform2SG
//********************************************************************
typedef  Transform2SG  Transform2SG_localtype;
Define_Module_ClassRef(panda,Transform2SG,Transform2SG_localtype,Transform2SG);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ButtonHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_DataNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_DisplayRegion;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_EventHandler;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_EventParameter;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_GeomNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LMatrix4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LPoint2f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LPoint3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ModifierButtons;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Namable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_NodePath;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PandaNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PointerEventList;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TextEncoder;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. ButtonThrower 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void ButtonThrower::set_button_down_event(basic_string< char > const &button_down_event)
 *******************************************************************/
static PyObject *Dtool_ButtonThrower_set_button_down_event_4(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonThrower * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonThrower,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ButtonThrower::set_button_down_event(basic_string< char > const &button_down_event)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"button_down_event", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setButtonDownEvent", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setButtonDownEvent", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_button_down_event(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ButtonThrower.setButtonDownEvent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setButtonDownEvent(non-const ButtonThrower this, string button_down_event)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonThrower_set_button_down_event_4_comment =
    "C++ Interface:\n"
    "setButtonDownEvent(non-const ButtonThrower this, string button_down_event)\n"
    "\n"
    "// Filename: buttonThrower.I\n"
    "// Created by:  drose (26Dec03)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonThrower::set_button_down_event\n"
    "//       Access: Published\n"
    "//  Description: Specifies the generic event that is generated (if\n"
    "//               any) each time a key or button is depressed.  Unlike\n"
    "//               the specific events that are unique to each key, this\n"
    "//               same event name is used for *all* button events, and\n"
    "//               the name of the button pressed (possibly with\n"
    "//               modifier prefixes) will be sent as a parameter.\n"
    "//\n"
    "//               If this string is empty, no event is generated.  It\n"
    "//               is possible to generate both generic events and\n"
    "//               specific events for the same button.\n"
    "//\n"
    "//               See also set_keystroke_event().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonThrower_set_button_down_event_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &ButtonThrower::get_button_down_event(void) const
 *******************************************************************/
static PyObject *Dtool_ButtonThrower_get_button_down_event_5(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonThrower * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonThrower,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &ButtonThrower::get_button_down_event(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getButtonDownEvent", key_word_list));
        else
            (PyArg_Parse(args, ":getButtonDownEvent"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const ButtonThrower*)local_this)->get_button_down_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getButtonDownEvent(const ButtonThrower this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonThrower_get_button_down_event_5_comment =
    "C++ Interface:\n"
    "getButtonDownEvent(const ButtonThrower this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonThrower::get_button_down_event\n"
    "//       Access: Published\n"
    "//  Description: Returns the button_down_event that has been set on\n"
    "//               this ButtonThrower.  See set_button_down_event().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonThrower_get_button_down_event_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ButtonThrower::set_button_up_event(basic_string< char > const &button_up_event)
 *******************************************************************/
static PyObject *Dtool_ButtonThrower_set_button_up_event_6(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonThrower * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonThrower,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ButtonThrower::set_button_up_event(basic_string< char > const &button_up_event)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"button_up_event", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setButtonUpEvent", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setButtonUpEvent", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_button_up_event(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ButtonThrower.setButtonUpEvent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setButtonUpEvent(non-const ButtonThrower this, string button_up_event)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonThrower_set_button_up_event_6_comment =
    "C++ Interface:\n"
    "setButtonUpEvent(non-const ButtonThrower this, string button_up_event)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonThrower::set_button_up_event\n"
    "//       Access: Published\n"
    "//  Description: Specifies the generic event that is generated (if\n"
    "//               any) each time a key or button is released.  See\n"
    "//               set_button_down_event().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonThrower_set_button_up_event_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &ButtonThrower::get_button_up_event(void) const
 *******************************************************************/
static PyObject *Dtool_ButtonThrower_get_button_up_event_7(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonThrower * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonThrower,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &ButtonThrower::get_button_up_event(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getButtonUpEvent", key_word_list));
        else
            (PyArg_Parse(args, ":getButtonUpEvent"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const ButtonThrower*)local_this)->get_button_up_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getButtonUpEvent(const ButtonThrower this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonThrower_get_button_up_event_7_comment =
    "C++ Interface:\n"
    "getButtonUpEvent(const ButtonThrower this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonThrower::get_button_up_event\n"
    "//       Access: Published\n"
    "//  Description: Returns the button_up_event that has been set on\n"
    "//               this ButtonThrower.  See set_button_up_event().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonThrower_get_button_up_event_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ButtonThrower::set_button_repeat_event(basic_string< char > const &button_repeat_event)
 *******************************************************************/
static PyObject *Dtool_ButtonThrower_set_button_repeat_event_8(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonThrower * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonThrower,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ButtonThrower::set_button_repeat_event(basic_string< char > const &button_repeat_event)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"button_repeat_event", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setButtonRepeatEvent", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setButtonRepeatEvent", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_button_repeat_event(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ButtonThrower.setButtonRepeatEvent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setButtonRepeatEvent(non-const ButtonThrower this, string button_repeat_event)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonThrower_set_button_repeat_event_8_comment =
    "C++ Interface:\n"
    "setButtonRepeatEvent(non-const ButtonThrower this, string button_repeat_event)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonThrower::set_button_repeat_event\n"
    "//       Access: Published\n"
    "//  Description: Specifies the generic event that is generated (if\n"
    "//               any) repeatedly while a key or button is held down.\n"
    "//               Unlike the specific events that are unique to each\n"
    "//               key, this same event name is used for *all* button\n"
    "//               events, and the name of the button pressed (possibly\n"
    "//               with modifier prefixes) will be sent as a parameter.\n"
    "//\n"
    "//               If this string is empty, no event is generated.  It\n"
    "//               is possible to generate both generic events and\n"
    "//               specific events for the same button.\n"
    "//\n"
    "//               See also set_keystroke_event().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonThrower_set_button_repeat_event_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &ButtonThrower::get_button_repeat_event(void) const
 *******************************************************************/
static PyObject *Dtool_ButtonThrower_get_button_repeat_event_9(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonThrower * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonThrower,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &ButtonThrower::get_button_repeat_event(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getButtonRepeatEvent", key_word_list));
        else
            (PyArg_Parse(args, ":getButtonRepeatEvent"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const ButtonThrower*)local_this)->get_button_repeat_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getButtonRepeatEvent(const ButtonThrower this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonThrower_get_button_repeat_event_9_comment =
    "C++ Interface:\n"
    "getButtonRepeatEvent(const ButtonThrower this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonThrower::get_button_repeat_event\n"
    "//       Access: Published\n"
    "//  Description: Returns the button_repeat_event that has been set on\n"
    "//               this ButtonThrower.  See set_button_repeat_event().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonThrower_get_button_repeat_event_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ButtonThrower::set_keystroke_event(basic_string< char > const &keystroke_event)
 *******************************************************************/
static PyObject *Dtool_ButtonThrower_set_keystroke_event_10(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonThrower * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonThrower,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ButtonThrower::set_keystroke_event(basic_string< char > const &keystroke_event)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"keystroke_event", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setKeystrokeEvent", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setKeystrokeEvent", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_keystroke_event(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ButtonThrower.setKeystrokeEvent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setKeystrokeEvent(non-const ButtonThrower this, string keystroke_event)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonThrower_set_keystroke_event_10_comment =
    "C++ Interface:\n"
    "setKeystrokeEvent(non-const ButtonThrower this, string keystroke_event)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonThrower::set_keystroke_event\n"
    "//       Access: Published\n"
    "//  Description: Specifies the event that is generated (if any) for\n"
    "//               each keystroke that is received.  A keystroke is\n"
    "//               different than a button event: it represents the\n"
    "//               semantic meaning of the sequence of keys that have\n"
    "//               been pressed.  For instance, pressing shift and 4\n"
    "//               together will generate the button event \"shift-4\",\n"
    "//               but it will generate the keystroke \"$\".\n"
    "//\n"
    "//               If a key is held down, keyrepeat will cause the same\n"
    "//               keystroke event to be generated repeatedly.  This is\n"
    "//               different from the corresponding down event, which\n"
    "//               will only be generated once, followed by a number of\n"
    "//               button repeat events.\n"
    "//\n"
    "//               This event is generated with a single wstring\n"
    "//               parameter, which is a one-character string that\n"
    "//               contains the keystroke generated.  If this event\n"
    "//               string is empty, no event is generated.\n"
    "//\n"
    "//               See also set_button_down_event().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonThrower_set_keystroke_event_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &ButtonThrower::get_keystroke_event(void) const
 *******************************************************************/
static PyObject *Dtool_ButtonThrower_get_keystroke_event_11(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonThrower * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonThrower,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &ButtonThrower::get_keystroke_event(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getKeystrokeEvent", key_word_list));
        else
            (PyArg_Parse(args, ":getKeystrokeEvent"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const ButtonThrower*)local_this)->get_keystroke_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getKeystrokeEvent(const ButtonThrower this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonThrower_get_keystroke_event_11_comment =
    "C++ Interface:\n"
    "getKeystrokeEvent(const ButtonThrower this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonThrower::get_keystroke_event\n"
    "//       Access: Published\n"
    "//  Description: Returns the keystroke_event that has been set on this\n"
    "//               ButtonThrower.  See set_keystroke_event().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonThrower_get_keystroke_event_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ButtonThrower::set_candidate_event(basic_string< char > const &candidate_event)
 *******************************************************************/
static PyObject *Dtool_ButtonThrower_set_candidate_event_12(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonThrower * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonThrower,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ButtonThrower::set_candidate_event(basic_string< char > const &candidate_event)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"candidate_event", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setCandidateEvent", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setCandidateEvent", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_candidate_event(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ButtonThrower.setCandidateEvent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCandidateEvent(non-const ButtonThrower this, string candidate_event)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonThrower_set_candidate_event_12_comment =
    "C++ Interface:\n"
    "setCandidateEvent(non-const ButtonThrower this, string candidate_event)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonThrower::set_candidate_event\n"
    "//       Access: Published\n"
    "//  Description: Specifies the event that is generated (if any) for\n"
    "//               each IME candidate string event received.  Events of\n"
    "//               this nature are received only when the user is\n"
    "//               entering data using a Microsoft Input Method Editor,\n"
    "//               typically used for Asian languages such as Japanese\n"
    "//               or Korean.\n"
    "//\n"
    "//               If you are designing a typing user interface, you\n"
    "//               should track this event to support the use of the\n"
    "//               IME.  In response to this event, you should display\n"
    "//               the candidate string in the entry box, with the\n"
    "//               appropriate sections highlighted, so the user can\n"
    "//               scroll through the available choices.\n"
    "//\n"
    "//               This event is generated with four parameters, in\n"
    "//               order: the candidate string, the character at which\n"
    "//               to start the highlight, the character at which to end\n"
    "//               the highlight, and the current cursor position.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonThrower_set_candidate_event_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &ButtonThrower::get_candidate_event(void) const
 *******************************************************************/
static PyObject *Dtool_ButtonThrower_get_candidate_event_13(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonThrower * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonThrower,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &ButtonThrower::get_candidate_event(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCandidateEvent", key_word_list));
        else
            (PyArg_Parse(args, ":getCandidateEvent"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const ButtonThrower*)local_this)->get_candidate_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCandidateEvent(const ButtonThrower this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonThrower_get_candidate_event_13_comment =
    "C++ Interface:\n"
    "getCandidateEvent(const ButtonThrower this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonThrower::get_candidate_event\n"
    "//       Access: Published\n"
    "//  Description: Returns the candidate_event that has been set on this\n"
    "//               ButtonThrower.  See set_candidate_event().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonThrower_get_candidate_event_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ButtonThrower::set_move_event(basic_string< char > const &move_event)
 *******************************************************************/
static PyObject *Dtool_ButtonThrower_set_move_event_14(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonThrower * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonThrower,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ButtonThrower::set_move_event(basic_string< char > const &move_event)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"move_event", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setMoveEvent", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setMoveEvent", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_move_event(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ButtonThrower.setMoveEvent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMoveEvent(non-const ButtonThrower this, string move_event)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonThrower_set_move_event_14_comment =
    "C++ Interface:\n"
    "setMoveEvent(non-const ButtonThrower this, string move_event)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonThrower::set_move_event\n"
    "//       Access: Published\n"
    "//  Description: Specifies the event that is generated (if any) each\n"
    "//               time the mouse is moved within the window.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonThrower_set_move_event_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &ButtonThrower::get_move_event(void) const
 *******************************************************************/
static PyObject *Dtool_ButtonThrower_get_move_event_15(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonThrower * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonThrower,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &ButtonThrower::get_move_event(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMoveEvent", key_word_list));
        else
            (PyArg_Parse(args, ":getMoveEvent"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const ButtonThrower*)local_this)->get_move_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMoveEvent(const ButtonThrower this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonThrower_get_move_event_15_comment =
    "C++ Interface:\n"
    "getMoveEvent(const ButtonThrower this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonThrower::get_move_event\n"
    "//       Access: Published\n"
    "//  Description: Returns the move_event that has been set on this\n"
    "//               ButtonThrower.  See set_move_event().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonThrower_get_move_event_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ButtonThrower::set_prefix(basic_string< char > const &prefix)
 *******************************************************************/
static PyObject *Dtool_ButtonThrower_set_prefix_16(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonThrower * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonThrower,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ButtonThrower::set_prefix(basic_string< char > const &prefix)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"prefix", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setPrefix", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setPrefix", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_prefix(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ButtonThrower.setPrefix() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPrefix(non-const ButtonThrower this, string prefix)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonThrower_set_prefix_16_comment =
    "C++ Interface:\n"
    "setPrefix(non-const ButtonThrower this, string prefix)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonThrower::set_prefix\n"
    "//       Access: Published\n"
    "//  Description: Sets the prefix which is prepended to all specific\n"
    "//               event names (that is, event names generated from the\n"
    "//               button name itself, as opposed to the generic event\n"
    "//               names like set_button_down_event) thrown by this\n"
    "//               object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonThrower_set_prefix_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &ButtonThrower::get_prefix(void) const
 *******************************************************************/
static PyObject *Dtool_ButtonThrower_get_prefix_17(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonThrower * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonThrower,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &ButtonThrower::get_prefix(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPrefix", key_word_list));
        else
            (PyArg_Parse(args, ":getPrefix"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const ButtonThrower*)local_this)->get_prefix();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPrefix(const ButtonThrower this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonThrower_get_prefix_17_comment =
    "C++ Interface:\n"
    "getPrefix(const ButtonThrower this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonThrower::get_prefix\n"
    "//       Access: Published\n"
    "//  Description: Returns the prefix that has been set on this\n"
    "//               ButtonThrower.  See set_prefix().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonThrower_get_prefix_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ButtonThrower::set_specific_flag(bool specific_flag)
 *******************************************************************/
static PyObject *Dtool_ButtonThrower_set_specific_flag_18(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonThrower * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonThrower,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ButtonThrower::set_specific_flag(bool specific_flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"specific_flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setSpecificFlag", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setSpecificFlag", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_specific_flag((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ButtonThrower.setSpecificFlag() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSpecificFlag(non-const ButtonThrower this, bool specific_flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonThrower_set_specific_flag_18_comment =
    "C++ Interface:\n"
    "setSpecificFlag(non-const ButtonThrower this, bool specific_flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonThrower::set_specific_flag\n"
    "//       Access: Published\n"
    "//  Description: Sets the flag that indicates whether specific events\n"
    "//               (events prefixed by set_prefix, and based on the\n"
    "//               event name) should be generated at all.  This is true\n"
    "//               by default, but may be disabled if you are only\n"
    "//               interested in the generic events (for instance,\n"
    "//               events like set_button_down_event).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonThrower_set_specific_flag_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ButtonThrower::get_specific_flag(void) const
 *******************************************************************/
static PyObject *Dtool_ButtonThrower_get_specific_flag_19(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonThrower * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonThrower,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ButtonThrower::get_specific_flag(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSpecificFlag", key_word_list));
        else
            (PyArg_Parse(args, ":getSpecificFlag"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ButtonThrower*)local_this)->get_specific_flag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSpecificFlag(const ButtonThrower this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonThrower_get_specific_flag_19_comment =
    "C++ Interface:\n"
    "getSpecificFlag(const ButtonThrower this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonThrower::get_specific_flag\n"
    "//       Access: Published\n"
    "//  Description: Returns the flag that indicates whether specific\n"
    "//               events should be generated.  See set_specific_flag().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonThrower_get_specific_flag_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ButtonThrower::set_time_flag(bool time_flag)
 *******************************************************************/
static PyObject *Dtool_ButtonThrower_set_time_flag_20(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonThrower * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonThrower,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ButtonThrower::set_time_flag(bool time_flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"time_flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setTimeFlag", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setTimeFlag", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_time_flag((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ButtonThrower.setTimeFlag() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTimeFlag(non-const ButtonThrower this, bool time_flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonThrower_set_time_flag_20_comment =
    "C++ Interface:\n"
    "setTimeFlag(non-const ButtonThrower this, bool time_flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonThrower::set_time_flag\n"
    "//       Access: Published\n"
    "//  Description: Sets the flag that indicates whether the time of the\n"
    "//               button event should be passed as a parameter or not.\n"
    "//               When this is true, an additional parameter is\n"
    "//               generated on each event (before all the parameters\n"
    "//               named by add_parameter) that consists of a single\n"
    "//               double value, and reflects the time the button was\n"
    "//               pressed or released, as a value from\n"
    "//               ClockObject::get_global_clock().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonThrower_set_time_flag_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ButtonThrower::get_time_flag(void) const
 *******************************************************************/
static PyObject *Dtool_ButtonThrower_get_time_flag_21(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonThrower * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonThrower,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ButtonThrower::get_time_flag(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTimeFlag", key_word_list));
        else
            (PyArg_Parse(args, ":getTimeFlag"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ButtonThrower*)local_this)->get_time_flag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTimeFlag(const ButtonThrower this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonThrower_get_time_flag_21_comment =
    "C++ Interface:\n"
    "getTimeFlag(const ButtonThrower this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonThrower::get_time_flag\n"
    "//       Access: Published\n"
    "//  Description: Returns the flag that indicates whether the time of\n"
    "//               the button event should be passed as a parameter.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonThrower_get_time_flag_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ButtonThrower::add_parameter(EventParameter const &obj)
 *******************************************************************/
static PyObject *Dtool_ButtonThrower_add_parameter_22(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonThrower * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonThrower,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void ButtonThrower::add_parameter(EventParameter const &obj)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"obj", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addParameter", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addParameter", &param1));
            if(!PyErr_Occurred())
            {
                EventParameter *param1_this = (EventParameter *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_EventParameter, 1, "ButtonThrower.addParameter", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_parameter(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ButtonThrower.addParameter() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addParameter(non-const ButtonThrower this, const EventParameter obj)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonThrower_add_parameter_22_comment =
    "C++ Interface:\n"
    "addParameter(non-const ButtonThrower this, const EventParameter obj)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonThrower::add_parameter\n"
    "//       Access: Public\n"
    "//  Description: Adds the indicated parameter to the list of\n"
    "//               parameters that will be passed with each event\n"
    "//               generated by this ButtonThrower.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonThrower_add_parameter_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int ButtonThrower::get_num_parameters(void) const
 *******************************************************************/
static PyObject *Dtool_ButtonThrower_get_num_parameters_23(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonThrower * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonThrower,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int ButtonThrower::get_num_parameters(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumParameters", key_word_list));
        else
            (PyArg_Parse(args, ":getNumParameters"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ButtonThrower*)local_this)->get_num_parameters();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumParameters(const ButtonThrower this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonThrower_get_num_parameters_23_comment =
    "C++ Interface:\n"
    "getNumParameters(const ButtonThrower this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonThrower::get_num_parameters\n"
    "//       Access: Public\n"
    "//  Description: Returns the number of parameters that have been added\n"
    "//               to the list of parameters to be passed with each\n"
    "//               event generated by this ButtonThrower.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonThrower_get_num_parameters_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * EventParameter ButtonThrower::get_parameter(int n) const
 *******************************************************************/
static PyObject *Dtool_ButtonThrower_get_parameter_24(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonThrower * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonThrower,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-EventParameter ButtonThrower::get_parameter(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParameter", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParameter", &param1));
        if(!PyErr_Occurred())
        {
            EventParameter result = ((const ButtonThrower*)local_this)->get_parameter((int)param1);
            EventParameter *return_value = new EventParameter(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_EventParameter,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParameter(const ButtonThrower this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonThrower_get_parameter_24_comment =
    "C++ Interface:\n"
    "getParameter(const ButtonThrower this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonThrower::get_parameter\n"
    "//       Access: Public\n"
    "//  Description: Returns the nth parameter that has been added to the\n"
    "//               list of parameters passed with each event generated\n"
    "//               by this ButtonThrower.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonThrower_get_parameter_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ModifierButtons const &ButtonThrower::get_modifier_buttons(void) const
 *******************************************************************/
static PyObject *Dtool_ButtonThrower_get_modifier_buttons_25(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonThrower * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonThrower,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline ModifierButtons const &ButtonThrower::get_modifier_buttons(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getModifierButtons", key_word_list));
        else
            (PyArg_Parse(args, ":getModifierButtons"));
        if(!PyErr_Occurred())
        {
            ModifierButtons const *return_value = &(((const ButtonThrower*)local_this)->get_modifier_buttons());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ModifierButtons,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getModifierButtons(const ButtonThrower this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonThrower_get_modifier_buttons_25_comment =
    "C++ Interface:\n"
    "getModifierButtons(const ButtonThrower this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonThrower::get_modifier_buttons\n"
    "//       Access: Published\n"
    "//  Description: Returns the set of ModifierButtons that the\n"
    "//               ButtonThrower will consider important enough to\n"
    "//               prepend the event name with.  Normally, this set will\n"
    "//               be empty, and the ButtonThrower will therefore ignore\n"
    "//               all ModifierButtons attached to the key events, but\n"
    "//               if one or more buttons have been added to this set,\n"
    "//               and those modifier buttons are set on the button\n"
    "//               event, then the event name will be prepended with the\n"
    "//               names of the modifier buttons.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonThrower_get_modifier_buttons_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ButtonThrower::set_modifier_buttons(ModifierButtons const &mods)
 *******************************************************************/
static PyObject *Dtool_ButtonThrower_set_modifier_buttons_26(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonThrower * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonThrower,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ButtonThrower::set_modifier_buttons(ModifierButtons const &mods)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"mods", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setModifierButtons", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setModifierButtons", &param1));
            if(!PyErr_Occurred())
            {
                ModifierButtons *param1_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ModifierButtons, 1, "ButtonThrower.setModifierButtons", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_modifier_buttons(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ButtonThrower.setModifierButtons() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setModifierButtons(non-const ButtonThrower this, const ModifierButtons mods)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonThrower_set_modifier_buttons_26_comment =
    "C++ Interface:\n"
    "setModifierButtons(non-const ButtonThrower this, const ModifierButtons mods)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonThrower::set_modifier_buttons\n"
    "//       Access: Published\n"
    "//  Description: Changes the set of ModifierButtons that the\n"
    "//               ButtonThrower will consider important enough to\n"
    "//               prepend the event name with.  Normally, this set will\n"
    "//               be empty, and the ButtonThrower will therefore ignore\n"
    "//               all ModifierButtons attached to the key events, but\n"
    "//               if one or more buttons have been added to this set,\n"
    "//               then the event name will be prepended with the names\n"
    "//               of the modifier buttons.\n"
    "//\n"
    "//               It is recommended that you change this setting by\n"
    "//               first calling get_modifier_buttons(), making\n"
    "//               adjustments, and passing the new value to\n"
    "//               set_modifier_buttons().  This way the current state\n"
    "//               of the modifier buttons will not be lost.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonThrower_set_modifier_buttons_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ButtonThrower::set_throw_buttons_active(bool flag)
 *******************************************************************/
static PyObject *Dtool_ButtonThrower_set_throw_buttons_active_27(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonThrower * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonThrower,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ButtonThrower::set_throw_buttons_active(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setThrowButtonsActive", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setThrowButtonsActive", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_throw_buttons_active((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ButtonThrower.setThrowButtonsActive() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setThrowButtonsActive(non-const ButtonThrower this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonThrower_set_throw_buttons_active_27_comment =
    "C++ Interface:\n"
    "setThrowButtonsActive(non-const ButtonThrower this, bool flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonThrower::set_throw_buttons_active\n"
    "//       Access: Published\n"
    "//  Description: Sets the flag that indicates whether the\n"
    "//               ButtonThrower will only process events for the\n"
    "//               explicitly named buttons or not.  Normally this is\n"
    "//               false, meaning all buttons are processed; set it true\n"
    "//               to indicate that only some buttons should be\n"
    "//               processed.  See add_throw_button().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonThrower_set_throw_buttons_active_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ButtonThrower::get_throw_buttons_active(void) const
 *******************************************************************/
static PyObject *Dtool_ButtonThrower_get_throw_buttons_active_28(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonThrower * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonThrower,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ButtonThrower::get_throw_buttons_active(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getThrowButtonsActive", key_word_list));
        else
            (PyArg_Parse(args, ":getThrowButtonsActive"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ButtonThrower*)local_this)->get_throw_buttons_active();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getThrowButtonsActive(const ButtonThrower this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonThrower_get_throw_buttons_active_28_comment =
    "C++ Interface:\n"
    "getThrowButtonsActive(const ButtonThrower this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonThrower::get_throw_buttons_active\n"
    "//       Access: Published\n"
    "//  Description: Returns the flag that indicates whether the\n"
    "//               ButtonThrower will only process events for the\n"
    "//               explicitly named buttons or not.  See\n"
    "//               set_throw_buttons_active().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonThrower_get_throw_buttons_active_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ButtonThrower::add_throw_button(ModifierButtons const &mods, ButtonHandle const &button)
 *******************************************************************/
static PyObject *Dtool_ButtonThrower_add_throw_button_29(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonThrower * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonThrower,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool ButtonThrower::add_throw_button(ModifierButtons const &mods, ButtonHandle const &button)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"mods", (char *)"button", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:addThrowButton", key_word_list, &param1, &param2))
            {
                ModifierButtons *param1_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ModifierButtons, 1, "ButtonThrower.addThrowButton", 1, coerced_ptr, report_errors);
ButtonHandle *param2_this = (ButtonHandle *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_ButtonHandle, 2, "ButtonThrower.addThrowButton", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    bool return_value = (local_this)->add_throw_button(*param1_this, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ButtonThrower.addThrowButton() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addThrowButton(non-const ButtonThrower this, const ModifierButtons mods, const ButtonHandle button)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonThrower_add_throw_button_29_comment =
    "C++ Interface:\n"
    "addThrowButton(non-const ButtonThrower this, const ModifierButtons mods, const ButtonHandle button)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonThrower::add_throw_button\n"
    "//       Access: Published\n"
    "//  Description: Adds a new button to the set of buttons that the\n"
    "//               ButtonThrower explicitly processes.\n"
    "//\n"
    "//               If set_throw_buttons_active is false (which is the\n"
    "//               default), the ButtonThrower will process all buttons.\n"
    "//               Otherwise, the ButtonThrower will only process events\n"
    "//               for the button(s) explicitly named by this function;\n"
    "//               buttons not on the list will be ignored by this\n"
    "//               object and passed on downstream to the child node(s)\n"
    "//               in the data graph.  A button that *is* on the list\n"
    "//               will be processed by the ButtonThrower and not passed\n"
    "//               on to the child node(s).\n"
    "//\n"
    "//               The return value is true if the button is added, or\n"
    "//               false if it was already in the set.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonThrower_add_throw_button_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ButtonThrower::remove_throw_button(ModifierButtons const &mods, ButtonHandle const &button)
 *******************************************************************/
static PyObject *Dtool_ButtonThrower_remove_throw_button_30(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonThrower * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonThrower,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool ButtonThrower::remove_throw_button(ModifierButtons const &mods, ButtonHandle const &button)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"mods", (char *)"button", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:removeThrowButton", key_word_list, &param1, &param2))
            {
                ModifierButtons *param1_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ModifierButtons, 1, "ButtonThrower.removeThrowButton", 1, coerced_ptr, report_errors);
ButtonHandle *param2_this = (ButtonHandle *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_ButtonHandle, 2, "ButtonThrower.removeThrowButton", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    bool return_value = (local_this)->remove_throw_button(*param1_this, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ButtonThrower.removeThrowButton() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeThrowButton(non-const ButtonThrower this, const ModifierButtons mods, const ButtonHandle button)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonThrower_remove_throw_button_30_comment =
    "C++ Interface:\n"
    "removeThrowButton(non-const ButtonThrower this, const ModifierButtons mods, const ButtonHandle button)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonThrower::remove_throw_button\n"
    "//       Access: Published\n"
    "//  Description: Removes the indicated button from the set of buttons\n"
    "//               that the ButtonThrower explicitly processes.  See\n"
    "//               add_throw_button().\n"
    "//\n"
    "//               The return value is true if the button is removed, or\n"
    "//               false if it was not on the set.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonThrower_remove_throw_button_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool ButtonThrower::has_throw_button(ButtonHandle const &button) const
 * bool ButtonThrower::has_throw_button(ModifierButtons const &mods, ButtonHandle const &button) const
 *******************************************************************/
static PyObject *Dtool_ButtonThrower_has_throw_button_31(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonThrower * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonThrower,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-bool ButtonThrower::has_throw_button(ButtonHandle const &button) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"button", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:hasThrowButton", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:hasThrowButton", &param1));
                if(!PyErr_Occurred())
                {
                    ButtonHandle *param1_this = (ButtonHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ButtonHandle, 1, "ButtonThrower.hasThrowButton", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = ((const ButtonThrower*)local_this)->has_throw_button(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-bool ButtonThrower::has_throw_button(ModifierButtons const &mods, ButtonHandle const &button) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"mods", (char *)"button", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:hasThrowButton", key_word_list, &param1, &param2))
                {
                    ModifierButtons *param1_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ModifierButtons, 1, "ButtonThrower.hasThrowButton", 1, coerced_ptr, report_errors);
ButtonHandle *param2_this = (ButtonHandle *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_ButtonHandle, 2, "ButtonThrower.hasThrowButton", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        bool return_value = ((const ButtonThrower*)local_this)->has_throw_button(*param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "hasThrowButton() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "hasThrowButton(const ButtonThrower this, const ButtonHandle button)\n"
          "hasThrowButton(const ButtonThrower this, const ModifierButtons mods, const ButtonHandle button)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonThrower_has_throw_button_31_comment =
    "C++ Interface:\n"
    "hasThrowButton(const ButtonThrower this, const ButtonHandle button)\n"
    "hasThrowButton(const ButtonThrower this, const ModifierButtons mods, const ButtonHandle button)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonThrower::has_throw_button\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the indicated button is on the set of\n"
    "//               buttons that will be processed by the ButtonThrower,\n"
    "//               false otherwise.  See add_throw_button().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonThrower::has_throw_button\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the indicated button, in conjunction\n"
    "//               with any nonspecified modifier buttons, is on the set\n"
    "//               of buttons that will be processed by the\n"
    "//               ButtonThrower.  That is to say, returns true if this\n"
    "//               button was ever passed as the second parameter\n"
    "//               add_throw_button(), regardless of what the first\n"
    "//               parameter was.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonThrower_has_throw_button_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ButtonThrower::clear_throw_buttons(void)
 *******************************************************************/
static PyObject *Dtool_ButtonThrower_clear_throw_buttons_32(PyObject *self, PyObject *args,PyObject *kwds) {
    ButtonThrower * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ButtonThrower,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ButtonThrower::clear_throw_buttons(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearThrowButtons", key_word_list));
        else
            (PyArg_Parse(args, ":clearThrowButtons"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_throw_buttons();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ButtonThrower.clearThrowButtons() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearThrowButtons(non-const ButtonThrower this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonThrower_clear_throw_buttons_32_comment =
    "C++ Interface:\n"
    "clearThrowButtons(non-const ButtonThrower this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ButtonThrower::clear_throw_buttons\n"
    "//       Access: Published\n"
    "//  Description: Empties the set of buttons that were added via\n"
    "//               add_throw_button().  See add_throw_button().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ButtonThrower_clear_throw_buttons_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ButtonThrower::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_ButtonThrower_get_class_type_33(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ButtonThrower::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ButtonThrower::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ButtonThrower_get_class_type_33_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_ButtonThrower_get_class_type_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ButtonThrower::ButtonThrower(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_ButtonThrower(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-ButtonThrower::ButtonThrower(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:ButtonThrower", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:ButtonThrower", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            ButtonThrower *return_value = new ButtonThrower(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_ButtonThrower,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ButtonThrower(string name)\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_ButtonThrower_get_parameters(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumParameters", "getParameter");
}
inline void  * Dtool_UpcastInterface_ButtonThrower(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ButtonThrower)
    {
        printf("ButtonThrower ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ButtonThrower * local_this = (ButtonThrower *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ButtonThrower)
        return local_this;
    if(requested_type == &Dtool_DataNode)
        return ( DataNode *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( DataNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ButtonThrower(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ButtonThrower)
        return from_this;
    if(from_type == &Dtool_DataNode)
    {
          DataNode* other_this = (DataNode*)from_this;
          return (ButtonThrower*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (ButtonThrower*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (ButtonThrower*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (ButtonThrower*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (ButtonThrower*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. MouseInterfaceNode 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void MouseInterfaceNode::require_button(ButtonHandle const &button, bool is_down)
 *******************************************************************/
static PyObject *Dtool_MouseInterfaceNode_require_button_35(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseInterfaceNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseInterfaceNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void MouseInterfaceNode::require_button(ButtonHandle const &button, bool is_down)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"button", (char *)"is_down", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:requireButton", key_word_list, &param1, &param2))
            {
                ButtonHandle *param1_this = (ButtonHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ButtonHandle, 1, "MouseInterfaceNode.requireButton", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->require_button(*param1_this, (PyObject_IsTrue(param2)!=0));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MouseInterfaceNode.requireButton() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "requireButton(non-const MouseInterfaceNode this, const ButtonHandle button, bool is_down)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseInterfaceNode_require_button_35_comment =
    "C++ Interface:\n"
    "requireButton(non-const MouseInterfaceNode this, const ButtonHandle button, bool is_down)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseInterfaceNode::require_button\n"
    "//       Access: Published\n"
    "//  Description: Indicates that the indicated button must be in the\n"
    "//               required state (either up or down) in order for this\n"
    "//               particular MouseInterfaceNode to do anything.  For\n"
    "//               instance, this may be called to make a Trackball\n"
    "//               object respect mouse input only when the control key\n"
    "//               is held down.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseInterfaceNode_require_button_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MouseInterfaceNode::clear_button(ButtonHandle const &button)
 *******************************************************************/
static PyObject *Dtool_MouseInterfaceNode_clear_button_36(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseInterfaceNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseInterfaceNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void MouseInterfaceNode::clear_button(ButtonHandle const &button)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"button", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:clearButton", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:clearButton", &param1));
            if(!PyErr_Occurred())
            {
                ButtonHandle *param1_this = (ButtonHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ButtonHandle, 1, "MouseInterfaceNode.clearButton", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->clear_button(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MouseInterfaceNode.clearButton() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearButton(non-const MouseInterfaceNode this, const ButtonHandle button)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseInterfaceNode_clear_button_36_comment =
    "C++ Interface:\n"
    "clearButton(non-const MouseInterfaceNode this, const ButtonHandle button)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseInterfaceNode::clear_button\n"
    "//       Access: Published\n"
    "//  Description: Removes any requirement on the indicated button set\n"
    "//               by an earlier call to require_button().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseInterfaceNode_clear_button_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MouseInterfaceNode::clear_all_buttons(void)
 *******************************************************************/
static PyObject *Dtool_MouseInterfaceNode_clear_all_buttons_37(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseInterfaceNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseInterfaceNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void MouseInterfaceNode::clear_all_buttons(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearAllButtons", key_word_list));
        else
            (PyArg_Parse(args, ":clearAllButtons"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_all_buttons();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseInterfaceNode.clearAllButtons() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearAllButtons(non-const MouseInterfaceNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseInterfaceNode_clear_all_buttons_37_comment =
    "C++ Interface:\n"
    "clearAllButtons(non-const MouseInterfaceNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseInterfaceNode::clear_all_button\n"
    "//       Access: Published\n"
    "//  Description: Removes all requirements on buttons set by an earlier\n"
    "//               call to require_button().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseInterfaceNode_clear_all_buttons_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle MouseInterfaceNode::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_MouseInterfaceNode_get_class_type_38(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle MouseInterfaceNode::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = MouseInterfaceNode::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseInterfaceNode_get_class_type_38_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_MouseInterfaceNode_get_class_type_38_comment = NULL;
#endif

int  Dtool_Init_MouseInterfaceNode(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (MouseInterfaceNode)");
       return -1;
}
inline void  * Dtool_UpcastInterface_MouseInterfaceNode(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_MouseInterfaceNode)
    {
        printf("MouseInterfaceNode ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    MouseInterfaceNode * local_this = (MouseInterfaceNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_MouseInterfaceNode)
        return local_this;
    if(requested_type == &Dtool_DataNode)
        return ( DataNode *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( DataNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_MouseInterfaceNode(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_MouseInterfaceNode)
        return from_this;
    if(from_type == &Dtool_DataNode)
    {
          DataNode* other_this = (DataNode*)from_this;
          return (MouseInterfaceNode*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (MouseInterfaceNode*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (MouseInterfaceNode*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (MouseInterfaceNode*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (MouseInterfaceNode*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DriveInterface 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DriveInterface::set_forward_speed(float speed)
 *******************************************************************/
static PyObject *Dtool_DriveInterface_set_forward_speed_41(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DriveInterface::set_forward_speed(float speed)
        double param1;
        static char * key_word_list[] = {(char *)"speed", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setForwardSpeed", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setForwardSpeed", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_forward_speed((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DriveInterface.setForwardSpeed() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setForwardSpeed(non-const DriveInterface this, float speed)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_set_forward_speed_41_comment =
    "C++ Interface:\n"
    "setForwardSpeed(non-const DriveInterface this, float speed)\n"
    "\n"
    "// Filename: driveInterface.I\n"
    "// Created by:  drose (12Mar02)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::set_forward_speed\n"
    "//       Access: Published\n"
    "//  Description: Sets the speed of full forward motion, when the mouse\n"
    "//               is at the very top of the window.  This is in units\n"
    "//               (e.g. feet) per second.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_set_forward_speed_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DriveInterface::get_forward_speed(void) const
 *******************************************************************/
static PyObject *Dtool_DriveInterface_get_forward_speed_42(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DriveInterface::get_forward_speed(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getForwardSpeed", key_word_list));
        else
            (PyArg_Parse(args, ":getForwardSpeed"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DriveInterface*)local_this)->get_forward_speed();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getForwardSpeed(const DriveInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_get_forward_speed_42_comment =
    "C++ Interface:\n"
    "getForwardSpeed(const DriveInterface this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::get_forward_speed\n"
    "//       Access: Published\n"
    "//  Description: Returns the speed of full forward motion, when the\n"
    "//               mouse is at the very top of the window.  This is in\n"
    "//               units (e.g. feet) per second.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_get_forward_speed_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DriveInterface::set_reverse_speed(float speed)
 *******************************************************************/
static PyObject *Dtool_DriveInterface_set_reverse_speed_43(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DriveInterface::set_reverse_speed(float speed)
        double param1;
        static char * key_word_list[] = {(char *)"speed", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setReverseSpeed", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setReverseSpeed", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_reverse_speed((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DriveInterface.setReverseSpeed() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setReverseSpeed(non-const DriveInterface this, float speed)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_set_reverse_speed_43_comment =
    "C++ Interface:\n"
    "setReverseSpeed(non-const DriveInterface this, float speed)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::set_reverse_speed\n"
    "//       Access: Published\n"
    "//  Description: Sets the speed of full reverse motion, when the mouse\n"
    "//               is at the very bottom of the window.  This is in\n"
    "//               units (e.g. feet) per second.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_set_reverse_speed_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DriveInterface::get_reverse_speed(void) const
 *******************************************************************/
static PyObject *Dtool_DriveInterface_get_reverse_speed_44(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DriveInterface::get_reverse_speed(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getReverseSpeed", key_word_list));
        else
            (PyArg_Parse(args, ":getReverseSpeed"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DriveInterface*)local_this)->get_reverse_speed();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getReverseSpeed(const DriveInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_get_reverse_speed_44_comment =
    "C++ Interface:\n"
    "getReverseSpeed(const DriveInterface this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::get_reverse_speed\n"
    "//       Access: Published\n"
    "//  Description: Returns the speed of full reverse motion, when the\n"
    "//               mouse is at the very bottom of the window.  This is\n"
    "//               in units (e.g. feet) per second.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_get_reverse_speed_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DriveInterface::set_rotate_speed(float speed)
 *******************************************************************/
static PyObject *Dtool_DriveInterface_set_rotate_speed_45(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DriveInterface::set_rotate_speed(float speed)
        double param1;
        static char * key_word_list[] = {(char *)"speed", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setRotateSpeed", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setRotateSpeed", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_rotate_speed((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DriveInterface.setRotateSpeed() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRotateSpeed(non-const DriveInterface this, float speed)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_set_rotate_speed_45_comment =
    "C++ Interface:\n"
    "setRotateSpeed(non-const DriveInterface this, float speed)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::set_rotate_speed\n"
    "//       Access: Published\n"
    "//  Description: Sets the maximum rate at which the user can rotate\n"
    "//               left or right, when the mouse is at the very edge of\n"
    "//               the window.  This is in degrees per second.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_set_rotate_speed_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DriveInterface::get_rotate_speed(void) const
 *******************************************************************/
static PyObject *Dtool_DriveInterface_get_rotate_speed_46(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DriveInterface::get_rotate_speed(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRotateSpeed", key_word_list));
        else
            (PyArg_Parse(args, ":getRotateSpeed"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DriveInterface*)local_this)->get_rotate_speed();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRotateSpeed(const DriveInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_get_rotate_speed_46_comment =
    "C++ Interface:\n"
    "getRotateSpeed(const DriveInterface this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::get_rotate_speed\n"
    "//       Access: Published\n"
    "//  Description: Returns the maximum rate at which the user can rotate\n"
    "//               left or right, when the mouse is at the very edge of\n"
    "//               the window.  This is in degrees per second.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_get_rotate_speed_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DriveInterface::set_vertical_dead_zone(float zone)
 *******************************************************************/
static PyObject *Dtool_DriveInterface_set_vertical_dead_zone_47(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DriveInterface::set_vertical_dead_zone(float zone)
        double param1;
        static char * key_word_list[] = {(char *)"zone", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setVerticalDeadZone", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setVerticalDeadZone", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_vertical_dead_zone((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DriveInterface.setVerticalDeadZone() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setVerticalDeadZone(non-const DriveInterface this, float zone)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_set_vertical_dead_zone_47_comment =
    "C++ Interface:\n"
    "setVerticalDeadZone(non-const DriveInterface this, float zone)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::set_vertical_dead_zone\n"
    "//       Access: Published\n"
    "//  Description: Sets the size of the horizontal bar in the center of\n"
    "//               the screen that represents the \"dead zone\" of\n"
    "//               vertical motion: the region in which the mouse does\n"
    "//               not report vertical motion.  This is in a fraction of\n"
    "//               the window height, so 0.5 will set a dead zone as\n"
    "//               large as half the screen.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_set_vertical_dead_zone_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DriveInterface::get_vertical_dead_zone(void) const
 *******************************************************************/
static PyObject *Dtool_DriveInterface_get_vertical_dead_zone_48(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DriveInterface::get_vertical_dead_zone(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getVerticalDeadZone", key_word_list));
        else
            (PyArg_Parse(args, ":getVerticalDeadZone"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DriveInterface*)local_this)->get_vertical_dead_zone();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVerticalDeadZone(const DriveInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_get_vertical_dead_zone_48_comment =
    "C++ Interface:\n"
    "getVerticalDeadZone(const DriveInterface this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::get_vertical_dead_zone\n"
    "//       Access: Published\n"
    "//  Description: Returns the size of the horizontal bar in the center\n"
    "//               of the screen that represents the \"dead zone\" of\n"
    "//               vertical motion: the region in which the mouse does\n"
    "//               not report vertical motion.  This is in a fraction of\n"
    "//               the window height, so 0.5 will set a dead zone as\n"
    "//               large as half the screen.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_get_vertical_dead_zone_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DriveInterface::set_horizontal_dead_zone(float zone)
 *******************************************************************/
static PyObject *Dtool_DriveInterface_set_horizontal_dead_zone_49(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DriveInterface::set_horizontal_dead_zone(float zone)
        double param1;
        static char * key_word_list[] = {(char *)"zone", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setHorizontalDeadZone", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setHorizontalDeadZone", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_horizontal_dead_zone((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DriveInterface.setHorizontalDeadZone() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setHorizontalDeadZone(non-const DriveInterface this, float zone)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_set_horizontal_dead_zone_49_comment =
    "C++ Interface:\n"
    "setHorizontalDeadZone(non-const DriveInterface this, float zone)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::set_horizontal_dead_zone\n"
    "//       Access: Published\n"
    "//  Description: Sets the size of the vertical bar in the center of\n"
    "//               the screen that represents the \"dead zone\" of\n"
    "//               horizontal motion: the region in which the mouse does\n"
    "//               not report horizontal motion.  This is in a fraction of\n"
    "//               the window width, so 0.5 will set a dead zone as\n"
    "//               large as half the screen.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_set_horizontal_dead_zone_49_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DriveInterface::get_horizontal_dead_zone(void) const
 *******************************************************************/
static PyObject *Dtool_DriveInterface_get_horizontal_dead_zone_50(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DriveInterface::get_horizontal_dead_zone(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHorizontalDeadZone", key_word_list));
        else
            (PyArg_Parse(args, ":getHorizontalDeadZone"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DriveInterface*)local_this)->get_horizontal_dead_zone();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHorizontalDeadZone(const DriveInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_get_horizontal_dead_zone_50_comment =
    "C++ Interface:\n"
    "getHorizontalDeadZone(const DriveInterface this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::get_horizontal_dead_zone\n"
    "//       Access: Published\n"
    "//  Description: Returns the size of the vertical bar in the center\n"
    "//               of the screen that represents the \"dead zone\" of\n"
    "//               horizontal motion: the region in which the mouse does\n"
    "//               not report horizontal motion.  This is in a fraction of\n"
    "//               the window width, so 0.5 will set a dead zone as\n"
    "//               large as half the screen.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_get_horizontal_dead_zone_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DriveInterface::set_vertical_ramp_up_time(float ramp_up_time)
 *******************************************************************/
static PyObject *Dtool_DriveInterface_set_vertical_ramp_up_time_51(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DriveInterface::set_vertical_ramp_up_time(float ramp_up_time)
        double param1;
        static char * key_word_list[] = {(char *)"ramp_up_time", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setVerticalRampUpTime", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setVerticalRampUpTime", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_vertical_ramp_up_time((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DriveInterface.setVerticalRampUpTime() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setVerticalRampUpTime(non-const DriveInterface this, float ramp_up_time)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_set_vertical_ramp_up_time_51_comment =
    "C++ Interface:\n"
    "setVerticalRampUpTime(non-const DriveInterface this, float ramp_up_time)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::set_vertical_ramp_up_time\n"
    "//       Access: Published\n"
    "//  Description: Sets the amount of time, in seconds, it takes between\n"
    "//               the time an up or down arrow key is pressed and the\n"
    "//               time it registers full forward or backward motion.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_set_vertical_ramp_up_time_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DriveInterface::get_vertical_ramp_up_time(void) const
 *******************************************************************/
static PyObject *Dtool_DriveInterface_get_vertical_ramp_up_time_52(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DriveInterface::get_vertical_ramp_up_time(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getVerticalRampUpTime", key_word_list));
        else
            (PyArg_Parse(args, ":getVerticalRampUpTime"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DriveInterface*)local_this)->get_vertical_ramp_up_time();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVerticalRampUpTime(const DriveInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_get_vertical_ramp_up_time_52_comment =
    "C++ Interface:\n"
    "getVerticalRampUpTime(const DriveInterface this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::get_vertical_ramp_up_time\n"
    "//       Access: Published\n"
    "//  Description: Returns the amount of time, in seconds, it takes\n"
    "//               between the time an up or down arrow key is pressed\n"
    "//               and the time it registers full forward or backward\n"
    "//               motion.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_get_vertical_ramp_up_time_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DriveInterface::set_vertical_ramp_down_time(float ramp_down_time)
 *******************************************************************/
static PyObject *Dtool_DriveInterface_set_vertical_ramp_down_time_53(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DriveInterface::set_vertical_ramp_down_time(float ramp_down_time)
        double param1;
        static char * key_word_list[] = {(char *)"ramp_down_time", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setVerticalRampDownTime", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setVerticalRampDownTime", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_vertical_ramp_down_time((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DriveInterface.setVerticalRampDownTime() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setVerticalRampDownTime(non-const DriveInterface this, float ramp_down_time)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_set_vertical_ramp_down_time_53_comment =
    "C++ Interface:\n"
    "setVerticalRampDownTime(non-const DriveInterface this, float ramp_down_time)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::set_vertical_ramp_down_time\n"
    "//       Access: Published\n"
    "//  Description: Sets the amount of time, in seconds, it takes between\n"
    "//               the time an up or down arrow key is released and the\n"
    "//               time it registers no motion.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_set_vertical_ramp_down_time_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DriveInterface::get_vertical_ramp_down_time(void) const
 *******************************************************************/
static PyObject *Dtool_DriveInterface_get_vertical_ramp_down_time_54(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DriveInterface::get_vertical_ramp_down_time(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getVerticalRampDownTime", key_word_list));
        else
            (PyArg_Parse(args, ":getVerticalRampDownTime"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DriveInterface*)local_this)->get_vertical_ramp_down_time();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVerticalRampDownTime(const DriveInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_get_vertical_ramp_down_time_54_comment =
    "C++ Interface:\n"
    "getVerticalRampDownTime(const DriveInterface this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::get_vertical_ramp_down_time\n"
    "//       Access: Published\n"
    "//  Description: Returns the amount of time, in seconds, it takes\n"
    "//               between the time an up or down arrow key is released\n"
    "//               and the time it registers no motion.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_get_vertical_ramp_down_time_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DriveInterface::set_horizontal_ramp_up_time(float ramp_up_time)
 *******************************************************************/
static PyObject *Dtool_DriveInterface_set_horizontal_ramp_up_time_55(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DriveInterface::set_horizontal_ramp_up_time(float ramp_up_time)
        double param1;
        static char * key_word_list[] = {(char *)"ramp_up_time", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setHorizontalRampUpTime", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setHorizontalRampUpTime", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_horizontal_ramp_up_time((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DriveInterface.setHorizontalRampUpTime() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setHorizontalRampUpTime(non-const DriveInterface this, float ramp_up_time)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_set_horizontal_ramp_up_time_55_comment =
    "C++ Interface:\n"
    "setHorizontalRampUpTime(non-const DriveInterface this, float ramp_up_time)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::set_horizontal_ramp_up_time\n"
    "//       Access: Published\n"
    "//  Description: Sets the amount of time, in seconds, it takes between\n"
    "//               the time a left or right arrow key is pressed and the\n"
    "//               time it registers full rotation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_set_horizontal_ramp_up_time_55_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DriveInterface::get_horizontal_ramp_up_time(void) const
 *******************************************************************/
static PyObject *Dtool_DriveInterface_get_horizontal_ramp_up_time_56(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DriveInterface::get_horizontal_ramp_up_time(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHorizontalRampUpTime", key_word_list));
        else
            (PyArg_Parse(args, ":getHorizontalRampUpTime"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DriveInterface*)local_this)->get_horizontal_ramp_up_time();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHorizontalRampUpTime(const DriveInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_get_horizontal_ramp_up_time_56_comment =
    "C++ Interface:\n"
    "getHorizontalRampUpTime(const DriveInterface this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::get_horizontal_ramp_up_time\n"
    "//       Access: Published\n"
    "//  Description: Returns the amount of time, in seconds, it takes\n"
    "//               between the time a left or right arrow key is pressed\n"
    "//               and the time it registers full rotation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_get_horizontal_ramp_up_time_56_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DriveInterface::set_horizontal_ramp_down_time(float ramp_down_time)
 *******************************************************************/
static PyObject *Dtool_DriveInterface_set_horizontal_ramp_down_time_57(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DriveInterface::set_horizontal_ramp_down_time(float ramp_down_time)
        double param1;
        static char * key_word_list[] = {(char *)"ramp_down_time", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setHorizontalRampDownTime", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setHorizontalRampDownTime", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_horizontal_ramp_down_time((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DriveInterface.setHorizontalRampDownTime() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setHorizontalRampDownTime(non-const DriveInterface this, float ramp_down_time)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_set_horizontal_ramp_down_time_57_comment =
    "C++ Interface:\n"
    "setHorizontalRampDownTime(non-const DriveInterface this, float ramp_down_time)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::set_horizontal_ramp_down_time\n"
    "//       Access: Published\n"
    "//  Description: Sets the amount of time, in seconds, it takes between\n"
    "//               the time a left or right arrow key is released and the\n"
    "//               time it registers no motion.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_set_horizontal_ramp_down_time_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DriveInterface::get_horizontal_ramp_down_time(void) const
 *******************************************************************/
static PyObject *Dtool_DriveInterface_get_horizontal_ramp_down_time_58(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DriveInterface::get_horizontal_ramp_down_time(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHorizontalRampDownTime", key_word_list));
        else
            (PyArg_Parse(args, ":getHorizontalRampDownTime"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DriveInterface*)local_this)->get_horizontal_ramp_down_time();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHorizontalRampDownTime(const DriveInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_get_horizontal_ramp_down_time_58_comment =
    "C++ Interface:\n"
    "getHorizontalRampDownTime(const DriveInterface this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::get_horizontal_ramp_down_time\n"
    "//       Access: Published\n"
    "//  Description: Returns the amount of time, in seconds, it takes\n"
    "//               between the time a left or right arrow key is released\n"
    "//               and the time it registers no motion.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_get_horizontal_ramp_down_time_58_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DriveInterface::get_speed(void) const
 *******************************************************************/
static PyObject *Dtool_DriveInterface_get_speed_59(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DriveInterface::get_speed(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSpeed", key_word_list));
        else
            (PyArg_Parse(args, ":getSpeed"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DriveInterface*)local_this)->get_speed();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSpeed(const DriveInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_get_speed_59_comment =
    "C++ Interface:\n"
    "getSpeed(const DriveInterface this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::get_speed\n"
    "//       Access: Published\n"
    "//  Description: Returns the speed of the previous update in units/sec\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_get_speed_59_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DriveInterface::get_rot_speed(void) const
 *******************************************************************/
static PyObject *Dtool_DriveInterface_get_rot_speed_60(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DriveInterface::get_rot_speed(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRotSpeed", key_word_list));
        else
            (PyArg_Parse(args, ":getRotSpeed"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DriveInterface*)local_this)->get_rot_speed();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRotSpeed(const DriveInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_get_rot_speed_60_comment =
    "C++ Interface:\n"
    "getRotSpeed(const DriveInterface this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::get_rot_speed\n"
    "//       Access: Published\n"
    "//  Description: Returns the rot_speed of the previous update in units/sec\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_get_rot_speed_60_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DriveInterface::reset(void)
 *******************************************************************/
static PyObject *Dtool_DriveInterface_reset_61(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DriveInterface::reset(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":reset", key_word_list));
        else
            (PyArg_Parse(args, ":reset"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DriveInterface.reset() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "reset(non-const DriveInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_reset_61_comment =
    "C++ Interface:\n"
    "reset(non-const DriveInterface this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::reset\n"
    "//       Access: Published\n"
    "//  Description: Reinitializes the driver to the origin and resets any\n"
    "//               knowledge about buttons being held down.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_reset_61_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f const &DriveInterface::get_pos(void) const
 *******************************************************************/
static PyObject *Dtool_DriveInterface_get_pos_62(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f const &DriveInterface::get_pos(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPos", key_word_list));
        else
            (PyArg_Parse(args, ":getPos"));
        if(!PyErr_Occurred())
        {
            LPoint3f const *return_value = &(((const DriveInterface*)local_this)->get_pos());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPos(const DriveInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_get_pos_62_comment =
    "C++ Interface:\n"
    "getPos(const DriveInterface this)\n"
    "\n"
    "/// **** Translation ****\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::get_pos\n"
    "//       Access: Published\n"
    "//  Description: Returns the driver's position.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_get_pos_62_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DriveInterface::get_x(void) const
 *******************************************************************/
static PyObject *Dtool_DriveInterface_get_x_63(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DriveInterface::get_x(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getX", key_word_list));
        else
            (PyArg_Parse(args, ":getX"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DriveInterface*)local_this)->get_x();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getX(const DriveInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_get_x_63_comment =
    "C++ Interface:\n"
    "getX(const DriveInterface this)\n"
    "\n"
    "";
#else
static const char * Dtool_DriveInterface_get_x_63_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DriveInterface::get_y(void) const
 *******************************************************************/
static PyObject *Dtool_DriveInterface_get_y_64(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DriveInterface::get_y(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getY", key_word_list));
        else
            (PyArg_Parse(args, ":getY"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DriveInterface*)local_this)->get_y();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getY(const DriveInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_get_y_64_comment =
    "C++ Interface:\n"
    "getY(const DriveInterface this)\n"
    "\n"
    "";
#else
static const char * Dtool_DriveInterface_get_y_64_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DriveInterface::get_z(void) const
 *******************************************************************/
static PyObject *Dtool_DriveInterface_get_z_65(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DriveInterface::get_z(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getZ", key_word_list));
        else
            (PyArg_Parse(args, ":getZ"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DriveInterface*)local_this)->get_z();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getZ(const DriveInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_get_z_65_comment =
    "C++ Interface:\n"
    "getZ(const DriveInterface this)\n"
    "\n"
    "";
#else
static const char * Dtool_DriveInterface_get_z_65_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DriveInterface::set_pos(LVecBase3f const &vec)
 * inline void DriveInterface::set_pos(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_DriveInterface_set_pos_66(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void DriveInterface::set_pos(LVecBase3f const &vec)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"vec", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setPos", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setPos", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "DriveInterface.setPos", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_pos(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call DriveInterface.setPos() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DriveInterface::set_pos(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setPos", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_pos((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DriveInterface.setPos() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setPos() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setPos(non-const DriveInterface this, const VBase3 vec)\n"
          "setPos(non-const DriveInterface this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_set_pos_66_comment =
    "C++ Interface:\n"
    "setPos(non-const DriveInterface this, const VBase3 vec)\n"
    "setPos(non-const DriveInterface this, float x, float y, float z)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::set_pos\n"
    "//       Access: Published\n"
    "//  Description: Directly sets the driver's position.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_set_pos_66_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DriveInterface::set_x(float x)
 *******************************************************************/
static PyObject *Dtool_DriveInterface_set_x_67(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DriveInterface::set_x(float x)
        double param1;
        static char * key_word_list[] = {(char *)"x", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setX", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setX", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_x((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DriveInterface.setX() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setX(non-const DriveInterface this, float x)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_set_x_67_comment =
    "C++ Interface:\n"
    "setX(non-const DriveInterface this, float x)\n"
    "\n"
    "";
#else
static const char * Dtool_DriveInterface_set_x_67_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DriveInterface::set_y(float y)
 *******************************************************************/
static PyObject *Dtool_DriveInterface_set_y_68(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DriveInterface::set_y(float y)
        double param1;
        static char * key_word_list[] = {(char *)"y", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setY", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setY", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_y((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DriveInterface.setY() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setY(non-const DriveInterface this, float y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_set_y_68_comment =
    "C++ Interface:\n"
    "setY(non-const DriveInterface this, float y)\n"
    "\n"
    "";
#else
static const char * Dtool_DriveInterface_set_y_68_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DriveInterface::set_z(float z)
 *******************************************************************/
static PyObject *Dtool_DriveInterface_set_z_69(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DriveInterface::set_z(float z)
        double param1;
        static char * key_word_list[] = {(char *)"z", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setZ", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setZ", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_z((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DriveInterface.setZ() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setZ(non-const DriveInterface this, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_set_z_69_comment =
    "C++ Interface:\n"
    "setZ(non-const DriveInterface this, float z)\n"
    "\n"
    "";
#else
static const char * Dtool_DriveInterface_set_z_69_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f const &DriveInterface::get_hpr(void) const
 *******************************************************************/
static PyObject *Dtool_DriveInterface_get_hpr_70(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f const &DriveInterface::get_hpr(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHpr", key_word_list));
        else
            (PyArg_Parse(args, ":getHpr"));
        if(!PyErr_Occurred())
        {
            LVecBase3f const *return_value = &(((const DriveInterface*)local_this)->get_hpr());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHpr(const DriveInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_get_hpr_70_comment =
    "C++ Interface:\n"
    "getHpr(const DriveInterface this)\n"
    "\n"
    "/// **** Rotation ****\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::get_hpr\n"
    "//       Access: Published\n"
    "//  Description: Returns the driver's orientation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_get_hpr_70_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DriveInterface::get_h(void) const
 *******************************************************************/
static PyObject *Dtool_DriveInterface_get_h_71(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DriveInterface::get_h(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getH", key_word_list));
        else
            (PyArg_Parse(args, ":getH"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DriveInterface*)local_this)->get_h();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getH(const DriveInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_get_h_71_comment =
    "C++ Interface:\n"
    "getH(const DriveInterface this)\n"
    "\n"
    "";
#else
static const char * Dtool_DriveInterface_get_h_71_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DriveInterface::get_p(void) const
 *******************************************************************/
static PyObject *Dtool_DriveInterface_get_p_72(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DriveInterface::get_p(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getP", key_word_list));
        else
            (PyArg_Parse(args, ":getP"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DriveInterface*)local_this)->get_p();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getP(const DriveInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_get_p_72_comment =
    "C++ Interface:\n"
    "getP(const DriveInterface this)\n"
    "\n"
    "";
#else
static const char * Dtool_DriveInterface_get_p_72_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DriveInterface::get_r(void) const
 *******************************************************************/
static PyObject *Dtool_DriveInterface_get_r_73(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DriveInterface::get_r(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getR", key_word_list));
        else
            (PyArg_Parse(args, ":getR"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DriveInterface*)local_this)->get_r();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getR(const DriveInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_get_r_73_comment =
    "C++ Interface:\n"
    "getR(const DriveInterface this)\n"
    "\n"
    "";
#else
static const char * Dtool_DriveInterface_get_r_73_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DriveInterface::set_hpr(LVecBase3f const &hpr)
 * inline void DriveInterface::set_hpr(float h, float p, float r)
 *******************************************************************/
static PyObject *Dtool_DriveInterface_set_hpr_74(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void DriveInterface::set_hpr(LVecBase3f const &hpr)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"hpr", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setHpr", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setHpr", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "DriveInterface.setHpr", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_hpr(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call DriveInterface.setHpr() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DriveInterface::set_hpr(float h, float p, float r)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"h", (char *)"p", (char *)"r", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setHpr", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_hpr((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DriveInterface.setHpr() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setHpr() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setHpr(non-const DriveInterface this, const VBase3 hpr)\n"
          "setHpr(non-const DriveInterface this, float h, float p, float r)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_set_hpr_74_comment =
    "C++ Interface:\n"
    "setHpr(non-const DriveInterface this, const VBase3 hpr)\n"
    "setHpr(non-const DriveInterface this, float h, float p, float r)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::set_hpr\n"
    "//       Access: Published\n"
    "//  Description: Directly sets the driver's orientation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_set_hpr_74_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DriveInterface::set_h(float h)
 *******************************************************************/
static PyObject *Dtool_DriveInterface_set_h_75(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DriveInterface::set_h(float h)
        double param1;
        static char * key_word_list[] = {(char *)"h", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setH", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setH", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_h((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DriveInterface.setH() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setH(non-const DriveInterface this, float h)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_set_h_75_comment =
    "C++ Interface:\n"
    "setH(non-const DriveInterface this, float h)\n"
    "\n"
    "";
#else
static const char * Dtool_DriveInterface_set_h_75_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DriveInterface::set_p(float p)
 *******************************************************************/
static PyObject *Dtool_DriveInterface_set_p_76(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DriveInterface::set_p(float p)
        double param1;
        static char * key_word_list[] = {(char *)"p", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setP", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setP", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_p((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DriveInterface.setP() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setP(non-const DriveInterface this, float p)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_set_p_76_comment =
    "C++ Interface:\n"
    "setP(non-const DriveInterface this, float p)\n"
    "\n"
    "";
#else
static const char * Dtool_DriveInterface_set_p_76_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DriveInterface::set_r(float r)
 *******************************************************************/
static PyObject *Dtool_DriveInterface_set_r_77(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DriveInterface::set_r(float r)
        double param1;
        static char * key_word_list[] = {(char *)"r", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setR", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setR", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_r((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DriveInterface.setR() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setR(non-const DriveInterface this, float r)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_set_r_77_comment =
    "C++ Interface:\n"
    "setR(non-const DriveInterface this, float r)\n"
    "\n"
    "";
#else
static const char * Dtool_DriveInterface_set_r_77_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DriveInterface::set_force_roll(float force_roll)
 *******************************************************************/
static PyObject *Dtool_DriveInterface_set_force_roll_78(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DriveInterface::set_force_roll(float force_roll)
        double param1;
        static char * key_word_list[] = {(char *)"force_roll", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setForceRoll", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setForceRoll", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_force_roll((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DriveInterface.setForceRoll() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setForceRoll(non-const DriveInterface this, float force_roll)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_set_force_roll_78_comment =
    "C++ Interface:\n"
    "setForceRoll(non-const DriveInterface this, float force_roll)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::set_force_roll\n"
    "//       Access: Published\n"
    "//  Description: This function is no longer used and does nothing.  It\n"
    "//               will be removed soon.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_set_force_roll_78_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DriveInterface::set_ignore_mouse(bool ignore_mouse)
 *******************************************************************/
static PyObject *Dtool_DriveInterface_set_ignore_mouse_79(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DriveInterface::set_ignore_mouse(bool ignore_mouse)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"ignore_mouse", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setIgnoreMouse", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setIgnoreMouse", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_ignore_mouse((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DriveInterface.setIgnoreMouse() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setIgnoreMouse(non-const DriveInterface this, bool ignore_mouse)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_set_ignore_mouse_79_comment =
    "C++ Interface:\n"
    "setIgnoreMouse(non-const DriveInterface this, bool ignore_mouse)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::set_ignore_mouse\n"
    "//       Access: Published\n"
    "//  Description: Changes the state of the ignore_mouse flag.  If this\n"
    "//               flag is true, the DriveInterface will ignore mouse\n"
    "//               down button events (but still recognize mouse up\n"
    "//               button events); the user will not be able to start\n"
    "//               the DriveInterface going again if it is stopped, but\n"
    "//               if the user is currently holding down a mouse button\n"
    "//               it will not stop immediately until the user\n"
    "//               eventually releases the button.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_set_ignore_mouse_79_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DriveInterface::get_ignore_mouse(void) const
 *******************************************************************/
static PyObject *Dtool_DriveInterface_get_ignore_mouse_80(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DriveInterface::get_ignore_mouse(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getIgnoreMouse", key_word_list));
        else
            (PyArg_Parse(args, ":getIgnoreMouse"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DriveInterface*)local_this)->get_ignore_mouse();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIgnoreMouse(const DriveInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_get_ignore_mouse_80_comment =
    "C++ Interface:\n"
    "getIgnoreMouse(const DriveInterface this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::get_ignore_mouse\n"
    "//       Access: Published\n"
    "//  Description: Returns the current setting of the ignore_mouse flag.\n"
    "//               See set_ignore_mouse().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_get_ignore_mouse_80_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DriveInterface::set_force_mouse(bool force_mouse)
 *******************************************************************/
static PyObject *Dtool_DriveInterface_set_force_mouse_81(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DriveInterface::set_force_mouse(bool force_mouse)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"force_mouse", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setForceMouse", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setForceMouse", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_force_mouse((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DriveInterface.setForceMouse() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setForceMouse(non-const DriveInterface this, bool force_mouse)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_set_force_mouse_81_comment =
    "C++ Interface:\n"
    "setForceMouse(non-const DriveInterface this, bool force_mouse)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::set_force_mouse\n"
    "//       Access: Published\n"
    "//  Description: Changes the state of the force_mouse flag.  If this\n"
    "//               flag is true, the mouse button need not be held down\n"
    "//               in order to drive the avatar around.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_set_force_mouse_81_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DriveInterface::get_force_mouse(void) const
 *******************************************************************/
static PyObject *Dtool_DriveInterface_get_force_mouse_82(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DriveInterface::get_force_mouse(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getForceMouse", key_word_list));
        else
            (PyArg_Parse(args, ":getForceMouse"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DriveInterface*)local_this)->get_force_mouse();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getForceMouse(const DriveInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_get_force_mouse_82_comment =
    "C++ Interface:\n"
    "getForceMouse(const DriveInterface this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::get_force_mouse\n"
    "//       Access: Published\n"
    "//  Description: Returns the current setting of the force_mouse flag.\n"
    "//               See set_force_mouse().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_get_force_mouse_82_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DriveInterface::set_stop_this_frame(bool stop_this_frame)
 *******************************************************************/
static PyObject *Dtool_DriveInterface_set_stop_this_frame_83(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DriveInterface::set_stop_this_frame(bool stop_this_frame)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"stop_this_frame", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setStopThisFrame", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setStopThisFrame", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_stop_this_frame((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DriveInterface.setStopThisFrame() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setStopThisFrame(non-const DriveInterface this, bool stop_this_frame)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_set_stop_this_frame_83_comment =
    "C++ Interface:\n"
    "setStopThisFrame(non-const DriveInterface this, bool stop_this_frame)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::set_stop_this_frame\n"
    "//       Access: Published\n"
    "//  Description: If stop_this_frame is true, the next time the frame\n"
    "//               is computed no motion will be allowed, and then the\n"
    "//               flag is reset to false.  This can be used to prevent\n"
    "//               too much movement when we know a long time has\n"
    "//               artificially elapsed, for instance when we take a\n"
    "//               screenshot, without munging the clock for everything\n"
    "//               else.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_set_stop_this_frame_83_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DriveInterface::get_stop_this_frame(void) const
 *******************************************************************/
static PyObject *Dtool_DriveInterface_get_stop_this_frame_84(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DriveInterface::get_stop_this_frame(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStopThisFrame", key_word_list));
        else
            (PyArg_Parse(args, ":getStopThisFrame"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DriveInterface*)local_this)->get_stop_this_frame();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStopThisFrame(const DriveInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_get_stop_this_frame_84_comment =
    "C++ Interface:\n"
    "getStopThisFrame(const DriveInterface this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::get_stop_this_frame\n"
    "//       Access: Published\n"
    "//  Description: Returns the current setting of the stop_this_frame\n"
    "//               flag.  See set_stop_this_frame().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_get_stop_this_frame_84_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DriveInterface::set_mat(LMatrix4f const &mat)
 *******************************************************************/
static PyObject *Dtool_DriveInterface_set_mat_85(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DriveInterface::set_mat(LMatrix4f const &mat)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"mat", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setMat", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setMat", &param1));
            if(!PyErr_Occurred())
            {
                LMatrix4f *param1_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LMatrix4f, 1, "DriveInterface.setMat", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_mat(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DriveInterface.setMat() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMat(non-const DriveInterface this, const Mat4 mat)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_set_mat_85_comment =
    "C++ Interface:\n"
    "setMat(non-const DriveInterface this, const Mat4 mat)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::set_mat\n"
    "//       Access: Published\n"
    "//  Description: Stores the indicated transform in the DriveInterface.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_set_mat_85_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LMatrix4f const &DriveInterface::get_mat(void)
 *******************************************************************/
static PyObject *Dtool_DriveInterface_get_mat_86(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-LMatrix4f const &DriveInterface::get_mat(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMat", key_word_list));
        else
            (PyArg_Parse(args, ":getMat"));
        if(!PyErr_Occurred())
        {
            LMatrix4f const *return_value = &((local_this)->get_mat());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LMatrix4f,false, true);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DriveInterface.getMat() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMat(non-const DriveInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_get_mat_86_comment =
    "C++ Interface:\n"
    "getMat(non-const DriveInterface this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::get_mat\n"
    "//       Access: Published\n"
    "//  Description: Returns the current transform.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_get_mat_86_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DriveInterface::force_dgraph(void)
 *******************************************************************/
static PyObject *Dtool_DriveInterface_force_dgraph_87(PyObject *self, PyObject *args,PyObject *kwds) {
    DriveInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DriveInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DriveInterface::force_dgraph(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":forceDgraph", key_word_list));
        else
            (PyArg_Parse(args, ":forceDgraph"));
        if(!PyErr_Occurred())
        {
            (local_this)->force_dgraph();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DriveInterface.forceDgraph() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "forceDgraph(non-const DriveInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_force_dgraph_87_comment =
    "C++ Interface:\n"
    "forceDgraph(non-const DriveInterface this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DriveInterface::force_dgraph\n"
    "//       Access: Public\n"
    "//  Description: This is a special kludge for DriveInterface to allow\n"
    "//               us to avoid the one-frame latency after a collision.\n"
    "//               It forces an immediate partial data flow for all data\n"
    "//               graph nodes below this node, causing all data nodes\n"
    "//               that depend on this matrix to be updated immediately.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DriveInterface_force_dgraph_87_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DriveInterface::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DriveInterface_get_class_type_88(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DriveInterface::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DriveInterface::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DriveInterface_get_class_type_88_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DriveInterface_get_class_type_88_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DriveInterface::DriveInterface(basic_string< char > const &name)
 * DriveInterface::DriveInterface(basic_string< char > const &name = (""))
 *******************************************************************/
int  Dtool_Init_DriveInterface(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-DriveInterface::DriveInterface(basic_string< char > const &name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":DriveInterface", key_word_list))
            {
                DriveInterface *return_value = new DriveInterface();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DriveInterface,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-DriveInterface::DriveInterface(basic_string< char > const &name)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DriveInterface", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:DriveInterface", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                DriveInterface *return_value = new DriveInterface(basic_string<char>(param0_str, param0_len));
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DriveInterface,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "DriveInterface() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "DriveInterface()\n"
          "DriveInterface(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DriveInterface(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DriveInterface)
    {
        printf("DriveInterface ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DriveInterface * local_this = (DriveInterface *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DriveInterface)
        return local_this;
    if(requested_type == &Dtool_DataNode)
        return ( DataNode *)( MouseInterfaceNode *) local_this;
    if(requested_type == &Dtool_MouseInterfaceNode)
        return ( MouseInterfaceNode *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( DataNode *)( MouseInterfaceNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( DataNode *)( MouseInterfaceNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( DataNode *)( MouseInterfaceNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( DataNode *)( MouseInterfaceNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( DataNode *)( MouseInterfaceNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DriveInterface(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DriveInterface)
        return from_this;
    if(from_type == &Dtool_DataNode)
    {
          DataNode* other_this = (DataNode*)from_this;
          return (DriveInterface*)other_this;
    }
    if(from_type == &Dtool_MouseInterfaceNode)
    {
          MouseInterfaceNode* other_this = (MouseInterfaceNode*)from_this;
          return (DriveInterface*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (DriveInterface*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (DriveInterface*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DriveInterface*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (DriveInterface*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. MouseSubregion 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline float MouseSubregion::get_left(void) const
 *******************************************************************/
static PyObject *Dtool_MouseSubregion_get_left_91(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseSubregion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseSubregion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float MouseSubregion::get_left(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLeft", key_word_list));
        else
            (PyArg_Parse(args, ":getLeft"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const MouseSubregion*)local_this)->get_left();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLeft(const MouseSubregion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseSubregion_get_left_91_comment =
    "C++ Interface:\n"
    "getLeft(const MouseSubregion this)\n"
    "\n"
    "// Filename: mouseSubregion.I\n"
    "// Created by:  drose (13May05)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseSubregion::get_left\n"
    "//       Access: Published\n"
    "//  Description: Retrieves the x coordinate of the left edge of the\n"
    "//               rectangle within the window.  This number will be in\n"
    "//               the range [0..1].\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseSubregion_get_left_91_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float MouseSubregion::get_right(void) const
 *******************************************************************/
static PyObject *Dtool_MouseSubregion_get_right_92(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseSubregion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseSubregion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float MouseSubregion::get_right(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRight", key_word_list));
        else
            (PyArg_Parse(args, ":getRight"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const MouseSubregion*)local_this)->get_right();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRight(const MouseSubregion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseSubregion_get_right_92_comment =
    "C++ Interface:\n"
    "getRight(const MouseSubregion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseSubregion::get_right\n"
    "//       Access: Published\n"
    "//  Description: Retrieves the x coordinate of the right edge of the\n"
    "//               rectangle within the window.  This number will be in\n"
    "//               the range [0..1].\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseSubregion_get_right_92_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float MouseSubregion::get_bottom(void) const
 *******************************************************************/
static PyObject *Dtool_MouseSubregion_get_bottom_93(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseSubregion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseSubregion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float MouseSubregion::get_bottom(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBottom", key_word_list));
        else
            (PyArg_Parse(args, ":getBottom"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const MouseSubregion*)local_this)->get_bottom();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBottom(const MouseSubregion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseSubregion_get_bottom_93_comment =
    "C++ Interface:\n"
    "getBottom(const MouseSubregion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseSubregion::get_bottom\n"
    "//       Access: Published\n"
    "//  Description: Retrieves the y coordinate of the bottom edge of \n"
    "//               the rectangle within the window.  This number will be\n"
    "//               in the range [0..1].\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseSubregion_get_bottom_93_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float MouseSubregion::get_top(void) const
 *******************************************************************/
static PyObject *Dtool_MouseSubregion_get_top_94(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseSubregion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseSubregion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float MouseSubregion::get_top(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTop", key_word_list));
        else
            (PyArg_Parse(args, ":getTop"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const MouseSubregion*)local_this)->get_top();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTop(const MouseSubregion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseSubregion_get_top_94_comment =
    "C++ Interface:\n"
    "getTop(const MouseSubregion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseSubregion::get_top\n"
    "//       Access: Published\n"
    "//  Description: Retrieves the y coordinate of the top edge of the\n"
    "//               rectangle within the window.  This number will be in\n"
    "//               the range [0..1].\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseSubregion_get_top_94_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MouseSubregion::set_dimensions(float l, float r, float b, float t)
 *******************************************************************/
static PyObject *Dtool_MouseSubregion_set_dimensions_95(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseSubregion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseSubregion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void MouseSubregion::set_dimensions(float l, float r, float b, float t)
        double param1;
        double param2;
        double param3;
        double param4;
        static char * key_word_list[] = {(char *)"l", (char *)"r", (char *)"b", (char *)"t", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:setDimensions", key_word_list, &param1, &param2, &param3, &param4))
        {
            (local_this)->set_dimensions((float)param1, (float)param2, (float)param3, (float)param4);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseSubregion.setDimensions() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDimensions(non-const MouseSubregion this, float l, float r, float b, float t)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseSubregion_set_dimensions_95_comment =
    "C++ Interface:\n"
    "setDimensions(non-const MouseSubregion this, float l, float r, float b, float t)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseSubregion::set_dimensions\n"
    "//       Access: Published\n"
    "//  Description: Changes the region of the window in which the mouse\n"
    "//               is considered to be active.  The parameters are\n"
    "//               identical to those for a DisplayRegion: they range\n"
    "//               from 0 to 1, where 0,0 is the lower left corner and\n"
    "//               1,1 is the upper right; (0, 1, 0, 1) represents the\n"
    "//               whole window.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseSubregion_set_dimensions_95_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle MouseSubregion::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_MouseSubregion_get_class_type_96(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle MouseSubregion::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = MouseSubregion::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseSubregion_get_class_type_96_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_MouseSubregion_get_class_type_96_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * MouseSubregion::MouseSubregion(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_MouseSubregion(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-MouseSubregion::MouseSubregion(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:MouseSubregion", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:MouseSubregion", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            MouseSubregion *return_value = new MouseSubregion(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_MouseSubregion,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "MouseSubregion(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_MouseSubregion(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_MouseSubregion)
    {
        printf("MouseSubregion ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    MouseSubregion * local_this = (MouseSubregion *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_MouseSubregion)
        return local_this;
    if(requested_type == &Dtool_DataNode)
        return ( DataNode *)( MouseInterfaceNode *) local_this;
    if(requested_type == &Dtool_MouseInterfaceNode)
        return ( MouseInterfaceNode *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( DataNode *)( MouseInterfaceNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( DataNode *)( MouseInterfaceNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( DataNode *)( MouseInterfaceNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( DataNode *)( MouseInterfaceNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( DataNode *)( MouseInterfaceNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_MouseSubregion(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_MouseSubregion)
        return from_this;
    if(from_type == &Dtool_DataNode)
    {
          DataNode* other_this = (DataNode*)from_this;
          return (MouseSubregion*)other_this;
    }
    if(from_type == &Dtool_MouseInterfaceNode)
    {
          MouseInterfaceNode* other_this = (MouseInterfaceNode*)from_this;
          return (MouseSubregion*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (MouseSubregion*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (MouseSubregion*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (MouseSubregion*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (MouseSubregion*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. MouseWatcherRegion 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void MouseWatcherRegion::set_frame(LVecBase4f const &frame)
 * inline void MouseWatcherRegion::set_frame(float left, float right, float bottom, float top)
 *******************************************************************/
static PyObject *Dtool_MouseWatcherRegion_set_frame_105(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void MouseWatcherRegion::set_frame(LVecBase4f const &frame)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"frame", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFrame", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setFrame", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "MouseWatcherRegion.setFrame", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_frame(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call MouseWatcherRegion.setFrame() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void MouseWatcherRegion::set_frame(float left, float right, float bottom, float top)
            double param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"left", (char *)"right", (char *)"bottom", (char *)"top", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:setFrame", key_word_list, &param1, &param2, &param3, &param4))
            {
                (local_this)->set_frame((float)param1, (float)param2, (float)param3, (float)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MouseWatcherRegion.setFrame() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setFrame() takes 2 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setFrame(non-const MouseWatcherRegion this, const VBase4 frame)\n"
          "setFrame(non-const MouseWatcherRegion this, float left, float right, float bottom, float top)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherRegion_set_frame_105_comment =
    "C++ Interface:\n"
    "setFrame(non-const MouseWatcherRegion this, const VBase4 frame)\n"
    "setFrame(non-const MouseWatcherRegion this, float left, float right, float bottom, float top)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherRegion::set_frame\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherRegion::set_frame\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherRegion_set_frame_105_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &MouseWatcherRegion::get_frame(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcherRegion_get_frame_106(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &MouseWatcherRegion::get_frame(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFrame", key_word_list));
        else
            (PyArg_Parse(args, ":getFrame"));
        if(!PyErr_Occurred())
        {
            LVecBase4f const *return_value = &(((const MouseWatcherRegion*)local_this)->get_frame());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFrame(const MouseWatcherRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherRegion_get_frame_106_comment =
    "C++ Interface:\n"
    "getFrame(const MouseWatcherRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherRegion::get_frame\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherRegion_get_frame_106_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float MouseWatcherRegion::get_area(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcherRegion_get_area_107(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float MouseWatcherRegion::get_area(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getArea", key_word_list));
        else
            (PyArg_Parse(args, ":getArea"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const MouseWatcherRegion*)local_this)->get_area();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getArea(const MouseWatcherRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherRegion_get_area_107_comment =
    "C++ Interface:\n"
    "getArea(const MouseWatcherRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherRegion::get_area\n"
    "//       Access: Published\n"
    "//  Description: Returns the area of the rectangular region.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherRegion_get_area_107_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MouseWatcherRegion::set_sort(int sort)
 *******************************************************************/
static PyObject *Dtool_MouseWatcherRegion_set_sort_108(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void MouseWatcherRegion::set_sort(int sort)
        int param1;
        static char * key_word_list[] = {(char *)"sort", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setSort", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setSort", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_sort((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseWatcherRegion.setSort() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSort(non-const MouseWatcherRegion this, int sort)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherRegion_set_sort_108_comment =
    "C++ Interface:\n"
    "setSort(non-const MouseWatcherRegion this, int sort)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherRegion::set_sort\n"
    "//       Access: Published\n"
    "//  Description: Changes the sorting order of this particular region.\n"
    "//               The sorting order is used to resolve conflicts in the\n"
    "//               case of overlapping region; the region with the\n"
    "//               highest sort value will be preferred, and between\n"
    "//               regions of the same sort value, the smallest region\n"
    "//               will be preferred.  The default sorting order, if\n"
    "//               none is explicitly specified, is 0.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherRegion_set_sort_108_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int MouseWatcherRegion::get_sort(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcherRegion_get_sort_109(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int MouseWatcherRegion::get_sort(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSort", key_word_list));
        else
            (PyArg_Parse(args, ":getSort"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const MouseWatcherRegion*)local_this)->get_sort();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSort(const MouseWatcherRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherRegion_get_sort_109_comment =
    "C++ Interface:\n"
    "getSort(const MouseWatcherRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherRegion::get_sort\n"
    "//       Access: Published\n"
    "//  Description: Returns the current sorting order of this region.\n"
    "//               See set_sort().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherRegion_get_sort_109_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MouseWatcherRegion::set_active(bool active)
 *******************************************************************/
static PyObject *Dtool_MouseWatcherRegion_set_active_110(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void MouseWatcherRegion::set_active(bool active)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"active", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setActive", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setActive", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_active((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseWatcherRegion.setActive() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setActive(non-const MouseWatcherRegion this, bool active)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherRegion_set_active_110_comment =
    "C++ Interface:\n"
    "setActive(non-const MouseWatcherRegion this, bool active)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherRegion::set_active\n"
    "//       Access: Published\n"
    "//  Description: Sets whether the region is active or not.  If it is\n"
    "//               not active, the MouseWatcher will never consider the\n"
    "//               mouse to be over the region.  The region might still\n"
    "//               receive keypress events if its set_keyboard() flag is\n"
    "//               true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherRegion_set_active_110_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool MouseWatcherRegion::get_active(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcherRegion_get_active_111(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool MouseWatcherRegion::get_active(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getActive", key_word_list));
        else
            (PyArg_Parse(args, ":getActive"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const MouseWatcherRegion*)local_this)->get_active();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getActive(const MouseWatcherRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherRegion_get_active_111_comment =
    "C++ Interface:\n"
    "getActive(const MouseWatcherRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherRegion::get_active\n"
    "//       Access: Published\n"
    "//  Description: Returns whether the region is active or not.  See\n"
    "//               set_active().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherRegion_get_active_111_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MouseWatcherRegion::set_keyboard(bool keyboard)
 *******************************************************************/
static PyObject *Dtool_MouseWatcherRegion_set_keyboard_112(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void MouseWatcherRegion::set_keyboard(bool keyboard)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"keyboard", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setKeyboard", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setKeyboard", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_keyboard((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseWatcherRegion.setKeyboard() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setKeyboard(non-const MouseWatcherRegion this, bool keyboard)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherRegion_set_keyboard_112_comment =
    "C++ Interface:\n"
    "setKeyboard(non-const MouseWatcherRegion this, bool keyboard)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherRegion::set_keyboard\n"
    "//       Access: Published\n"
    "//  Description: Sets whether the region is interested in global\n"
    "//               keyboard events.  If this is true, then any keyboard\n"
    "//               button events will be passed to press() and release()\n"
    "//               regardless of the position of the mouse onscreen;\n"
    "//               otherwise, these events will only be passed if the\n"
    "//               mouse is over the region.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherRegion_set_keyboard_112_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool MouseWatcherRegion::get_keyboard(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcherRegion_get_keyboard_113(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool MouseWatcherRegion::get_keyboard(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getKeyboard", key_word_list));
        else
            (PyArg_Parse(args, ":getKeyboard"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const MouseWatcherRegion*)local_this)->get_keyboard();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getKeyboard(const MouseWatcherRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherRegion_get_keyboard_113_comment =
    "C++ Interface:\n"
    "getKeyboard(const MouseWatcherRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherRegion::get_keyboard\n"
    "//       Access: Published\n"
    "//  Description: Returns whether the region is interested in global\n"
    "//               keyboard events; see set_keyboard().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherRegion_get_keyboard_113_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MouseWatcherRegion::set_suppress_flags(int suppress_flags)
 *******************************************************************/
static PyObject *Dtool_MouseWatcherRegion_set_suppress_flags_115(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void MouseWatcherRegion::set_suppress_flags(int suppress_flags)
        int param1;
        static char * key_word_list[] = {(char *)"suppress_flags", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setSuppressFlags", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setSuppressFlags", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_suppress_flags((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseWatcherRegion.setSuppressFlags() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSuppressFlags(non-const MouseWatcherRegion this, int suppress_flags)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherRegion_set_suppress_flags_115_comment =
    "C++ Interface:\n"
    "setSuppressFlags(non-const MouseWatcherRegion this, int suppress_flags)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherRegion::set_suppress_flags\n"
    "//       Access: Published\n"
    "//  Description: Sets which events are suppressed when the mouse is\n"
    "//               over the region.  This is the union of zero or more\n"
    "//               various SF_* values.  Normally, this is 0, indicating\n"
    "//               that no events are suppressed.\n"
    "//\n"
    "//               If you set this to a non-zero value, for instance\n"
    "//               SF_mouse_position, then the mouse position will not\n"
    "//               be sent along the data graph when the mouse is over\n"
    "//               this particular region.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherRegion_set_suppress_flags_115_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int MouseWatcherRegion::get_suppress_flags(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcherRegion_get_suppress_flags_116(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int MouseWatcherRegion::get_suppress_flags(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSuppressFlags", key_word_list));
        else
            (PyArg_Parse(args, ":getSuppressFlags"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const MouseWatcherRegion*)local_this)->get_suppress_flags();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSuppressFlags(const MouseWatcherRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherRegion_get_suppress_flags_116_comment =
    "C++ Interface:\n"
    "getSuppressFlags(const MouseWatcherRegion this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherRegion::get_suppress_flags\n"
    "//       Access: Published\n"
    "//  Description: Returns the current suppress_flags.  See\n"
    "//               set_suppress_flags().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherRegion_get_suppress_flags_116_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MouseWatcherRegion::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcherRegion_output_117(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void MouseWatcherRegion::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "MouseWatcherRegion.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const MouseWatcherRegion*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const MouseWatcherRegion this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherRegion_output_117_comment =
    "C++ Interface:\n"
    "output(const MouseWatcherRegion this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherRegion::output\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherRegion_output_117_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MouseWatcherRegion::write(ostream &out, int indent_level) const
 * void MouseWatcherRegion::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcherRegion_write_118(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void MouseWatcherRegion::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "MouseWatcherRegion.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const MouseWatcherRegion*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void MouseWatcherRegion::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "MouseWatcherRegion.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const MouseWatcherRegion*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const MouseWatcherRegion this, non-const Ostream out)\n"
          "write(const MouseWatcherRegion this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherRegion_write_118_comment =
    "C++ Interface:\n"
    "write(const MouseWatcherRegion this, non-const Ostream out)\n"
    "write(const MouseWatcherRegion this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherRegion::write\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherRegion_write_118_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle MouseWatcherRegion::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_MouseWatcherRegion_get_class_type_119(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle MouseWatcherRegion::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = MouseWatcherRegion::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherRegion_get_class_type_119_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_MouseWatcherRegion_get_class_type_119_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TypedWritableReferenceCount *MouseWatcherRegion::upcast_to_TypedWritableReferenceCount(void)
 *******************************************************************/
static PyObject *Dtool_MouseWatcherRegion_upcast_to_TypedWritableReferenceCount_99(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-TypedWritableReferenceCount *MouseWatcherRegion::upcast_to_TypedWritableReferenceCount(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToTypedWritableReferenceCount", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToTypedWritableReferenceCount"));
        if(!PyErr_Occurred())
        {
            TypedWritableReferenceCount *return_value = (TypedWritableReferenceCount *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TypedWritableReferenceCount,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseWatcherRegion.upcastToTypedWritableReferenceCount() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToTypedWritableReferenceCount(non-const MouseWatcherRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherRegion_upcast_to_TypedWritableReferenceCount_99_comment =
    "C++ Interface:\n"
    "upcastToTypedWritableReferenceCount(non-const MouseWatcherRegion this)\n"
    "\n"
    "upcast from MouseWatcherRegion to TypedWritableReferenceCount\n"
    "";
#else
static const char * Dtool_MouseWatcherRegion_upcast_to_TypedWritableReferenceCount_99_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Namable *MouseWatcherRegion::upcast_to_Namable(void)
 *******************************************************************/
static PyObject *Dtool_MouseWatcherRegion_upcast_to_Namable_102(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherRegion,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-Namable *MouseWatcherRegion::upcast_to_Namable(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToNamable", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToNamable"));
        if(!PyErr_Occurred())
        {
            Namable *return_value = (Namable *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Namable,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseWatcherRegion.upcastToNamable() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToNamable(non-const MouseWatcherRegion this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherRegion_upcast_to_Namable_102_comment =
    "C++ Interface:\n"
    "upcastToNamable(non-const MouseWatcherRegion this)\n"
    "\n"
    "upcast from MouseWatcherRegion to Namable\n"
    "";
#else
static const char * Dtool_MouseWatcherRegion_upcast_to_Namable_102_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline MouseWatcherRegion::MouseWatcherRegion(basic_string< char > const &name, LVecBase4f const &frame)
 * inline MouseWatcherRegion::MouseWatcherRegion(basic_string< char > const &name, float left, float right, float bottom, float top)
 *******************************************************************/
int  Dtool_Init_MouseWatcherRegion(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline MouseWatcherRegion::MouseWatcherRegion(basic_string< char > const &name, LVecBase4f const &frame)
                char *param0_str; int param0_len;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"name", (char *)"frame", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:MouseWatcherRegion", key_word_list, &param0_str, &param0_len, &param1))
                {
                    LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "MouseWatcherRegion.MouseWatcherRegion", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        MouseWatcherRegion *return_value = new MouseWatcherRegion(basic_string<char>(param0_str, param0_len), *param1_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_MouseWatcherRegion,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(5):
        {
        {
          // 1-inline MouseWatcherRegion::MouseWatcherRegion(basic_string< char > const &name, float left, float right, float bottom, float top)
            char *param0_str; int param0_len;
            double param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"name", (char *)"left", (char *)"right", (char *)"bottom", (char *)"top", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#dddd:MouseWatcherRegion", key_word_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4))
            {
                MouseWatcherRegion *return_value = new MouseWatcherRegion(basic_string<char>(param0_str, param0_len), (float)param1, (float)param2, (float)param3, (float)param4);
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_MouseWatcherRegion,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "MouseWatcherRegion() takes 2 or 5 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "MouseWatcherRegion(string name, const VBase4 frame)\n"
          "MouseWatcherRegion(string name, float left, float right, float bottom, float top)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_MouseWatcherRegion(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_MouseWatcherRegion)
    {
        printf("MouseWatcherRegion ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    MouseWatcherRegion * local_this = (MouseWatcherRegion *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_MouseWatcherRegion)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_MouseWatcherRegion(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_MouseWatcherRegion)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (MouseWatcherRegion*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (MouseWatcherRegion*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (MouseWatcherRegion*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (MouseWatcherRegion*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (MouseWatcherRegion*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. MouseWatcherGroup 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void MouseWatcherGroup::add_region(MouseWatcherRegion *region)
 *******************************************************************/
static PyObject *Dtool_MouseWatcherGroup_add_region_125(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void MouseWatcherGroup::add_region(MouseWatcherRegion *region)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"region", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addRegion", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addRegion", &param1));
            if(!PyErr_Occurred())
            {
                MouseWatcherRegion *param1_this = (MouseWatcherRegion *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_MouseWatcherRegion, 1, "MouseWatcherGroup.addRegion", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_region(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MouseWatcherGroup.addRegion() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addRegion(non-const MouseWatcherGroup this, non-const MouseWatcherRegion region)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherGroup_add_region_125_comment =
    "C++ Interface:\n"
    "addRegion(non-const MouseWatcherGroup this, non-const MouseWatcherRegion region)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherGroup::add_region\n"
    "//       Access: Published\n"
    "//  Description: Adds the indicated region to the set of regions in\n"
    "//               the group.  It is an error to add the same region to\n"
    "//               the set more than once.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherGroup_add_region_125_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool MouseWatcherGroup::has_region(MouseWatcherRegion *region) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcherGroup_has_region_126(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool MouseWatcherGroup::has_region(MouseWatcherRegion *region) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"region", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:hasRegion", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:hasRegion", &param1));
            if(!PyErr_Occurred())
            {
                MouseWatcherRegion *param1_this = (MouseWatcherRegion *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_MouseWatcherRegion, 1, "MouseWatcherGroup.hasRegion", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const MouseWatcherGroup*)local_this)->has_region(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasRegion(const MouseWatcherGroup this, non-const MouseWatcherRegion region)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherGroup_has_region_126_comment =
    "C++ Interface:\n"
    "hasRegion(const MouseWatcherGroup this, non-const MouseWatcherRegion region)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherGroup::has_region\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the indicated region has already been\n"
    "//               added to the MouseWatcherGroup, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherGroup_has_region_126_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool MouseWatcherGroup::remove_region(MouseWatcherRegion *region)
 *******************************************************************/
static PyObject *Dtool_MouseWatcherGroup_remove_region_127(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool MouseWatcherGroup::remove_region(MouseWatcherRegion *region)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"region", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeRegion", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeRegion", &param1));
            if(!PyErr_Occurred())
            {
                MouseWatcherRegion *param1_this = (MouseWatcherRegion *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_MouseWatcherRegion, 1, "MouseWatcherGroup.removeRegion", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->remove_region(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MouseWatcherGroup.removeRegion() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeRegion(non-const MouseWatcherGroup this, non-const MouseWatcherRegion region)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherGroup_remove_region_127_comment =
    "C++ Interface:\n"
    "removeRegion(non-const MouseWatcherGroup this, non-const MouseWatcherRegion region)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherGroup::remove_region\n"
    "//       Access: Published\n"
    "//  Description: Removes the indicated region from the group.\n"
    "//               Returns true if it was successfully removed, or false\n"
    "//               if it wasn't there in the first place.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherGroup_remove_region_127_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * MouseWatcherRegion *MouseWatcherGroup::find_region(basic_string< char > const &name) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcherGroup_find_region_128(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-MouseWatcherRegion *MouseWatcherGroup::find_region(basic_string< char > const &name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:findRegion", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:findRegion", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            MouseWatcherRegion *return_value = ((const MouseWatcherGroup*)local_this)->find_region(basic_string<char>(param1_str, param1_len));
            if (return_value != (MouseWatcherRegion *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_MouseWatcherRegion,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findRegion(const MouseWatcherGroup this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherGroup_find_region_128_comment =
    "C++ Interface:\n"
    "findRegion(const MouseWatcherGroup this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherGroup::find_region\n"
    "//       Access: Published\n"
    "//  Description: Returns a pointer to the first region found with the\n"
    "//               indicated name.  If multiple regions share the same\n"
    "//               name, the one that is returned is indeterminate.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherGroup_find_region_128_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MouseWatcherGroup::clear_regions(void)
 *******************************************************************/
static PyObject *Dtool_MouseWatcherGroup_clear_regions_129(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void MouseWatcherGroup::clear_regions(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearRegions", key_word_list));
        else
            (PyArg_Parse(args, ":clearRegions"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_regions();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseWatcherGroup.clearRegions() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearRegions(non-const MouseWatcherGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherGroup_clear_regions_129_comment =
    "C++ Interface:\n"
    "clearRegions(non-const MouseWatcherGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherGroup::clear_regions\n"
    "//       Access: Published\n"
    "//  Description: Removes all the regions from the group.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherGroup_clear_regions_129_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MouseWatcherGroup::sort_regions(void)
 *******************************************************************/
static PyObject *Dtool_MouseWatcherGroup_sort_regions_130(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void MouseWatcherGroup::sort_regions(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":sortRegions", key_word_list));
        else
            (PyArg_Parse(args, ":sortRegions"));
        if(!PyErr_Occurred())
        {
            (local_this)->sort_regions();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseWatcherGroup.sortRegions() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "sortRegions(non-const MouseWatcherGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherGroup_sort_regions_130_comment =
    "C++ Interface:\n"
    "sortRegions(non-const MouseWatcherGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherGroup::sort_regions\n"
    "//       Access: Published\n"
    "//  Description: Sorts all the regions in this group into pointer\n"
    "//               order.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherGroup_sort_regions_130_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool MouseWatcherGroup::is_sorted(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcherGroup_is_sorted_131(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool MouseWatcherGroup::is_sorted(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isSorted", key_word_list));
        else
            (PyArg_Parse(args, ":isSorted"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const MouseWatcherGroup*)local_this)->is_sorted();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isSorted(const MouseWatcherGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherGroup_is_sorted_131_comment =
    "C++ Interface:\n"
    "isSorted(const MouseWatcherGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherGroup::is_sorted\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the group has already been sorted,\n"
    "//               false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherGroup_is_sorted_131_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int MouseWatcherGroup::get_num_regions(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcherGroup_get_num_regions_132(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int MouseWatcherGroup::get_num_regions(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumRegions", key_word_list));
        else
            (PyArg_Parse(args, ":getNumRegions"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const MouseWatcherGroup*)local_this)->get_num_regions();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumRegions(const MouseWatcherGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherGroup_get_num_regions_132_comment =
    "C++ Interface:\n"
    "getNumRegions(const MouseWatcherGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherGroup::get_num_regions\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of regions in the group.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherGroup_get_num_regions_132_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * MouseWatcherRegion *MouseWatcherGroup::get_region(int n) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcherGroup_get_region_133(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-MouseWatcherRegion *MouseWatcherGroup::get_region(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getRegion", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getRegion", &param1));
        if(!PyErr_Occurred())
        {
            MouseWatcherRegion *return_value = ((const MouseWatcherGroup*)local_this)->get_region((int)param1);
            if (return_value != (MouseWatcherRegion *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_MouseWatcherRegion,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRegion(const MouseWatcherGroup this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherGroup_get_region_133_comment =
    "C++ Interface:\n"
    "getRegion(const MouseWatcherGroup this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherGroup::get_region\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth region of the group; returns NULL if\n"
    "//               there is no nth region.  Note that this is not\n"
    "//               thread-safe; another thread might have removed the\n"
    "//               nth region before you called this method.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherGroup_get_region_133_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MouseWatcherGroup::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcherGroup_output_134(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void MouseWatcherGroup::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "MouseWatcherGroup.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const MouseWatcherGroup*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const MouseWatcherGroup this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherGroup_output_134_comment =
    "C++ Interface:\n"
    "output(const MouseWatcherGroup this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherGroup::output\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherGroup_output_134_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MouseWatcherGroup::write(ostream &out, int indent_level) const
 * void MouseWatcherGroup::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcherGroup_write_135(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void MouseWatcherGroup::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "MouseWatcherGroup.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const MouseWatcherGroup*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void MouseWatcherGroup::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "MouseWatcherGroup.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const MouseWatcherGroup*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const MouseWatcherGroup this, non-const Ostream out)\n"
          "write(const MouseWatcherGroup this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherGroup_write_135_comment =
    "C++ Interface:\n"
    "write(const MouseWatcherGroup this, non-const Ostream out)\n"
    "write(const MouseWatcherGroup this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherGroup::write\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherGroup_write_135_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle MouseWatcherGroup::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_MouseWatcherGroup_get_class_type_136(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle MouseWatcherGroup::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = MouseWatcherGroup::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherGroup_get_class_type_136_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_MouseWatcherGroup_get_class_type_136_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ReferenceCount *MouseWatcherGroup::upcast_to_ReferenceCount(void)
 *******************************************************************/
static PyObject *Dtool_MouseWatcherGroup_upcast_to_ReferenceCount_123(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-ReferenceCount *MouseWatcherGroup::upcast_to_ReferenceCount(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToReferenceCount", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToReferenceCount"));
        if(!PyErr_Occurred())
        {
            ReferenceCount *return_value = (ReferenceCount *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ReferenceCount,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseWatcherGroup.upcastToReferenceCount() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToReferenceCount(non-const MouseWatcherGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherGroup_upcast_to_ReferenceCount_123_comment =
    "C++ Interface:\n"
    "upcastToReferenceCount(non-const MouseWatcherGroup this)\n"
    "\n"
    "upcast from MouseWatcherGroup to ReferenceCount\n"
    "";
#else
static const char * Dtool_MouseWatcherGroup_upcast_to_ReferenceCount_123_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * MouseWatcher *MouseWatcherGroup::downcast_to_MouseWatcher(void)
 *******************************************************************/
static PyObject *Dtool_MouseWatcherGroup_downcast_to_MouseWatcher_141(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-MouseWatcher *MouseWatcherGroup::downcast_to_MouseWatcher(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToMouseWatcher", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToMouseWatcher"));
        if(!PyErr_Occurred())
        {
            MouseWatcher *return_value = (MouseWatcher *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_MouseWatcher,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseWatcherGroup.downcastToMouseWatcher() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToMouseWatcher(non-const MouseWatcherGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherGroup_downcast_to_MouseWatcher_141_comment =
    "C++ Interface:\n"
    "downcastToMouseWatcher(non-const MouseWatcherGroup this)\n"
    "\n"
    "downcast from MouseWatcherGroup to MouseWatcher\n"
    "";
#else
static const char * Dtool_MouseWatcherGroup_downcast_to_MouseWatcher_141_comment = NULL;
#endif

int  Dtool_Init_MouseWatcherGroup(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (MouseWatcherGroup)");
       return -1;
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_MouseWatcherGroup_get_regions(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumRegions", "getRegion");
}
inline void  * Dtool_UpcastInterface_MouseWatcherGroup(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_MouseWatcherGroup)
    {
        printf("MouseWatcherGroup ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    MouseWatcherGroup * local_this = (MouseWatcherGroup *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_MouseWatcherGroup)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_MouseWatcherGroup(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_MouseWatcherGroup)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. MouseWatcher 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * bool MouseWatcher::remove_region(MouseWatcherRegion *region)
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_remove_region_144(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool MouseWatcher::remove_region(MouseWatcherRegion *region)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"region", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeRegion", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeRegion", &param1));
            if(!PyErr_Occurred())
            {
                MouseWatcherRegion *param1_this = (MouseWatcherRegion *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_MouseWatcherRegion, 1, "MouseWatcher.removeRegion", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->remove_region(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MouseWatcher.removeRegion() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeRegion(non-const MouseWatcher this, non-const MouseWatcherRegion region)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_remove_region_144_comment =
    "C++ Interface:\n"
    "removeRegion(non-const MouseWatcher this, non-const MouseWatcherRegion region)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::remove_region\n"
    "//       Access: Published\n"
    "//  Description: Removes the indicated region from the group.\n"
    "//               Returns true if it was successfully removed, or false\n"
    "//               if it wasn't there in the first place.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_remove_region_144_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool MouseWatcher::has_mouse(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_has_mouse_145(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool MouseWatcher::has_mouse(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasMouse", key_word_list));
        else
            (PyArg_Parse(args, ":hasMouse"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const MouseWatcher*)local_this)->has_mouse();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasMouse(const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_has_mouse_145_comment =
    "C++ Interface:\n"
    "hasMouse(const MouseWatcher this)\n"
    "\n"
    "// Filename: mouseWatcher.I\n"
    "// Created by:  drose (12Mar02)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::has_mouse\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the mouse is anywhere within the\n"
    "//               window, false otherwise.  Also see is_mouse_open().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_has_mouse_145_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool MouseWatcher::is_mouse_open(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_is_mouse_open_146(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool MouseWatcher::is_mouse_open(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isMouseOpen", key_word_list));
        else
            (PyArg_Parse(args, ":isMouseOpen"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const MouseWatcher*)local_this)->is_mouse_open();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isMouseOpen(const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_is_mouse_open_146_comment =
    "C++ Interface:\n"
    "isMouseOpen(const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::is_mouse_open\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the mouse is within the window and\n"
    "//               not over some particular MouseWatcherRegion that is\n"
    "//               marked to suppress mouse events; that is, that the\n"
    "//               mouse is in open space within the window.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_is_mouse_open_146_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint2f const &MouseWatcher::get_mouse(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_get_mouse_147(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint2f const &MouseWatcher::get_mouse(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMouse", key_word_list));
        else
            (PyArg_Parse(args, ":getMouse"));
        if(!PyErr_Occurred())
        {
            LPoint2f const *return_value = &(((const MouseWatcher*)local_this)->get_mouse());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint2f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMouse(const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_get_mouse_147_comment =
    "C++ Interface:\n"
    "getMouse(const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::get_mouse\n"
    "//       Access: Published\n"
    "//  Description: It is only valid to call this if has_mouse() returns\n"
    "//               true.  If so, this returns the current position of\n"
    "//               the mouse within the window.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_get_mouse_147_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float MouseWatcher::get_mouse_x(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_get_mouse_x_148(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float MouseWatcher::get_mouse_x(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMouseX", key_word_list));
        else
            (PyArg_Parse(args, ":getMouseX"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const MouseWatcher*)local_this)->get_mouse_x();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMouseX(const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_get_mouse_x_148_comment =
    "C++ Interface:\n"
    "getMouseX(const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::get_mouse_x\n"
    "//       Access: Published\n"
    "//  Description: It is only valid to call this if has_mouse() returns\n"
    "//               true.  If so, this returns the current X position of\n"
    "//               the mouse within the window.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_get_mouse_x_148_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float MouseWatcher::get_mouse_y(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_get_mouse_y_149(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float MouseWatcher::get_mouse_y(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMouseY", key_word_list));
        else
            (PyArg_Parse(args, ":getMouseY"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const MouseWatcher*)local_this)->get_mouse_y();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMouseY(const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_get_mouse_y_149_comment =
    "C++ Interface:\n"
    "getMouseY(const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::get_mouse_y\n"
    "//       Access: Published\n"
    "//  Description: It is only valid to call this if has_mouse() returns\n"
    "//               true.  If so, this returns the current Y position of\n"
    "//               the mouse within the window.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_get_mouse_y_149_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MouseWatcher::set_frame(LVecBase4f const &frame)
 * inline void MouseWatcher::set_frame(float left, float right, float bottom, float top)
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_set_frame_150(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void MouseWatcher::set_frame(LVecBase4f const &frame)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"frame", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFrame", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setFrame", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "MouseWatcher.setFrame", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_frame(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call MouseWatcher.setFrame() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void MouseWatcher::set_frame(float left, float right, float bottom, float top)
            double param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"left", (char *)"right", (char *)"bottom", (char *)"top", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:setFrame", key_word_list, &param1, &param2, &param3, &param4))
            {
                (local_this)->set_frame((float)param1, (float)param2, (float)param3, (float)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MouseWatcher.setFrame() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setFrame() takes 2 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setFrame(non-const MouseWatcher this, const VBase4 frame)\n"
          "setFrame(non-const MouseWatcher this, float left, float right, float bottom, float top)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_set_frame_150_comment =
    "C++ Interface:\n"
    "setFrame(non-const MouseWatcher this, const VBase4 frame)\n"
    "setFrame(non-const MouseWatcher this, float left, float right, float bottom, float top)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::set_frame\n"
    "//       Access: Published\n"
    "//  Description: Sets the frame of the MouseWatcher.  See the next\n"
    "//               flavor of this method for a more verbose explanation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::set_frame\n"
    "//       Access: Published\n"
    "//  Description: Sets the frame of the MouseWatcher.  This determines\n"
    "//               the coordinate space in which the MouseWatcherRegions\n"
    "//               should be expected to live.  Normally, this is left\n"
    "//               at -1, 1, -1, 1, which is the default setting, and\n"
    "//               matches the mouse coordinate range.\n"
    "//\n"
    "//               Whatever values you specify here indicate the shape\n"
    "//               of the full screen, and the MouseWatcherRegions will\n"
    "//               be given in coordinate space matching it.  For\n"
    "//               instance, if you specify (0, 1, 0, 1), then a\n"
    "//               MouseWatcherRegion with the frame (0, 1, 0, .5) will\n"
    "//               cover the lower half of the screen.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_set_frame_150_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &MouseWatcher::get_frame(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_get_frame_151(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &MouseWatcher::get_frame(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFrame", key_word_list));
        else
            (PyArg_Parse(args, ":getFrame"));
        if(!PyErr_Occurred())
        {
            LVecBase4f const *return_value = &(((const MouseWatcher*)local_this)->get_frame());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFrame(const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_get_frame_151_comment =
    "C++ Interface:\n"
    "getFrame(const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::get_frame\n"
    "//       Access: Published\n"
    "//  Description: Returns the frame of the MouseWatcher.  See\n"
    "//               set_frame().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_get_frame_151_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool MouseWatcher::is_over_region(void) const
 * inline bool MouseWatcher::is_over_region(LPoint2f const &pos) const
 * inline bool MouseWatcher::is_over_region(float x, float y) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_is_over_region_152(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline bool MouseWatcher::is_over_region(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":isOverRegion", key_word_list));
            else
                (PyArg_Parse(args, ":isOverRegion"));
            if(!PyErr_Occurred())
            {
                bool return_value = ((const MouseWatcher*)local_this)->is_over_region();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline bool MouseWatcher::is_over_region(LPoint2f const &pos) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"pos", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:isOverRegion", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:isOverRegion", &param1));
                if(!PyErr_Occurred())
                {
                    LPoint2f *param1_this = (LPoint2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint2f, 1, "MouseWatcher.isOverRegion", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = ((const MouseWatcher*)local_this)->is_over_region(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          // 1-inline bool MouseWatcher::is_over_region(float x, float y) const
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:isOverRegion", key_word_list, &param1, &param2))
            {
                bool return_value = ((const MouseWatcher*)local_this)->is_over_region((float)param1, (float)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "isOverRegion() takes 1, 2, or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "isOverRegion(const MouseWatcher this)\n"
          "isOverRegion(const MouseWatcher this, const Point2 pos)\n"
          "isOverRegion(const MouseWatcher this, float x, float y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_is_over_region_152_comment =
    "C++ Interface:\n"
    "isOverRegion(const MouseWatcher this)\n"
    "isOverRegion(const MouseWatcher this, const Point2 pos)\n"
    "isOverRegion(const MouseWatcher this, float x, float y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::is_over_region\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the mouse is over any rectangular\n"
    "//               region, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::is_over_region\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the mouse is over any rectangular\n"
    "//               region, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::is_over_region\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the mouse is over any rectangular\n"
    "//               region, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_is_over_region_152_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline MouseWatcherRegion *MouseWatcher::get_over_region(void) const
 * MouseWatcherRegion *MouseWatcher::get_over_region(LPoint2f const &pos) const
 * inline MouseWatcherRegion *MouseWatcher::get_over_region(float x, float y) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_get_over_region_153(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline MouseWatcherRegion *MouseWatcher::get_over_region(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":getOverRegion", key_word_list));
            else
                (PyArg_Parse(args, ":getOverRegion"));
            if(!PyErr_Occurred())
            {
                MouseWatcherRegion *return_value = ((const MouseWatcher*)local_this)->get_over_region();
                if (return_value != (MouseWatcherRegion *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_MouseWatcherRegion,true, false, (return_value)->as_typed_object()->get_type_index());
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-MouseWatcherRegion *MouseWatcher::get_over_region(LPoint2f const &pos) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"pos", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:getOverRegion", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:getOverRegion", &param1));
                if(!PyErr_Occurred())
                {
                    LPoint2f *param1_this = (LPoint2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint2f, 1, "MouseWatcher.getOverRegion", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        MouseWatcherRegion *return_value = ((const MouseWatcher*)local_this)->get_over_region(*param1_this);
                        if (return_value != (MouseWatcherRegion *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_MouseWatcherRegion,true, false, (return_value)->as_typed_object()->get_type_index());
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          // 1-inline MouseWatcherRegion *MouseWatcher::get_over_region(float x, float y) const
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:getOverRegion", key_word_list, &param1, &param2))
            {
                MouseWatcherRegion *return_value = ((const MouseWatcher*)local_this)->get_over_region((float)param1, (float)param2);
                if (return_value != (MouseWatcherRegion *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_MouseWatcherRegion,true, false, (return_value)->as_typed_object()->get_type_index());
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getOverRegion() takes 1, 2, or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getOverRegion(const MouseWatcher this)\n"
          "getOverRegion(const MouseWatcher this, const Point2 pos)\n"
          "getOverRegion(const MouseWatcher this, float x, float y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_get_over_region_153_comment =
    "C++ Interface:\n"
    "getOverRegion(const MouseWatcher this)\n"
    "getOverRegion(const MouseWatcher this, const Point2 pos)\n"
    "getOverRegion(const MouseWatcher this, float x, float y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::get_over_region\n"
    "//       Access: Published\n"
    "//  Description: Returns the smallest region the mouse is currently\n"
    "//               over, or NULL if it is over no region.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::get_over_region\n"
    "//       Access: Published\n"
    "//  Description: Returns the smallest region the indicated point is\n"
    "//               over, or NULL if it is over no region.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::get_over_region\n"
    "//       Access: Published\n"
    "//  Description: Returns the preferred region the mouse is over.  In\n"
    "//               the case of overlapping regions, the region with the\n"
    "//               largest sort order is preferred; if two regions have\n"
    "//               the same sort order, then the smaller region is\n"
    "//               preferred.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_get_over_region_153_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool MouseWatcher::is_button_down(ButtonHandle button) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_is_button_down_154(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool MouseWatcher::is_button_down(ButtonHandle button) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"button", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:isButtonDown", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:isButtonDown", &param1));
            if(!PyErr_Occurred())
            {
                ButtonHandle *param1_this = (ButtonHandle *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ButtonHandle, 1, "MouseWatcher.isButtonDown", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const MouseWatcher*)local_this)->is_button_down(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isButtonDown(const MouseWatcher this, const ButtonHandle button)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_is_button_down_154_comment =
    "C++ Interface:\n"
    "isButtonDown(const MouseWatcher this, const ButtonHandle button)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::is_button_down\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the indicated button is currently\n"
    "//               being held down, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_is_button_down_154_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MouseWatcher::set_button_down_pattern(basic_string< char > const &pattern)
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_set_button_down_pattern_155(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void MouseWatcher::set_button_down_pattern(basic_string< char > const &pattern)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"pattern", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setButtonDownPattern", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setButtonDownPattern", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_button_down_pattern(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseWatcher.setButtonDownPattern() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setButtonDownPattern(non-const MouseWatcher this, string pattern)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_set_button_down_pattern_155_comment =
    "C++ Interface:\n"
    "setButtonDownPattern(non-const MouseWatcher this, string pattern)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::set_button_down_pattern\n"
    "//       Access: Published\n"
    "//  Description: Sets the pattern string that indicates how the event\n"
    "//               names are generated when a button is depressed.  This\n"
    "//               is a string that may contain any of the following:\n"
    "//\n"
    "//                  %r  - the name of the region the mouse is over\n"
    "//                  %b  - the name of the button pressed.\n"
    "//\n"
    "//               The event name will be based on the in_pattern\n"
    "//               string specified here, with all occurrences of the\n"
    "//               above strings replaced with the corresponding values.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_set_button_down_pattern_155_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &MouseWatcher::get_button_down_pattern(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_get_button_down_pattern_156(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &MouseWatcher::get_button_down_pattern(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getButtonDownPattern", key_word_list));
        else
            (PyArg_Parse(args, ":getButtonDownPattern"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const MouseWatcher*)local_this)->get_button_down_pattern();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getButtonDownPattern(const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_get_button_down_pattern_156_comment =
    "C++ Interface:\n"
    "getButtonDownPattern(const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::get_button_down_pattern\n"
    "//       Access: Published\n"
    "//  Description: Returns the string that indicates how event names are\n"
    "//               generated when a button is depressed.  See\n"
    "//               set_button_down_pattern().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_get_button_down_pattern_156_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MouseWatcher::set_button_up_pattern(basic_string< char > const &pattern)
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_set_button_up_pattern_157(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void MouseWatcher::set_button_up_pattern(basic_string< char > const &pattern)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"pattern", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setButtonUpPattern", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setButtonUpPattern", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_button_up_pattern(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseWatcher.setButtonUpPattern() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setButtonUpPattern(non-const MouseWatcher this, string pattern)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_set_button_up_pattern_157_comment =
    "C++ Interface:\n"
    "setButtonUpPattern(non-const MouseWatcher this, string pattern)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::set_button_up_pattern\n"
    "//       Access: Published\n"
    "//  Description: Sets the pattern string that indicates how the event\n"
    "//               names are generated when a button is released.  See\n"
    "//               set_button_down_pattern().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_set_button_up_pattern_157_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &MouseWatcher::get_button_up_pattern(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_get_button_up_pattern_158(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &MouseWatcher::get_button_up_pattern(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getButtonUpPattern", key_word_list));
        else
            (PyArg_Parse(args, ":getButtonUpPattern"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const MouseWatcher*)local_this)->get_button_up_pattern();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getButtonUpPattern(const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_get_button_up_pattern_158_comment =
    "C++ Interface:\n"
    "getButtonUpPattern(const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::get_button_up_pattern\n"
    "//       Access: Published\n"
    "//  Description: Returns the string that indicates how event names are\n"
    "//               generated when a button is released.  See\n"
    "//               set_button_down_pattern().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_get_button_up_pattern_158_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MouseWatcher::set_button_repeat_pattern(basic_string< char > const &pattern)
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_set_button_repeat_pattern_159(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void MouseWatcher::set_button_repeat_pattern(basic_string< char > const &pattern)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"pattern", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setButtonRepeatPattern", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setButtonRepeatPattern", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_button_repeat_pattern(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseWatcher.setButtonRepeatPattern() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setButtonRepeatPattern(non-const MouseWatcher this, string pattern)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_set_button_repeat_pattern_159_comment =
    "C++ Interface:\n"
    "setButtonRepeatPattern(non-const MouseWatcher this, string pattern)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::set_button_repeat_pattern\n"
    "//       Access: Published\n"
    "//  Description: Sets the pattern string that indicates how the event\n"
    "//               names are generated when a button is continuously\n"
    "//               held and generates keyrepeat \"down\" events.  This is\n"
    "//               a string that may contain any of the following:\n"
    "//\n"
    "//                  %r  - the name of the region the mouse is over\n"
    "//                  %b  - the name of the button pressed.\n"
    "//\n"
    "//               The event name will be based on the in_pattern\n"
    "//               string specified here, with all occurrences of the\n"
    "//               above strings replaced with the corresponding values.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_set_button_repeat_pattern_159_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &MouseWatcher::get_button_repeat_pattern(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_get_button_repeat_pattern_160(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &MouseWatcher::get_button_repeat_pattern(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getButtonRepeatPattern", key_word_list));
        else
            (PyArg_Parse(args, ":getButtonRepeatPattern"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const MouseWatcher*)local_this)->get_button_repeat_pattern();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getButtonRepeatPattern(const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_get_button_repeat_pattern_160_comment =
    "C++ Interface:\n"
    "getButtonRepeatPattern(const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::get_button_repeat_pattern\n"
    "//       Access: Published\n"
    "//  Description: Returns the string that indicates how event names are\n"
    "//               names are generated when a button is continuously\n"
    "//               held and generates keyrepeat \"down\" events.  See\n"
    "//               set_button_repeat_pattern().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_get_button_repeat_pattern_160_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MouseWatcher::set_enter_pattern(basic_string< char > const &pattern)
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_set_enter_pattern_161(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void MouseWatcher::set_enter_pattern(basic_string< char > const &pattern)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"pattern", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setEnterPattern", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setEnterPattern", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_enter_pattern(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseWatcher.setEnterPattern() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEnterPattern(non-const MouseWatcher this, string pattern)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_set_enter_pattern_161_comment =
    "C++ Interface:\n"
    "setEnterPattern(non-const MouseWatcher this, string pattern)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::set_enter_pattern\n"
    "//       Access: Published\n"
    "//  Description: Sets the pattern string that indicates how the event\n"
    "//               names are generated when the mouse enters a region.\n"
    "//               This is different from within_pattern, in that a\n"
    "//               mouse is only \"entered\" in the topmost region at a\n"
    "//               given time, while it might be \"within\" multiple\n"
    "//               nested regions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_set_enter_pattern_161_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &MouseWatcher::get_enter_pattern(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_get_enter_pattern_162(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &MouseWatcher::get_enter_pattern(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEnterPattern", key_word_list));
        else
            (PyArg_Parse(args, ":getEnterPattern"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const MouseWatcher*)local_this)->get_enter_pattern();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEnterPattern(const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_get_enter_pattern_162_comment =
    "C++ Interface:\n"
    "getEnterPattern(const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::get_enter_pattern\n"
    "//       Access: Published\n"
    "//  Description: Returns the string that indicates how event names are\n"
    "//               generated when the mouse enters a region.  This is\n"
    "//               different from within_pattern, in that a mouse is\n"
    "//               only \"entered\" in the topmost region at a given time,\n"
    "//               while it might be \"within\" multiple nested regions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_get_enter_pattern_162_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MouseWatcher::set_leave_pattern(basic_string< char > const &pattern)
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_set_leave_pattern_163(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void MouseWatcher::set_leave_pattern(basic_string< char > const &pattern)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"pattern", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setLeavePattern", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setLeavePattern", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_leave_pattern(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseWatcher.setLeavePattern() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setLeavePattern(non-const MouseWatcher this, string pattern)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_set_leave_pattern_163_comment =
    "C++ Interface:\n"
    "setLeavePattern(non-const MouseWatcher this, string pattern)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::set_leave_pattern\n"
    "//       Access: Published\n"
    "//  Description: Sets the pattern string that indicates how the event\n"
    "//               names are generated when the mouse leaves a region.\n"
    "//               This is different from without_pattern, in that a\n"
    "//               mouse is only \"entered\" in the topmost region at a\n"
    "//               given time, while it might be \"within\" multiple\n"
    "//               nested regions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_set_leave_pattern_163_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &MouseWatcher::get_leave_pattern(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_get_leave_pattern_164(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &MouseWatcher::get_leave_pattern(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLeavePattern", key_word_list));
        else
            (PyArg_Parse(args, ":getLeavePattern"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const MouseWatcher*)local_this)->get_leave_pattern();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLeavePattern(const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_get_leave_pattern_164_comment =
    "C++ Interface:\n"
    "getLeavePattern(const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::get_leave_pattern\n"
    "//       Access: Published\n"
    "//  Description: Returns the string that indicates how event names are\n"
    "//               generated when the mouse leaves a region.  This is\n"
    "//               different from without_pattern, in that a mouse is\n"
    "//               only \"entered\" in the topmost region at a given time,\n"
    "//               while it might be \"within\" multiple nested regions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_get_leave_pattern_164_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MouseWatcher::set_within_pattern(basic_string< char > const &pattern)
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_set_within_pattern_165(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void MouseWatcher::set_within_pattern(basic_string< char > const &pattern)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"pattern", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setWithinPattern", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setWithinPattern", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_within_pattern(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseWatcher.setWithinPattern() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWithinPattern(non-const MouseWatcher this, string pattern)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_set_within_pattern_165_comment =
    "C++ Interface:\n"
    "setWithinPattern(non-const MouseWatcher this, string pattern)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::set_within_pattern\n"
    "//       Access: Published\n"
    "//  Description: Sets the pattern string that indicates how the event\n"
    "//               names are generated when the mouse wanders over a\n"
    "//               region.  This is different from enter_pattern, in\n"
    "//               that a mouse is only \"entered\" in the topmost region\n"
    "//               at a given time, while it might be \"within\" multiple\n"
    "//               nested regions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_set_within_pattern_165_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &MouseWatcher::get_within_pattern(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_get_within_pattern_166(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &MouseWatcher::get_within_pattern(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWithinPattern", key_word_list));
        else
            (PyArg_Parse(args, ":getWithinPattern"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const MouseWatcher*)local_this)->get_within_pattern();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWithinPattern(const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_get_within_pattern_166_comment =
    "C++ Interface:\n"
    "getWithinPattern(const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::get_within_pattern\n"
    "//       Access: Published\n"
    "//  Description: Returns the string that indicates how event names are\n"
    "//               generated when the mouse wanders over a region.  This\n"
    "//               is different from enter_pattern, in that a mouse is\n"
    "//               only \"entered\" in the topmost region at a given time,\n"
    "//               while it might be \"within\" multiple nested regions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_get_within_pattern_166_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MouseWatcher::set_without_pattern(basic_string< char > const &pattern)
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_set_without_pattern_167(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void MouseWatcher::set_without_pattern(basic_string< char > const &pattern)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"pattern", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setWithoutPattern", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setWithoutPattern", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_without_pattern(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseWatcher.setWithoutPattern() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWithoutPattern(non-const MouseWatcher this, string pattern)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_set_without_pattern_167_comment =
    "C++ Interface:\n"
    "setWithoutPattern(non-const MouseWatcher this, string pattern)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::set_without_pattern\n"
    "//       Access: Published\n"
    "//  Description: Sets the pattern string that indicates how the event\n"
    "//               names are generated when the mouse wanders out of a\n"
    "//               region.  This is different from leave_pattern, in\n"
    "//               that a mouse is only \"entered\" in the topmost region\n"
    "//               at a given time, while it might be \"within\" multiple\n"
    "//               nested regions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_set_without_pattern_167_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &MouseWatcher::get_without_pattern(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_get_without_pattern_168(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &MouseWatcher::get_without_pattern(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWithoutPattern", key_word_list));
        else
            (PyArg_Parse(args, ":getWithoutPattern"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const MouseWatcher*)local_this)->get_without_pattern();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWithoutPattern(const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_get_without_pattern_168_comment =
    "C++ Interface:\n"
    "getWithoutPattern(const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::get_without_pattern\n"
    "//       Access: Published\n"
    "//  Description: Returns the string that indicates how event names are\n"
    "//               generated when the mouse wanders out of a region.\n"
    "//               This is different from leave_pattern, in that a mouse\n"
    "//               is only \"entered\" in the topmost region at a given\n"
    "//               time, while it might be \"within\" multiple nested\n"
    "//               regions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_get_without_pattern_168_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MouseWatcher::set_geometry(PandaNode *node)
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_set_geometry_169(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void MouseWatcher::set_geometry(PandaNode *node)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setGeometry", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setGeometry", &param1));
            if(!PyErr_Occurred())
            {
                PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PandaNode, 1, "MouseWatcher.setGeometry", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_geometry(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MouseWatcher.setGeometry() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setGeometry(non-const MouseWatcher this, non-const PandaNode node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_set_geometry_169_comment =
    "C++ Interface:\n"
    "setGeometry(non-const MouseWatcher this, non-const PandaNode node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::set_geometry\n"
    "//       Access: Published\n"
    "//  Description: Sets the node that will be transformed each frame by\n"
    "//               the mouse's coordinates.  It will also be hidden when\n"
    "//               the mouse goes outside the window.  This can be used\n"
    "//               to implement a software mouse pointer for when a\n"
    "//               hardware (or system) mouse pointer is unavailable.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_set_geometry_169_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool MouseWatcher::has_geometry(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_has_geometry_170(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool MouseWatcher::has_geometry(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasGeometry", key_word_list));
        else
            (PyArg_Parse(args, ":hasGeometry"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const MouseWatcher*)local_this)->has_geometry();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasGeometry(const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_has_geometry_170_comment =
    "C++ Interface:\n"
    "hasGeometry(const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::has_geometry\n"
    "//       Access: Published\n"
    "//  Description: Returns true if a software mouse pointer has been\n"
    "//               setup via set_geometry(), or false otherwise.  See\n"
    "//               set_geometry().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_has_geometry_170_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PandaNode *MouseWatcher::get_geometry(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_get_geometry_171(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PandaNode *MouseWatcher::get_geometry(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getGeometry", key_word_list));
        else
            (PyArg_Parse(args, ":getGeometry"));
        if(!PyErr_Occurred())
        {
            PandaNode *return_value = ((const MouseWatcher*)local_this)->get_geometry();
            if (return_value != (PandaNode *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PandaNode,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGeometry(const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_get_geometry_171_comment =
    "C++ Interface:\n"
    "getGeometry(const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::get_geometry\n"
    "//       Access: Published\n"
    "//  Description: Returns the node that has been set as the software\n"
    "//               mouse pointer, or NULL if no node has been set.  See\n"
    "//               has_geometry() and set_geometry().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_get_geometry_171_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MouseWatcher::clear_geometry(void)
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_clear_geometry_172(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void MouseWatcher::clear_geometry(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearGeometry", key_word_list));
        else
            (PyArg_Parse(args, ":clearGeometry"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_geometry();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseWatcher.clearGeometry() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearGeometry(non-const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_clear_geometry_172_comment =
    "C++ Interface:\n"
    "clearGeometry(non-const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::clear_geometry\n"
    "//       Access: Published\n"
    "//  Description: Stops the use of the software cursor set up via\n"
    "//               set_geometry().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_clear_geometry_172_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MouseWatcher::set_extra_handler(EventHandler *eh)
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_set_extra_handler_173(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void MouseWatcher::set_extra_handler(EventHandler *eh)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"eh", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setExtraHandler", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setExtraHandler", &param1));
            if(!PyErr_Occurred())
            {
                EventHandler *param1_this = (EventHandler *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_EventHandler, 1, "MouseWatcher.setExtraHandler", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_extra_handler(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MouseWatcher.setExtraHandler() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setExtraHandler(non-const MouseWatcher this, non-const EventHandler eh)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_set_extra_handler_173_comment =
    "C++ Interface:\n"
    "setExtraHandler(non-const MouseWatcher this, non-const EventHandler eh)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::set_extra_handler\n"
    "//       Access: Published\n"
    "//  Description: As an optimization for the C++ Gui, an extra handler\n"
    "//               can be registered with a mouseWatcher so that events\n"
    "//               can be dealt with much sooner.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_set_extra_handler_173_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline EventHandler *MouseWatcher::get_extra_handler(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_get_extra_handler_174(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline EventHandler *MouseWatcher::get_extra_handler(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getExtraHandler", key_word_list));
        else
            (PyArg_Parse(args, ":getExtraHandler"));
        if(!PyErr_Occurred())
        {
            EventHandler *return_value = ((const MouseWatcher*)local_this)->get_extra_handler();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_EventHandler,false, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getExtraHandler(const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_get_extra_handler_174_comment =
    "C++ Interface:\n"
    "getExtraHandler(const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::get_extra_handler\n"
    "//       Access: Published\n"
    "//  Description: As an optimization for the C++ Gui, an extra handler\n"
    "//               can be registered with a mouseWatcher so that events\n"
    "//               can be dealt with much sooner.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_get_extra_handler_174_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MouseWatcher::set_modifier_buttons(ModifierButtons const &mods)
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_set_modifier_buttons_175(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void MouseWatcher::set_modifier_buttons(ModifierButtons const &mods)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"mods", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setModifierButtons", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setModifierButtons", &param1));
            if(!PyErr_Occurred())
            {
                ModifierButtons *param1_this = (ModifierButtons *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ModifierButtons, 1, "MouseWatcher.setModifierButtons", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_modifier_buttons(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MouseWatcher.setModifierButtons() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setModifierButtons(non-const MouseWatcher this, const ModifierButtons mods)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_set_modifier_buttons_175_comment =
    "C++ Interface:\n"
    "setModifierButtons(non-const MouseWatcher this, const ModifierButtons mods)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::set_modifier_buttons\n"
    "//       Access: Public\n"
    "//  Description: Sets the buttons that should be monitored as modifier\n"
    "//               buttons for generating events to the\n"
    "//               MouseWatcherRegions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_set_modifier_buttons_175_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ModifierButtons MouseWatcher::get_modifier_buttons(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_get_modifier_buttons_176(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline ModifierButtons MouseWatcher::get_modifier_buttons(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getModifierButtons", key_word_list));
        else
            (PyArg_Parse(args, ":getModifierButtons"));
        if(!PyErr_Occurred())
        {
            ModifierButtons result = ((const MouseWatcher*)local_this)->get_modifier_buttons();
            ModifierButtons *return_value = new ModifierButtons(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ModifierButtons,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getModifierButtons(const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_get_modifier_buttons_176_comment =
    "C++ Interface:\n"
    "getModifierButtons(const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::get_modifier_buttons\n"
    "//       Access: Published\n"
    "//  Description: Returns the set of buttons that are being monitored\n"
    "//               as modifier buttons, as well as their current state.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_get_modifier_buttons_176_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MouseWatcher::set_display_region(DisplayRegion *dr)
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_set_display_region_177(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void MouseWatcher::set_display_region(DisplayRegion *dr)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"dr", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setDisplayRegion", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setDisplayRegion", &param1));
            if(!PyErr_Occurred())
            {
                DisplayRegion *param1_this = (DisplayRegion *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DisplayRegion, 1, "MouseWatcher.setDisplayRegion", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_display_region(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MouseWatcher.setDisplayRegion() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDisplayRegion(non-const MouseWatcher this, non-const DisplayRegion dr)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_set_display_region_177_comment =
    "C++ Interface:\n"
    "setDisplayRegion(non-const MouseWatcher this, non-const DisplayRegion dr)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::set_display_region\n"
    "//       Access: Published\n"
    "//  Description: Constrains the MouseWatcher to watching the mouse\n"
    "//               within a particular indicated region of the screen.\n"
    "//               DataNodes parented under the MouseWatcher will\n"
    "//               observe the mouse and keyboard events only when the\n"
    "//               mouse is within the indicated region, and the\n"
    "//               observed range will be from -1 .. 1 across the\n"
    "//               region.\n"
    "//\n"
    "//               Do not delete the DisplayRegion while it is owned by\n"
    "//               the MouseWatcher.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_set_display_region_177_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MouseWatcher::clear_display_region(void)
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_clear_display_region_178(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void MouseWatcher::clear_display_region(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearDisplayRegion", key_word_list));
        else
            (PyArg_Parse(args, ":clearDisplayRegion"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_display_region();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseWatcher.clearDisplayRegion() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearDisplayRegion(non-const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_clear_display_region_178_comment =
    "C++ Interface:\n"
    "clearDisplayRegion(non-const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::clear_display_region\n"
    "//       Access: Published\n"
    "//  Description: Removes the display region constraint from the\n"
    "//               MouseWatcher, and restores it to the default behavior\n"
    "//               of watching the whole window.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_clear_display_region_178_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DisplayRegion *MouseWatcher::get_display_region(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_get_display_region_179(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline DisplayRegion *MouseWatcher::get_display_region(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDisplayRegion", key_word_list));
        else
            (PyArg_Parse(args, ":getDisplayRegion"));
        if(!PyErr_Occurred())
        {
            DisplayRegion *return_value = ((const MouseWatcher*)local_this)->get_display_region();
            if (return_value != (DisplayRegion *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_DisplayRegion,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDisplayRegion(const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_get_display_region_179_comment =
    "C++ Interface:\n"
    "getDisplayRegion(const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::get_display_region\n"
    "//       Access: Published\n"
    "//  Description: Returns the display region the MouseWatcher is\n"
    "//               constrained to by set_display_region(), or NULL if it\n"
    "//               is not constrained.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_get_display_region_179_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool MouseWatcher::has_display_region(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_has_display_region_180(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool MouseWatcher::has_display_region(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasDisplayRegion", key_word_list));
        else
            (PyArg_Parse(args, ":hasDisplayRegion"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const MouseWatcher*)local_this)->has_display_region();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasDisplayRegion(const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_has_display_region_180_comment =
    "C++ Interface:\n"
    "hasDisplayRegion(const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::has_display_region\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the MouseWatcher has been constrained\n"
    "//               to a particular region of the screen via\n"
    "//               set_display_region(), or false otherwise.  If this\n"
    "//               returns true, get_display_region() may be used to\n"
    "//               return the particular region.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_has_display_region_180_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool MouseWatcher::add_group(MouseWatcherGroup *group)
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_add_group_181(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool MouseWatcher::add_group(MouseWatcherGroup *group)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"group", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addGroup", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addGroup", &param1));
            if(!PyErr_Occurred())
            {
                MouseWatcherGroup *param1_this = (MouseWatcherGroup *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_MouseWatcherGroup, 1, "MouseWatcher.addGroup", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->add_group(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MouseWatcher.addGroup() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addGroup(non-const MouseWatcher this, non-const MouseWatcherGroup group)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_add_group_181_comment =
    "C++ Interface:\n"
    "addGroup(non-const MouseWatcher this, non-const MouseWatcherGroup group)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::add_group\n"
    "//       Access: Published\n"
    "//  Description: Adds the indicated group of regions to the set of\n"
    "//               regions the MouseWatcher will monitor each frame.\n"
    "//\n"
    "//               Since the MouseWatcher itself inherits from\n"
    "//               MouseWatcherGroup, this operation is normally not\n"
    "//               necessary--you can simply add the Regions you care\n"
    "//               about one at a time.  Adding a complete group is\n"
    "//               useful when you may want to explicitly remove the\n"
    "//               regions as a group later.\n"
    "//\n"
    "//               Returns true if the group was successfully added, or\n"
    "//               false if it was already on the list.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_add_group_181_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool MouseWatcher::remove_group(MouseWatcherGroup *group)
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_remove_group_182(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool MouseWatcher::remove_group(MouseWatcherGroup *group)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"group", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeGroup", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeGroup", &param1));
            if(!PyErr_Occurred())
            {
                MouseWatcherGroup *param1_this = (MouseWatcherGroup *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_MouseWatcherGroup, 1, "MouseWatcher.removeGroup", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->remove_group(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MouseWatcher.removeGroup() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeGroup(non-const MouseWatcher this, non-const MouseWatcherGroup group)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_remove_group_182_comment =
    "C++ Interface:\n"
    "removeGroup(non-const MouseWatcher this, non-const MouseWatcherGroup group)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::remove_group\n"
    "//       Access: Published\n"
    "//  Description: Removes the indicated group from the set of extra\n"
    "//               groups associated with the MouseWatcher.  Returns\n"
    "//               true if successful, or false if the group was already\n"
    "//               removed or was never added via add_group().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_remove_group_182_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool MouseWatcher::replace_group(MouseWatcherGroup *old_group, MouseWatcherGroup *new_group)
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_replace_group_183(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool MouseWatcher::replace_group(MouseWatcherGroup *old_group, MouseWatcherGroup *new_group)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"old_group", (char *)"new_group", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:replaceGroup", key_word_list, &param1, &param2))
            {
                MouseWatcherGroup *param1_this = (MouseWatcherGroup *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_MouseWatcherGroup, 1, "MouseWatcher.replaceGroup", 0, coerced_ptr, report_errors);
MouseWatcherGroup *param2_this = (MouseWatcherGroup *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_MouseWatcherGroup, 2, "MouseWatcher.replaceGroup", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    bool return_value = (local_this)->replace_group(param1_this, param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call MouseWatcher.replaceGroup() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "replaceGroup(non-const MouseWatcher this, non-const MouseWatcherGroup old_group, non-const MouseWatcherGroup new_group)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_replace_group_183_comment =
    "C++ Interface:\n"
    "replaceGroup(non-const MouseWatcher this, non-const MouseWatcherGroup old_group, non-const MouseWatcherGroup new_group)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::replace_group\n"
    "//       Access: Published\n"
    "//  Description: Atomically removes old_group from the MouseWatcher,\n"
    "//               and replaces it with new_group.  Presumably old_group\n"
    "//               and new_group might have some regions in common;\n"
    "//               these are handled properly.\n"
    "//\n"
    "//               If old_group is not already present, simply adds\n"
    "//               new_group and returns false.  Otherwise, removes\n"
    "//               old_group and adds new_group, and then returns true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_replace_group_183_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int MouseWatcher::get_num_groups(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_get_num_groups_184(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int MouseWatcher::get_num_groups(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumGroups", key_word_list));
        else
            (PyArg_Parse(args, ":getNumGroups"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const MouseWatcher*)local_this)->get_num_groups();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumGroups(const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_get_num_groups_184_comment =
    "C++ Interface:\n"
    "getNumGroups(const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::get_num_groups\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of separate groups added to the\n"
    "//               MouseWatcher via add_group().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_get_num_groups_184_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * MouseWatcherGroup *MouseWatcher::get_group(int n) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_get_group_185(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-MouseWatcherGroup *MouseWatcher::get_group(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getGroup", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getGroup", &param1));
        if(!PyErr_Occurred())
        {
            MouseWatcherGroup *return_value = ((const MouseWatcher*)local_this)->get_group((int)param1);
            if (return_value != (MouseWatcherGroup *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_MouseWatcherGroup,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGroup(const MouseWatcher this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_get_group_185_comment =
    "C++ Interface:\n"
    "getGroup(const MouseWatcher this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::get_group\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth group added to the MouseWatcher via\n"
    "//               add_group().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_get_group_185_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MouseWatcher::set_inactivity_timeout(double timeout)
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_set_inactivity_timeout_186(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void MouseWatcher::set_inactivity_timeout(double timeout)
        double param1;
        static char * key_word_list[] = {(char *)"timeout", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setInactivityTimeout", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setInactivityTimeout", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_inactivity_timeout((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseWatcher.setInactivityTimeout() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setInactivityTimeout(non-const MouseWatcher this, float timeout)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_set_inactivity_timeout_186_comment =
    "C++ Interface:\n"
    "setInactivityTimeout(non-const MouseWatcher this, float timeout)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::set_inactivity_timeout\n"
    "//       Access: Published\n"
    "//  Description: Sets an inactivity timeout on the mouse activity.\n"
    "//               When this timeout (in seconds) is exceeded with no\n"
    "//               keyboard or mouse activity, all currently-held\n"
    "//               buttons are automatically released.  This is intended\n"
    "//               to help protect against people who inadvertently (or\n"
    "//               intentionally) leave a keyboard key stuck down and\n"
    "//               then wander away from the keyboard.\n"
    "//\n"
    "//               Also, when this timeout expires, the event specified\n"
    "//               by set_inactivity_timeout_event() will be generated.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_set_inactivity_timeout_186_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool MouseWatcher::has_inactivity_timeout(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_has_inactivity_timeout_187(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool MouseWatcher::has_inactivity_timeout(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasInactivityTimeout", key_word_list));
        else
            (PyArg_Parse(args, ":hasInactivityTimeout"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const MouseWatcher*)local_this)->has_inactivity_timeout();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasInactivityTimeout(const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_has_inactivity_timeout_187_comment =
    "C++ Interface:\n"
    "hasInactivityTimeout(const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::has_inactivity_timeout\n"
    "//       Access: Published\n"
    "//  Description: Returns true if an inactivity timeout has been set,\n"
    "//               false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_has_inactivity_timeout_187_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double MouseWatcher::get_inactivity_timeout(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_get_inactivity_timeout_188(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double MouseWatcher::get_inactivity_timeout(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInactivityTimeout", key_word_list));
        else
            (PyArg_Parse(args, ":getInactivityTimeout"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const MouseWatcher*)local_this)->get_inactivity_timeout();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInactivityTimeout(const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_get_inactivity_timeout_188_comment =
    "C++ Interface:\n"
    "getInactivityTimeout(const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::get_inactivity_timeout\n"
    "//       Access: Published\n"
    "//  Description: Returns the inactivity timeout that has been set.\n"
    "//               It is an error to call this if\n"
    "//               has_inactivity_timeout() returns false.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_get_inactivity_timeout_188_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MouseWatcher::clear_inactivity_timeout(void)
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_clear_inactivity_timeout_189(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void MouseWatcher::clear_inactivity_timeout(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearInactivityTimeout", key_word_list));
        else
            (PyArg_Parse(args, ":clearInactivityTimeout"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_inactivity_timeout();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseWatcher.clearInactivityTimeout() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearInactivityTimeout(non-const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_clear_inactivity_timeout_189_comment =
    "C++ Interface:\n"
    "clearInactivityTimeout(non-const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::clear_inactivity_timeout\n"
    "//       Access: Published\n"
    "//  Description: Removes the inactivity timeout and restores the\n"
    "//               MouseWatcher to its default behavior of allowing a\n"
    "//               key to be held indefinitely.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_clear_inactivity_timeout_189_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MouseWatcher::set_inactivity_timeout_event(basic_string< char > const &event)
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_set_inactivity_timeout_event_190(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void MouseWatcher::set_inactivity_timeout_event(basic_string< char > const &event)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"event", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setInactivityTimeoutEvent", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setInactivityTimeoutEvent", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_inactivity_timeout_event(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseWatcher.setInactivityTimeoutEvent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setInactivityTimeoutEvent(non-const MouseWatcher this, string event)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_set_inactivity_timeout_event_190_comment =
    "C++ Interface:\n"
    "setInactivityTimeoutEvent(non-const MouseWatcher this, string event)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::set_inactivity_timeout_event\n"
    "//       Access: Published\n"
    "//  Description: Specifies the event string that will be generated\n"
    "//               when the inactivity timeout counter expires.  See\n"
    "//               set_inactivity_timeout().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_set_inactivity_timeout_event_190_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &MouseWatcher::get_inactivity_timeout_event(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_get_inactivity_timeout_event_191(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &MouseWatcher::get_inactivity_timeout_event(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInactivityTimeoutEvent", key_word_list));
        else
            (PyArg_Parse(args, ":getInactivityTimeoutEvent"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const MouseWatcher*)local_this)->get_inactivity_timeout_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInactivityTimeoutEvent(const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_get_inactivity_timeout_event_191_comment =
    "C++ Interface:\n"
    "getInactivityTimeoutEvent(const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::get_inactivity_timeout_event\n"
    "//       Access: Published\n"
    "//  Description: Returns the event string that will be generated\n"
    "//               when the inactivity timeout counter expires.  See\n"
    "//               set_inactivity_timeout().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_get_inactivity_timeout_event_191_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ConstPointerTo< PointerEventList > MouseWatcher::get_trail_log(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_get_trail_log_192(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline ConstPointerTo< PointerEventList > MouseWatcher::get_trail_log(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTrailLog", key_word_list));
        else
            (PyArg_Parse(args, ":getTrailLog"));
        if(!PyErr_Occurred())
        {
            ConstPointerTo< PointerEventList > return_value = ((const MouseWatcher*)local_this)->get_trail_log();
            if (return_value != (PointerEventList const *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_PointerEventList,true, true, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTrailLog(const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_get_trail_log_192_comment =
    "C++ Interface:\n"
    "getTrailLog(const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::get_trail_log\n"
    "//       Access: Published\n"
    "//  Description: Obtain the mouse trail log.  This is a PointerEventList.\n"
    "//               Does not make a copy, therefore, this PointerEventList\n"
    "//               will be updated each time process_events gets called.\n"
    "//\n"
    "//               To use trail logging, you need to enable the\n"
    "//               generation of pointer events in the\n"
    "//               GraphicsWindowInputDevice and set the trail log\n"
    "//               duration in the MouseWatcher. Otherwise, the\n"
    "//               trail log will be empty.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_get_trail_log_192_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int MouseWatcher::num_trail_recent(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_num_trail_recent_193(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int MouseWatcher::num_trail_recent(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":numTrailRecent", key_word_list));
        else
            (PyArg_Parse(args, ":numTrailRecent"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const MouseWatcher*)local_this)->num_trail_recent();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "numTrailRecent(const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_num_trail_recent_193_comment =
    "C++ Interface:\n"
    "numTrailRecent(const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::num_trail_recent\n"
    "//       Access: Published\n"
    "//  Description: This counter indicates how many events were added\n"
    "//               to the trail log this frame.  The trail log is\n"
    "//               updated once per frame, during the process_events\n"
    "//               operation.  \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_num_trail_recent_193_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MouseWatcher::set_trail_log_duration(double duration)
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_set_trail_log_duration_194(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void MouseWatcher::set_trail_log_duration(double duration)
        double param1;
        static char * key_word_list[] = {(char *)"duration", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setTrailLogDuration", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setTrailLogDuration", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_trail_log_duration((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseWatcher.setTrailLogDuration() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTrailLogDuration(non-const MouseWatcher this, float duration)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_set_trail_log_duration_194_comment =
    "C++ Interface:\n"
    "setTrailLogDuration(non-const MouseWatcher this, float duration)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::set_trail_log_duration\n"
    "//       Access: Published\n"
    "//  Description: If the duration is nonzero, causes the MouseWatcher\n"
    "//               to log the mouse's trail.  Events older than the\n"
    "//               specified duration are discarded.  If the duration is\n"
    "//               zero, logging is disabled.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_set_trail_log_duration_194_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< GeomNode > MouseWatcher::get_trail_node(void)
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_get_trail_node_195(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-PointerTo< GeomNode > MouseWatcher::get_trail_node(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTrailNode", key_word_list));
        else
            (PyArg_Parse(args, ":getTrailNode"));
        if(!PyErr_Occurred())
        {
            PointerTo< GeomNode > return_value = (local_this)->get_trail_node();
            if (return_value != (GeomNode *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_GeomNode,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseWatcher.getTrailNode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTrailNode(non-const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_get_trail_node_195_comment =
    "C++ Interface:\n"
    "getTrailNode(non-const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::get_trail_node\n"
    "//       Access: Published\n"
    "//  Description: Returns a GeomNode that represents the mouse trail.\n"
    "//               The intent is that you should reparent this GeomNode\n"
    "//               to Render2D, and then forget about it.  The\n"
    "//               MouseWatcher will continually update the trail node.\n"
    "//               There is only one trail node, it does not create a\n"
    "//               new one each time you call get_trail_node.\n"
    "//\n"
    "//               This is not a particularly beautiful way to render\n"
    "//               a mouse trail.  It is intended more for debugging\n"
    "//               purposes than for finished applications.  Even so,\n"
    "//               It is suggested that you might want to apply a line\n"
    "//               thickness and antialias mode to the line --- doing\n"
    "//               so makes it look a lot better.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_get_trail_node_195_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MouseWatcher::clear_trail_node(void)
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_clear_trail_node_196(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void MouseWatcher::clear_trail_node(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearTrailNode", key_word_list));
        else
            (PyArg_Parse(args, ":clearTrailNode"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_trail_node();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseWatcher.clearTrailNode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearTrailNode(non-const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_clear_trail_node_196_comment =
    "C++ Interface:\n"
    "clearTrailNode(non-const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::clear_trail_node\n"
    "//       Access: Published\n"
    "//  Description: If you have previously fetched the trail node\n"
    "//               using get_trail_node, then the MouseWatcher is\n"
    "//               continually updating the trail node every frame.\n"
    "//               Using clear_trail_node causes the MouseWatcher to\n"
    "//               forget the trail node and stop updating it.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_clear_trail_node_196_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void MouseWatcher::clear_trail_log(void)
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_clear_trail_log_197(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void MouseWatcher::clear_trail_log(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearTrailLog", key_word_list));
        else
            (PyArg_Parse(args, ":clearTrailLog"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_trail_log();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseWatcher.clearTrailLog() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearTrailLog(non-const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_clear_trail_log_197_comment =
    "C++ Interface:\n"
    "clearTrailLog(non-const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::clear_trail_log\n"
    "//       Access: Published\n"
    "//  Description: Clears the mouse trail log.  This does not prevent\n"
    "//               further accumulation of the log given future events.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_clear_trail_log_197_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MouseWatcher::note_activity(void)
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_note_activity_198(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void MouseWatcher::note_activity(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":noteActivity", key_word_list));
        else
            (PyArg_Parse(args, ":noteActivity"));
        if(!PyErr_Occurred())
        {
            (local_this)->note_activity();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseWatcher.noteActivity() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "noteActivity(non-const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_note_activity_198_comment =
    "C++ Interface:\n"
    "noteActivity(non-const MouseWatcher this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcher::note_activity\n"
    "//       Access: Published\n"
    "//  Description: Can be used in conjunction with the inactivity\n"
    "//               timeout to inform the MouseWatcher that the user has\n"
    "//               just performed some action which proves he/she is\n"
    "//               present.  It may be necessary to call this for\n"
    "//               external events, such as joystick action, that the\n"
    "//               MouseWatcher might otherwise not know about.  This\n"
    "//               will reset the current inactivity timer.  When the\n"
    "//               inactivity timer reaches the length of time specified\n"
    "//               by set_inactivity_timeout(), with no keyboard or\n"
    "//               mouse activity and no calls to note_activity(), then\n"
    "//               any buttons held will be automatically released.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcher_note_activity_198_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle MouseWatcher::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_get_class_type_199(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle MouseWatcher::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = MouseWatcher::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_get_class_type_199_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_MouseWatcher_get_class_type_199_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DataNode *MouseWatcher::upcast_to_DataNode(void)
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_upcast_to_DataNode_138(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-DataNode *MouseWatcher::upcast_to_DataNode(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToDataNode", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToDataNode"));
        if(!PyErr_Occurred())
        {
            DataNode *return_value = (DataNode *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_DataNode,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseWatcher.upcastToDataNode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToDataNode(non-const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_upcast_to_DataNode_138_comment =
    "C++ Interface:\n"
    "upcastToDataNode(non-const MouseWatcher this)\n"
    "\n"
    "upcast from MouseWatcher to DataNode\n"
    "";
#else
static const char * Dtool_MouseWatcher_upcast_to_DataNode_138_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * MouseWatcherGroup *MouseWatcher::upcast_to_MouseWatcherGroup(void)
 *******************************************************************/
static PyObject *Dtool_MouseWatcher_upcast_to_MouseWatcherGroup_140(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcher * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcher,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-MouseWatcherGroup *MouseWatcher::upcast_to_MouseWatcherGroup(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToMouseWatcherGroup", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToMouseWatcherGroup"));
        if(!PyErr_Occurred())
        {
            MouseWatcherGroup *return_value = (MouseWatcherGroup *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_MouseWatcherGroup,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MouseWatcher.upcastToMouseWatcherGroup() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToMouseWatcherGroup(non-const MouseWatcher this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcher_upcast_to_MouseWatcherGroup_140_comment =
    "C++ Interface:\n"
    "upcastToMouseWatcherGroup(non-const MouseWatcher this)\n"
    "\n"
    "upcast from MouseWatcher to MouseWatcherGroup\n"
    "";
#else
static const char * Dtool_MouseWatcher_upcast_to_MouseWatcherGroup_140_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * MouseWatcher::MouseWatcher(basic_string< char > const &name)
 * MouseWatcher::MouseWatcher(basic_string< char > const &name = (""))
 *******************************************************************/
int  Dtool_Init_MouseWatcher(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-MouseWatcher::MouseWatcher(basic_string< char > const &name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":MouseWatcher", key_word_list))
            {
                MouseWatcher *return_value = new MouseWatcher();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_MouseWatcher,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-MouseWatcher::MouseWatcher(basic_string< char > const &name)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:MouseWatcher", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:MouseWatcher", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                MouseWatcher *return_value = new MouseWatcher(basic_string<char>(param0_str, param0_len));
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_MouseWatcher,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "MouseWatcher() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "MouseWatcher()\n"
          "MouseWatcher(string name)\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_MouseWatcher_get_groups(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumGroups", "getGroup");
}
inline void  * Dtool_UpcastInterface_MouseWatcher(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_MouseWatcher)
    {
        printf("MouseWatcher ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    MouseWatcher * local_this = (MouseWatcher *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_MouseWatcher)
        return local_this;
    if(requested_type == &Dtool_DataNode)
        return ( DataNode *) local_this;
    if(requested_type == &Dtool_MouseWatcherGroup)
        return ( MouseWatcherGroup *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( DataNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_MouseWatcher(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_MouseWatcher)
        return from_this;
    if(from_type == &Dtool_DataNode)
    {
          DataNode* other_this = (DataNode*)from_this;
          return (MouseWatcher*)other_this;
    }
    if(from_type == &Dtool_MouseWatcherGroup)
    {
          MouseWatcherGroup* other_this = (MouseWatcherGroup*)from_this;
          return (MouseWatcher*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (MouseWatcher*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (MouseWatcher*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (MouseWatcher*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (MouseWatcher*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. MouseWatcherParameter 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline bool MouseWatcherParameter::has_button(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcherParameter_has_button_202(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool MouseWatcherParameter::has_button(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasButton", key_word_list));
        else
            (PyArg_Parse(args, ":hasButton"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const MouseWatcherParameter*)local_this)->has_button();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasButton(const MouseWatcherParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherParameter_has_button_202_comment =
    "C++ Interface:\n"
    "hasButton(const MouseWatcherParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherParameter::has_button\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this parameter has an associated\n"
    "//               mouse or keyboard button, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherParameter_has_button_202_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ButtonHandle MouseWatcherParameter::get_button(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcherParameter_get_button_203(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline ButtonHandle MouseWatcherParameter::get_button(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getButton", key_word_list));
        else
            (PyArg_Parse(args, ":getButton"));
        if(!PyErr_Occurred())
        {
            ButtonHandle result = ((const MouseWatcherParameter*)local_this)->get_button();
            ButtonHandle *return_value = new ButtonHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ButtonHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getButton(const MouseWatcherParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherParameter_get_button_203_comment =
    "C++ Interface:\n"
    "getButton(const MouseWatcherParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherParameter::get_button\n"
    "//       Access: Published\n"
    "//  Description: Returns the mouse or keyboard button associated with\n"
    "//               this event.  If has_button(), above, returns false,\n"
    "//               this returns ButtonHandle::none().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherParameter_get_button_203_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool MouseWatcherParameter::is_keyrepeat(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcherParameter_is_keyrepeat_204(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool MouseWatcherParameter::is_keyrepeat(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isKeyrepeat", key_word_list));
        else
            (PyArg_Parse(args, ":isKeyrepeat"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const MouseWatcherParameter*)local_this)->is_keyrepeat();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isKeyrepeat(const MouseWatcherParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherParameter_is_keyrepeat_204_comment =
    "C++ Interface:\n"
    "isKeyrepeat(const MouseWatcherParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherParameter::is_keyrepeat\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the button-down even was generated\n"
    "//               due to keyrepeat, or false if it was an original\n"
    "//               button down.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherParameter_is_keyrepeat_204_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool MouseWatcherParameter::has_keycode(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcherParameter_has_keycode_205(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool MouseWatcherParameter::has_keycode(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasKeycode", key_word_list));
        else
            (PyArg_Parse(args, ":hasKeycode"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const MouseWatcherParameter*)local_this)->has_keycode();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasKeycode(const MouseWatcherParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherParameter_has_keycode_205_comment =
    "C++ Interface:\n"
    "hasKeycode(const MouseWatcherParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherParameter::has_keycode\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this parameter has an associated\n"
    "//               keycode, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherParameter_has_keycode_205_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int MouseWatcherParameter::get_keycode(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcherParameter_get_keycode_206(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int MouseWatcherParameter::get_keycode(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getKeycode", key_word_list));
        else
            (PyArg_Parse(args, ":getKeycode"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const MouseWatcherParameter*)local_this)->get_keycode();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getKeycode(const MouseWatcherParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherParameter_get_keycode_206_comment =
    "C++ Interface:\n"
    "getKeycode(const MouseWatcherParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherParameter::get_keycode\n"
    "//       Access: Published\n"
    "//  Description: Returns the keycode associated with this event.  If\n"
    "//               has_keycode(), above, returns false, this returns 0.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherParameter_get_keycode_206_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool MouseWatcherParameter::has_candidate(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcherParameter_has_candidate_207(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool MouseWatcherParameter::has_candidate(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasCandidate", key_word_list));
        else
            (PyArg_Parse(args, ":hasCandidate"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const MouseWatcherParameter*)local_this)->has_candidate();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasCandidate(const MouseWatcherParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherParameter_has_candidate_207_comment =
    "C++ Interface:\n"
    "hasCandidate(const MouseWatcherParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherParameter::has_candidate\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this parameter has an associated\n"
    "//               candidate string, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherParameter_has_candidate_207_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > MouseWatcherParameter::get_candidate_string_encoded(void) const
 * inline basic_string< char > MouseWatcherParameter::get_candidate_string_encoded(TextEncoder::Encoding encoding) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcherParameter_get_candidate_string_encoded_208(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline basic_string< char > MouseWatcherParameter::get_candidate_string_encoded(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":getCandidateStringEncoded", key_word_list));
            else
                (PyArg_Parse(args, ":getCandidateStringEncoded"));
            if(!PyErr_Occurred())
            {
                basic_string< char > return_value = ((const MouseWatcherParameter*)local_this)->get_candidate_string_encoded();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-inline basic_string< char > MouseWatcherParameter::get_candidate_string_encoded(TextEncoder::Encoding encoding) const
            int param1;
            static char * key_word_list[] = {(char *)"encoding", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:getCandidateStringEncoded", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:getCandidateStringEncoded", &param1));
            if(!PyErr_Occurred())
            {
                basic_string< char > return_value = ((const MouseWatcherParameter*)local_this)->get_candidate_string_encoded((TextEncoder::Encoding)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getCandidateStringEncoded() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getCandidateStringEncoded(const MouseWatcherParameter this)\n"
          "getCandidateStringEncoded(const MouseWatcherParameter this, int encoding)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherParameter_get_candidate_string_encoded_208_comment =
    "C++ Interface:\n"
    "getCandidateStringEncoded(const MouseWatcherParameter this)\n"
    "getCandidateStringEncoded(const MouseWatcherParameter this, int encoding)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherParameter::get_candidate_string_encoded\n"
    "//       Access: Published\n"
    "//  Description: Returns the candidate string associated with this\n"
    "//               event.  If has_candidate(), above, returns false,\n"
    "//               this returns the empty string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherParameter::get_candidate_string_encoded\n"
    "//       Access: Published\n"
    "//  Description: Returns the candidate string associated with this\n"
    "//               event.  If has_candidate(), above, returns false,\n"
    "//               this returns the empty string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherParameter_get_candidate_string_encoded_208_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int MouseWatcherParameter::get_highlight_start(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcherParameter_get_highlight_start_209(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int MouseWatcherParameter::get_highlight_start(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHighlightStart", key_word_list));
        else
            (PyArg_Parse(args, ":getHighlightStart"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const MouseWatcherParameter*)local_this)->get_highlight_start();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHighlightStart(const MouseWatcherParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherParameter_get_highlight_start_209_comment =
    "C++ Interface:\n"
    "getHighlightStart(const MouseWatcherParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherParameter::get_highlight_start\n"
    "//       Access: Published\n"
    "//  Description: Returns the first highlighted character in the\n"
    "//               candidate string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherParameter_get_highlight_start_209_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int MouseWatcherParameter::get_highlight_end(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcherParameter_get_highlight_end_210(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int MouseWatcherParameter::get_highlight_end(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHighlightEnd", key_word_list));
        else
            (PyArg_Parse(args, ":getHighlightEnd"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const MouseWatcherParameter*)local_this)->get_highlight_end();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHighlightEnd(const MouseWatcherParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherParameter_get_highlight_end_210_comment =
    "C++ Interface:\n"
    "getHighlightEnd(const MouseWatcherParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherParameter::get_highlight_end\n"
    "//       Access: Published\n"
    "//  Description: Returns one more than the last highlighted character\n"
    "//               in the candidate string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherParameter_get_highlight_end_210_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int MouseWatcherParameter::get_cursor_pos(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcherParameter_get_cursor_pos_211(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int MouseWatcherParameter::get_cursor_pos(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCursorPos", key_word_list));
        else
            (PyArg_Parse(args, ":getCursorPos"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const MouseWatcherParameter*)local_this)->get_cursor_pos();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCursorPos(const MouseWatcherParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherParameter_get_cursor_pos_211_comment =
    "C++ Interface:\n"
    "getCursorPos(const MouseWatcherParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherParameter::get_cursor_pos\n"
    "//       Access: Published\n"
    "//  Description: Returns the position of the user's edit cursor within\n"
    "//               the candidate string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherParameter_get_cursor_pos_211_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ModifierButtons const &MouseWatcherParameter::get_modifier_buttons(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcherParameter_get_modifier_buttons_212(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline ModifierButtons const &MouseWatcherParameter::get_modifier_buttons(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getModifierButtons", key_word_list));
        else
            (PyArg_Parse(args, ":getModifierButtons"));
        if(!PyErr_Occurred())
        {
            ModifierButtons const *return_value = &(((const MouseWatcherParameter*)local_this)->get_modifier_buttons());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ModifierButtons,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getModifierButtons(const MouseWatcherParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherParameter_get_modifier_buttons_212_comment =
    "C++ Interface:\n"
    "getModifierButtons(const MouseWatcherParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherParameter::get_modifier_buttons\n"
    "//       Access: Published\n"
    "//  Description: Returns the set of modifier buttons that were being\n"
    "//               held down while the event was generated.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherParameter_get_modifier_buttons_212_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool MouseWatcherParameter::has_mouse(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcherParameter_has_mouse_213(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool MouseWatcherParameter::has_mouse(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasMouse", key_word_list));
        else
            (PyArg_Parse(args, ":hasMouse"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const MouseWatcherParameter*)local_this)->has_mouse();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasMouse(const MouseWatcherParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherParameter_has_mouse_213_comment =
    "C++ Interface:\n"
    "hasMouse(const MouseWatcherParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherParameter::has_mouse\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this parameter has an associated\n"
    "//               mouse position, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherParameter_has_mouse_213_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint2f const &MouseWatcherParameter::get_mouse(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcherParameter_get_mouse_214(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint2f const &MouseWatcherParameter::get_mouse(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMouse", key_word_list));
        else
            (PyArg_Parse(args, ":getMouse"));
        if(!PyErr_Occurred())
        {
            LPoint2f const *return_value = &(((const MouseWatcherParameter*)local_this)->get_mouse());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint2f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMouse(const MouseWatcherParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherParameter_get_mouse_214_comment =
    "C++ Interface:\n"
    "getMouse(const MouseWatcherParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherParameter::get_mouse\n"
    "//       Access: Published\n"
    "//  Description: Returns the mouse position at the time the event was\n"
    "//               generated, in the normalized range (-1 .. 1).  It is\n"
    "//               valid to call this only if has_mouse() returned true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherParameter_get_mouse_214_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool MouseWatcherParameter::is_outside(void) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcherParameter_is_outside_215(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool MouseWatcherParameter::is_outside(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isOutside", key_word_list));
        else
            (PyArg_Parse(args, ":isOutside"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const MouseWatcherParameter*)local_this)->is_outside();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isOutside(const MouseWatcherParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherParameter_is_outside_215_comment =
    "C++ Interface:\n"
    "isOutside(const MouseWatcherParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherParameter::is_outside\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the mouse was outside the region at\n"
    "//               the time the event was generated, false otherwise.\n"
    "//               This is only valid for \"release\" type events.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherParameter_is_outside_215_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MouseWatcherParameter::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_MouseWatcherParameter_output_216(PyObject *self, PyObject *args,PyObject *kwds) {
    MouseWatcherParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void MouseWatcherParameter::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "MouseWatcherParameter.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const MouseWatcherParameter*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const MouseWatcherParameter this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MouseWatcherParameter_output_216_comment =
    "C++ Interface:\n"
    "output(const MouseWatcherParameter this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MouseWatcherParameter::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MouseWatcherParameter_output_216_comment = NULL;
#endif

int  Dtool_Init_MouseWatcherParameter(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (MouseWatcherParameter)");
       return -1;
}
inline void  * Dtool_UpcastInterface_MouseWatcherParameter(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_MouseWatcherParameter)
    {
        printf("MouseWatcherParameter ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    MouseWatcherParameter * local_this = (MouseWatcherParameter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_MouseWatcherParameter)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_MouseWatcherParameter(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_MouseWatcherParameter)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Trackball 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void Trackball::reset(void)
 *******************************************************************/
static PyObject *Dtool_Trackball_reset_219(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Trackball::reset(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":reset", key_word_list));
        else
            (PyArg_Parse(args, ":reset"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Trackball.reset() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "reset(non-const Trackball this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_reset_219_comment =
    "C++ Interface:\n"
    "reset(non-const Trackball this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Trackball::reset\n"
    "//       Access: Published\n"
    "//  Description: Reinitializes all transforms to identity.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Trackball_reset_219_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float Trackball::get_forward_scale(void) const
 *******************************************************************/
static PyObject *Dtool_Trackball_get_forward_scale_220(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-float Trackball::get_forward_scale(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getForwardScale", key_word_list));
        else
            (PyArg_Parse(args, ":getForwardScale"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const Trackball*)local_this)->get_forward_scale();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getForwardScale(const Trackball this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_get_forward_scale_220_comment =
    "C++ Interface:\n"
    "getForwardScale(const Trackball this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Trackball::get_forward_scale\n"
    "//       Access: Published\n"
    "//  Description: Returns the scale factor applied to forward and\n"
    "//               backward motion.  See set_forward_scale().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Trackball_get_forward_scale_220_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Trackball::set_forward_scale(float fwdscale)
 *******************************************************************/
static PyObject *Dtool_Trackball_set_forward_scale_221(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Trackball::set_forward_scale(float fwdscale)
        double param1;
        static char * key_word_list[] = {(char *)"fwdscale", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setForwardScale", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setForwardScale", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_forward_scale((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Trackball.setForwardScale() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setForwardScale(non-const Trackball this, float fwdscale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_set_forward_scale_221_comment =
    "C++ Interface:\n"
    "setForwardScale(non-const Trackball this, float fwdscale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Trackball::set_forward_scale\n"
    "//       Access: Published\n"
    "//  Description: Changes the scale factor applied to forward and\n"
    "//               backward motion.  The larger this number, the faster\n"
    "//               the model will move in response to dollying in and\n"
    "//               out.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Trackball_set_forward_scale_221_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LPoint3f const &Trackball::get_pos(void) const
 *******************************************************************/
static PyObject *Dtool_Trackball_get_pos_222(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-LPoint3f const &Trackball::get_pos(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPos", key_word_list));
        else
            (PyArg_Parse(args, ":getPos"));
        if(!PyErr_Occurred())
        {
            LPoint3f const *return_value = &(((const Trackball*)local_this)->get_pos());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPos(const Trackball this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_get_pos_222_comment =
    "C++ Interface:\n"
    "getPos(const Trackball this)\n"
    "\n"
    "/// **** Translation ****\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Trackball::get_pos\n"
    "//       Access: Published\n"
    "//  Description: Return the offset from the center of rotation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Trackball_get_pos_222_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float Trackball::get_x(void) const
 *******************************************************************/
static PyObject *Dtool_Trackball_get_x_223(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-float Trackball::get_x(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getX", key_word_list));
        else
            (PyArg_Parse(args, ":getX"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const Trackball*)local_this)->get_x();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getX(const Trackball this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_get_x_223_comment =
    "C++ Interface:\n"
    "getX(const Trackball this)\n"
    "\n"
    "";
#else
static const char * Dtool_Trackball_get_x_223_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float Trackball::get_y(void) const
 *******************************************************************/
static PyObject *Dtool_Trackball_get_y_224(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-float Trackball::get_y(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getY", key_word_list));
        else
            (PyArg_Parse(args, ":getY"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const Trackball*)local_this)->get_y();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getY(const Trackball this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_get_y_224_comment =
    "C++ Interface:\n"
    "getY(const Trackball this)\n"
    "\n"
    "";
#else
static const char * Dtool_Trackball_get_y_224_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float Trackball::get_z(void) const
 *******************************************************************/
static PyObject *Dtool_Trackball_get_z_225(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-float Trackball::get_z(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getZ", key_word_list));
        else
            (PyArg_Parse(args, ":getZ"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const Trackball*)local_this)->get_z();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getZ(const Trackball this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_get_z_225_comment =
    "C++ Interface:\n"
    "getZ(const Trackball this)\n"
    "\n"
    "";
#else
static const char * Dtool_Trackball_get_z_225_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Trackball::set_pos(LVecBase3f const &vec)
 * void Trackball::set_pos(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_Trackball_set_pos_226(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void Trackball::set_pos(LVecBase3f const &vec)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"vec", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setPos", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setPos", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "Trackball.setPos", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_pos(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call Trackball.setPos() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void Trackball::set_pos(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setPos", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_pos((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Trackball.setPos() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setPos() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setPos(non-const Trackball this, const VBase3 vec)\n"
          "setPos(non-const Trackball this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_set_pos_226_comment =
    "C++ Interface:\n"
    "setPos(non-const Trackball this, const VBase3 vec)\n"
    "setPos(non-const Trackball this, float x, float y, float z)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Trackball::set_pos\n"
    "//       Access: Published\n"
    "//  Description: Directly set the offset from the rotational origin.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Trackball_set_pos_226_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Trackball::set_x(float x)
 *******************************************************************/
static PyObject *Dtool_Trackball_set_x_227(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Trackball::set_x(float x)
        double param1;
        static char * key_word_list[] = {(char *)"x", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setX", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setX", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_x((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Trackball.setX() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setX(non-const Trackball this, float x)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_set_x_227_comment =
    "C++ Interface:\n"
    "setX(non-const Trackball this, float x)\n"
    "\n"
    "";
#else
static const char * Dtool_Trackball_set_x_227_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Trackball::set_y(float y)
 *******************************************************************/
static PyObject *Dtool_Trackball_set_y_228(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Trackball::set_y(float y)
        double param1;
        static char * key_word_list[] = {(char *)"y", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setY", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setY", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_y((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Trackball.setY() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setY(non-const Trackball this, float y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_set_y_228_comment =
    "C++ Interface:\n"
    "setY(non-const Trackball this, float y)\n"
    "\n"
    "";
#else
static const char * Dtool_Trackball_set_y_228_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Trackball::set_z(float z)
 *******************************************************************/
static PyObject *Dtool_Trackball_set_z_229(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Trackball::set_z(float z)
        double param1;
        static char * key_word_list[] = {(char *)"z", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setZ", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setZ", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_z((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Trackball.setZ() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setZ(non-const Trackball this, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_set_z_229_comment =
    "C++ Interface:\n"
    "setZ(non-const Trackball this, float z)\n"
    "\n"
    "";
#else
static const char * Dtool_Trackball_set_z_229_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LVecBase3f Trackball::get_hpr(void) const
 *******************************************************************/
static PyObject *Dtool_Trackball_get_hpr_230(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-LVecBase3f Trackball::get_hpr(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHpr", key_word_list));
        else
            (PyArg_Parse(args, ":getHpr"));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const Trackball*)local_this)->get_hpr();
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHpr(const Trackball this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_get_hpr_230_comment =
    "C++ Interface:\n"
    "getHpr(const Trackball this)\n"
    "\n"
    "/// **** Rotation ****\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Trackball::get_hpr\n"
    "//       Access: Published\n"
    "//  Description: Return the trackball's orientation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Trackball_get_hpr_230_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float Trackball::get_h(void) const
 *******************************************************************/
static PyObject *Dtool_Trackball_get_h_231(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-float Trackball::get_h(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getH", key_word_list));
        else
            (PyArg_Parse(args, ":getH"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const Trackball*)local_this)->get_h();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getH(const Trackball this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_get_h_231_comment =
    "C++ Interface:\n"
    "getH(const Trackball this)\n"
    "\n"
    "";
#else
static const char * Dtool_Trackball_get_h_231_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float Trackball::get_p(void) const
 *******************************************************************/
static PyObject *Dtool_Trackball_get_p_232(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-float Trackball::get_p(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getP", key_word_list));
        else
            (PyArg_Parse(args, ":getP"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const Trackball*)local_this)->get_p();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getP(const Trackball this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_get_p_232_comment =
    "C++ Interface:\n"
    "getP(const Trackball this)\n"
    "\n"
    "";
#else
static const char * Dtool_Trackball_get_p_232_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float Trackball::get_r(void) const
 *******************************************************************/
static PyObject *Dtool_Trackball_get_r_233(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-float Trackball::get_r(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getR", key_word_list));
        else
            (PyArg_Parse(args, ":getR"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const Trackball*)local_this)->get_r();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getR(const Trackball this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_get_r_233_comment =
    "C++ Interface:\n"
    "getR(const Trackball this)\n"
    "\n"
    "";
#else
static const char * Dtool_Trackball_get_r_233_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Trackball::set_hpr(LVecBase3f const &hpr)
 * void Trackball::set_hpr(float h, float p, float r)
 *******************************************************************/
static PyObject *Dtool_Trackball_set_hpr_234(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void Trackball::set_hpr(LVecBase3f const &hpr)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"hpr", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setHpr", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setHpr", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "Trackball.setHpr", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_hpr(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call Trackball.setHpr() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void Trackball::set_hpr(float h, float p, float r)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"h", (char *)"p", (char *)"r", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setHpr", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_hpr((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Trackball.setHpr() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setHpr() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setHpr(non-const Trackball this, const VBase3 hpr)\n"
          "setHpr(non-const Trackball this, float h, float p, float r)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_set_hpr_234_comment =
    "C++ Interface:\n"
    "setHpr(non-const Trackball this, const VBase3 hpr)\n"
    "setHpr(non-const Trackball this, float h, float p, float r)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Trackball::set_hpr\n"
    "//       Access: Published\n"
    "//  Description: Directly set the mover's orientation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Trackball_set_hpr_234_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Trackball::set_h(float h)
 *******************************************************************/
static PyObject *Dtool_Trackball_set_h_235(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Trackball::set_h(float h)
        double param1;
        static char * key_word_list[] = {(char *)"h", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setH", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setH", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_h((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Trackball.setH() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setH(non-const Trackball this, float h)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_set_h_235_comment =
    "C++ Interface:\n"
    "setH(non-const Trackball this, float h)\n"
    "\n"
    "";
#else
static const char * Dtool_Trackball_set_h_235_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Trackball::set_p(float p)
 *******************************************************************/
static PyObject *Dtool_Trackball_set_p_236(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Trackball::set_p(float p)
        double param1;
        static char * key_word_list[] = {(char *)"p", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setP", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setP", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_p((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Trackball.setP() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setP(non-const Trackball this, float p)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_set_p_236_comment =
    "C++ Interface:\n"
    "setP(non-const Trackball this, float p)\n"
    "\n"
    "";
#else
static const char * Dtool_Trackball_set_p_236_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Trackball::set_r(float r)
 *******************************************************************/
static PyObject *Dtool_Trackball_set_r_237(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Trackball::set_r(float r)
        double param1;
        static char * key_word_list[] = {(char *)"r", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setR", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setR", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_r((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Trackball.setR() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setR(non-const Trackball this, float r)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_set_r_237_comment =
    "C++ Interface:\n"
    "setR(non-const Trackball this, float r)\n"
    "\n"
    "";
#else
static const char * Dtool_Trackball_set_r_237_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Trackball::reset_origin_here(void)
 *******************************************************************/
static PyObject *Dtool_Trackball_reset_origin_here_238(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Trackball::reset_origin_here(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":resetOriginHere", key_word_list));
        else
            (PyArg_Parse(args, ":resetOriginHere"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_origin_here();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Trackball.resetOriginHere() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetOriginHere(non-const Trackball this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_reset_origin_here_238_comment =
    "C++ Interface:\n"
    "resetOriginHere(non-const Trackball this)\n"
    "\n"
    "/// **** Origin of Rotation ****\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Trackball::reset_origin_here\n"
    "//       Access: Published\n"
    "//  Description: Reposition the center of rotation to coincide with\n"
    "//               the current translation offset.  Future rotations\n"
    "//               will be about the current origin.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Trackball_reset_origin_here_238_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Trackball::move_origin(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_Trackball_move_origin_239(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Trackball::move_origin(float x, float y, float z)
        double param1;
        double param2;
        double param3;
        static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:moveOrigin", key_word_list, &param1, &param2, &param3))
        {
            (local_this)->move_origin((float)param1, (float)param2, (float)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Trackball.moveOrigin() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "moveOrigin(non-const Trackball this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_move_origin_239_comment =
    "C++ Interface:\n"
    "moveOrigin(non-const Trackball this, float x, float y, float z)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Trackball::move_origin\n"
    "//       Access: Published\n"
    "//  Description: Moves the center of rotation by the given amount.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Trackball_move_origin_239_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LPoint3f Trackball::get_origin(void) const
 *******************************************************************/
static PyObject *Dtool_Trackball_get_origin_240(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-LPoint3f Trackball::get_origin(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOrigin", key_word_list));
        else
            (PyArg_Parse(args, ":getOrigin"));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const Trackball*)local_this)->get_origin();
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOrigin(const Trackball this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_get_origin_240_comment =
    "C++ Interface:\n"
    "getOrigin(const Trackball this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Trackball::get_origin\n"
    "//       Access: Published\n"
    "//  Description: Returns the current center of rotation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Trackball_get_origin_240_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Trackball::set_origin(LVecBase3f const &origin)
 *******************************************************************/
static PyObject *Dtool_Trackball_set_origin_241(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void Trackball::set_origin(LVecBase3f const &origin)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"origin", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setOrigin", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setOrigin", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "Trackball.setOrigin", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_origin(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Trackball.setOrigin() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setOrigin(non-const Trackball this, const VBase3 origin)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_set_origin_241_comment =
    "C++ Interface:\n"
    "setOrigin(non-const Trackball this, const VBase3 origin)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Trackball::set_origin\n"
    "//       Access: Published\n"
    "//  Description: Directly sets the center of rotation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Trackball_set_origin_241_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Trackball::set_invert(bool flag)
 *******************************************************************/
static PyObject *Dtool_Trackball_set_invert_242(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Trackball::set_invert(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setInvert", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setInvert", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_invert((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Trackball.setInvert() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setInvert(non-const Trackball this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_set_invert_242_comment =
    "C++ Interface:\n"
    "setInvert(non-const Trackball this, bool flag)\n"
    "\n"
    "/// **** Misc ****\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Trackball::set_invert\n"
    "//       Access: Published\n"
    "//  Description: Sets the invert flag.  When this is set, the inverse\n"
    "//               matrix is generated, suitable for joining to a\n"
    "//               camera, instead of parenting the scene under it.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Trackball_set_invert_242_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Trackball::get_invert(void) const
 *******************************************************************/
static PyObject *Dtool_Trackball_get_invert_243(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool Trackball::get_invert(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInvert", key_word_list));
        else
            (PyArg_Parse(args, ":getInvert"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Trackball*)local_this)->get_invert();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInvert(const Trackball this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_get_invert_243_comment =
    "C++ Interface:\n"
    "getInvert(const Trackball this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Trackball::get_invert\n"
    "//       Access: Published\n"
    "//  Description: Returns the invert flag.  When this is set, the\n"
    "//               inverse matrix is generated, suitable for joining to\n"
    "//               a camera, instead of parenting the scene under it.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Trackball_get_invert_243_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Trackball::set_rel_to(NodePath const &rel_to)
 *******************************************************************/
static PyObject *Dtool_Trackball_set_rel_to_244(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void Trackball::set_rel_to(NodePath const &rel_to)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"rel_to", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setRelTo", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setRelTo", &param1));
            if(!PyErr_Occurred())
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "Trackball.setRelTo", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_rel_to(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Trackball.setRelTo() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRelTo(non-const Trackball this, const NodePath rel_to)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_set_rel_to_244_comment =
    "C++ Interface:\n"
    "setRelTo(non-const Trackball this, const NodePath rel_to)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Trackball::set_rel_to\n"
    "//       Access: Published\n"
    "//  Description: Sets the NodePath that all trackball manipulations\n"
    "//               are to be assumed to be relative to.  For instance,\n"
    "//               set your camera node here to make the trackball\n"
    "//               motion camera relative.  The default is the empty\n"
    "//               path, which means trackball motion is in global\n"
    "//               space.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Trackball_set_rel_to_244_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NodePath const &Trackball::get_rel_to(void) const
 *******************************************************************/
static PyObject *Dtool_Trackball_get_rel_to_245(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-NodePath const &Trackball::get_rel_to(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRelTo", key_word_list));
        else
            (PyArg_Parse(args, ":getRelTo"));
        if(!PyErr_Occurred())
        {
            NodePath const *return_value = &(((const Trackball*)local_this)->get_rel_to());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRelTo(const Trackball this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_get_rel_to_245_comment =
    "C++ Interface:\n"
    "getRelTo(const Trackball this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Trackball::get_rel_to\n"
    "//       Access: Published\n"
    "//  Description: Returns the NodePath that all trackball manipulations\n"
    "//               are relative to, or the empty path.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Trackball_get_rel_to_245_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Trackball::set_coordinate_system(CoordinateSystem cs)
 *******************************************************************/
static PyObject *Dtool_Trackball_set_coordinate_system_246(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Trackball::set_coordinate_system(CoordinateSystem cs)
        int param1;
        static char * key_word_list[] = {(char *)"cs", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setCoordinateSystem", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setCoordinateSystem", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_coordinate_system((CoordinateSystem)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Trackball.setCoordinateSystem() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCoordinateSystem(non-const Trackball this, int cs)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_set_coordinate_system_246_comment =
    "C++ Interface:\n"
    "setCoordinateSystem(non-const Trackball this, int cs)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Trackball::set_coordinate_system\n"
    "//       Access: Published\n"
    "//  Description: Sets the coordinate system of the Trackball.\n"
    "//               Normally, this is the default coordinate system.\n"
    "//               This changes the axes the Trackball manipulates so\n"
    "//               that the user interface remains consistent across\n"
    "//               different coordinate systems.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Trackball_set_coordinate_system_246_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CoordinateSystem Trackball::get_coordinate_system(void) const
 *******************************************************************/
static PyObject *Dtool_Trackball_get_coordinate_system_247(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-CoordinateSystem Trackball::get_coordinate_system(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCoordinateSystem", key_word_list));
        else
            (PyArg_Parse(args, ":getCoordinateSystem"));
        if(!PyErr_Occurred())
        {
            CoordinateSystem return_value = ((const Trackball*)local_this)->get_coordinate_system();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCoordinateSystem(const Trackball this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_get_coordinate_system_247_comment =
    "C++ Interface:\n"
    "getCoordinateSystem(const Trackball this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Trackball::get_coordinate_system\n"
    "//       Access: Published\n"
    "//  Description: Returns the coordinate system of the Trackball.\n"
    "//               See set_coordinate_system().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Trackball_get_coordinate_system_247_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Trackball::set_mat(LMatrix4f const &mat)
 *******************************************************************/
static PyObject *Dtool_Trackball_set_mat_248(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void Trackball::set_mat(LMatrix4f const &mat)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"mat", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setMat", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setMat", &param1));
            if(!PyErr_Occurred())
            {
                LMatrix4f *param1_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LMatrix4f, 1, "Trackball.setMat", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_mat(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Trackball.setMat() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMat(non-const Trackball this, const Mat4 mat)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_set_mat_248_comment =
    "C++ Interface:\n"
    "setMat(non-const Trackball this, const Mat4 mat)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Trackball::set_mat\n"
    "//       Access: Published\n"
    "//  Description: Stores the indicated transform in the trackball.\n"
    "//               This is a transform in global space, regardless of\n"
    "//               the rel_to node.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Trackball_set_mat_248_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LMatrix4f const &Trackball::get_mat(void) const
 *******************************************************************/
static PyObject *Dtool_Trackball_get_mat_249(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-LMatrix4f const &Trackball::get_mat(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMat", key_word_list));
        else
            (PyArg_Parse(args, ":getMat"));
        if(!PyErr_Occurred())
        {
            LMatrix4f const *return_value = &(((const Trackball*)local_this)->get_mat());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LMatrix4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMat(const Trackball this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_get_mat_249_comment =
    "C++ Interface:\n"
    "getMat(const Trackball this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Trackball::get_mat\n"
    "//       Access: Published\n"
    "//  Description: Returns the matrix represented by the trackball\n"
    "//               rotation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Trackball_get_mat_249_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LMatrix4f const &Trackball::get_trans_mat(void) const
 *******************************************************************/
static PyObject *Dtool_Trackball_get_trans_mat_250(PyObject *self, PyObject *args,PyObject *kwds) {
    Trackball * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Trackball,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-LMatrix4f const &Trackball::get_trans_mat(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTransMat", key_word_list));
        else
            (PyArg_Parse(args, ":getTransMat"));
        if(!PyErr_Occurred())
        {
            LMatrix4f const *return_value = &(((const Trackball*)local_this)->get_trans_mat());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LMatrix4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTransMat(const Trackball this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_get_trans_mat_250_comment =
    "C++ Interface:\n"
    "getTransMat(const Trackball this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Trackball::get_trans_mat\n"
    "//       Access: Published\n"
    "//  Description: Returns the actual transform that will be applied to\n"
    "//               the scene graph.  This is the same as get_mat(),\n"
    "//               unless invert is in effect.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Trackball_get_trans_mat_250_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle Trackball::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_Trackball_get_class_type_251(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle Trackball::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = Trackball::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Trackball_get_class_type_251_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_Trackball_get_class_type_251_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Trackball::Trackball(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_Trackball(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-Trackball::Trackball(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:Trackball", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:Trackball", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            Trackball *return_value = new Trackball(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_Trackball,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Trackball(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Trackball(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Trackball)
    {
        printf("Trackball ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Trackball * local_this = (Trackball *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Trackball)
        return local_this;
    if(requested_type == &Dtool_DataNode)
        return ( DataNode *)( MouseInterfaceNode *) local_this;
    if(requested_type == &Dtool_MouseInterfaceNode)
        return ( MouseInterfaceNode *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( DataNode *)( MouseInterfaceNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( DataNode *)( MouseInterfaceNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( DataNode *)( MouseInterfaceNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( DataNode *)( MouseInterfaceNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( DataNode *)( MouseInterfaceNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Trackball(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Trackball)
        return from_this;
    if(from_type == &Dtool_DataNode)
    {
          DataNode* other_this = (DataNode*)from_this;
          return (Trackball*)other_this;
    }
    if(from_type == &Dtool_MouseInterfaceNode)
    {
          MouseInterfaceNode* other_this = (MouseInterfaceNode*)from_this;
          return (Trackball*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (Trackball*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (Trackball*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (Trackball*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (Trackball*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Transform2SG 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void Transform2SG::set_node(PandaNode *node)
 *******************************************************************/
static PyObject *Dtool_Transform2SG_set_node_254(PyObject *self, PyObject *args,PyObject *kwds) {
    Transform2SG * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Transform2SG,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void Transform2SG::set_node(PandaNode *node)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setNode", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setNode", &param1));
            if(!PyErr_Occurred())
            {
                PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PandaNode, 1, "Transform2SG.setNode", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_node(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Transform2SG.setNode() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setNode(non-const Transform2SG this, non-const PandaNode node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Transform2SG_set_node_254_comment =
    "C++ Interface:\n"
    "setNode(non-const Transform2SG this, non-const PandaNode node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Transform2SG::set_node\n"
    "//       Access: Public\n"
    "//  Description: Sets the node that this object will adjust.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Transform2SG_set_node_254_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PandaNode *Transform2SG::get_node(void) const
 *******************************************************************/
static PyObject *Dtool_Transform2SG_get_node_255(PyObject *self, PyObject *args,PyObject *kwds) {
    Transform2SG * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Transform2SG,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PandaNode *Transform2SG::get_node(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNode", key_word_list));
        else
            (PyArg_Parse(args, ":getNode"));
        if(!PyErr_Occurred())
        {
            PandaNode *return_value = ((const Transform2SG*)local_this)->get_node();
            if (return_value != (PandaNode *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PandaNode,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNode(const Transform2SG this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Transform2SG_get_node_255_comment =
    "C++ Interface:\n"
    "getNode(const Transform2SG this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Transform2SG::get_node\n"
    "//       Access: Public\n"
    "//  Description: Returns the node that this object will adjust, or NULL\n"
    "//               if the node has not yet been set.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Transform2SG_get_node_255_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle Transform2SG::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_Transform2SG_get_class_type_256(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle Transform2SG::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = Transform2SG::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Transform2SG_get_class_type_256_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_Transform2SG_get_class_type_256_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Transform2SG::Transform2SG(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_Transform2SG(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-Transform2SG::Transform2SG(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:Transform2SG", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:Transform2SG", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            Transform2SG *return_value = new Transform2SG(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_Transform2SG,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "Transform2SG(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Transform2SG(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Transform2SG)
    {
        printf("Transform2SG ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Transform2SG * local_this = (Transform2SG *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Transform2SG)
        return local_this;
    if(requested_type == &Dtool_DataNode)
        return ( DataNode *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( DataNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( DataNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Transform2SG(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Transform2SG)
        return from_this;
    if(from_type == &Dtool_DataNode)
    {
          DataNode* other_this = (DataNode*)from_this;
          return (Transform2SG*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (Transform2SG*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (Transform2SG*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (Transform2SG*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (Transform2SG*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. ButtonThrower | ButtonThrower
//********************************************************************
PyMethodDef Dtool_Methods_ButtonThrower[]= {
  { "setButtonDownEvent",(PyCFunction ) &Dtool_ButtonThrower_set_button_down_event_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonThrower_set_button_down_event_4_comment},
  { "getButtonDownEvent",(PyCFunction ) &Dtool_ButtonThrower_get_button_down_event_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonThrower_get_button_down_event_5_comment},
  { "setButtonUpEvent",(PyCFunction ) &Dtool_ButtonThrower_set_button_up_event_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonThrower_set_button_up_event_6_comment},
  { "getButtonUpEvent",(PyCFunction ) &Dtool_ButtonThrower_get_button_up_event_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonThrower_get_button_up_event_7_comment},
  { "setButtonRepeatEvent",(PyCFunction ) &Dtool_ButtonThrower_set_button_repeat_event_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonThrower_set_button_repeat_event_8_comment},
  { "getButtonRepeatEvent",(PyCFunction ) &Dtool_ButtonThrower_get_button_repeat_event_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonThrower_get_button_repeat_event_9_comment},
  { "setKeystrokeEvent",(PyCFunction ) &Dtool_ButtonThrower_set_keystroke_event_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonThrower_set_keystroke_event_10_comment},
  { "getKeystrokeEvent",(PyCFunction ) &Dtool_ButtonThrower_get_keystroke_event_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonThrower_get_keystroke_event_11_comment},
  { "setCandidateEvent",(PyCFunction ) &Dtool_ButtonThrower_set_candidate_event_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonThrower_set_candidate_event_12_comment},
  { "getCandidateEvent",(PyCFunction ) &Dtool_ButtonThrower_get_candidate_event_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonThrower_get_candidate_event_13_comment},
  { "setMoveEvent",(PyCFunction ) &Dtool_ButtonThrower_set_move_event_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonThrower_set_move_event_14_comment},
  { "getMoveEvent",(PyCFunction ) &Dtool_ButtonThrower_get_move_event_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonThrower_get_move_event_15_comment},
  { "setPrefix",(PyCFunction ) &Dtool_ButtonThrower_set_prefix_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonThrower_set_prefix_16_comment},
  { "getPrefix",(PyCFunction ) &Dtool_ButtonThrower_get_prefix_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonThrower_get_prefix_17_comment},
  { "setSpecificFlag",(PyCFunction ) &Dtool_ButtonThrower_set_specific_flag_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonThrower_set_specific_flag_18_comment},
  { "getSpecificFlag",(PyCFunction ) &Dtool_ButtonThrower_get_specific_flag_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonThrower_get_specific_flag_19_comment},
  { "setTimeFlag",(PyCFunction ) &Dtool_ButtonThrower_set_time_flag_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonThrower_set_time_flag_20_comment},
  { "getTimeFlag",(PyCFunction ) &Dtool_ButtonThrower_get_time_flag_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonThrower_get_time_flag_21_comment},
  { "addParameter",(PyCFunction ) &Dtool_ButtonThrower_add_parameter_22, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonThrower_add_parameter_22_comment},
  { "getNumParameters",(PyCFunction ) &Dtool_ButtonThrower_get_num_parameters_23, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonThrower_get_num_parameters_23_comment},
  { "getParameter",(PyCFunction ) &Dtool_ButtonThrower_get_parameter_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonThrower_get_parameter_24_comment},
  { "getModifierButtons",(PyCFunction ) &Dtool_ButtonThrower_get_modifier_buttons_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonThrower_get_modifier_buttons_25_comment},
  { "setModifierButtons",(PyCFunction ) &Dtool_ButtonThrower_set_modifier_buttons_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonThrower_set_modifier_buttons_26_comment},
  { "setThrowButtonsActive",(PyCFunction ) &Dtool_ButtonThrower_set_throw_buttons_active_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonThrower_set_throw_buttons_active_27_comment},
  { "getThrowButtonsActive",(PyCFunction ) &Dtool_ButtonThrower_get_throw_buttons_active_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonThrower_get_throw_buttons_active_28_comment},
  { "addThrowButton",(PyCFunction ) &Dtool_ButtonThrower_add_throw_button_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonThrower_add_throw_button_29_comment},
  { "removeThrowButton",(PyCFunction ) &Dtool_ButtonThrower_remove_throw_button_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonThrower_remove_throw_button_30_comment},
  { "hasThrowButton",(PyCFunction ) &Dtool_ButtonThrower_has_throw_button_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonThrower_has_throw_button_31_comment},
  { "clearThrowButtons",(PyCFunction ) &Dtool_ButtonThrower_clear_throw_buttons_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonThrower_clear_throw_buttons_32_comment},
  { "getClassType",(PyCFunction ) &Dtool_ButtonThrower_get_class_type_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ButtonThrower_get_class_type_33_comment},
  { "getParameters",(PyCFunction) &MakeSeq_ButtonThrower_get_parameters, METH_NOARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ButtonThrower(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ButtonThrower.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ButtonThrower\n"
          "// Description : Throws Panda Events for button down/up events\n"
          "//               generated within the data graph.\n"
          "//\n"
          "//               This is a DataNode which is intended to be parented\n"
          "//               to the data graph below a device which is generating\n"
          "//               a sequence of button events, like a MouseAndKeyboard\n"
          "//               device.  It simply takes each button it finds and\n"
          "//               throws a corresponding event based on the button name\n"
          "//               via the throw_event() call.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DataNode._Dtool_ClassInit(NULL);
        Dtool_ButtonThrower.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DataNode.As_PyTypeObject());
        Dtool_ButtonThrower.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ButtonThrower.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ButtonThrower.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ButtonThrower.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ButtonThrower)");
             printf(" Error In PyType_ReadyButtonThrower");
             return;
        }
        Py_INCREF(&Dtool_ButtonThrower.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ButtonThrower.As_PyTypeObject().tp_dict,"ButtonThrower",&Dtool_ButtonThrower.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_ButtonThrower.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_ButtonThrower[29],&Dtool_ButtonThrower.As_PyObject()));
        RegisterRuntimeClass(&Dtool_ButtonThrower,ButtonThrower::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ButtonThrower.As_PyTypeObject());
        PyModule_AddObject(module, "ButtonThrower",(PyObject *)&Dtool_ButtonThrower.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. MouseInterfaceNode | MouseInterfaceNode
//********************************************************************
PyMethodDef Dtool_Methods_MouseInterfaceNode[]= {
  { "requireButton",(PyCFunction ) &Dtool_MouseInterfaceNode_require_button_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseInterfaceNode_require_button_35_comment},
  { "clearButton",(PyCFunction ) &Dtool_MouseInterfaceNode_clear_button_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseInterfaceNode_clear_button_36_comment},
  { "clearAllButtons",(PyCFunction ) &Dtool_MouseInterfaceNode_clear_all_buttons_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseInterfaceNode_clear_all_buttons_37_comment},
  { "getClassType",(PyCFunction ) &Dtool_MouseInterfaceNode_get_class_type_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseInterfaceNode_get_class_type_38_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_MouseInterfaceNode(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_MouseInterfaceNode.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : MouseInterfaceNode\n"
          "// Description : This is the base class for some classes that monitor\n"
          "//               the mouse and keyboard input and perform some action\n"
          "//               due to their state.\n"
          "//\n"
          "//               It collects together some common interface; in\n"
          "//               particular, the require_button() and related methods.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DataNode._Dtool_ClassInit(NULL);
        Dtool_MouseInterfaceNode.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DataNode.As_PyTypeObject());
        Dtool_MouseInterfaceNode.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_MouseInterfaceNode.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_MouseInterfaceNode.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_MouseInterfaceNode.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(MouseInterfaceNode)");
             printf(" Error In PyType_ReadyMouseInterfaceNode");
             return;
        }
        Py_INCREF(&Dtool_MouseInterfaceNode.As_PyTypeObject());
        PyDict_SetItemString(Dtool_MouseInterfaceNode.As_PyTypeObject().tp_dict,"MouseInterfaceNode",&Dtool_MouseInterfaceNode.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_MouseInterfaceNode.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_MouseInterfaceNode[3],&Dtool_MouseInterfaceNode.As_PyObject()));
        RegisterRuntimeClass(&Dtool_MouseInterfaceNode,MouseInterfaceNode::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_MouseInterfaceNode.As_PyTypeObject());
        PyModule_AddObject(module, "MouseInterfaceNode",(PyObject *)&Dtool_MouseInterfaceNode.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DriveInterface | DriveInterface
//********************************************************************
PyMethodDef Dtool_Methods_DriveInterface[]= {
  { "setForwardSpeed",(PyCFunction ) &Dtool_DriveInterface_set_forward_speed_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_set_forward_speed_41_comment},
  { "getForwardSpeed",(PyCFunction ) &Dtool_DriveInterface_get_forward_speed_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_get_forward_speed_42_comment},
  { "setReverseSpeed",(PyCFunction ) &Dtool_DriveInterface_set_reverse_speed_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_set_reverse_speed_43_comment},
  { "getReverseSpeed",(PyCFunction ) &Dtool_DriveInterface_get_reverse_speed_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_get_reverse_speed_44_comment},
  { "setRotateSpeed",(PyCFunction ) &Dtool_DriveInterface_set_rotate_speed_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_set_rotate_speed_45_comment},
  { "getRotateSpeed",(PyCFunction ) &Dtool_DriveInterface_get_rotate_speed_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_get_rotate_speed_46_comment},
  { "setVerticalDeadZone",(PyCFunction ) &Dtool_DriveInterface_set_vertical_dead_zone_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_set_vertical_dead_zone_47_comment},
  { "getVerticalDeadZone",(PyCFunction ) &Dtool_DriveInterface_get_vertical_dead_zone_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_get_vertical_dead_zone_48_comment},
  { "setHorizontalDeadZone",(PyCFunction ) &Dtool_DriveInterface_set_horizontal_dead_zone_49, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_set_horizontal_dead_zone_49_comment},
  { "getHorizontalDeadZone",(PyCFunction ) &Dtool_DriveInterface_get_horizontal_dead_zone_50, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_get_horizontal_dead_zone_50_comment},
  { "setVerticalRampUpTime",(PyCFunction ) &Dtool_DriveInterface_set_vertical_ramp_up_time_51, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_set_vertical_ramp_up_time_51_comment},
  { "getVerticalRampUpTime",(PyCFunction ) &Dtool_DriveInterface_get_vertical_ramp_up_time_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_get_vertical_ramp_up_time_52_comment},
  { "setVerticalRampDownTime",(PyCFunction ) &Dtool_DriveInterface_set_vertical_ramp_down_time_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_set_vertical_ramp_down_time_53_comment},
  { "getVerticalRampDownTime",(PyCFunction ) &Dtool_DriveInterface_get_vertical_ramp_down_time_54, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_get_vertical_ramp_down_time_54_comment},
  { "setHorizontalRampUpTime",(PyCFunction ) &Dtool_DriveInterface_set_horizontal_ramp_up_time_55, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_set_horizontal_ramp_up_time_55_comment},
  { "getHorizontalRampUpTime",(PyCFunction ) &Dtool_DriveInterface_get_horizontal_ramp_up_time_56, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_get_horizontal_ramp_up_time_56_comment},
  { "setHorizontalRampDownTime",(PyCFunction ) &Dtool_DriveInterface_set_horizontal_ramp_down_time_57, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_set_horizontal_ramp_down_time_57_comment},
  { "getHorizontalRampDownTime",(PyCFunction ) &Dtool_DriveInterface_get_horizontal_ramp_down_time_58, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_get_horizontal_ramp_down_time_58_comment},
  { "getSpeed",(PyCFunction ) &Dtool_DriveInterface_get_speed_59, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_get_speed_59_comment},
  { "getRotSpeed",(PyCFunction ) &Dtool_DriveInterface_get_rot_speed_60, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_get_rot_speed_60_comment},
  { "reset",(PyCFunction ) &Dtool_DriveInterface_reset_61, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_reset_61_comment},
  { "getPos",(PyCFunction ) &Dtool_DriveInterface_get_pos_62, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_get_pos_62_comment},
  { "getX",(PyCFunction ) &Dtool_DriveInterface_get_x_63, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_get_x_63_comment},
  { "getY",(PyCFunction ) &Dtool_DriveInterface_get_y_64, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_get_y_64_comment},
  { "getZ",(PyCFunction ) &Dtool_DriveInterface_get_z_65, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_get_z_65_comment},
  { "setPos",(PyCFunction ) &Dtool_DriveInterface_set_pos_66, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_set_pos_66_comment},
  { "setX",(PyCFunction ) &Dtool_DriveInterface_set_x_67, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_set_x_67_comment},
  { "setY",(PyCFunction ) &Dtool_DriveInterface_set_y_68, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_set_y_68_comment},
  { "setZ",(PyCFunction ) &Dtool_DriveInterface_set_z_69, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_set_z_69_comment},
  { "getHpr",(PyCFunction ) &Dtool_DriveInterface_get_hpr_70, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_get_hpr_70_comment},
  { "getH",(PyCFunction ) &Dtool_DriveInterface_get_h_71, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_get_h_71_comment},
  { "getP",(PyCFunction ) &Dtool_DriveInterface_get_p_72, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_get_p_72_comment},
  { "getR",(PyCFunction ) &Dtool_DriveInterface_get_r_73, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_get_r_73_comment},
  { "setHpr",(PyCFunction ) &Dtool_DriveInterface_set_hpr_74, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_set_hpr_74_comment},
  { "setH",(PyCFunction ) &Dtool_DriveInterface_set_h_75, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_set_h_75_comment},
  { "setP",(PyCFunction ) &Dtool_DriveInterface_set_p_76, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_set_p_76_comment},
  { "setR",(PyCFunction ) &Dtool_DriveInterface_set_r_77, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_set_r_77_comment},
  { "setForceRoll",(PyCFunction ) &Dtool_DriveInterface_set_force_roll_78, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_set_force_roll_78_comment},
  { "setIgnoreMouse",(PyCFunction ) &Dtool_DriveInterface_set_ignore_mouse_79, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_set_ignore_mouse_79_comment},
  { "getIgnoreMouse",(PyCFunction ) &Dtool_DriveInterface_get_ignore_mouse_80, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_get_ignore_mouse_80_comment},
  { "setForceMouse",(PyCFunction ) &Dtool_DriveInterface_set_force_mouse_81, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_set_force_mouse_81_comment},
  { "getForceMouse",(PyCFunction ) &Dtool_DriveInterface_get_force_mouse_82, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_get_force_mouse_82_comment},
  { "setStopThisFrame",(PyCFunction ) &Dtool_DriveInterface_set_stop_this_frame_83, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_set_stop_this_frame_83_comment},
  { "getStopThisFrame",(PyCFunction ) &Dtool_DriveInterface_get_stop_this_frame_84, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_get_stop_this_frame_84_comment},
  { "setMat",(PyCFunction ) &Dtool_DriveInterface_set_mat_85, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_set_mat_85_comment},
  { "getMat",(PyCFunction ) &Dtool_DriveInterface_get_mat_86, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_get_mat_86_comment},
  { "forceDgraph",(PyCFunction ) &Dtool_DriveInterface_force_dgraph_87, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_force_dgraph_87_comment},
  { "getClassType",(PyCFunction ) &Dtool_DriveInterface_get_class_type_88, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DriveInterface_get_class_type_88_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DriveInterface(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DriveInterface.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DriveInterface\n"
          "// Description : This is a TFormer, similar to Trackball, that moves\n"
          "//               around a transform matrix in response to mouse input.\n"
          "//               The basic motion is on a horizontal plane, as if\n"
          "//               driving a vehicle.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_MouseInterfaceNode._Dtool_ClassInit(NULL);
        Dtool_DriveInterface.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_MouseInterfaceNode.As_PyTypeObject());
        Dtool_DriveInterface.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DriveInterface.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DriveInterface.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DriveInterface.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DriveInterface)");
             printf(" Error In PyType_ReadyDriveInterface");
             return;
        }
        Py_INCREF(&Dtool_DriveInterface.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DriveInterface.As_PyTypeObject().tp_dict,"DriveInterface",&Dtool_DriveInterface.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DriveInterface.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DriveInterface[47],&Dtool_DriveInterface.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DriveInterface,DriveInterface::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DriveInterface.As_PyTypeObject());
        PyModule_AddObject(module, "DriveInterface",(PyObject *)&Dtool_DriveInterface.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. MouseSubregion | MouseSubregion
//********************************************************************
PyMethodDef Dtool_Methods_MouseSubregion[]= {
  { "getLeft",(PyCFunction ) &Dtool_MouseSubregion_get_left_91, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseSubregion_get_left_91_comment},
  { "getRight",(PyCFunction ) &Dtool_MouseSubregion_get_right_92, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseSubregion_get_right_92_comment},
  { "getBottom",(PyCFunction ) &Dtool_MouseSubregion_get_bottom_93, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseSubregion_get_bottom_93_comment},
  { "getTop",(PyCFunction ) &Dtool_MouseSubregion_get_top_94, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseSubregion_get_top_94_comment},
  { "setDimensions",(PyCFunction ) &Dtool_MouseSubregion_set_dimensions_95, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseSubregion_set_dimensions_95_comment},
  { "getClassType",(PyCFunction ) &Dtool_MouseSubregion_get_class_type_96, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseSubregion_get_class_type_96_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_MouseSubregion(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_MouseSubregion.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : MouseSubregion\n"
          "// Description : The MouseSubregion object scales the mouse inputs\n"
          "//               from within a rectangular region of the screen, as if\n"
          "//               they were the full-screen inputs.\n"
          "//\n"
          "//               If you choose your MouseSubregion coordinates to\n"
          "//               exactly match a DisplayRegion within your window, you\n"
          "//               end up with a virtual mouse within your\n"
          "//               DisplayRegion.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_MouseInterfaceNode._Dtool_ClassInit(NULL);
        Dtool_MouseSubregion.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_MouseInterfaceNode.As_PyTypeObject());
        Dtool_MouseSubregion.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_MouseSubregion.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_MouseSubregion.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_MouseSubregion.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(MouseSubregion)");
             printf(" Error In PyType_ReadyMouseSubregion");
             return;
        }
        Py_INCREF(&Dtool_MouseSubregion.As_PyTypeObject());
        PyDict_SetItemString(Dtool_MouseSubregion.As_PyTypeObject().tp_dict,"MouseSubregion",&Dtool_MouseSubregion.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_MouseSubregion.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_MouseSubregion[5],&Dtool_MouseSubregion.As_PyObject()));
        RegisterRuntimeClass(&Dtool_MouseSubregion,MouseSubregion::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_MouseSubregion.As_PyTypeObject());
        PyModule_AddObject(module, "MouseSubregion",(PyObject *)&Dtool_MouseSubregion.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. MouseWatcherRegion | MouseWatcherRegion
//********************************************************************
PyMethodDef Dtool_Methods_MouseWatcherRegion[]= {
  { "setFrame",(PyCFunction ) &Dtool_MouseWatcherRegion_set_frame_105, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherRegion_set_frame_105_comment},
  { "getFrame",(PyCFunction ) &Dtool_MouseWatcherRegion_get_frame_106, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherRegion_get_frame_106_comment},
  { "getArea",(PyCFunction ) &Dtool_MouseWatcherRegion_get_area_107, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherRegion_get_area_107_comment},
  { "setSort",(PyCFunction ) &Dtool_MouseWatcherRegion_set_sort_108, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherRegion_set_sort_108_comment},
  { "getSort",(PyCFunction ) &Dtool_MouseWatcherRegion_get_sort_109, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherRegion_get_sort_109_comment},
  { "setActive",(PyCFunction ) &Dtool_MouseWatcherRegion_set_active_110, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherRegion_set_active_110_comment},
  { "getActive",(PyCFunction ) &Dtool_MouseWatcherRegion_get_active_111, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherRegion_get_active_111_comment},
  { "setKeyboard",(PyCFunction ) &Dtool_MouseWatcherRegion_set_keyboard_112, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherRegion_set_keyboard_112_comment},
  { "getKeyboard",(PyCFunction ) &Dtool_MouseWatcherRegion_get_keyboard_113, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherRegion_get_keyboard_113_comment},
  { "setSuppressFlags",(PyCFunction ) &Dtool_MouseWatcherRegion_set_suppress_flags_115, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherRegion_set_suppress_flags_115_comment},
  { "getSuppressFlags",(PyCFunction ) &Dtool_MouseWatcherRegion_get_suppress_flags_116, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherRegion_get_suppress_flags_116_comment},
  { "output",(PyCFunction ) &Dtool_MouseWatcherRegion_output_117, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherRegion_output_117_comment},
  { "write",(PyCFunction ) &Dtool_MouseWatcherRegion_write_118, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherRegion_write_118_comment},
  { "getClassType",(PyCFunction ) &Dtool_MouseWatcherRegion_get_class_type_119, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherRegion_get_class_type_119_comment},
  { "upcastToTypedWritableReferenceCount",(PyCFunction ) &Dtool_MouseWatcherRegion_upcast_to_TypedWritableReferenceCount_99, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherRegion_upcast_to_TypedWritableReferenceCount_99_comment},
  { "upcastToNamable",(PyCFunction ) &Dtool_MouseWatcherRegion_upcast_to_Namable_102, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherRegion_upcast_to_Namable_102_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     MouseWatcherRegion
//////////////////
static PyObject *  Dtool_Repr_MouseWatcherRegion(PyObject * self)
{
    MouseWatcherRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherRegion,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     MouseWatcherRegion
//////////////////
static PyObject *  Dtool_Str_MouseWatcherRegion(PyObject * self)
{
    MouseWatcherRegion * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherRegion,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_MouseWatcherRegion(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_MouseWatcherRegion.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : MouseWatcherRegion\n"
          "// Description : This is the class that defines a rectangular region\n"
          "//               on the screen for the MouseWatcher.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedWritableReferenceCount._Dtool_ClassInit(NULL);
        Dtool_Namable._Dtool_ClassInit(NULL);
        Dtool_MouseWatcherRegion.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_TypedWritableReferenceCount.As_PyTypeObject(),&Dtool_Namable.As_PyTypeObject());
        Dtool_MouseWatcherRegion.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_MouseWatcherRegion.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_MouseWatcherRegion.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_MouseWatcherRegion.As_PyTypeObject().tp_repr = & Dtool_Repr_MouseWatcherRegion;
        // __str__
        Dtool_MouseWatcherRegion.As_PyTypeObject().tp_str = & Dtool_Str_MouseWatcherRegion;
        // Enum  MouseWatcherRegion::SuppressFlags;
        PyDict_SetItemString(Dtool_MouseWatcherRegion.As_PyTypeObject().tp_dict,"SFMouseButton",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_MouseWatcherRegion.As_PyTypeObject().tp_dict,"SFOtherButton",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_MouseWatcherRegion.As_PyTypeObject().tp_dict,"SFAnyButton",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_MouseWatcherRegion.As_PyTypeObject().tp_dict,"SFMousePosition",PyInt_FromLong(4));
        if(PyType_Ready(&Dtool_MouseWatcherRegion.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(MouseWatcherRegion)");
             printf(" Error In PyType_ReadyMouseWatcherRegion");
             return;
        }
        Py_INCREF(&Dtool_MouseWatcherRegion.As_PyTypeObject());
        PyDict_SetItemString(Dtool_MouseWatcherRegion.As_PyTypeObject().tp_dict,"MouseWatcherRegion",&Dtool_MouseWatcherRegion.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_MouseWatcherRegion.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_MouseWatcherRegion[13],&Dtool_MouseWatcherRegion.As_PyObject()));
        RegisterRuntimeClass(&Dtool_MouseWatcherRegion,MouseWatcherRegion::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_MouseWatcherRegion.As_PyTypeObject());
        PyModule_AddObject(module, "MouseWatcherRegion",(PyObject *)&Dtool_MouseWatcherRegion.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. MouseWatcherGroup | MouseWatcherGroup
//********************************************************************
PyMethodDef Dtool_Methods_MouseWatcherGroup[]= {
  { "addRegion",(PyCFunction ) &Dtool_MouseWatcherGroup_add_region_125, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherGroup_add_region_125_comment},
  { "hasRegion",(PyCFunction ) &Dtool_MouseWatcherGroup_has_region_126, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherGroup_has_region_126_comment},
  { "removeRegion",(PyCFunction ) &Dtool_MouseWatcherGroup_remove_region_127, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherGroup_remove_region_127_comment},
  { "findRegion",(PyCFunction ) &Dtool_MouseWatcherGroup_find_region_128, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherGroup_find_region_128_comment},
  { "clearRegions",(PyCFunction ) &Dtool_MouseWatcherGroup_clear_regions_129, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherGroup_clear_regions_129_comment},
  { "sortRegions",(PyCFunction ) &Dtool_MouseWatcherGroup_sort_regions_130, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherGroup_sort_regions_130_comment},
  { "isSorted",(PyCFunction ) &Dtool_MouseWatcherGroup_is_sorted_131, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherGroup_is_sorted_131_comment},
  { "getNumRegions",(PyCFunction ) &Dtool_MouseWatcherGroup_get_num_regions_132, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherGroup_get_num_regions_132_comment},
  { "getRegion",(PyCFunction ) &Dtool_MouseWatcherGroup_get_region_133, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherGroup_get_region_133_comment},
  { "output",(PyCFunction ) &Dtool_MouseWatcherGroup_output_134, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherGroup_output_134_comment},
  { "write",(PyCFunction ) &Dtool_MouseWatcherGroup_write_135, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherGroup_write_135_comment},
  { "getClassType",(PyCFunction ) &Dtool_MouseWatcherGroup_get_class_type_136, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherGroup_get_class_type_136_comment},
  { "upcastToReferenceCount",(PyCFunction ) &Dtool_MouseWatcherGroup_upcast_to_ReferenceCount_123, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherGroup_upcast_to_ReferenceCount_123_comment},
  { "downcastToMouseWatcher",(PyCFunction ) &Dtool_MouseWatcherGroup_downcast_to_MouseWatcher_141, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherGroup_downcast_to_MouseWatcher_141_comment},
  { "getRegions",(PyCFunction) &MakeSeq_MouseWatcherGroup_get_regions, METH_NOARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     MouseWatcherGroup
//////////////////
static PyObject *  Dtool_Repr_MouseWatcherGroup(PyObject * self)
{
    MouseWatcherGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherGroup,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     MouseWatcherGroup
//////////////////
static PyObject *  Dtool_Str_MouseWatcherGroup(PyObject * self)
{
    MouseWatcherGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherGroup,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_MouseWatcherGroup(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_MouseWatcherGroup.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : MouseWatcherGroup\n"
          "// Description : This represents a collection of MouseWatcherRegions\n"
          "//               that may be managed as a group.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ReferenceCount._Dtool_ClassInit(NULL);
        Dtool_MouseWatcherGroup.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ReferenceCount.As_PyTypeObject());
        Dtool_MouseWatcherGroup.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_MouseWatcherGroup.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_MouseWatcherGroup.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_MouseWatcherGroup.As_PyTypeObject().tp_repr = & Dtool_Repr_MouseWatcherGroup;
        // __str__
        Dtool_MouseWatcherGroup.As_PyTypeObject().tp_str = & Dtool_Str_MouseWatcherGroup;
        if(PyType_Ready(&Dtool_MouseWatcherGroup.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(MouseWatcherGroup)");
             printf(" Error In PyType_ReadyMouseWatcherGroup");
             return;
        }
        Py_INCREF(&Dtool_MouseWatcherGroup.As_PyTypeObject());
        PyDict_SetItemString(Dtool_MouseWatcherGroup.As_PyTypeObject().tp_dict,"MouseWatcherGroup",&Dtool_MouseWatcherGroup.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_MouseWatcherGroup.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_MouseWatcherGroup[11],&Dtool_MouseWatcherGroup.As_PyObject()));
        RegisterRuntimeClass(&Dtool_MouseWatcherGroup,MouseWatcherGroup::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_MouseWatcherGroup.As_PyTypeObject());
        PyModule_AddObject(module, "MouseWatcherGroup",(PyObject *)&Dtool_MouseWatcherGroup.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. MouseWatcher | MouseWatcher
//********************************************************************
PyMethodDef Dtool_Methods_MouseWatcher[]= {
  { "removeRegion",(PyCFunction ) &Dtool_MouseWatcher_remove_region_144, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_remove_region_144_comment},
  { "hasMouse",(PyCFunction ) &Dtool_MouseWatcher_has_mouse_145, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_has_mouse_145_comment},
  { "isMouseOpen",(PyCFunction ) &Dtool_MouseWatcher_is_mouse_open_146, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_is_mouse_open_146_comment},
  { "getMouse",(PyCFunction ) &Dtool_MouseWatcher_get_mouse_147, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_get_mouse_147_comment},
  { "getMouseX",(PyCFunction ) &Dtool_MouseWatcher_get_mouse_x_148, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_get_mouse_x_148_comment},
  { "getMouseY",(PyCFunction ) &Dtool_MouseWatcher_get_mouse_y_149, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_get_mouse_y_149_comment},
  { "setFrame",(PyCFunction ) &Dtool_MouseWatcher_set_frame_150, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_set_frame_150_comment},
  { "getFrame",(PyCFunction ) &Dtool_MouseWatcher_get_frame_151, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_get_frame_151_comment},
  { "isOverRegion",(PyCFunction ) &Dtool_MouseWatcher_is_over_region_152, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_is_over_region_152_comment},
  { "getOverRegion",(PyCFunction ) &Dtool_MouseWatcher_get_over_region_153, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_get_over_region_153_comment},
  { "isButtonDown",(PyCFunction ) &Dtool_MouseWatcher_is_button_down_154, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_is_button_down_154_comment},
  { "setButtonDownPattern",(PyCFunction ) &Dtool_MouseWatcher_set_button_down_pattern_155, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_set_button_down_pattern_155_comment},
  { "getButtonDownPattern",(PyCFunction ) &Dtool_MouseWatcher_get_button_down_pattern_156, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_get_button_down_pattern_156_comment},
  { "setButtonUpPattern",(PyCFunction ) &Dtool_MouseWatcher_set_button_up_pattern_157, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_set_button_up_pattern_157_comment},
  { "getButtonUpPattern",(PyCFunction ) &Dtool_MouseWatcher_get_button_up_pattern_158, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_get_button_up_pattern_158_comment},
  { "setButtonRepeatPattern",(PyCFunction ) &Dtool_MouseWatcher_set_button_repeat_pattern_159, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_set_button_repeat_pattern_159_comment},
  { "getButtonRepeatPattern",(PyCFunction ) &Dtool_MouseWatcher_get_button_repeat_pattern_160, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_get_button_repeat_pattern_160_comment},
  { "setEnterPattern",(PyCFunction ) &Dtool_MouseWatcher_set_enter_pattern_161, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_set_enter_pattern_161_comment},
  { "getEnterPattern",(PyCFunction ) &Dtool_MouseWatcher_get_enter_pattern_162, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_get_enter_pattern_162_comment},
  { "setLeavePattern",(PyCFunction ) &Dtool_MouseWatcher_set_leave_pattern_163, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_set_leave_pattern_163_comment},
  { "getLeavePattern",(PyCFunction ) &Dtool_MouseWatcher_get_leave_pattern_164, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_get_leave_pattern_164_comment},
  { "setWithinPattern",(PyCFunction ) &Dtool_MouseWatcher_set_within_pattern_165, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_set_within_pattern_165_comment},
  { "getWithinPattern",(PyCFunction ) &Dtool_MouseWatcher_get_within_pattern_166, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_get_within_pattern_166_comment},
  { "setWithoutPattern",(PyCFunction ) &Dtool_MouseWatcher_set_without_pattern_167, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_set_without_pattern_167_comment},
  { "getWithoutPattern",(PyCFunction ) &Dtool_MouseWatcher_get_without_pattern_168, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_get_without_pattern_168_comment},
  { "setGeometry",(PyCFunction ) &Dtool_MouseWatcher_set_geometry_169, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_set_geometry_169_comment},
  { "hasGeometry",(PyCFunction ) &Dtool_MouseWatcher_has_geometry_170, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_has_geometry_170_comment},
  { "getGeometry",(PyCFunction ) &Dtool_MouseWatcher_get_geometry_171, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_get_geometry_171_comment},
  { "clearGeometry",(PyCFunction ) &Dtool_MouseWatcher_clear_geometry_172, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_clear_geometry_172_comment},
  { "setExtraHandler",(PyCFunction ) &Dtool_MouseWatcher_set_extra_handler_173, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_set_extra_handler_173_comment},
  { "getExtraHandler",(PyCFunction ) &Dtool_MouseWatcher_get_extra_handler_174, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_get_extra_handler_174_comment},
  { "setModifierButtons",(PyCFunction ) &Dtool_MouseWatcher_set_modifier_buttons_175, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_set_modifier_buttons_175_comment},
  { "getModifierButtons",(PyCFunction ) &Dtool_MouseWatcher_get_modifier_buttons_176, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_get_modifier_buttons_176_comment},
  { "setDisplayRegion",(PyCFunction ) &Dtool_MouseWatcher_set_display_region_177, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_set_display_region_177_comment},
  { "clearDisplayRegion",(PyCFunction ) &Dtool_MouseWatcher_clear_display_region_178, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_clear_display_region_178_comment},
  { "getDisplayRegion",(PyCFunction ) &Dtool_MouseWatcher_get_display_region_179, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_get_display_region_179_comment},
  { "hasDisplayRegion",(PyCFunction ) &Dtool_MouseWatcher_has_display_region_180, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_has_display_region_180_comment},
  { "addGroup",(PyCFunction ) &Dtool_MouseWatcher_add_group_181, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_add_group_181_comment},
  { "removeGroup",(PyCFunction ) &Dtool_MouseWatcher_remove_group_182, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_remove_group_182_comment},
  { "replaceGroup",(PyCFunction ) &Dtool_MouseWatcher_replace_group_183, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_replace_group_183_comment},
  { "getNumGroups",(PyCFunction ) &Dtool_MouseWatcher_get_num_groups_184, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_get_num_groups_184_comment},
  { "getGroup",(PyCFunction ) &Dtool_MouseWatcher_get_group_185, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_get_group_185_comment},
  { "setInactivityTimeout",(PyCFunction ) &Dtool_MouseWatcher_set_inactivity_timeout_186, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_set_inactivity_timeout_186_comment},
  { "hasInactivityTimeout",(PyCFunction ) &Dtool_MouseWatcher_has_inactivity_timeout_187, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_has_inactivity_timeout_187_comment},
  { "getInactivityTimeout",(PyCFunction ) &Dtool_MouseWatcher_get_inactivity_timeout_188, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_get_inactivity_timeout_188_comment},
  { "clearInactivityTimeout",(PyCFunction ) &Dtool_MouseWatcher_clear_inactivity_timeout_189, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_clear_inactivity_timeout_189_comment},
  { "setInactivityTimeoutEvent",(PyCFunction ) &Dtool_MouseWatcher_set_inactivity_timeout_event_190, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_set_inactivity_timeout_event_190_comment},
  { "getInactivityTimeoutEvent",(PyCFunction ) &Dtool_MouseWatcher_get_inactivity_timeout_event_191, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_get_inactivity_timeout_event_191_comment},
  { "getTrailLog",(PyCFunction ) &Dtool_MouseWatcher_get_trail_log_192, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_get_trail_log_192_comment},
  { "numTrailRecent",(PyCFunction ) &Dtool_MouseWatcher_num_trail_recent_193, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_num_trail_recent_193_comment},
  { "setTrailLogDuration",(PyCFunction ) &Dtool_MouseWatcher_set_trail_log_duration_194, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_set_trail_log_duration_194_comment},
  { "getTrailNode",(PyCFunction ) &Dtool_MouseWatcher_get_trail_node_195, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_get_trail_node_195_comment},
  { "clearTrailNode",(PyCFunction ) &Dtool_MouseWatcher_clear_trail_node_196, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_clear_trail_node_196_comment},
  { "clearTrailLog",(PyCFunction ) &Dtool_MouseWatcher_clear_trail_log_197, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_clear_trail_log_197_comment},
  { "noteActivity",(PyCFunction ) &Dtool_MouseWatcher_note_activity_198, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_note_activity_198_comment},
  { "getClassType",(PyCFunction ) &Dtool_MouseWatcher_get_class_type_199, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_get_class_type_199_comment},
  { "upcastToDataNode",(PyCFunction ) &Dtool_MouseWatcher_upcast_to_DataNode_138, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_upcast_to_DataNode_138_comment},
  { "upcastToMouseWatcherGroup",(PyCFunction ) &Dtool_MouseWatcher_upcast_to_MouseWatcherGroup_140, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcher_upcast_to_MouseWatcherGroup_140_comment},
  { "getGroups",(PyCFunction) &MakeSeq_MouseWatcher_get_groups, METH_NOARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_MouseWatcher(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_MouseWatcher.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : MouseWatcher\n"
          "// Description : This TFormer maintains a list of rectangular regions\n"
          "//               on the screen that are considered special mouse\n"
          "//               regions; typically these will be click buttons.  When\n"
          "//               the mouse passes in or out of one of these regions,\n"
          "//               or when a button is clicked while the mouse is in one\n"
          "//               of these regions, an event is thrown.\n"
          "//\n"
          "//               Mouse events may also be suppressed from the rest of\n"
          "//               the datagraph in these special regions.\n"
          "//\n"
          "//               This class can also implement a software mouse\n"
          "//               pointer by automatically generating a transform to\n"
          "//               apply to a piece of geometry placed under the 2-d\n"
          "//               scene graph.  It will move the geometry around\n"
          "//               according to the mouse's known position.\n"
          "//\n"
          "//               Finally, this class can keep a record of the mouse\n"
          "//               trail.  This is useful if you want to know, not just\n"
          "//               where the mouse is, but the exact sequence of movements\n"
          "//               it took to get there.  This information is mainly useful\n"
          "//               for gesture-recognition code.  To use trail logging,\n"
          "//               you need to enable the generation of pointer events\n"
          "//               in the GraphicsWindowInputDevice and set the trail \n"
          "//               log duration in the MouseWatcher. Otherwise, the\n"
          "//               trail log will be empty.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DataNode._Dtool_ClassInit(NULL);
        Dtool_MouseWatcherGroup._Dtool_ClassInit(NULL);
        Dtool_MouseWatcher.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_DataNode.As_PyTypeObject(),&Dtool_MouseWatcherGroup.As_PyTypeObject());
        Dtool_MouseWatcher.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_MouseWatcher.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_MouseWatcher.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_MouseWatcher.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(MouseWatcher)");
             printf(" Error In PyType_ReadyMouseWatcher");
             return;
        }
        Py_INCREF(&Dtool_MouseWatcher.As_PyTypeObject());
        PyDict_SetItemString(Dtool_MouseWatcher.As_PyTypeObject().tp_dict,"MouseWatcher",&Dtool_MouseWatcher.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_MouseWatcher.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_MouseWatcher[55],&Dtool_MouseWatcher.As_PyObject()));
        RegisterRuntimeClass(&Dtool_MouseWatcher,MouseWatcher::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_MouseWatcher.As_PyTypeObject());
        PyModule_AddObject(module, "MouseWatcher",(PyObject *)&Dtool_MouseWatcher.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. MouseWatcherParameter | MouseWatcherParameter
//********************************************************************
PyMethodDef Dtool_Methods_MouseWatcherParameter[]= {
  { "hasButton",(PyCFunction ) &Dtool_MouseWatcherParameter_has_button_202, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherParameter_has_button_202_comment},
  { "getButton",(PyCFunction ) &Dtool_MouseWatcherParameter_get_button_203, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherParameter_get_button_203_comment},
  { "isKeyrepeat",(PyCFunction ) &Dtool_MouseWatcherParameter_is_keyrepeat_204, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherParameter_is_keyrepeat_204_comment},
  { "hasKeycode",(PyCFunction ) &Dtool_MouseWatcherParameter_has_keycode_205, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherParameter_has_keycode_205_comment},
  { "getKeycode",(PyCFunction ) &Dtool_MouseWatcherParameter_get_keycode_206, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherParameter_get_keycode_206_comment},
  { "hasCandidate",(PyCFunction ) &Dtool_MouseWatcherParameter_has_candidate_207, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherParameter_has_candidate_207_comment},
  { "getCandidateStringEncoded",(PyCFunction ) &Dtool_MouseWatcherParameter_get_candidate_string_encoded_208, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherParameter_get_candidate_string_encoded_208_comment},
  { "getHighlightStart",(PyCFunction ) &Dtool_MouseWatcherParameter_get_highlight_start_209, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherParameter_get_highlight_start_209_comment},
  { "getHighlightEnd",(PyCFunction ) &Dtool_MouseWatcherParameter_get_highlight_end_210, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherParameter_get_highlight_end_210_comment},
  { "getCursorPos",(PyCFunction ) &Dtool_MouseWatcherParameter_get_cursor_pos_211, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherParameter_get_cursor_pos_211_comment},
  { "getModifierButtons",(PyCFunction ) &Dtool_MouseWatcherParameter_get_modifier_buttons_212, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherParameter_get_modifier_buttons_212_comment},
  { "hasMouse",(PyCFunction ) &Dtool_MouseWatcherParameter_has_mouse_213, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherParameter_has_mouse_213_comment},
  { "getMouse",(PyCFunction ) &Dtool_MouseWatcherParameter_get_mouse_214, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherParameter_get_mouse_214_comment},
  { "isOutside",(PyCFunction ) &Dtool_MouseWatcherParameter_is_outside_215, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherParameter_is_outside_215_comment},
  { "output",(PyCFunction ) &Dtool_MouseWatcherParameter_output_216, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MouseWatcherParameter_output_216_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     MouseWatcherParameter
//////////////////
static PyObject *  Dtool_Repr_MouseWatcherParameter(PyObject * self)
{
    MouseWatcherParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MouseWatcherParameter,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_MouseWatcherParameter(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_MouseWatcherParameter.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : MouseWatcherParameter\n"
          "// Description : This is sent along as a parameter to most events\n"
          "//               generated for a region to indicate the mouse and\n"
          "//               button state for the event.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_MouseWatcherParameter.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_MouseWatcherParameter.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_MouseWatcherParameter.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_MouseWatcherParameter.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_MouseWatcherParameter.As_PyTypeObject().tp_repr = & Dtool_Repr_MouseWatcherParameter;
        // __str__ Repr Proxy
        Dtool_MouseWatcherParameter.As_PyTypeObject().tp_str = & Dtool_Repr_MouseWatcherParameter;
        if(PyType_Ready(&Dtool_MouseWatcherParameter.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(MouseWatcherParameter)");
             printf(" Error In PyType_ReadyMouseWatcherParameter");
             return;
        }
        Py_INCREF(&Dtool_MouseWatcherParameter.As_PyTypeObject());
        PyDict_SetItemString(Dtool_MouseWatcherParameter.As_PyTypeObject().tp_dict,"MouseWatcherParameter",&Dtool_MouseWatcherParameter.As_PyObject());
        RegisterRuntimeClass(&Dtool_MouseWatcherParameter,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_MouseWatcherParameter.As_PyTypeObject());
        PyModule_AddObject(module, "MouseWatcherParameter",(PyObject *)&Dtool_MouseWatcherParameter.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Trackball | Trackball
//********************************************************************
PyMethodDef Dtool_Methods_Trackball[]= {
  { "reset",(PyCFunction ) &Dtool_Trackball_reset_219, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_reset_219_comment},
  { "getForwardScale",(PyCFunction ) &Dtool_Trackball_get_forward_scale_220, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_get_forward_scale_220_comment},
  { "setForwardScale",(PyCFunction ) &Dtool_Trackball_set_forward_scale_221, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_set_forward_scale_221_comment},
  { "getPos",(PyCFunction ) &Dtool_Trackball_get_pos_222, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_get_pos_222_comment},
  { "getX",(PyCFunction ) &Dtool_Trackball_get_x_223, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_get_x_223_comment},
  { "getY",(PyCFunction ) &Dtool_Trackball_get_y_224, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_get_y_224_comment},
  { "getZ",(PyCFunction ) &Dtool_Trackball_get_z_225, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_get_z_225_comment},
  { "setPos",(PyCFunction ) &Dtool_Trackball_set_pos_226, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_set_pos_226_comment},
  { "setX",(PyCFunction ) &Dtool_Trackball_set_x_227, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_set_x_227_comment},
  { "setY",(PyCFunction ) &Dtool_Trackball_set_y_228, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_set_y_228_comment},
  { "setZ",(PyCFunction ) &Dtool_Trackball_set_z_229, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_set_z_229_comment},
  { "getHpr",(PyCFunction ) &Dtool_Trackball_get_hpr_230, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_get_hpr_230_comment},
  { "getH",(PyCFunction ) &Dtool_Trackball_get_h_231, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_get_h_231_comment},
  { "getP",(PyCFunction ) &Dtool_Trackball_get_p_232, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_get_p_232_comment},
  { "getR",(PyCFunction ) &Dtool_Trackball_get_r_233, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_get_r_233_comment},
  { "setHpr",(PyCFunction ) &Dtool_Trackball_set_hpr_234, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_set_hpr_234_comment},
  { "setH",(PyCFunction ) &Dtool_Trackball_set_h_235, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_set_h_235_comment},
  { "setP",(PyCFunction ) &Dtool_Trackball_set_p_236, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_set_p_236_comment},
  { "setR",(PyCFunction ) &Dtool_Trackball_set_r_237, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_set_r_237_comment},
  { "resetOriginHere",(PyCFunction ) &Dtool_Trackball_reset_origin_here_238, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_reset_origin_here_238_comment},
  { "moveOrigin",(PyCFunction ) &Dtool_Trackball_move_origin_239, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_move_origin_239_comment},
  { "getOrigin",(PyCFunction ) &Dtool_Trackball_get_origin_240, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_get_origin_240_comment},
  { "setOrigin",(PyCFunction ) &Dtool_Trackball_set_origin_241, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_set_origin_241_comment},
  { "setInvert",(PyCFunction ) &Dtool_Trackball_set_invert_242, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_set_invert_242_comment},
  { "getInvert",(PyCFunction ) &Dtool_Trackball_get_invert_243, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_get_invert_243_comment},
  { "setRelTo",(PyCFunction ) &Dtool_Trackball_set_rel_to_244, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_set_rel_to_244_comment},
  { "getRelTo",(PyCFunction ) &Dtool_Trackball_get_rel_to_245, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_get_rel_to_245_comment},
  { "setCoordinateSystem",(PyCFunction ) &Dtool_Trackball_set_coordinate_system_246, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_set_coordinate_system_246_comment},
  { "getCoordinateSystem",(PyCFunction ) &Dtool_Trackball_get_coordinate_system_247, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_get_coordinate_system_247_comment},
  { "setMat",(PyCFunction ) &Dtool_Trackball_set_mat_248, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_set_mat_248_comment},
  { "getMat",(PyCFunction ) &Dtool_Trackball_get_mat_249, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_get_mat_249_comment},
  { "getTransMat",(PyCFunction ) &Dtool_Trackball_get_trans_mat_250, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_get_trans_mat_250_comment},
  { "getClassType",(PyCFunction ) &Dtool_Trackball_get_class_type_251, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Trackball_get_class_type_251_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Trackball(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Trackball.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : Trackball\n"
          "// Description : Trackball acts like Performer in trackball mode.  It\n"
          "//               can either spin around a piece of geometry directly,\n"
          "//               or it can spin around a camera with the inverse\n"
          "//               transform to make it appear that the whole world is\n"
          "//               spinning.\n"
          "//\n"
          "//               The Trackball object actually just places a transform\n"
          "//               in the data graph; parent a Transform2SG node under\n"
          "//               it to actually transform objects (or cameras) in the\n"
          "//               world.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_MouseInterfaceNode._Dtool_ClassInit(NULL);
        Dtool_Trackball.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_MouseInterfaceNode.As_PyTypeObject());
        Dtool_Trackball.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Trackball.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Trackball.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Trackball.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Trackball)");
             printf(" Error In PyType_ReadyTrackball");
             return;
        }
        Py_INCREF(&Dtool_Trackball.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Trackball.As_PyTypeObject().tp_dict,"Trackball",&Dtool_Trackball.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_Trackball.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_Trackball[32],&Dtool_Trackball.As_PyObject()));
        RegisterRuntimeClass(&Dtool_Trackball,Trackball::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Trackball.As_PyTypeObject());
        PyModule_AddObject(module, "Trackball",(PyObject *)&Dtool_Trackball.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Transform2SG | Transform2SG
//********************************************************************
PyMethodDef Dtool_Methods_Transform2SG[]= {
  { "setNode",(PyCFunction ) &Dtool_Transform2SG_set_node_254, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Transform2SG_set_node_254_comment},
  { "getNode",(PyCFunction ) &Dtool_Transform2SG_get_node_255, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Transform2SG_get_node_255_comment},
  { "getClassType",(PyCFunction ) &Dtool_Transform2SG_get_class_type_256, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Transform2SG_get_class_type_256_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Transform2SG(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Transform2SG.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : Transform2SG\n"
          "// Description : input: Transform (matrix)\n"
          "//\n"
          "//               output: none, but applies the matrix as the transform\n"
          "//               transition for a given arc of the scene graph.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DataNode._Dtool_ClassInit(NULL);
        Dtool_Transform2SG.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DataNode.As_PyTypeObject());
        Dtool_Transform2SG.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Transform2SG.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Transform2SG.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Transform2SG.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Transform2SG)");
             printf(" Error In PyType_ReadyTransform2SG");
             return;
        }
        Py_INCREF(&Dtool_Transform2SG.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Transform2SG.As_PyTypeObject().tp_dict,"Transform2SG",&Dtool_Transform2SG.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_Transform2SG.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_Transform2SG[2],&Dtool_Transform2SG.As_PyObject()));
        RegisterRuntimeClass(&Dtool_Transform2SG,Transform2SG::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Transform2SG.As_PyTypeObject());
        PyModule_AddObject(module, "Transform2SG",(PyObject *)&Dtool_Transform2SG.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Enums  ..CoordinateSystem
//********************************************************************
   PyModule_AddIntConstant(module,"CSDefault",0);
   PyModule_AddIntConstant(module,"CSZupRight",1);
   PyModule_AddIntConstant(module,"CSYupRight",2);
   PyModule_AddIntConstant(module,"CSZupLeft",3);
   PyModule_AddIntConstant(module,"CSYupLeft",4);
   PyModule_AddIntConstant(module,"CSInvalid",5);
//********************************************************************
//*** Module Init Updcall ..ButtonThrower
//********************************************************************
   Dtool_PyModuleClassInit_ButtonThrower(module);
//********************************************************************
//*** Module Init Updcall ..MouseInterfaceNode
//********************************************************************
   Dtool_PyModuleClassInit_MouseInterfaceNode(module);
//********************************************************************
//*** Module Init Updcall ..DriveInterface
//********************************************************************
   Dtool_PyModuleClassInit_DriveInterface(module);
//********************************************************************
//*** Module Init Updcall ..MouseSubregion
//********************************************************************
   Dtool_PyModuleClassInit_MouseSubregion(module);
//********************************************************************
//*** Module Init Updcall ..MouseWatcherRegion
//********************************************************************
   Dtool_PyModuleClassInit_MouseWatcherRegion(module);
//********************************************************************
//*** Module Init Updcall ..MouseWatcherGroup
//********************************************************************
   Dtool_PyModuleClassInit_MouseWatcherGroup(module);
//********************************************************************
//*** Module Init Updcall ..MouseWatcher
//********************************************************************
   Dtool_PyModuleClassInit_MouseWatcher(module);
//********************************************************************
//*** Module Init Updcall ..MouseWatcherParameter
//********************************************************************
   Dtool_PyModuleClassInit_MouseWatcherParameter(module);
//********************************************************************
//*** Module Init Updcall ..Trackball
//********************************************************************
   Dtool_PyModuleClassInit_Trackball(module);
//********************************************************************
//*** Module Init Updcall ..Transform2SG
//********************************************************************
   Dtool_PyModuleClassInit_Transform2SG(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libtform_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212902,  /* file_identifier */
  "libtform",  /* library_name */
  "yiw5",  /* library_hash_name */
  "panda",  /* module_name */
  "libtform.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  611  /* next_index */
};

Configure(_in_configure_libtform);
ConfigureFn(_in_configure_libtform) {
  interrogate_request_module(&_in_module_def);
}

