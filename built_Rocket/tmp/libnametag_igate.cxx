/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir otp/nametag -Iotp/nametag -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libnametag_igate.cxx -od built_Rocket/pandac/input/libnametag.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Iotp/nametag -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_OTP -module otp -library libnametag chatBalloon.h chatFlags.h clickablePopup.h config_nametag.h marginManager.h marginPopup.h nametag.h nametag2d.h nametag3d.h nametagFloat2d.h nametagFloat3d.h nametagGlobals.h nametagGroup.h nametag_composite1.cxx nametag_composite2.cxx popupMouseWatcherRegion.h whisperPopup.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libnametag
#include "py_panda.h"  

#include "audioSound.h"
#include "cInterval.h"
#include "chatBalloon.h"
#include "chatFlags.h"
#include "clickablePopup.h"
#include "configVariableBool.h"
#include "configVariableString.h"
#include "config_nametag.h"
#include "luse.h"
#include "marginManager.h"
#include "marginPopup.h"
#include "mouseWatcher.h"
#include "nametag.h"
#include "nametag2d.h"
#include "nametag3d.h"
#include "nametagFloat2d.h"
#include "nametagFloat3d.h"
#include "nametagGlobals.h"
#include "nametagGroup.h"
#include "nodePath.h"
#include "notifyCategoryProxy.h"
#include "otpbase.h"
#include "pStatCollector.h"
#include "pandaNode.h"
#include "pgButton.h"
#include "pmap.h"
#include "pointerTo.h"
#include "popupMouseWatcherRegion.h"
#include "pvector.h"
#include "referenceCount.h"
#include "textNode.h"
#include "updateSeq.h"
#include "vector_int.h"
#include "whisperPopup.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. ChatBalloon
//********************************************************************
typedef  ChatBalloon  ChatBalloon_localtype;
Define_Module_ClassRef(otp,ChatBalloon,ChatBalloon_localtype,ChatBalloon);
//********************************************************************
//*** prototypes for .. ClickablePopup
//********************************************************************
typedef  ClickablePopup  ClickablePopup_localtype;
Define_Module_Class(otp,ClickablePopup,ClickablePopup_localtype,ClickablePopup);
//********************************************************************
//*** prototypes for .. MarginPopup
//********************************************************************
typedef  MarginPopup  MarginPopup_localtype;
Define_Module_ClassRef(otp,MarginPopup,MarginPopup_localtype,MarginPopup);
//********************************************************************
//*** prototypes for .. MarginManager
//********************************************************************
typedef  MarginManager  MarginManager_localtype;
Define_Module_ClassRef(otp,MarginManager,MarginManager_localtype,MarginManager);
//********************************************************************
//*** prototypes for .. Nametag
//********************************************************************
typedef  Nametag  Nametag_localtype;
Define_Module_ClassRef(otp,Nametag,Nametag_localtype,Nametag);
//********************************************************************
//*** prototypes for .. Nametag2d
//********************************************************************
typedef  Nametag2d  Nametag2d_localtype;
Define_Module_ClassRef(otp,Nametag2d,Nametag2d_localtype,Nametag2d);
//********************************************************************
//*** prototypes for .. Nametag3d
//********************************************************************
typedef  Nametag3d  Nametag3d_localtype;
Define_Module_ClassRef(otp,Nametag3d,Nametag3d_localtype,Nametag3d);
//********************************************************************
//*** prototypes for .. NametagFloat2d
//********************************************************************
typedef  NametagFloat2d  NametagFloat2d_localtype;
Define_Module_ClassRef(otp,NametagFloat2d,NametagFloat2d_localtype,NametagFloat2d);
//********************************************************************
//*** prototypes for .. NametagFloat3d
//********************************************************************
typedef  NametagFloat3d  NametagFloat3d_localtype;
Define_Module_ClassRef(otp,NametagFloat3d,NametagFloat3d_localtype,NametagFloat3d);
//********************************************************************
//*** prototypes for .. NametagGroup
//********************************************************************
typedef  NametagGroup  NametagGroup_localtype;
Define_Module_Class(otp,NametagGroup,NametagGroup_localtype,NametagGroup);
//********************************************************************
//*** prototypes for .. WhisperPopup
//********************************************************************
typedef  WhisperPopup  WhisperPopup_localtype;
Define_Module_ClassRef(otp,WhisperPopup,WhisperPopup_localtype,WhisperPopup);
//********************************************************************
//*** prototypes for .. NametagGlobals
//********************************************************************
typedef  NametagGlobals  NametagGlobals_localtype;
Define_Module_Class(otp,NametagGlobals,NametagGlobals_localtype,NametagGlobals);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_AudioSound;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase2f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_MouseWatcher;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Namable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_NodePath;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PGButton;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PandaNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TextFont;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritable;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. ChatBalloon 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * PointerTo< PandaNode > ChatBalloon::generate(basic_string< char > const &text, TextFont *font, float wordwrap, LVecBase4f const &text_color, LVecBase4f const &balloon_color, bool for_3d, bool has_draw_order, int draw_order, NodePath const &page_button, bool space_for_button, bool reversed, NodePath &new_button)
 *******************************************************************/
static PyObject *Dtool_ChatBalloon_generate_4(PyObject *self, PyObject *args,PyObject *kwds) {
    ChatBalloon * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ChatBalloon,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-PointerTo< PandaNode > ChatBalloon::generate(basic_string< char > const &text, TextFont *font, float wordwrap, LVecBase4f const &text_color, LVecBase4f const &balloon_color, bool for_3d, bool has_draw_order, int draw_order, NodePath const &page_button, bool space_for_button, bool reversed, NodePath &new_button)
            char *param1_str; int param1_len;
            PyObject *param2;
            double param3;
            PyObject *param4;
            PyObject *param5;
            PyObject *param6;
            PyObject *param7;
            int param8;
            PyObject *param9;
            PyObject *param10;
            PyObject *param11;
            PyObject *param12;
            static char * key_word_list[] = {(char *)"text", (char *)"font", (char *)"wordwrap", (char *)"text_color", (char *)"balloon_color", (char *)"for_3d", (char *)"has_draw_order", (char *)"draw_order", (char *)"page_button", (char *)"space_for_button", (char *)"reversed", (char *)"new_button", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#OdOOOOiOOOO:generate", key_word_list, &param1_str, &param1_len, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12))
            {
                TextFont *param2_this = (TextFont *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_TextFont, 2, "ChatBalloon.generate", 0, coerced_ptr, report_errors);
LVecBase4f *param4_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LVecBase4f, 4, "ChatBalloon.generate", 1, coerced_ptr, report_errors);
LVecBase4f *param5_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_LVecBase4f, 5, "ChatBalloon.generate", 1, coerced_ptr, report_errors);
NodePath *param9_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param9, &Dtool_NodePath, 9, "ChatBalloon.generate", 1, coerced_ptr, report_errors);
NodePath *param12_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param12, &Dtool_NodePath, 12, "ChatBalloon.generate", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)|| (param4_this == NULL)|| (param5_this == NULL)|| (param9_this == NULL)|| (param12_this == NULL)))
                {
                    PointerTo< PandaNode > return_value = (local_this)->generate(basic_string<char>(param1_str, param1_len), param2_this, (float)param3, *param4_this, *param5_this, (PyObject_IsTrue(param6)!=0), (PyObject_IsTrue(param7)!=0), (int)param8, *param9_this, (PyObject_IsTrue(param10)!=0), (PyObject_IsTrue(param11)!=0), *param12_this);
                    if (return_value != (PandaNode *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value.p() == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_PandaNode,true, false, (return_value.p())->as_typed_object()->get_type_index());
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ChatBalloon.generate() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "generate(non-const ChatBalloon this, string text, non-const TextFont font, float wordwrap, const VBase4 text_color, const VBase4 balloon_color, bool for_3d, bool has_draw_order, int draw_order, const NodePath page_button, bool space_for_button, bool reversed, non-const NodePath new_button)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ChatBalloon_generate_4_comment =
    "C++ Interface:\n"
    "generate(non-const ChatBalloon this, string text, non-const TextFont font, float wordwrap, const VBase4 text_color, const VBase4 balloon_color, bool for_3d, bool has_draw_order, int draw_order, const NodePath page_button, bool space_for_button, bool reversed, non-const NodePath new_button)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ChatBalloon::generate\n"
    "//       Access: Public\n"
    "//  Description: Generates a new subgraph representing the text in the\n"
    "//               indicated TextNode framed within the balloon.\n"
    "//\n"
    "//               If for_3d is true, the text will be decalled onto the\n"
    "//               balloon geometry; otherwise, it will simply be\n"
    "//               parented so that it will be rendered second (in the\n"
    "//               2-d scene graph).\n"
    "//\n"
    "//               If has_draw_order is true, the geometry will be\n"
    "//               assigned to the fixed bin with the indicated\n"
    "//               draw_order.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ChatBalloon_generate_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ChatBalloon::ChatBalloon(PandaNode *root_node)
 *******************************************************************/
int  Dtool_Init_ChatBalloon(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-ChatBalloon::ChatBalloon(PandaNode *root_node)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"root_node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:ChatBalloon", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:ChatBalloon", &param0));
            if(!PyErr_Occurred())
            {
                PandaNode *param0_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PandaNode, 0, "ChatBalloon.ChatBalloon", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    ChatBalloon *return_value = new ChatBalloon(param0_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ChatBalloon,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ChatBalloon(non-const PandaNode root_node)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ChatBalloon(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ChatBalloon)
    {
        printf("ChatBalloon ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ChatBalloon * local_this = (ChatBalloon *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ChatBalloon)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ChatBalloon(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ChatBalloon)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (ChatBalloon*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ClickablePopup 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ClickablePopup::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_ClickablePopup_get_class_type_8(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ClickablePopup::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ClickablePopup::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClickablePopup_get_class_type_8_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_ClickablePopup_get_class_type_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual TypeHandle ClickablePopup::get_type(void) const
 *******************************************************************/
static PyObject *Dtool_ClickablePopup_get_type_9(PyObject *self, PyObject *args,PyObject *kwds) {
    ClickablePopup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClickablePopup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual TypeHandle ClickablePopup::get_type(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getType", key_word_list));
        else
            (PyArg_Parse(args, ":getType"));
        if(!PyErr_Occurred())
        {
            TypeHandle result = ((const ClickablePopup*)local_this)->get_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getType(const ClickablePopup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClickablePopup_get_type_9_comment =
    "C++ Interface:\n"
    "getType(const ClickablePopup this)\n"
    "\n"
    "// We define get_type() even though we don't inherit from\n"
    "// TypedObject.  We can't actually inherit from TypedObject because\n"
    "// of the whole multiple-inheritance thing in our derived classes.\n"
    "";
#else
static const char * Dtool_ClickablePopup_get_type_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Nametag *ClickablePopup::downcast_to_Nametag(void)
 *******************************************************************/
static PyObject *Dtool_ClickablePopup_downcast_to_Nametag_25(PyObject *self, PyObject *args,PyObject *kwds) {
    ClickablePopup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClickablePopup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-Nametag *ClickablePopup::downcast_to_Nametag(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToNametag", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToNametag"));
        if(!PyErr_Occurred())
        {
            Nametag *return_value = (Nametag *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Nametag,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ClickablePopup.downcastToNametag() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToNametag(non-const ClickablePopup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClickablePopup_downcast_to_Nametag_25_comment =
    "C++ Interface:\n"
    "downcastToNametag(non-const ClickablePopup this)\n"
    "\n"
    "downcast from ClickablePopup to Nametag\n"
    "";
#else
static const char * Dtool_ClickablePopup_downcast_to_Nametag_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * WhisperPopup *ClickablePopup::downcast_to_WhisperPopup(void)
 *******************************************************************/
static PyObject *Dtool_ClickablePopup_downcast_to_WhisperPopup_132(PyObject *self, PyObject *args,PyObject *kwds) {
    ClickablePopup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ClickablePopup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-WhisperPopup *ClickablePopup::downcast_to_WhisperPopup(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToWhisperPopup", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToWhisperPopup"));
        if(!PyErr_Occurred())
        {
            WhisperPopup *return_value = (WhisperPopup *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_WhisperPopup,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ClickablePopup.downcastToWhisperPopup() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToWhisperPopup(non-const ClickablePopup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ClickablePopup_downcast_to_WhisperPopup_132_comment =
    "C++ Interface:\n"
    "downcastToWhisperPopup(non-const ClickablePopup this)\n"
    "\n"
    "downcast from ClickablePopup to WhisperPopup\n"
    "";
#else
static const char * Dtool_ClickablePopup_downcast_to_WhisperPopup_132_comment = NULL;
#endif

int  Dtool_Init_ClickablePopup(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (ClickablePopup)");
       return -1;
}
inline void  * Dtool_UpcastInterface_ClickablePopup(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ClickablePopup)
    {
        printf("ClickablePopup ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ClickablePopup * local_this = (ClickablePopup *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ClickablePopup)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ClickablePopup(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ClickablePopup)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. MarginPopup 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline bool MarginPopup::is_managed(void) const
 *******************************************************************/
static PyObject *Dtool_MarginPopup_is_managed_12(PyObject *self, PyObject *args,PyObject *kwds) {
    MarginPopup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MarginPopup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool MarginPopup::is_managed(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isManaged", key_word_list));
        else
            (PyArg_Parse(args, ":isManaged"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const MarginPopup*)local_this)->is_managed();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isManaged(const MarginPopup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MarginPopup_is_managed_12_comment =
    "C++ Interface:\n"
    "isManaged(const MarginPopup this)\n"
    "\n"
    "// Filename: marginPopup.I\n"
    "// Created by:  drose (19Jul01)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MarginPopup::is_managed\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this popup is currently managed\n"
    "//               (that is, available to be made visible), or false if\n"
    "//               it is not managed (it will never be visible).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MarginPopup_is_managed_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool MarginPopup::is_visible(void) const
 *******************************************************************/
static PyObject *Dtool_MarginPopup_is_visible_13(PyObject *self, PyObject *args,PyObject *kwds) {
    MarginPopup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MarginPopup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool MarginPopup::is_visible(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isVisible", key_word_list));
        else
            (PyArg_Parse(args, ":isVisible"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const MarginPopup*)local_this)->is_visible();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isVisible(const MarginPopup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MarginPopup_is_visible_13_comment =
    "C++ Interface:\n"
    "isVisible(const MarginPopup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MarginPopup::is_visible\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this popup is currently visible\n"
    "//               or false if it is invisible (which may mean that it\n"
    "//               is managed, but not visible).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MarginPopup_is_visible_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle MarginPopup::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_MarginPopup_get_class_type_14(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle MarginPopup::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = MarginPopup::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MarginPopup_get_class_type_14_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_MarginPopup_get_class_type_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Nametag2d *MarginPopup::downcast_to_Nametag2d(void)
 *******************************************************************/
static PyObject *Dtool_MarginPopup_downcast_to_Nametag2d_48(PyObject *self, PyObject *args,PyObject *kwds) {
    MarginPopup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MarginPopup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-Nametag2d *MarginPopup::downcast_to_Nametag2d(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToNametag2d", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToNametag2d"));
        if(!PyErr_Occurred())
        {
            Nametag2d *return_value = (Nametag2d *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Nametag2d,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MarginPopup.downcastToNametag2d() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToNametag2d(non-const MarginPopup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MarginPopup_downcast_to_Nametag2d_48_comment =
    "C++ Interface:\n"
    "downcastToNametag2d(non-const MarginPopup this)\n"
    "\n"
    "downcast from MarginPopup to Nametag2d\n"
    "";
#else
static const char * Dtool_MarginPopup_downcast_to_Nametag2d_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * WhisperPopup *MarginPopup::downcast_to_WhisperPopup(void)
 *******************************************************************/
static PyObject *Dtool_MarginPopup_downcast_to_WhisperPopup_130(PyObject *self, PyObject *args,PyObject *kwds) {
    MarginPopup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MarginPopup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-WhisperPopup *MarginPopup::downcast_to_WhisperPopup(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToWhisperPopup", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToWhisperPopup"));
        if(!PyErr_Occurred())
        {
            WhisperPopup *return_value = (WhisperPopup *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_WhisperPopup,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MarginPopup.downcastToWhisperPopup() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToWhisperPopup(non-const MarginPopup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MarginPopup_downcast_to_WhisperPopup_130_comment =
    "C++ Interface:\n"
    "downcastToWhisperPopup(non-const MarginPopup this)\n"
    "\n"
    "downcast from MarginPopup to WhisperPopup\n"
    "";
#else
static const char * Dtool_MarginPopup_downcast_to_WhisperPopup_130_comment = NULL;
#endif

int  Dtool_Init_MarginPopup(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (MarginPopup)");
       return -1;
}
inline void  * Dtool_UpcastInterface_MarginPopup(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_MarginPopup)
    {
        printf("MarginPopup ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    MarginPopup * local_this = (MarginPopup *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_MarginPopup)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_MarginPopup(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_MarginPopup)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (MarginPopup*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (MarginPopup*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (MarginPopup*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (MarginPopup*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. MarginManager 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * int MarginManager::add_grid_cell(float x, float y, float screen_left, float screen_right, float screen_bottom, float screen_top)
 *******************************************************************/
static PyObject *Dtool_MarginManager_add_grid_cell_17(PyObject *self, PyObject *args,PyObject *kwds) {
    MarginManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MarginManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int MarginManager::add_grid_cell(float x, float y, float screen_left, float screen_right, float screen_bottom, float screen_top)
        double param1;
        double param2;
        double param3;
        double param4;
        double param5;
        double param6;
        static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"screen_left", (char *)"screen_right", (char *)"screen_bottom", (char *)"screen_top", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dddddd:addGridCell", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6))
        {
            int return_value = (local_this)->add_grid_cell((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MarginManager.addGridCell() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addGridCell(non-const MarginManager this, float x, float y, float screen_left, float screen_right, float screen_bottom, float screen_top)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MarginManager_add_grid_cell_17_comment =
    "C++ Interface:\n"
    "addGridCell(non-const MarginManager this, float x, float y, float screen_left, float screen_right, float screen_bottom, float screen_top)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MarginManager::add_grid_cell\n"
    "//       Access: Published\n"
    "//  Description: This variant on add_cell() adds a new cell based on\n"
    "//               its coordinates within an imaginary grid, where (0,\n"
    "//               0) is the bottom left corner and\n"
    "//               (NametagGlobals::grid_count_horizontal - 1,\n"
    "//               NametagGlobals::grid_count_vertical - 1) is the upper\n"
    "//               right corner.  The dimensions of the entire screen\n"
    "//               are given.\n"
    "//\n"
    "//               The return value is the index number associated with\n"
    "//               this cell, which may be passed to get_cell_available()\n"
    "//               or set_cell_available().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MarginManager_add_grid_cell_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int MarginManager::add_cell(float left, float right, float bottom, float top)
 *******************************************************************/
static PyObject *Dtool_MarginManager_add_cell_18(PyObject *self, PyObject *args,PyObject *kwds) {
    MarginManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MarginManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int MarginManager::add_cell(float left, float right, float bottom, float top)
        double param1;
        double param2;
        double param3;
        double param4;
        static char * key_word_list[] = {(char *)"left", (char *)"right", (char *)"bottom", (char *)"top", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:addCell", key_word_list, &param1, &param2, &param3, &param4))
        {
            int return_value = (local_this)->add_cell((float)param1, (float)param2, (float)param3, (float)param4);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MarginManager.addCell() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addCell(non-const MarginManager this, float left, float right, float bottom, float top)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MarginManager_add_cell_18_comment =
    "C++ Interface:\n"
    "addCell(non-const MarginManager this, float left, float right, float bottom, float top)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MarginManager::add_cell\n"
    "//       Access: Published\n"
    "//  Description: Adds a new cell to the list of available cells for\n"
    "//               popups.  The coordinates given define the rectangular\n"
    "//               region that defines the cell; the cell will be set up\n"
    "//               in a coordinate space that maps -1 .. 1 in the y\n"
    "//               dimension and -width .. width in the x dimension to\n"
    "//               the rectangle defined.\n"
    "//\n"
    "//               The return value is the index number associated with\n"
    "//               this cell, which may be passed to get_cell_available()\n"
    "//               or set_cell_available().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MarginManager_add_cell_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void MarginManager::set_cell_available(int cell_index, bool available)
 *******************************************************************/
static PyObject *Dtool_MarginManager_set_cell_available_19(PyObject *self, PyObject *args,PyObject *kwds) {
    MarginManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MarginManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void MarginManager::set_cell_available(int cell_index, bool available)
        int param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"cell_index", (char *)"available", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setCellAvailable", key_word_list, &param1, &param2))
        {
            (local_this)->set_cell_available((int)param1, (PyObject_IsTrue(param2)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call MarginManager.setCellAvailable() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCellAvailable(non-const MarginManager this, int cell_index, bool available)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MarginManager_set_cell_available_19_comment =
    "C++ Interface:\n"
    "setCellAvailable(non-const MarginManager this, int cell_index, bool available)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MarginManager::set_cell_available\n"
    "//       Access: Published\n"
    "//  Description: Sets whether the indicated cell may be used to\n"
    "//               display popups.  See get_cell_available().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MarginManager_set_cell_available_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool MarginManager::get_cell_available(int cell_index) const
 *******************************************************************/
static PyObject *Dtool_MarginManager_get_cell_available_20(PyObject *self, PyObject *args,PyObject *kwds) {
    MarginManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_MarginManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool MarginManager::get_cell_available(int cell_index) const
        int param1;
        static char * key_word_list[] = {(char *)"cell_index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getCellAvailable", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getCellAvailable", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const MarginManager*)local_this)->get_cell_available((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCellAvailable(const MarginManager this, int cell_index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MarginManager_get_cell_available_20_comment =
    "C++ Interface:\n"
    "getCellAvailable(const MarginManager this, int cell_index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: MarginManager::get_cell_available\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the indicated cell number is\n"
    "//               currently available, false if not.  If the cell is\n"
    "//               available, it may be used to display popups; otherwise,\n"
    "//               it must remain empty.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_MarginManager_get_cell_available_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle MarginManager::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_MarginManager_get_class_type_21(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle MarginManager::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = MarginManager::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MarginManager_get_class_type_21_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_MarginManager_get_class_type_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * MarginManager::MarginManager(void)
 *******************************************************************/
int  Dtool_Init_MarginManager(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-MarginManager::MarginManager(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":MarginManager", key_word_list))
        {
            MarginManager *return_value = new MarginManager();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_MarginManager,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "MarginManager()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_MarginManager(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_MarginManager)
    {
        printf("MarginManager ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    MarginManager * local_this = (MarginManager *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_MarginManager)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_MarginManager(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_MarginManager)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (MarginManager*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (MarginManager*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (MarginManager*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (MarginManager*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Nametag 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void Nametag::set_contents(int flags)
 *******************************************************************/
static PyObject *Dtool_Nametag_set_contents_28(PyObject *self, PyObject *args,PyObject *kwds) {
    Nametag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Nametag,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Nametag::set_contents(int flags)
        int param1;
        static char * key_word_list[] = {(char *)"flags", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setContents", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setContents", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_contents((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Nametag.setContents() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setContents(non-const Nametag this, int flags)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Nametag_set_contents_28_comment =
    "C++ Interface:\n"
    "setContents(non-const Nametag this, int flags)\n"
    "\n"
    "// Filename: nametag.I\n"
    "// Created by:  drose (19Jul01)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Nametag::set_contents\n"
    "//       Access: Published\n"
    "//  Description: Changes the bitmask that indicates the set of\n"
    "//               contents the Nametag may represent.  This is the\n"
    "//               union of all the bits corresponding to name, speech,\n"
    "//               or thoughts, that may be displayed in the Nametag.\n"
    "//               Set it to 0 to disable the Nametag altogether.\n"
    "//\n"
    "//               This mask is defined both for NametagGroup as well as\n"
    "//               for the individual Nametags within the group; the\n"
    "//               actual mask in effect for a particular Nametag is the\n"
    "//               intersection of the two masks.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Nametag_set_contents_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int Nametag::get_contents(void) const
 *******************************************************************/
static PyObject *Dtool_Nametag_get_contents_29(PyObject *self, PyObject *args,PyObject *kwds) {
    Nametag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Nametag,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int Nametag::get_contents(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getContents", key_word_list));
        else
            (PyArg_Parse(args, ":getContents"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const Nametag*)local_this)->get_contents();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getContents(const Nametag this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Nametag_get_contents_29_comment =
    "C++ Interface:\n"
    "getContents(const Nametag this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Nametag::get_contents\n"
    "//       Access: Published\n"
    "//  Description: Returns the bitmask that indicates the set of\n"
    "//               contents the Nametag may represent.  See\n"
    "//               set_contents().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Nametag_get_contents_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Nametag::set_active(bool active)
 *******************************************************************/
static PyObject *Dtool_Nametag_set_active_30(PyObject *self, PyObject *args,PyObject *kwds) {
    Nametag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Nametag,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Nametag::set_active(bool active)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"active", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setActive", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setActive", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_active((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Nametag.setActive() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setActive(non-const Nametag this, bool active)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Nametag_set_active_30_comment =
    "C++ Interface:\n"
    "setActive(non-const Nametag this, bool active)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Nametag::set_active\n"
    "//       Access: Published\n"
    "//  Description: Changes the active flag.  When the Nametag is active,\n"
    "//               it can be clicked on; when it is not active, it\n"
    "//               cannot be clicked on.  The active flag may be set\n"
    "//               either on the individual Nametag, or on the entire\n"
    "//               group.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Nametag_set_active_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Nametag::is_active(void) const
 *******************************************************************/
static PyObject *Dtool_Nametag_is_active_31(PyObject *self, PyObject *args,PyObject *kwds) {
    Nametag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Nametag,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool Nametag::is_active(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isActive", key_word_list));
        else
            (PyArg_Parse(args, ":isActive"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Nametag*)local_this)->is_active();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isActive(const Nametag this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Nametag_is_active_31_comment =
    "C++ Interface:\n"
    "isActive(const Nametag this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Nametag::is_active\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Nametag_is_active_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Nametag::display_as_active(void) const
 *******************************************************************/
static PyObject *Dtool_Nametag_display_as_active_32(PyObject *self, PyObject *args,PyObject *kwds) {
    Nametag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Nametag,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool Nametag::display_as_active(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":displayAsActive", key_word_list));
        else
            (PyArg_Parse(args, ":displayAsActive"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Nametag*)local_this)->display_as_active();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "displayAsActive(const Nametag this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Nametag_display_as_active_32_comment =
    "C++ Interface:\n"
    "displayAsActive(const Nametag this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Nametag::display_as_active\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the nametag is effectively active,\n"
    "//               false otherwise.  This includes all the things that\n"
    "//               affect nametags, including whether it has been\n"
    "//               explicitly set inactive, whether global nametags have\n"
    "//               been set inactive, and whether the group has a page\n"
    "//               button.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Nametag_display_as_active_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool Nametag::has_group(void) const
 *******************************************************************/
static PyObject *Dtool_Nametag_has_group_33(PyObject *self, PyObject *args,PyObject *kwds) {
    Nametag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Nametag,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool Nametag::has_group(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasGroup", key_word_list));
        else
            (PyArg_Parse(args, ":hasGroup"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Nametag*)local_this)->has_group();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasGroup(const Nametag this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Nametag_has_group_33_comment =
    "C++ Interface:\n"
    "hasGroup(const Nametag this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Nametag::has_group\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the Nametag is associated with a\n"
    "//               NametagGroup, false otherwise.  A Nametag must be\n"
    "//               associated with a group to be useful.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Nametag_has_group_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NametagGroup *Nametag::get_group(void) const
 *******************************************************************/
static PyObject *Dtool_Nametag_get_group_34(PyObject *self, PyObject *args,PyObject *kwds) {
    Nametag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Nametag,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NametagGroup *Nametag::get_group(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getGroup", key_word_list));
        else
            (PyArg_Parse(args, ":getGroup"));
        if(!PyErr_Occurred())
        {
            NametagGroup *return_value = ((const Nametag*)local_this)->get_group();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NametagGroup,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGroup(const Nametag this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Nametag_get_group_34_comment =
    "C++ Interface:\n"
    "getGroup(const Nametag this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Nametag::get_group\n"
    "//       Access: Published\n"
    "//  Description: Returns the NametagGroup that the Nametag is\n"
    "//               associated with, or NULL if it is not associated with\n"
    "//               any group.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Nametag_get_group_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Nametag::set_draw_order(int draw_order)
 *******************************************************************/
static PyObject *Dtool_Nametag_set_draw_order_35(PyObject *self, PyObject *args,PyObject *kwds) {
    Nametag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Nametag,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Nametag::set_draw_order(int draw_order)
        int param1;
        static char * key_word_list[] = {(char *)"draw_order", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setDrawOrder", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setDrawOrder", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_draw_order((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Nametag.setDrawOrder() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDrawOrder(non-const Nametag this, int draw_order)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Nametag_set_draw_order_35_comment =
    "C++ Interface:\n"
    "setDrawOrder(non-const Nametag this, int draw_order)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Nametag::set_draw_order\n"
    "//       Access: Published\n"
    "//  Description: Causes the Nametag to be rendered in the fixed bin\n"
    "//               with the indicated sort order.  This is only relevant\n"
    "//               if the Nametag will be parented in a scene graph\n"
    "//               where the cull traversal is in effect.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Nametag_set_draw_order_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Nametag::clear_draw_order(void)
 *******************************************************************/
static PyObject *Dtool_Nametag_clear_draw_order_36(PyObject *self, PyObject *args,PyObject *kwds) {
    Nametag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Nametag,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Nametag::clear_draw_order(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearDrawOrder", key_word_list));
        else
            (PyArg_Parse(args, ":clearDrawOrder"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_draw_order();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Nametag.clearDrawOrder() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearDrawOrder(non-const Nametag this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Nametag_clear_draw_order_36_comment =
    "C++ Interface:\n"
    "clearDrawOrder(non-const Nametag this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Nametag::clear_draw_order\n"
    "//       Access: Published\n"
    "//  Description: Removes the sort order previously specified with\n"
    "//               set_draw_order().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Nametag_clear_draw_order_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Nametag::set_chat_wordwrap(float wordwrap)
 *******************************************************************/
static PyObject *Dtool_Nametag_set_chat_wordwrap_37(PyObject *self, PyObject *args,PyObject *kwds) {
    Nametag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Nametag,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Nametag::set_chat_wordwrap(float wordwrap)
        double param1;
        static char * key_word_list[] = {(char *)"wordwrap", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setChatWordwrap", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setChatWordwrap", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_chat_wordwrap((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Nametag.setChatWordwrap() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setChatWordwrap(non-const Nametag this, float wordwrap)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Nametag_set_chat_wordwrap_37_comment =
    "C++ Interface:\n"
    "setChatWordwrap(non-const Nametag this, float wordwrap)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Nametag::set_chat_wordwrap\n"
    "//       Access: Published\n"
    "//  Description: Specifies the width at which the Nametag will\n"
    "//               wordwrap the text in its chat balloons.  For\n"
    "//               Nametag2d type nametags, this will indirectly affect\n"
    "//               the scale of the text, since the text will be scaled\n"
    "//               so that this width fills the cell it is assigned to.\n"
    "//               For in-the-world type nametags, this only affects how\n"
    "//               wide the chat balloon is allowed to be.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Nametag_set_chat_wordwrap_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float Nametag::get_chat_wordwrap(void) const
 *******************************************************************/
static PyObject *Dtool_Nametag_get_chat_wordwrap_38(PyObject *self, PyObject *args,PyObject *kwds) {
    Nametag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Nametag,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float Nametag::get_chat_wordwrap(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getChatWordwrap", key_word_list));
        else
            (PyArg_Parse(args, ":getChatWordwrap"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const Nametag*)local_this)->get_chat_wordwrap();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getChatWordwrap(const Nametag this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Nametag_get_chat_wordwrap_38_comment =
    "C++ Interface:\n"
    "getChatWordwrap(const Nametag this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Nametag::get_chat_wordwrap\n"
    "//       Access: Published\n"
    "//  Description: Returns the width at which the Nametag will\n"
    "//               wordwrap the text in its chat balloons.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Nametag_get_chat_wordwrap_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Nametag::set_avatar(NodePath const &node)
 *******************************************************************/
static PyObject *Dtool_Nametag_set_avatar_39(PyObject *self, PyObject *args,PyObject *kwds) {
    Nametag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Nametag,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void Nametag::set_avatar(NodePath const &node)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAvatar", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setAvatar", &param1));
            if(!PyErr_Occurred())
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "Nametag.setAvatar", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_avatar(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Nametag.setAvatar() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAvatar(non-const Nametag this, const NodePath node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Nametag_set_avatar_39_comment =
    "C++ Interface:\n"
    "setAvatar(non-const Nametag this, const NodePath node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Nametag::set_avatar\n"
    "//       Access: Published\n"
    "//  Description: Specifies the particular node that represents the\n"
    "//               Avatar for this Nametag.  The default if this is\n"
    "//               unset is the node specified to the NametagGroup that\n"
    "//               owns this Nametag.  The user is responsible for\n"
    "//               ensuring that this node does not get deleted during\n"
    "//               the lifetime of the Nametag.\n"
    "//\n"
    "//               This is generally a node that the Nametag is parented\n"
    "//               to, representing the position of the avatar.\n"
    "//               Normally, this is the avatar itself, but certain\n"
    "//               specialty Nametags may be parented to other nodes\n"
    "//               that represent the avatar (for instance, a head).\n"
    "//\n"
    "//               This should be some node in the 3-d scene graph,\n"
    "//               never a node in the 2-d graph.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Nametag_set_avatar_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Nametag::clear_avatar(void)
 *******************************************************************/
static PyObject *Dtool_Nametag_clear_avatar_40(PyObject *self, PyObject *args,PyObject *kwds) {
    Nametag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Nametag,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Nametag::clear_avatar(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearAvatar", key_word_list));
        else
            (PyArg_Parse(args, ":clearAvatar"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_avatar();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Nametag.clearAvatar() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearAvatar(non-const Nametag this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Nametag_clear_avatar_40_comment =
    "C++ Interface:\n"
    "clearAvatar(non-const Nametag this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Nametag::clear_avatar\n"
    "//       Access: Published\n"
    "//  Description: Removes the node previously specified with\n"
    "//               set_avatar(), and allows the node specified by\n"
    "//               NametagGroup::set_avatar() to apply.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Nametag_clear_avatar_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NodePath const &Nametag::get_avatar(void) const
 *******************************************************************/
static PyObject *Dtool_Nametag_get_avatar_41(PyObject *self, PyObject *args,PyObject *kwds) {
    Nametag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Nametag,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-NodePath const &Nametag::get_avatar(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAvatar", key_word_list));
        else
            (PyArg_Parse(args, ":getAvatar"));
        if(!PyErr_Occurred())
        {
            NodePath const *return_value = &(((const Nametag*)local_this)->get_avatar());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAvatar(const Nametag this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Nametag_get_avatar_41_comment =
    "C++ Interface:\n"
    "getAvatar(const Nametag this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Nametag::get_avatar\n"
    "//       Access: Published\n"
    "//  Description: Returns the node that represents the Avatar for this\n"
    "//               Nametag.  This is either the node set by\n"
    "//               set_avatar() on this nametag, or if no node was\n"
    "//               set, the one specified by set_avatar() on this\n"
    "//               nametag's group.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Nametag_get_avatar_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle Nametag::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_Nametag_get_class_type_42(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle Nametag::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = Nametag::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Nametag_get_class_type_42_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_Nametag_get_class_type_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual TypeHandle Nametag::get_type(void) const
 *******************************************************************/
static PyObject *Dtool_Nametag_get_type_43(PyObject *self, PyObject *args,PyObject *kwds) {
    Nametag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Nametag,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual TypeHandle Nametag::get_type(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getType", key_word_list));
        else
            (PyArg_Parse(args, ":getType"));
        if(!PyErr_Occurred())
        {
            TypeHandle result = ((const Nametag*)local_this)->get_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getType(const Nametag this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Nametag_get_type_43_comment =
    "C++ Interface:\n"
    "getType(const Nametag this)\n"
    "\n"
    "// We define get_type() even though we don't inherit from\n"
    "// TypedObject.  We can't actually inherit from TypedObject because\n"
    "// of the whole multiple-inheritance thing in our derived classes.\n"
    "";
#else
static const char * Dtool_Nametag_get_type_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ReferenceCount *Nametag::upcast_to_ReferenceCount(void)
 *******************************************************************/
static PyObject *Dtool_Nametag_upcast_to_ReferenceCount_23(PyObject *self, PyObject *args,PyObject *kwds) {
    Nametag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Nametag,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-ReferenceCount *Nametag::upcast_to_ReferenceCount(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToReferenceCount", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToReferenceCount"));
        if(!PyErr_Occurred())
        {
            ReferenceCount *return_value = (ReferenceCount *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ReferenceCount,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Nametag.upcastToReferenceCount() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToReferenceCount(non-const Nametag this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Nametag_upcast_to_ReferenceCount_23_comment =
    "C++ Interface:\n"
    "upcastToReferenceCount(non-const Nametag this)\n"
    "\n"
    "upcast from Nametag to ReferenceCount\n"
    "";
#else
static const char * Dtool_Nametag_upcast_to_ReferenceCount_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ClickablePopup *Nametag::upcast_to_ClickablePopup(void)
 *******************************************************************/
static PyObject *Dtool_Nametag_upcast_to_ClickablePopup_24(PyObject *self, PyObject *args,PyObject *kwds) {
    Nametag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Nametag,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-ClickablePopup *Nametag::upcast_to_ClickablePopup(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToClickablePopup", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToClickablePopup"));
        if(!PyErr_Occurred())
        {
            ClickablePopup *return_value = (ClickablePopup *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ClickablePopup,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Nametag.upcastToClickablePopup() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToClickablePopup(non-const Nametag this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Nametag_upcast_to_ClickablePopup_24_comment =
    "C++ Interface:\n"
    "upcastToClickablePopup(non-const Nametag this)\n"
    "\n"
    "upcast from Nametag to ClickablePopup\n"
    "";
#else
static const char * Dtool_Nametag_upcast_to_ClickablePopup_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Nametag2d *Nametag::downcast_to_Nametag2d(void)
 *******************************************************************/
static PyObject *Dtool_Nametag_downcast_to_Nametag2d_46(PyObject *self, PyObject *args,PyObject *kwds) {
    Nametag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Nametag,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-Nametag2d *Nametag::downcast_to_Nametag2d(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToNametag2d", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToNametag2d"));
        if(!PyErr_Occurred())
        {
            Nametag2d *return_value = (Nametag2d *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Nametag2d,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Nametag.downcastToNametag2d() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToNametag2d(non-const Nametag this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Nametag_downcast_to_Nametag2d_46_comment =
    "C++ Interface:\n"
    "downcastToNametag2d(non-const Nametag this)\n"
    "\n"
    "downcast from Nametag to Nametag2d\n"
    "";
#else
static const char * Dtool_Nametag_downcast_to_Nametag2d_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Nametag3d *Nametag::downcast_to_Nametag3d(void)
 *******************************************************************/
static PyObject *Dtool_Nametag_downcast_to_Nametag3d_53(PyObject *self, PyObject *args,PyObject *kwds) {
    Nametag * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Nametag,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-Nametag3d *Nametag::downcast_to_Nametag3d(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToNametag3d", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToNametag3d"));
        if(!PyErr_Occurred())
        {
            Nametag3d *return_value = (Nametag3d *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Nametag3d,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Nametag.downcastToNametag3d() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToNametag3d(non-const Nametag this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Nametag_downcast_to_Nametag3d_53_comment =
    "C++ Interface:\n"
    "downcastToNametag3d(non-const Nametag this)\n"
    "\n"
    "downcast from Nametag to Nametag3d\n"
    "";
#else
static const char * Dtool_Nametag_downcast_to_Nametag3d_53_comment = NULL;
#endif

int  Dtool_Init_Nametag(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (Nametag)");
       return -1;
}
inline void  * Dtool_UpcastInterface_Nametag(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Nametag)
    {
        printf("Nametag ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Nametag * local_this = (Nametag *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Nametag)
        return local_this;
    if(requested_type == &Dtool_ClickablePopup)
        return ( ClickablePopup *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Nametag(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Nametag)
        return from_this;
    if(from_type == &Dtool_ClickablePopup)
    {
          ClickablePopup* other_this = (ClickablePopup*)from_this;
          return (Nametag*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Nametag2d 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle Nametag2d::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_Nametag2d_get_class_type_50(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle Nametag2d::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = Nametag2d::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Nametag2d_get_class_type_50_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_Nametag2d_get_class_type_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Nametag *Nametag2d::upcast_to_Nametag(void)
 *******************************************************************/
static PyObject *Dtool_Nametag2d_upcast_to_Nametag_45(PyObject *self, PyObject *args,PyObject *kwds) {
    Nametag2d * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Nametag2d,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-Nametag *Nametag2d::upcast_to_Nametag(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToNametag", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToNametag"));
        if(!PyErr_Occurred())
        {
            Nametag *return_value = (Nametag *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Nametag,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Nametag2d.upcastToNametag() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToNametag(non-const Nametag2d this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Nametag2d_upcast_to_Nametag_45_comment =
    "C++ Interface:\n"
    "upcastToNametag(non-const Nametag2d this)\n"
    "\n"
    "upcast from Nametag2d to Nametag\n"
    "";
#else
static const char * Dtool_Nametag2d_upcast_to_Nametag_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * MarginPopup *Nametag2d::upcast_to_MarginPopup(void)
 *******************************************************************/
static PyObject *Dtool_Nametag2d_upcast_to_MarginPopup_47(PyObject *self, PyObject *args,PyObject *kwds) {
    Nametag2d * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Nametag2d,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-MarginPopup *Nametag2d::upcast_to_MarginPopup(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToMarginPopup", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToMarginPopup"));
        if(!PyErr_Occurred())
        {
            MarginPopup *return_value = (MarginPopup *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_MarginPopup,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Nametag2d.upcastToMarginPopup() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToMarginPopup(non-const Nametag2d this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Nametag2d_upcast_to_MarginPopup_47_comment =
    "C++ Interface:\n"
    "upcastToMarginPopup(non-const Nametag2d this)\n"
    "\n"
    "upcast from Nametag2d to MarginPopup\n"
    "";
#else
static const char * Dtool_Nametag2d_upcast_to_MarginPopup_47_comment = NULL;
#endif

int  Dtool_Init_Nametag2d(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (Nametag2d)");
       return -1;
}
inline void  * Dtool_UpcastInterface_Nametag2d(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Nametag2d)
    {
        printf("Nametag2d ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Nametag2d * local_this = (Nametag2d *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Nametag2d)
        return local_this;
    if(requested_type == &Dtool_ClickablePopup)
        return ( ClickablePopup *)( Nametag *) local_this;
    if(requested_type == &Dtool_MarginPopup)
        return ( MarginPopup *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( MarginPopup *) local_this;
    if(requested_type == &Dtool_Nametag)
        return ( Nametag *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( MarginPopup *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( Nametag *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( MarginPopup *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( MarginPopup *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Nametag2d(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Nametag2d)
        return from_this;
    if(from_type == &Dtool_ClickablePopup)
    {
          ClickablePopup* other_this = (ClickablePopup*)from_this;
          return (Nametag2d*)other_this;
    }
    if(from_type == &Dtool_MarginPopup)
    {
          MarginPopup* other_this = (MarginPopup*)from_this;
          return (Nametag2d*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (Nametag2d*)other_this;
    }
    if(from_type == &Dtool_Nametag)
    {
          Nametag* other_this = (Nametag*)from_this;
          return (Nametag2d*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (Nametag2d*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (Nametag2d*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (Nametag2d*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Nametag3d 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void Nametag3d::set_billboard_offset(float billboard_offset)
 *******************************************************************/
static PyObject *Dtool_Nametag3d_set_billboard_offset_57(PyObject *self, PyObject *args,PyObject *kwds) {
    Nametag3d * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Nametag3d,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Nametag3d::set_billboard_offset(float billboard_offset)
        double param1;
        static char * key_word_list[] = {(char *)"billboard_offset", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setBillboardOffset", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setBillboardOffset", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_billboard_offset((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Nametag3d.setBillboardOffset() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBillboardOffset(non-const Nametag3d this, float billboard_offset)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Nametag3d_set_billboard_offset_57_comment =
    "C++ Interface:\n"
    "setBillboardOffset(non-const Nametag3d this, float billboard_offset)\n"
    "\n"
    "// Filename: nametag3d.I\n"
    "// Created by:  drose (19Jul01)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Nametag3d::set_billboard_offset\n"
    "//       Access: Published\n"
    "//  Description: Sets the offset distance by which the Nametag is slid\n"
    "//               towards the camera after billboarding.  This is used\n"
    "//               to help the Nametag not be obscured by the avatar.\n"
    "//\n"
    "//               The default value is set in NametagGlobals, but this\n"
    "//               may be overridden at runtime.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Nametag3d_set_billboard_offset_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float Nametag3d::get_billboard_offset(void) const
 *******************************************************************/
static PyObject *Dtool_Nametag3d_get_billboard_offset_58(PyObject *self, PyObject *args,PyObject *kwds) {
    Nametag3d * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Nametag3d,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float Nametag3d::get_billboard_offset(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBillboardOffset", key_word_list));
        else
            (PyArg_Parse(args, ":getBillboardOffset"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const Nametag3d*)local_this)->get_billboard_offset();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBillboardOffset(const Nametag3d this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Nametag3d_get_billboard_offset_58_comment =
    "C++ Interface:\n"
    "getBillboardOffset(const Nametag3d this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: Nametag3d::get_billboard_offset\n"
    "//       Access: Published\n"
    "//  Description: Returns the offset distance by which the Nametag is\n"
    "//               slid towards the camera after billboarding.  See\n"
    "//               set_billboard_offset().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Nametag3d_get_billboard_offset_58_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle Nametag3d::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_Nametag3d_get_class_type_59(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle Nametag3d::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = Nametag3d::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Nametag3d_get_class_type_59_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_Nametag3d_get_class_type_59_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Nametag *Nametag3d::upcast_to_Nametag(void)
 *******************************************************************/
static PyObject *Dtool_Nametag3d_upcast_to_Nametag_52(PyObject *self, PyObject *args,PyObject *kwds) {
    Nametag3d * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Nametag3d,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-Nametag *Nametag3d::upcast_to_Nametag(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToNametag", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToNametag"));
        if(!PyErr_Occurred())
        {
            Nametag *return_value = (Nametag *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Nametag,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Nametag3d.upcastToNametag() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToNametag(non-const Nametag3d this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Nametag3d_upcast_to_Nametag_52_comment =
    "C++ Interface:\n"
    "upcastToNametag(non-const Nametag3d this)\n"
    "\n"
    "upcast from Nametag3d to Nametag\n"
    "";
#else
static const char * Dtool_Nametag3d_upcast_to_Nametag_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PandaNode *Nametag3d::upcast_to_PandaNode(void)
 *******************************************************************/
static PyObject *Dtool_Nametag3d_upcast_to_PandaNode_54(PyObject *self, PyObject *args,PyObject *kwds) {
    Nametag3d * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Nametag3d,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-PandaNode *Nametag3d::upcast_to_PandaNode(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToPandaNode", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToPandaNode"));
        if(!PyErr_Occurred())
        {
            PandaNode *return_value = (PandaNode *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PandaNode,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Nametag3d.upcastToPandaNode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToPandaNode(non-const Nametag3d this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Nametag3d_upcast_to_PandaNode_54_comment =
    "C++ Interface:\n"
    "upcastToPandaNode(non-const Nametag3d this)\n"
    "\n"
    "upcast from Nametag3d to PandaNode\n"
    "";
#else
static const char * Dtool_Nametag3d_upcast_to_PandaNode_54_comment = NULL;
#endif

int  Dtool_Init_Nametag3d(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (Nametag3d)");
       return -1;
}
inline void  * Dtool_UpcastInterface_Nametag3d(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Nametag3d)
    {
        printf("Nametag3d ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Nametag3d * local_this = (Nametag3d *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Nametag3d)
        return local_this;
    if(requested_type == &Dtool_ClickablePopup)
        return ( ClickablePopup *)( Nametag *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_Nametag)
        return ( Nametag *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( Nametag *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Nametag3d(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Nametag3d)
        return from_this;
    if(from_type == &Dtool_ClickablePopup)
    {
          ClickablePopup* other_this = (ClickablePopup*)from_this;
          return (Nametag3d*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (Nametag3d*)other_this;
    }
    if(from_type == &Dtool_Nametag)
    {
          Nametag* other_this = (Nametag*)from_this;
          return (Nametag3d*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (Nametag3d*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (Nametag3d*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (Nametag3d*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. NametagFloat2d 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle NametagFloat2d::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_NametagFloat2d_get_class_type_62(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle NametagFloat2d::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = NametagFloat2d::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagFloat2d_get_class_type_62_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_NametagFloat2d_get_class_type_62_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NametagFloat2d::NametagFloat2d(void)
 *******************************************************************/
int  Dtool_Init_NametagFloat2d(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-NametagFloat2d::NametagFloat2d(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":NametagFloat2d", key_word_list))
        {
            NametagFloat2d *return_value = new NametagFloat2d();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_NametagFloat2d,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "NametagFloat2d()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_NametagFloat2d(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_NametagFloat2d)
    {
        printf("NametagFloat2d ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    NametagFloat2d * local_this = (NametagFloat2d *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_NametagFloat2d)
        return local_this;
    if(requested_type == &Dtool_ClickablePopup)
        return ( ClickablePopup *)( Nametag *)( Nametag3d *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( Nametag3d *) local_this;
    if(requested_type == &Dtool_Nametag)
        return ( Nametag *)( Nametag3d *) local_this;
    if(requested_type == &Dtool_Nametag3d)
        return ( Nametag3d *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( Nametag3d *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( Nametag *)( Nametag3d *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( Nametag3d *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( Nametag3d *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_NametagFloat2d(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_NametagFloat2d)
        return from_this;
    if(from_type == &Dtool_ClickablePopup)
    {
          ClickablePopup* other_this = (ClickablePopup*)from_this;
          return (NametagFloat2d*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (NametagFloat2d*)other_this;
    }
    if(from_type == &Dtool_Nametag)
    {
          Nametag* other_this = (Nametag*)from_this;
          return (NametagFloat2d*)other_this;
    }
    if(from_type == &Dtool_Nametag3d)
    {
          Nametag3d* other_this = (Nametag3d*)from_this;
          return (NametagFloat2d*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (NametagFloat2d*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (NametagFloat2d*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (NametagFloat2d*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. NametagFloat3d 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle NametagFloat3d::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_NametagFloat3d_get_class_type_65(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle NametagFloat3d::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = NametagFloat3d::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagFloat3d_get_class_type_65_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_NametagFloat3d_get_class_type_65_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NametagFloat3d::NametagFloat3d(void)
 *******************************************************************/
int  Dtool_Init_NametagFloat3d(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-NametagFloat3d::NametagFloat3d(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":NametagFloat3d", key_word_list))
        {
            NametagFloat3d *return_value = new NametagFloat3d();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_NametagFloat3d,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "NametagFloat3d()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_NametagFloat3d(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_NametagFloat3d)
    {
        printf("NametagFloat3d ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    NametagFloat3d * local_this = (NametagFloat3d *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_NametagFloat3d)
        return local_this;
    if(requested_type == &Dtool_ClickablePopup)
        return ( ClickablePopup *)( Nametag *)( Nametag3d *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( Nametag3d *) local_this;
    if(requested_type == &Dtool_Nametag)
        return ( Nametag *)( Nametag3d *) local_this;
    if(requested_type == &Dtool_Nametag3d)
        return ( Nametag3d *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( Nametag3d *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( Nametag *)( Nametag3d *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( Nametag3d *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( Nametag3d *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_NametagFloat3d(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_NametagFloat3d)
        return from_this;
    if(from_type == &Dtool_ClickablePopup)
    {
          ClickablePopup* other_this = (ClickablePopup*)from_this;
          return (NametagFloat3d*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (NametagFloat3d*)other_this;
    }
    if(from_type == &Dtool_Nametag)
    {
          Nametag* other_this = (Nametag*)from_this;
          return (NametagFloat3d*)other_this;
    }
    if(from_type == &Dtool_Nametag3d)
    {
          Nametag3d* other_this = (Nametag3d*)from_this;
          return (NametagFloat3d*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (NametagFloat3d*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (NametagFloat3d*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (NametagFloat3d*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. NametagGroup 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline Nametag2d *NametagGroup::get_nametag2d(void)
 *******************************************************************/
static PyObject *Dtool_NametagGroup_get_nametag2d_70(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline Nametag2d *NametagGroup::get_nametag2d(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNametag2d", key_word_list));
        else
            (PyArg_Parse(args, ":getNametag2d"));
        if(!PyErr_Occurred())
        {
            Nametag2d *return_value = (local_this)->get_nametag2d();
            if (return_value != (Nametag2d *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Nametag2d,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NametagGroup.getNametag2d() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNametag2d(non-const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_get_nametag2d_70_comment =
    "C++ Interface:\n"
    "getNametag2d(non-const NametagGroup this)\n"
    "\n"
    "// Filename: nametagGroup.I\n"
    "// Created by:  drose (19Jul01)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::get_nametag2d\n"
    "//       Access: Published\n"
    "//  Description: Returns the default Nametag2d object associated with\n"
    "//               the group.  This is the Nametag that is displayed\n"
    "//               along the edge of the screen when the avatar is not\n"
    "//               visible.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_get_nametag2d_70_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Nametag3d *NametagGroup::get_nametag3d(void)
 *******************************************************************/
static PyObject *Dtool_NametagGroup_get_nametag3d_71(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline Nametag3d *NametagGroup::get_nametag3d(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNametag3d", key_word_list));
        else
            (PyArg_Parse(args, ":getNametag3d"));
        if(!PyErr_Occurred())
        {
            Nametag3d *return_value = (local_this)->get_nametag3d();
            if (return_value != (Nametag3d *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Nametag3d,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NametagGroup.getNametag3d() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNametag3d(non-const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_get_nametag3d_71_comment =
    "C++ Interface:\n"
    "getNametag3d(non-const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::get_nametag3d\n"
    "//       Access: Published\n"
    "//  Description: Returns the default Nametag3d object associated with\n"
    "//               the group.  This is the Nametag that floats over the\n"
    "//               avatar's head in the world.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_get_nametag3d_71_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NametagGroup::add_nametag(Nametag *tag)
 *******************************************************************/
static PyObject *Dtool_NametagGroup_add_nametag_72(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void NametagGroup::add_nametag(Nametag *tag)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"tag", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addNametag", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addNametag", &param1));
            if(!PyErr_Occurred())
            {
                Nametag *param1_this = (Nametag *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Nametag, 1, "NametagGroup.addNametag", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_nametag(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call NametagGroup.addNametag() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addNametag(non-const NametagGroup this, non-const Nametag tag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_add_nametag_72_comment =
    "C++ Interface:\n"
    "addNametag(non-const NametagGroup this, non-const Nametag tag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::add_nametag\n"
    "//       Access: Published\n"
    "//  Description: Adds the indicated Nametag to the group.  The Nametag\n"
    "//               must not already be a member of any NametagGroup.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_add_nametag_72_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NametagGroup::remove_nametag(Nametag *tag)
 *******************************************************************/
static PyObject *Dtool_NametagGroup_remove_nametag_73(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void NametagGroup::remove_nametag(Nametag *tag)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"tag", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeNametag", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeNametag", &param1));
            if(!PyErr_Occurred())
            {
                Nametag *param1_this = (Nametag *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Nametag, 1, "NametagGroup.removeNametag", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->remove_nametag(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call NametagGroup.removeNametag() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeNametag(non-const NametagGroup this, non-const Nametag tag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_remove_nametag_73_comment =
    "C++ Interface:\n"
    "removeNametag(non-const NametagGroup this, non-const Nametag tag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::remove_nametag\n"
    "//       Access: Published\n"
    "//  Description: Removes the indicated Nametag to the group.  The\n"
    "//               Nametag must have previously been added to the\n"
    "//               NametagGroup.  It is an error to attempt to remove\n"
    "//               either of the two default nametags created with the\n"
    "//               group.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_remove_nametag_73_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NametagGroup::clear_aux_nametags(void)
 *******************************************************************/
static PyObject *Dtool_NametagGroup_clear_aux_nametags_74(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void NametagGroup::clear_aux_nametags(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearAuxNametags", key_word_list));
        else
            (PyArg_Parse(args, ":clearAuxNametags"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_aux_nametags();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NametagGroup.clearAuxNametags() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearAuxNametags(non-const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_clear_aux_nametags_74_comment =
    "C++ Interface:\n"
    "clearAuxNametags(non-const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::clear_aux_nametags\n"
    "//       Access: Published\n"
    "//  Description: Removes any Nametags from the group except the\n"
    "//               default Nametag2d and Nametag3d that are created with\n"
    "//               the group itself.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_clear_aux_nametags_74_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int NametagGroup::get_num_nametags(void) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_get_num_nametags_75(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int NametagGroup::get_num_nametags(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumNametags", key_word_list));
        else
            (PyArg_Parse(args, ":getNumNametags"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NametagGroup*)local_this)->get_num_nametags();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumNametags(const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_get_num_nametags_75_comment =
    "C++ Interface:\n"
    "getNumNametags(const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::get_num_nametags\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of Nametags in to the group.\n"
    "//               Originally, this is 2, but there may be more added by\n"
    "//               user control.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_get_num_nametags_75_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Nametag *NametagGroup::get_nametag(int n) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_get_nametag_76(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-Nametag *NametagGroup::get_nametag(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getNametag", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getNametag", &param1));
        if(!PyErr_Occurred())
        {
            Nametag *return_value = ((const NametagGroup*)local_this)->get_nametag((int)param1);
            if (return_value != (Nametag *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Nametag,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNametag(const NametagGroup this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_get_nametag_76_comment =
    "C++ Interface:\n"
    "getNametag(const NametagGroup this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::get_nametag\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth Nametag in the group.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_get_nametag_76_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void NametagGroup::set_font(TextFont *font)
 *******************************************************************/
static PyObject *Dtool_NametagGroup_set_font_77(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void NametagGroup::set_font(TextFont *font)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"font", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFont", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setFont", &param1));
            if(!PyErr_Occurred())
            {
                TextFont *param1_this = (TextFont *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TextFont, 1, "NametagGroup.setFont", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_font(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call NametagGroup.setFont() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFont(non-const NametagGroup this, non-const TextFont font)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_set_font_77_comment =
    "C++ Interface:\n"
    "setFont(non-const NametagGroup this, non-const TextFont font)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::set_font\n"
    "//       Access: Published\n"
    "//  Description: Simultaneously sets both the name font and the chat\n"
    "//               font.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_set_font_77_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void NametagGroup::set_name_font(TextFont *font)
 *******************************************************************/
static PyObject *Dtool_NametagGroup_set_name_font_78(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void NametagGroup::set_name_font(TextFont *font)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"font", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setNameFont", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setNameFont", &param1));
            if(!PyErr_Occurred())
            {
                TextFont *param1_this = (TextFont *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TextFont, 1, "NametagGroup.setNameFont", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_name_font(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call NametagGroup.setNameFont() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setNameFont(non-const NametagGroup this, non-const TextFont font)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_set_name_font_78_comment =
    "C++ Interface:\n"
    "setNameFont(non-const NametagGroup this, non-const TextFont font)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::set_name_font\n"
    "//       Access: Published\n"
    "//  Description: Redefines the TextFont used by this group to\n"
    "//               generate text for the names.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_set_name_font_78_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline TextFont *NametagGroup::get_name_font(void) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_get_name_font_79(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline TextFont *NametagGroup::get_name_font(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNameFont", key_word_list));
        else
            (PyArg_Parse(args, ":getNameFont"));
        if(!PyErr_Occurred())
        {
            TextFont *return_value = ((const NametagGroup*)local_this)->get_name_font();
            if (return_value != (TextFont *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TextFont,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNameFont(const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_get_name_font_79_comment =
    "C++ Interface:\n"
    "getNameFont(const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::set_name_font\n"
    "//       Access: Published\n"
    "//  Description: Returns the TextFont used by this group to\n"
    "//               generate text for the names.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_get_name_font_79_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void NametagGroup::set_chat_font(TextFont *font)
 *******************************************************************/
static PyObject *Dtool_NametagGroup_set_chat_font_80(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void NametagGroup::set_chat_font(TextFont *font)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"font", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setChatFont", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setChatFont", &param1));
            if(!PyErr_Occurred())
            {
                TextFont *param1_this = (TextFont *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TextFont, 1, "NametagGroup.setChatFont", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_chat_font(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call NametagGroup.setChatFont() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setChatFont(non-const NametagGroup this, non-const TextFont font)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_set_chat_font_80_comment =
    "C++ Interface:\n"
    "setChatFont(non-const NametagGroup this, non-const TextFont font)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::set_chat_font\n"
    "//       Access: Published\n"
    "//  Description: Redefines the TextFont used by this group to\n"
    "//               generate text for the chat messages.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_set_chat_font_80_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline TextFont *NametagGroup::get_chat_font(void) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_get_chat_font_81(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline TextFont *NametagGroup::get_chat_font(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getChatFont", key_word_list));
        else
            (PyArg_Parse(args, ":getChatFont"));
        if(!PyErr_Occurred())
        {
            TextFont *return_value = ((const NametagGroup*)local_this)->get_chat_font();
            if (return_value != (TextFont *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TextFont,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getChatFont(const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_get_chat_font_81_comment =
    "C++ Interface:\n"
    "getChatFont(const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::set_chat_font\n"
    "//       Access: Published\n"
    "//  Description: Returns the TextFont used by this group to\n"
    "//               generate text for the chat messages.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_get_chat_font_81_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void NametagGroup::set_avatar(NodePath const &node)
 *******************************************************************/
static PyObject *Dtool_NametagGroup_set_avatar_82(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void NametagGroup::set_avatar(NodePath const &node)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAvatar", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setAvatar", &param1));
            if(!PyErr_Occurred())
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "NametagGroup.setAvatar", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_avatar(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call NametagGroup.setAvatar() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAvatar(non-const NametagGroup this, const NodePath node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_set_avatar_82_comment =
    "C++ Interface:\n"
    "setAvatar(non-const NametagGroup this, const NodePath node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::set_avatar\n"
    "//       Access: Published\n"
    "//  Description: Sets the node that indicates the avatar that\n"
    "//               corresponds to this Nametag.  If this is non-NULL,\n"
    "//               the Nametag2d will take advantage of this to rotate\n"
    "//               the little arrow to face in the right direction.\n"
    "//\n"
    "//               It is the responsibility of the user to ensure that\n"
    "//               the avatar node does not destruct during the lifetime\n"
    "//               of the NametagGroup.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_set_avatar_82_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NodePath const &NametagGroup::get_avatar(void) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_get_avatar_83(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NodePath const &NametagGroup::get_avatar(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAvatar", key_word_list));
        else
            (PyArg_Parse(args, ":getAvatar"));
        if(!PyErr_Occurred())
        {
            NodePath const *return_value = &(((const NametagGroup*)local_this)->get_avatar());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAvatar(const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_get_avatar_83_comment =
    "C++ Interface:\n"
    "getAvatar(const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::get_avatar\n"
    "//       Access: Published\n"
    "//  Description: Returns the node that indicates the avatar that\n"
    "//               corresponds to this Nametag.  See set_avatar().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_get_avatar_83_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NodePath &NametagGroup::get_name_icon(void)
 *******************************************************************/
static PyObject *Dtool_NametagGroup_get_name_icon_84(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline NodePath &NametagGroup::get_name_icon(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNameIcon", key_word_list));
        else
            (PyArg_Parse(args, ":getNameIcon"));
        if(!PyErr_Occurred())
        {
            NodePath *return_value = &((local_this)->get_name_icon());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NametagGroup.getNameIcon() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNameIcon(non-const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_get_name_icon_84_comment =
    "C++ Interface:\n"
    "getNameIcon(non-const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::get_name_icon\n"
    "//       Access: Published\n"
    "//  Description: Returns a NodePath to which geometry may be parented\n"
    "//               to draw stuff behind the name (but in front of the\n"
    "//               name's background card).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_get_name_icon_84_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NametagGroup::set_name_wordwrap(float name_wordwrap)
 *******************************************************************/
static PyObject *Dtool_NametagGroup_set_name_wordwrap_85(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void NametagGroup::set_name_wordwrap(float name_wordwrap)
        double param1;
        static char * key_word_list[] = {(char *)"name_wordwrap", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setNameWordwrap", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setNameWordwrap", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_name_wordwrap((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NametagGroup.setNameWordwrap() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setNameWordwrap(non-const NametagGroup this, float name_wordwrap)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_set_name_wordwrap_85_comment =
    "C++ Interface:\n"
    "setNameWordwrap(non-const NametagGroup this, float name_wordwrap)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::set_name_wordwrap\n"
    "//       Access: Published\n"
    "//  Description: Specifies the point at which the name is wrapped; and\n"
    "//               indirectly, the scale of the font in the nametag\n"
    "//               (since the nametag text is scaled to fit its\n"
    "//               available space).\n"
    "//\n"
    "//               Set this to -1 to use the default wordwrap.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_set_name_wordwrap_85_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float NametagGroup::get_name_wordwrap(void) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_get_name_wordwrap_86(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-float NametagGroup::get_name_wordwrap(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNameWordwrap", key_word_list));
        else
            (PyArg_Parse(args, ":getNameWordwrap"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const NametagGroup*)local_this)->get_name_wordwrap();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNameWordwrap(const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_get_name_wordwrap_86_comment =
    "C++ Interface:\n"
    "getNameWordwrap(const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::get_name_wordwrap\n"
    "//       Access: Published\n"
    "//  Description: Returns either the value set by set_name_wordwrap(),\n"
    "//               or the default wordwrap value for nametags of this\n"
    "//               type.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_get_name_wordwrap_86_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NametagGroup::set_color_code(NametagGroup::ColorCode code)
 *******************************************************************/
static PyObject *Dtool_NametagGroup_set_color_code_87(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void NametagGroup::set_color_code(NametagGroup::ColorCode code)
        int param1;
        static char * key_word_list[] = {(char *)"code", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setColorCode", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setColorCode", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_color_code((NametagGroup::ColorCode)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NametagGroup.setColorCode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setColorCode(non-const NametagGroup this, int code)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_set_color_code_87_comment =
    "C++ Interface:\n"
    "setColorCode(non-const NametagGroup this, int code)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::set_color_code\n"
    "//       Access: Published\n"
    "//  Description: Sets the color code of this particular avatar.  This\n"
    "//               indicates which of a family of colors the nametag\n"
    "//               should be drawn in, according to the avatar's\n"
    "//               properties.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_set_color_code_87_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NametagGroup::ColorCode NametagGroup::get_color_code(void) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_get_color_code_88(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NametagGroup::ColorCode NametagGroup::get_color_code(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getColorCode", key_word_list));
        else
            (PyArg_Parse(args, ":getColorCode"));
        if(!PyErr_Occurred())
        {
            NametagGroup::ColorCode return_value = ((const NametagGroup*)local_this)->get_color_code();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getColorCode(const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_get_color_code_88_comment =
    "C++ Interface:\n"
    "getColorCode(const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::get_color_code\n"
    "//       Access: Published\n"
    "//  Description: Returns the color code set for this particular\n"
    "//               avatar.  See set_color_code().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_get_color_code_88_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void NametagGroup::set_qt_color(LVecBase4f const &color)
 *******************************************************************/
static PyObject *Dtool_NametagGroup_set_qt_color_89(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void NametagGroup::set_qt_color(LVecBase4f const &color)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"color", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setQtColor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setQtColor", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "NametagGroup.setQtColor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_qt_color(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call NametagGroup.setQtColor() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setQtColor(non-const NametagGroup this, const VBase4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_set_qt_color_89_comment =
    "C++ Interface:\n"
    "setQtColor(non-const NametagGroup this, const VBase4 color)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::set_qt_color\n"
    "//       Access: Published\n"
    "//  Description: Sets the background color for quicktalker (SpeedChat)\n"
    "//               messages from this avatar.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_set_qt_color_89_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &NametagGroup::get_qt_color(void) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_get_qt_color_90(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &NametagGroup::get_qt_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getQtColor", key_word_list));
        else
            (PyArg_Parse(args, ":getQtColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f const *return_value = &(((const NametagGroup*)local_this)->get_qt_color());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getQtColor(const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_get_qt_color_90_comment =
    "C++ Interface:\n"
    "getQtColor(const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::get_qt_color\n"
    "//       Access: Published\n"
    "//  Description: Returns the background color set for quicktalker\n"
    "//               (SpeedChat) messages from this avatar.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_get_qt_color_90_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &NametagGroup::get_balloon_modulation_color(void) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_get_balloon_modulation_color_91(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &NametagGroup::get_balloon_modulation_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBalloonModulationColor", key_word_list));
        else
            (PyArg_Parse(args, ":getBalloonModulationColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f const *return_value = &(((const NametagGroup*)local_this)->get_balloon_modulation_color());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBalloonModulationColor(const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_get_balloon_modulation_color_91_comment =
    "C++ Interface:\n"
    "getBalloonModulationColor(const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::get_balloon_modulation_color\n"
    "//       Access: Published\n"
    "//  Description: Returns the balloon modulation color.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_get_balloon_modulation_color_91_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void NametagGroup::set_shadow(float xoffset, float yoffset)
 *******************************************************************/
static PyObject *Dtool_NametagGroup_set_shadow_92(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void NametagGroup::set_shadow(float xoffset, float yoffset)
        double param1;
        double param2;
        static char * key_word_list[] = {(char *)"xoffset", (char *)"yoffset", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:setShadow", key_word_list, &param1, &param2))
        {
            (local_this)->set_shadow((float)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NametagGroup.setShadow() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setShadow(non-const NametagGroup this, float xoffset, float yoffset)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_set_shadow_92_comment =
    "C++ Interface:\n"
    "setShadow(non-const NametagGroup this, float xoffset, float yoffset)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::set_shadow\n"
    "//       Access: Published\n"
    "//  Description: Specifies that the name should be drawn with a\n"
    "//               shadow, by creating a second copy of the name and\n"
    "//               offsetting it slightly behind the first.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_set_shadow_92_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void NametagGroup::clear_shadow(void)
 *******************************************************************/
static PyObject *Dtool_NametagGroup_clear_shadow_93(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void NametagGroup::clear_shadow(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearShadow", key_word_list));
        else
            (PyArg_Parse(args, ":clearShadow"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_shadow();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NametagGroup.clearShadow() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearShadow(non-const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_clear_shadow_93_comment =
    "C++ Interface:\n"
    "clearShadow(non-const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::clear_shadow\n"
    "//       Access: Published\n"
    "//  Description: Specifies that a shadow will not be drawn behind the\n"
    "//               name.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_clear_shadow_93_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool NametagGroup::has_shadow(void) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_has_shadow_94(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool NametagGroup::has_shadow(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasShadow", key_word_list));
        else
            (PyArg_Parse(args, ":hasShadow"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const NametagGroup*)local_this)->has_shadow();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasShadow(const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_has_shadow_94_comment =
    "C++ Interface:\n"
    "hasShadow(const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::has_shadow\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_has_shadow_94_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase2f NametagGroup::get_shadow(void) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_get_shadow_95(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase2f NametagGroup::get_shadow(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getShadow", key_word_list));
        else
            (PyArg_Parse(args, ":getShadow"));
        if(!PyErr_Occurred())
        {
            LVecBase2f result = ((const NametagGroup*)local_this)->get_shadow();
            LVecBase2f *return_value = new LVecBase2f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase2f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getShadow(const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_get_shadow_95_comment =
    "C++ Interface:\n"
    "getShadow(const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::get_shadow\n"
    "//       Access: Published\n"
    "//  Description: Returns the offset of the shadow as set by\n"
    "//               set_shadow().  It is an error to call this if\n"
    "//               has_shadow() is false.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_get_shadow_95_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void NametagGroup::set_name(basic_string< char > const &name)
 *******************************************************************/
static PyObject *Dtool_NametagGroup_set_name_96(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void NametagGroup::set_name(basic_string< char > const &name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setName", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setName", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_name(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NametagGroup.setName() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setName(non-const NametagGroup this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_set_name_96_comment =
    "C++ Interface:\n"
    "setName(non-const NametagGroup this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::set_name\n"
    "//       Access: Published\n"
    "//  Description: Changes both the name of the avatar, which is used to\n"
    "//               prefix messages displayed by the Nametag2d, as well\n"
    "//               as the display name of the avatar, which is what is\n"
    "//               displayed for every Nametag.\n"
    "//\n"
    "//               See also set_display_name(), which sets only the name\n"
    "//               that is displayed on the Nametags.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_set_name_96_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &NametagGroup::get_name(void) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_get_name_97(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &NametagGroup::get_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getName", key_word_list));
        else
            (PyArg_Parse(args, ":getName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const NametagGroup*)local_this)->get_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getName(const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_get_name_97_comment =
    "C++ Interface:\n"
    "getName(const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::get_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the name that was set on this group.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_get_name_97_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NametagGroup::set_display_name(basic_string< char > const &name)
 *******************************************************************/
static PyObject *Dtool_NametagGroup_set_display_name_98(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void NametagGroup::set_display_name(basic_string< char > const &name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setDisplayName", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setDisplayName", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_display_name(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NametagGroup.setDisplayName() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDisplayName(non-const NametagGroup this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_set_display_name_98_comment =
    "C++ Interface:\n"
    "setDisplayName(non-const NametagGroup this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::set_display_name\n"
    "//       Access: Published\n"
    "//  Description: Changes the name displayed by all the nametags in\n"
    "//               this group.  This does not change the name that is\n"
    "//               printed within the Nametag2d's for this avatar; see\n"
    "//               set_name().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_set_display_name_98_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &NametagGroup::get_display_name(void) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_get_display_name_99(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &NametagGroup::get_display_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDisplayName", key_word_list));
        else
            (PyArg_Parse(args, ":getDisplayName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const NametagGroup*)local_this)->get_display_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDisplayName(const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_get_display_name_99_comment =
    "C++ Interface:\n"
    "getDisplayName(const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::get_display_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the display_name that was set on this group.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_get_display_name_99_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NametagGroup::set_chat(basic_string< char > const &chat, int chat_flags, int page_number)
 * void NametagGroup::set_chat(basic_string< char > const &chat, int chat_flags, int page_number = (0))
 *******************************************************************/
static PyObject *Dtool_NametagGroup_set_chat_100(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void NametagGroup::set_chat(basic_string< char > const &chat, int chat_flags, int page_number = (0))
            char *param1_str; int param1_len;
            int param2;
            static char * key_word_list[] = {(char *)"chat", (char *)"chat_flags", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#i:setChat", key_word_list, &param1_str, &param1_len, &param2))
            {
                (local_this)->set_chat(basic_string<char>(param1_str, param1_len), (int)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call NametagGroup.setChat() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void NametagGroup::set_chat(basic_string< char > const &chat, int chat_flags, int page_number)
            char *param1_str; int param1_len;
            int param2;
            int param3;
            static char * key_word_list[] = {(char *)"chat", (char *)"chat_flags", (char *)"page_number", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#ii:setChat", key_word_list, &param1_str, &param1_len, &param2, &param3))
            {
                (local_this)->set_chat(basic_string<char>(param1_str, param1_len), (int)param2, (int)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call NametagGroup.setChat() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setChat() takes 3 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setChat(non-const NametagGroup this, string chat, int chat_flags)\n"
          "setChat(non-const NametagGroup this, string chat, int chat_flags, int page_number)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_set_chat_100_comment =
    "C++ Interface:\n"
    "setChat(non-const NametagGroup this, string chat, int chat_flags)\n"
    "setChat(non-const NametagGroup this, string chat, int chat_flags, int page_number)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::set_chat\n"
    "//       Access: Published\n"
    "//  Description: Changes the chat message displayed by all the\n"
    "//               nametags in this group.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_set_chat_100_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void NametagGroup::clear_chat(void)
 *******************************************************************/
static PyObject *Dtool_NametagGroup_clear_chat_101(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void NametagGroup::clear_chat(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearChat", key_word_list));
        else
            (PyArg_Parse(args, ":clearChat"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_chat();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NametagGroup.clearChat() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearChat(non-const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_clear_chat_101_comment =
    "C++ Interface:\n"
    "clearChat(non-const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::clear_chat\n"
    "//       Access: Published\n"
    "//  Description: Removes the current chat message from this group.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_clear_chat_101_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > NametagGroup::get_chat(void) const
 * inline basic_string< char > const &NametagGroup::get_chat(int page_number) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_get_chat_102(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline basic_string< char > NametagGroup::get_chat(void) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":getChat", key_word_list));
            else
                (PyArg_Parse(args, ":getChat"));
            if(!PyErr_Occurred())
            {
                basic_string< char > return_value = ((const NametagGroup*)local_this)->get_chat();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-inline basic_string< char > const &NametagGroup::get_chat(int page_number) const
            int param1;
            static char * key_word_list[] = {(char *)"page_number", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:getChat", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:getChat", &param1));
            if(!PyErr_Occurred())
            {
                basic_string< char > const &return_value = ((const NametagGroup*)local_this)->get_chat((int)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getChat() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getChat(const NametagGroup this)\n"
          "getChat(const NametagGroup this, int page_number)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_get_chat_102_comment =
    "C++ Interface:\n"
    "getChat(const NametagGroup this)\n"
    "getChat(const NametagGroup this, int page_number)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::get_chat\n"
    "//       Access: Published\n"
    "//  Description: Returns the current page of the chat message.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::get_chat\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth page of the chat message.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_get_chat_102_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > NametagGroup::get_stomp_text(void) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_get_stomp_text_103(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > NametagGroup::get_stomp_text(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStompText", key_word_list));
        else
            (PyArg_Parse(args, ":getStompText"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const NametagGroup*)local_this)->get_stomp_text();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStompText(const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_get_stomp_text_103_comment =
    "C++ Interface:\n"
    "getStompText(const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::get_stomp_text\n"
    "//       Access: Published\n"
    "//  Description: Returns the current page of the chat message.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_get_stomp_text_103_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int NametagGroup::get_chat_flags(void) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_get_chat_flags_104(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int NametagGroup::get_chat_flags(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getChatFlags", key_word_list));
        else
            (PyArg_Parse(args, ":getChatFlags"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NametagGroup*)local_this)->get_chat_flags();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getChatFlags(const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_get_chat_flags_104_comment =
    "C++ Interface:\n"
    "getChatFlags(const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::get_chat_flags\n"
    "//       Access: Published\n"
    "//  Description: Returns the chat flags that were set on this group.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_get_chat_flags_104_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NametagGroup::set_page_number(int page_number)
 *******************************************************************/
static PyObject *Dtool_NametagGroup_set_page_number_105(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void NametagGroup::set_page_number(int page_number)
        int param1;
        static char * key_word_list[] = {(char *)"page_number", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setPageNumber", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setPageNumber", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_page_number((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NametagGroup.setPageNumber() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPageNumber(non-const NametagGroup this, int page_number)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_set_page_number_105_comment =
    "C++ Interface:\n"
    "setPageNumber(non-const NametagGroup this, int page_number)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::set_page_number\n"
    "//       Access: Published\n"
    "//  Description: Sets the page that is displayed for multi-page chat\n"
    "//               messages.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_set_page_number_105_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int NametagGroup::get_page_number(void) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_get_page_number_106(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int NametagGroup::get_page_number(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPageNumber", key_word_list));
        else
            (PyArg_Parse(args, ":getPageNumber"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NametagGroup*)local_this)->get_page_number();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPageNumber(const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_get_page_number_106_comment =
    "C++ Interface:\n"
    "getPageNumber(const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::get_page_number\n"
    "//       Access: Published\n"
    "//  Description: Returns the current page number on multi-page\n"
    "//               messages.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_get_page_number_106_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int NametagGroup::get_num_chat_pages(void) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_get_num_chat_pages_107(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int NametagGroup::get_num_chat_pages(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumChatPages", key_word_list));
        else
            (PyArg_Parse(args, ":getNumChatPages"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NametagGroup*)local_this)->get_num_chat_pages();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumChatPages(const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_get_num_chat_pages_107_comment =
    "C++ Interface:\n"
    "getNumChatPages(const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::get_num_chat_pages\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of pages available in the current\n"
    "//               chat message.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_get_num_chat_pages_107_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int NametagGroup::get_chat_stomp(void) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_get_chat_stomp_108(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int NametagGroup::get_chat_stomp(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getChatStomp", key_word_list));
        else
            (PyArg_Parse(args, ":getChatStomp"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NametagGroup*)local_this)->get_chat_stomp();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getChatStomp(const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_get_chat_stomp_108_comment =
    "C++ Interface:\n"
    "getChatStomp(const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::get_chat_stomp\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of pages available in the current\n"
    "//               chat message.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_get_chat_stomp_108_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float NametagGroup::get_stomp_delay(void) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_get_stomp_delay_109(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float NametagGroup::get_stomp_delay(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStompDelay", key_word_list));
        else
            (PyArg_Parse(args, ":getStompDelay"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const NametagGroup*)local_this)->get_stomp_delay();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStompDelay(const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_get_stomp_delay_109_comment =
    "C++ Interface:\n"
    "getStompDelay(const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::get_stomp_delay\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of pages available in the current\n"
    "//               chat message.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_get_stomp_delay_109_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void NametagGroup::set_unique_id(basic_string< char > const &event)
 *******************************************************************/
static PyObject *Dtool_NametagGroup_set_unique_id_110(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void NametagGroup::set_unique_id(basic_string< char > const &event)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"event", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setUniqueId", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setUniqueId", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_unique_id(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NametagGroup.setUniqueId() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setUniqueId(non-const NametagGroup this, string event)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_set_unique_id_110_comment =
    "C++ Interface:\n"
    "setUniqueId(non-const NametagGroup this, string event)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::set_unique_id\n"
    "//       Access: Published\n"
    "//  Description: Changes the event which will be thrown in response to\n"
    "//               the user's clicking on any of the nametags in this\n"
    "//               group.  This is arbitrarily defined to a unique\n"
    "//               string by default, but it may be redefined by the\n"
    "//               user.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_set_unique_id_110_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &NametagGroup::get_unique_id(void) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_get_unique_id_111(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &NametagGroup::get_unique_id(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUniqueId", key_word_list));
        else
            (PyArg_Parse(args, ":getUniqueId"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const NametagGroup*)local_this)->get_unique_id();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUniqueId(const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_get_unique_id_111_comment =
    "C++ Interface:\n"
    "getUniqueId(const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::get_unique_id\n"
    "//       Access: Published\n"
    "//  Description: Returns the event which will be thrown in response to\n"
    "//               the user's clicking on any of the nametags in this\n"
    "//               group.  This is arbitrarily defined to a unique\n"
    "//               string by default, but it may be redefined by the\n"
    "//               user.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_get_unique_id_111_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void NametagGroup::set_object_code(int code)
 *******************************************************************/
static PyObject *Dtool_NametagGroup_set_object_code_112(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void NametagGroup::set_object_code(int code)
        int param1;
        static char * key_word_list[] = {(char *)"code", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setObjectCode", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setObjectCode", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_object_code((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NametagGroup.setObjectCode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setObjectCode(non-const NametagGroup this, int code)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_set_object_code_112_comment =
    "C++ Interface:\n"
    "setObjectCode(non-const NametagGroup this, int code)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::set_object_code\n"
    "//       Access: Published\n"
    "//  Description: Associates a code number with the nametags in this\n"
    "//               group.  If the code number is nonzero, and any two\n"
    "//               nametags with the same code would be onscreen\n"
    "//               simultaneously, only the nearest one is displayed.\n"
    "//               This is intended to prevent redundant display of\n"
    "//               multiple nametags for the same object (e.g. a\n"
    "//               building with multiple doors).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_set_object_code_112_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int NametagGroup::get_object_code(void) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_get_object_code_113(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int NametagGroup::get_object_code(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getObjectCode", key_word_list));
        else
            (PyArg_Parse(args, ":getObjectCode"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NametagGroup*)local_this)->get_object_code();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getObjectCode(const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_get_object_code_113_comment =
    "C++ Interface:\n"
    "getObjectCode(const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::get_object_code\n"
    "//       Access: Published\n"
    "//  Description: Returns the code number associated with the nametags\n"
    "//               in this group.  See set_object_code().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_get_object_code_113_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NametagGroup::click(void)
 *******************************************************************/
static PyObject *Dtool_NametagGroup_click_114(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void NametagGroup::click(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":click", key_word_list));
        else
            (PyArg_Parse(args, ":click"));
        if(!PyErr_Occurred())
        {
            (local_this)->click();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NametagGroup.click() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "click(non-const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_click_114_comment =
    "C++ Interface:\n"
    "click(non-const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::click\n"
    "//       Access: Published\n"
    "//  Description: This is normally called in response to a mouse button\n"
    "//               down-and-up on one of our nametags, but it may be\n"
    "//               called directly by the user for debugging purposes or\n"
    "//               to simulate a nametag click.\n"
    "//\n"
    "//               This throws the unique ID of this group as an event.\n"
    "//               This ID can be queried or changed via get_unique_id()\n"
    "//               and set_unique_id().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_click_114_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NametagGroup::manage(MarginManager *manager)
 *******************************************************************/
static PyObject *Dtool_NametagGroup_manage_115(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void NametagGroup::manage(MarginManager *manager)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"manager", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:manage", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:manage", &param1));
            if(!PyErr_Occurred())
            {
                MarginManager *param1_this = (MarginManager *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_MarginManager, 1, "NametagGroup.manage", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->manage(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call NametagGroup.manage() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "manage(non-const NametagGroup this, non-const MarginManager manager)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_manage_115_comment =
    "C++ Interface:\n"
    "manage(non-const NametagGroup this, non-const MarginManager manager)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::manage\n"
    "//       Access: Published\n"
    "//  Description: Activates all the Nametags in the group and makes\n"
    "//               them visible onscreen when appropriate.  The supplied\n"
    "//               MarginManager will be responsible for managing\n"
    "//               the 2-d Nametag with the group; the remaining\n"
    "//               Nametags can take care of themselves.\n"
    "//\n"
    "//               This should be called whenever an avatar with a\n"
    "//               Nametag is brought into the world.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_manage_115_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NametagGroup::unmanage(MarginManager *manager)
 *******************************************************************/
static PyObject *Dtool_NametagGroup_unmanage_116(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void NametagGroup::unmanage(MarginManager *manager)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"manager", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:unmanage", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:unmanage", &param1));
            if(!PyErr_Occurred())
            {
                MarginManager *param1_this = (MarginManager *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_MarginManager, 1, "NametagGroup.unmanage", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->unmanage(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call NametagGroup.unmanage() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unmanage(non-const NametagGroup this, non-const MarginManager manager)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_unmanage_116_comment =
    "C++ Interface:\n"
    "unmanage(non-const NametagGroup this, non-const MarginManager manager)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::unmanage\n"
    "//       Access: Published\n"
    "//  Description: Deactivates the Nametags in the group and ensures\n"
    "//               their MouseWatcherRegions are removed, etc.  This\n"
    "//               should be called whenever an avatar with a Nametag is\n"
    "//               removed from the world.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_unmanage_116_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool NametagGroup::is_managed(void) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_is_managed_117(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool NametagGroup::is_managed(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isManaged", key_word_list));
        else
            (PyArg_Parse(args, ":isManaged"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const NametagGroup*)local_this)->is_managed();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isManaged(const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_is_managed_117_comment =
    "C++ Interface:\n"
    "isManaged(const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::is_managed\n"
    "//       Access: Published\n"
    "//  Description: Returns the managed flag.  This flag indicates that\n"
    "//               the Nametags associated with this group are attached\n"
    "//               to an active avatar in the world, and they should be\n"
    "//               given live MouseWatcherRegions, etc.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_is_managed_117_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void NametagGroup::set_contents(int flags)
 *******************************************************************/
static PyObject *Dtool_NametagGroup_set_contents_118(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void NametagGroup::set_contents(int flags)
        int param1;
        static char * key_word_list[] = {(char *)"flags", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setContents", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setContents", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_contents((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NametagGroup.setContents() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setContents(non-const NametagGroup this, int flags)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_set_contents_118_comment =
    "C++ Interface:\n"
    "setContents(non-const NametagGroup this, int flags)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::set_contents\n"
    "//       Access: Published\n"
    "//  Description: Changes the bitmask that indicates the set of\n"
    "//               contents the Nametag may represent.  This is the\n"
    "//               union of all the bits corresponding to name, speech,\n"
    "//               or thoughts, that may be displayed in the Nametag.\n"
    "//               Set it to 0 to disable the Nametag altogether.\n"
    "//\n"
    "//               This mask is defined both for NametagGroup as well as\n"
    "//               for the individual Nametags within the group; the\n"
    "//               actual mask in effect for a particular Nametag is the\n"
    "//               intersection of the two masks.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_set_contents_118_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int NametagGroup::get_contents(void) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_get_contents_119(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int NametagGroup::get_contents(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getContents", key_word_list));
        else
            (PyArg_Parse(args, ":getContents"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NametagGroup*)local_this)->get_contents();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getContents(const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_get_contents_119_comment =
    "C++ Interface:\n"
    "getContents(const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::get_contents\n"
    "//       Access: Published\n"
    "//  Description: Returns the bitmask that indicates the set of\n"
    "//               contents the Nametag may represent.  See\n"
    "//               set_contents().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_get_contents_119_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void NametagGroup::set_active(bool active)
 *******************************************************************/
static PyObject *Dtool_NametagGroup_set_active_120(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void NametagGroup::set_active(bool active)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"active", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setActive", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setActive", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_active((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NametagGroup.setActive() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setActive(non-const NametagGroup this, bool active)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_set_active_120_comment =
    "C++ Interface:\n"
    "setActive(non-const NametagGroup this, bool active)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::set_active\n"
    "//       Access: Published\n"
    "//  Description: Changes the active flag.  When the Nametag is active,\n"
    "//               it can be clicked on; when it is not active, it\n"
    "//               cannot be clicked on.  The active flag may be set\n"
    "//               either on the individual Nametag, or on the entire\n"
    "//               group.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_set_active_120_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool NametagGroup::is_active(void) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_is_active_121(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool NametagGroup::is_active(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isActive", key_word_list));
        else
            (PyArg_Parse(args, ":isActive"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const NametagGroup*)local_this)->is_active();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isActive(const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_is_active_121_comment =
    "C++ Interface:\n"
    "isActive(const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::is_active\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_is_active_121_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool NametagGroup::has_page_button(void) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_has_page_button_122(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool NametagGroup::has_page_button(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasPageButton", key_word_list));
        else
            (PyArg_Parse(args, ":hasPageButton"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const NametagGroup*)local_this)->has_page_button();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasPageButton(const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_has_page_button_122_comment =
    "C++ Interface:\n"
    "hasPageButton(const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::has_page_button\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the group should be displaying a page\n"
    "//               button at the end of each page, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_has_page_button_122_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool NametagGroup::has_quit_button(void) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_has_quit_button_123(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool NametagGroup::has_quit_button(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasQuitButton", key_word_list));
        else
            (PyArg_Parse(args, ":hasQuitButton"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const NametagGroup*)local_this)->has_quit_button();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasQuitButton(const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_has_quit_button_123_comment =
    "C++ Interface:\n"
    "hasQuitButton(const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::has_quit_button\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the group should be displaying a quit\n"
    "//               button at the end of the last page, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_has_quit_button_123_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool NametagGroup::has_no_quit_button(void) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_has_no_quit_button_124(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool NametagGroup::has_no_quit_button(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasNoQuitButton", key_word_list));
        else
            (PyArg_Parse(args, ":hasNoQuitButton"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const NametagGroup*)local_this)->has_no_quit_button();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasNoQuitButton(const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_has_no_quit_button_124_comment =
    "C++ Interface:\n"
    "hasNoQuitButton(const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::has_no_quit_button\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the group not display any button at\n"
    "//               all on the final page of a multi-page chat.  If\n"
    "//               neither this nor has_quit_button is true, the group\n"
    "//               will display a page-advance arrow on the final page.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_has_no_quit_button_124_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool NametagGroup::has_button(void) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_has_button_125(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool NametagGroup::has_button(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasButton", key_word_list));
        else
            (PyArg_Parse(args, ":hasButton"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const NametagGroup*)local_this)->has_button();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasButton(const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_has_button_125_comment =
    "C++ Interface:\n"
    "hasButton(const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::has_button\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the group should be displaying any\n"
    "//               button.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_has_button_125_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool NametagGroup::will_have_button(void) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_will_have_button_126(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool NametagGroup::will_have_button(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":willHaveButton", key_word_list));
        else
            (PyArg_Parse(args, ":willHaveButton"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const NametagGroup*)local_this)->will_have_button();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "willHaveButton(const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_will_have_button_126_comment =
    "C++ Interface:\n"
    "willHaveButton(const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::will_have_button\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the group should be displaying a\n"
    "//               page-advance or quit button now, or will eventually\n"
    "//               be displaying a button, once the button timeout\n"
    "//               expires.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_will_have_button_126_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool NametagGroup::display_as_active(void) const
 *******************************************************************/
static PyObject *Dtool_NametagGroup_display_as_active_127(PyObject *self, PyObject *args,PyObject *kwds) {
    NametagGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NametagGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool NametagGroup::display_as_active(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":displayAsActive", key_word_list));
        else
            (PyArg_Parse(args, ":displayAsActive"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const NametagGroup*)local_this)->display_as_active();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "displayAsActive(const NametagGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGroup_display_as_active_127_comment =
    "C++ Interface:\n"
    "displayAsActive(const NametagGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGroup::display_as_active\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the group is effectively active,\n"
    "//               false otherwise.  This includes all the things that\n"
    "//               affect groups, including whether it has been\n"
    "//               explicitly set inactive, whether global nametags have\n"
    "//               been set inactive, and whether the group has a page\n"
    "//               button.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGroup_display_as_active_127_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NametagGroup::NametagGroup(void)
 *******************************************************************/
int  Dtool_Init_NametagGroup(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-NametagGroup::NametagGroup(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":NametagGroup", key_word_list))
        {
            NametagGroup *return_value = new NametagGroup();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_NametagGroup,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "NametagGroup()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_NametagGroup(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_NametagGroup)
    {
        printf("NametagGroup ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    NametagGroup * local_this = (NametagGroup *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_NametagGroup)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_NametagGroup(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_NametagGroup)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. WhisperPopup 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void WhisperPopup::set_clickable(basic_string< char > const &avatar_name, int avatar_id, int is_player_id)
 * void WhisperPopup::set_clickable(basic_string< char > const &avatar_name, int avatar_id, int is_player_id = (0))
 *******************************************************************/
static PyObject *Dtool_WhisperPopup_set_clickable_136(PyObject *self, PyObject *args,PyObject *kwds) {
    WhisperPopup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WhisperPopup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void WhisperPopup::set_clickable(basic_string< char > const &avatar_name, int avatar_id, int is_player_id = (0))
            char *param1_str; int param1_len;
            int param2;
            static char * key_word_list[] = {(char *)"avatar_name", (char *)"avatar_id", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#i:setClickable", key_word_list, &param1_str, &param1_len, &param2))
            {
                (local_this)->set_clickable(basic_string<char>(param1_str, param1_len), (int)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call WhisperPopup.setClickable() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void WhisperPopup::set_clickable(basic_string< char > const &avatar_name, int avatar_id, int is_player_id)
            char *param1_str; int param1_len;
            int param2;
            int param3;
            static char * key_word_list[] = {(char *)"avatar_name", (char *)"avatar_id", (char *)"is_player_id", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#ii:setClickable", key_word_list, &param1_str, &param1_len, &param2, &param3))
            {
                (local_this)->set_clickable(basic_string<char>(param1_str, param1_len), (int)param2, (int)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call WhisperPopup.setClickable() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setClickable() takes 3 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setClickable(non-const WhisperPopup this, string avatar_name, int avatar_id)\n"
          "setClickable(non-const WhisperPopup this, string avatar_name, int avatar_id, int is_player_id)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WhisperPopup_set_clickable_136_comment =
    "C++ Interface:\n"
    "setClickable(non-const WhisperPopup this, string avatar_name, int avatar_id)\n"
    "setClickable(non-const WhisperPopup this, string avatar_name, int avatar_id, int is_player_id)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WhisperPopup::set_clickable\n"
    "//       Access: Published\n"
    "//  Description: Makes the popup clickable.  When the user clicks on\n"
    "//               the popup, an event named \"whisperTo\" is generated\n"
    "//               with the two supplied parameters.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WhisperPopup_set_clickable_136_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void WhisperPopup::manage(MarginManager *manager)
 *******************************************************************/
static PyObject *Dtool_WhisperPopup_manage_137(PyObject *self, PyObject *args,PyObject *kwds) {
    WhisperPopup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WhisperPopup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void WhisperPopup::manage(MarginManager *manager)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"manager", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:manage", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:manage", &param1));
            if(!PyErr_Occurred())
            {
                MarginManager *param1_this = (MarginManager *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_MarginManager, 1, "WhisperPopup.manage", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->manage(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call WhisperPopup.manage() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "manage(non-const WhisperPopup this, non-const MarginManager manager)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WhisperPopup_manage_137_comment =
    "C++ Interface:\n"
    "manage(non-const WhisperPopup this, non-const MarginManager manager)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WhisperPopup::manage\n"
    "//       Access: Published\n"
    "//  Description: Adds the popup to the pool of available popups to be\n"
    "//               made visible when appropriate (i.e. when there is\n"
    "//               room available).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WhisperPopup_manage_137_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void WhisperPopup::unmanage(MarginManager *manager)
 *******************************************************************/
static PyObject *Dtool_WhisperPopup_unmanage_138(PyObject *self, PyObject *args,PyObject *kwds) {
    WhisperPopup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WhisperPopup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void WhisperPopup::unmanage(MarginManager *manager)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"manager", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:unmanage", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:unmanage", &param1));
            if(!PyErr_Occurred())
            {
                MarginManager *param1_this = (MarginManager *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_MarginManager, 1, "WhisperPopup.unmanage", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->unmanage(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call WhisperPopup.unmanage() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unmanage(non-const WhisperPopup this, non-const MarginManager manager)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WhisperPopup_unmanage_138_comment =
    "C++ Interface:\n"
    "unmanage(non-const WhisperPopup this, non-const MarginManager manager)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: WhisperPopup::unmanage\n"
    "//       Access: Published\n"
    "//  Description: Removes the popup from the pool of available popups\n"
    "//               to be made visible.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_WhisperPopup_unmanage_138_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle WhisperPopup::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_WhisperPopup_get_class_type_139(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle WhisperPopup::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = WhisperPopup::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WhisperPopup_get_class_type_139_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_WhisperPopup_get_class_type_139_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * MarginPopup *WhisperPopup::upcast_to_MarginPopup(void)
 *******************************************************************/
static PyObject *Dtool_WhisperPopup_upcast_to_MarginPopup_129(PyObject *self, PyObject *args,PyObject *kwds) {
    WhisperPopup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WhisperPopup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-MarginPopup *WhisperPopup::upcast_to_MarginPopup(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToMarginPopup", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToMarginPopup"));
        if(!PyErr_Occurred())
        {
            MarginPopup *return_value = (MarginPopup *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_MarginPopup,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WhisperPopup.upcastToMarginPopup() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToMarginPopup(non-const WhisperPopup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WhisperPopup_upcast_to_MarginPopup_129_comment =
    "C++ Interface:\n"
    "upcastToMarginPopup(non-const WhisperPopup this)\n"
    "\n"
    "upcast from WhisperPopup to MarginPopup\n"
    "";
#else
static const char * Dtool_WhisperPopup_upcast_to_MarginPopup_129_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ClickablePopup *WhisperPopup::upcast_to_ClickablePopup(void)
 *******************************************************************/
static PyObject *Dtool_WhisperPopup_upcast_to_ClickablePopup_131(PyObject *self, PyObject *args,PyObject *kwds) {
    WhisperPopup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_WhisperPopup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-ClickablePopup *WhisperPopup::upcast_to_ClickablePopup(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToClickablePopup", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToClickablePopup"));
        if(!PyErr_Occurred())
        {
            ClickablePopup *return_value = (ClickablePopup *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ClickablePopup,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call WhisperPopup.upcastToClickablePopup() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToClickablePopup(non-const WhisperPopup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WhisperPopup_upcast_to_ClickablePopup_131_comment =
    "C++ Interface:\n"
    "upcastToClickablePopup(non-const WhisperPopup this)\n"
    "\n"
    "upcast from WhisperPopup to ClickablePopup\n"
    "";
#else
static const char * Dtool_WhisperPopup_upcast_to_ClickablePopup_131_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * WhisperPopup::WhisperPopup(basic_string< char > const &text, TextFont *font, WhisperPopup::WhisperType whisper_type)
 *******************************************************************/
int  Dtool_Init_WhisperPopup(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-WhisperPopup::WhisperPopup(basic_string< char > const &text, TextFont *font, WhisperPopup::WhisperType whisper_type)
            char *param0_str; int param0_len;
            PyObject *param1;
            int param2;
            static char * key_word_list[] = {(char *)"text", (char *)"font", (char *)"whisper_type", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#Oi:WhisperPopup", key_word_list, &param0_str, &param0_len, &param1, &param2))
            {
                TextFont *param1_this = (TextFont *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TextFont, 1, "WhisperPopup.WhisperPopup", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    WhisperPopup *return_value = new WhisperPopup(basic_string<char>(param0_str, param0_len), param1_this, (WhisperPopup::WhisperType)param2);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_WhisperPopup,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "WhisperPopup(string text, non-const TextFont font, int whisper_type)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_WhisperPopup(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_WhisperPopup)
    {
        printf("WhisperPopup ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    WhisperPopup * local_this = (WhisperPopup *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_WhisperPopup)
        return local_this;
    if(requested_type == &Dtool_ClickablePopup)
        return ( ClickablePopup *) local_this;
    if(requested_type == &Dtool_MarginPopup)
        return ( MarginPopup *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( MarginPopup *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( MarginPopup *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( MarginPopup *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( MarginPopup *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( MarginPopup *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_WhisperPopup(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_WhisperPopup)
        return from_this;
    if(from_type == &Dtool_ClickablePopup)
    {
          ClickablePopup* other_this = (ClickablePopup*)from_this;
          return (WhisperPopup*)other_this;
    }
    if(from_type == &Dtool_MarginPopup)
    {
          MarginPopup* other_this = (MarginPopup*)from_this;
          return (WhisperPopup*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (WhisperPopup*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (WhisperPopup*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (WhisperPopup*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (WhisperPopup*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. NametagGlobals 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static inline float NametagGlobals::get_name_wordwrap(void)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_get_name_wordwrap_141(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline float NametagGlobals::get_name_wordwrap(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getNameWordwrap", key_word_list))
        {
            float return_value = NametagGlobals::get_name_wordwrap();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNameWordwrap()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_get_name_wordwrap_141_comment =
    "C++ Interface:\n"
    "getNameWordwrap()\n"
    "\n"
    "// Filename: nametagGlobals.I\n"
    "// Created by:  drose (19Jul01)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::get_name_wordwrap\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the width at which all avatar nametags will\n"
    "//               be wordwrapped.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_get_name_wordwrap_141_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline LVecBase4f const &NametagGlobals::get_card_pad(void)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_get_card_pad_142(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline LVecBase4f const &NametagGlobals::get_card_pad(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getCardPad", key_word_list))
        {
            LVecBase4f const *return_value = &(NametagGlobals::get_card_pad());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCardPad()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_get_card_pad_142_comment =
    "C++ Interface:\n"
    "getCardPad()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::get_card_pad\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the amount of padding applied to the card\n"
    "//               behind the nametags, in each direction (left, right,\n"
    "//               bottom, top).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_get_card_pad_142_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void NametagGlobals::set_camera(NodePath const &node)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_set_camera_143(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static inline void NametagGlobals::set_camera(NodePath const &node)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCamera", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:setCamera", &param0));
            if(!PyErr_Occurred())
            {
                NodePath *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_NodePath, 0, "NametagGlobals.setCamera", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    NametagGlobals::set_camera(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCamera(const NodePath node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_set_camera_143_comment =
    "C++ Interface:\n"
    "setCamera(const NodePath node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::set_camera\n"
    "//       Access: Published, Static\n"
    "//  Description: Sets the node that indicates the camera.  The\n"
    "//               Nametags will rotate and scale (or spin their little\n"
    "//               arrows around) according to the relative position of\n"
    "//               the camera node.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_set_camera_143_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline NodePath const &NametagGlobals::get_camera(void)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_get_camera_144(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline NodePath const &NametagGlobals::get_camera(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getCamera", key_word_list))
        {
            NodePath const *return_value = &(NametagGlobals::get_camera());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCamera()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_get_camera_144_comment =
    "C++ Interface:\n"
    "getCamera()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::get_camera\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the node that indicates the camera.  See\n"
    "//               See set_camera().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_get_camera_144_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void NametagGlobals::set_toon(NodePath const &node)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_set_toon_145(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static inline void NametagGlobals::set_toon(NodePath const &node)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setToon", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:setToon", &param0));
            if(!PyErr_Occurred())
            {
                NodePath *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_NodePath, 0, "NametagGlobals.setToon", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    NametagGlobals::set_toon(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setToon(const NodePath node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_set_toon_145_comment =
    "C++ Interface:\n"
    "setToon(const NodePath node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::set_toon\n"
    "//       Access: Published, Static\n"
    "//  Description: Sets the node that indicates the LocalToon.  This is\n"
    "//               important for 2-d Nametags to determine how to rotate\n"
    "//               their arrows correctly.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_set_toon_145_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline NodePath const &NametagGlobals::get_toon(void)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_get_toon_146(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline NodePath const &NametagGlobals::get_toon(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getToon", key_word_list))
        {
            NodePath const *return_value = &(NametagGlobals::get_toon());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getToon()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_get_toon_146_comment =
    "C++ Interface:\n"
    "getToon()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::get_toon\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the node that indicates the LocalToon.  See\n"
    "//               See set_toon().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_get_toon_146_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void NametagGlobals::set_arrow_model(NodePath const &node)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_set_arrow_model_147(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static inline void NametagGlobals::set_arrow_model(NodePath const &node)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setArrowModel", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:setArrowModel", &param0));
            if(!PyErr_Occurred())
            {
                NodePath *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_NodePath, 0, "NametagGlobals.setArrowModel", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    NametagGlobals::set_arrow_model(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setArrowModel(const NodePath node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_set_arrow_model_147_comment =
    "C++ Interface:\n"
    "setArrowModel(const NodePath node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::set_arrow_model\n"
    "//       Access: Published, Static\n"
    "//  Description: Sets the node that will be instanced to each\n"
    "//               Nametag2d to draw a little arrow.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_set_arrow_model_147_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline NodePath const &NametagGlobals::get_arrow_model(void)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_get_arrow_model_148(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline NodePath const &NametagGlobals::get_arrow_model(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getArrowModel", key_word_list))
        {
            NodePath const *return_value = &(NametagGlobals::get_arrow_model());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getArrowModel()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_get_arrow_model_148_comment =
    "C++ Interface:\n"
    "getArrowModel()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::get_arrow_model\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the node that will be instanced to each\n"
    "//               Nametag2d to draw a little arrow.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_get_arrow_model_148_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void NametagGlobals::set_page_button(int state, NodePath const &node)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_set_page_button_149(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static inline void NametagGlobals::set_page_button(int state, NodePath const &node)
            int param0;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"state", (char *)"node", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setPageButton", key_word_list, &param0, &param1))
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "NametagGlobals.setPageButton", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    NametagGlobals::set_page_button((int)param0, *param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPageButton(int state, const NodePath node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_set_page_button_149_comment =
    "C++ Interface:\n"
    "setPageButton(int state, const NodePath node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::set_page_button_ready\n"
    "//       Access: Published, Static\n"
    "//  Description: Sets the node that will be used to draw a\n"
    "//               page-advance button in the bottom corner of chat\n"
    "//               balloons when CF_page_button is set, in the indicated\n"
    "//               button state.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_set_page_button_149_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline NodePath const &NametagGlobals::get_page_button(int state)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_get_page_button_150(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline NodePath const &NametagGlobals::get_page_button(int state)
        int param0;
        static char * key_word_list[] = {(char *)"state", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getPageButton", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:getPageButton", &param0));
        if(!PyErr_Occurred())
        {
            NodePath const *return_value = &(NametagGlobals::get_page_button((int)param0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPageButton(int state)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_get_page_button_150_comment =
    "C++ Interface:\n"
    "getPageButton(int state)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::get_page_button_ready\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the node that will be used to draw a\n"
    "//               page-advance button in the indicated button state.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_get_page_button_150_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void NametagGlobals::set_quit_button(int state, NodePath const &node)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_set_quit_button_151(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static inline void NametagGlobals::set_quit_button(int state, NodePath const &node)
            int param0;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"state", (char *)"node", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setQuitButton", key_word_list, &param0, &param1))
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "NametagGlobals.setQuitButton", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    NametagGlobals::set_quit_button((int)param0, *param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setQuitButton(int state, const NodePath node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_set_quit_button_151_comment =
    "C++ Interface:\n"
    "setQuitButton(int state, const NodePath node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::set_quit_button_ready\n"
    "//       Access: Published, Static\n"
    "//  Description: Sets the node that will be used to draw a\n"
    "//               quit button in the bottom corner of chat balloons\n"
    "//               when CF_page_button is set, in the indicated button\n"
    "//               state.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_set_quit_button_151_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline NodePath const &NametagGlobals::get_quit_button(int state)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_get_quit_button_152(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline NodePath const &NametagGlobals::get_quit_button(int state)
        int param0;
        static char * key_word_list[] = {(char *)"state", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getQuitButton", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:getQuitButton", &param0));
        if(!PyErr_Occurred())
        {
            NodePath const *return_value = &(NametagGlobals::get_quit_button((int)param0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getQuitButton(int state)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_get_quit_button_152_comment =
    "C++ Interface:\n"
    "getQuitButton(int state)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::get_quit_button_ready\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the node that will be used to draw a\n"
    "//               quit button in the indicated button state.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_get_quit_button_152_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void NametagGlobals::set_nametag_card(NodePath const &node, LVecBase4f const &frame)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_set_nametag_card_153(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static inline void NametagGlobals::set_nametag_card(NodePath const &node, LVecBase4f const &frame)
            PyObject *param0;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"node", (char *)"frame", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:setNametagCard", key_word_list, &param0, &param1))
            {
                NodePath *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_NodePath, 0, "NametagGlobals.setNametagCard", 1, coerced_ptr, report_errors);
LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "NametagGlobals.setNametagCard", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)|| (param1_this == NULL)))
                {
                    NametagGlobals::set_nametag_card(*param0_this, *param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setNametagCard(const NodePath node, const VBase4 frame)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_set_nametag_card_153_comment =
    "C++ Interface:\n"
    "setNametagCard(const NodePath node, const VBase4 frame)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::set_nametag_card\n"
    "//       Access: Published, Static\n"
    "//  Description: Sets the geometry that will be parented behind each\n"
    "//               Nametag as a background card, and simultaneously\n"
    "//               specifies the size of the model.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_set_nametag_card_153_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline NodePath const &NametagGlobals::get_nametag_card(void)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_get_nametag_card_154(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline NodePath const &NametagGlobals::get_nametag_card(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getNametagCard", key_word_list))
        {
            NodePath const *return_value = &(NametagGlobals::get_nametag_card());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNametagCard()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_get_nametag_card_154_comment =
    "C++ Interface:\n"
    "getNametagCard()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::get_nametag_card\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the geometry that will be parented behind\n"
    "//               each Nametag as a background card.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_get_nametag_card_154_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline LVecBase4f const &NametagGlobals::get_nametag_card_frame(void)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_get_nametag_card_frame_155(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline LVecBase4f const &NametagGlobals::get_nametag_card_frame(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getNametagCardFrame", key_word_list))
        {
            LVecBase4f const *return_value = &(NametagGlobals::get_nametag_card_frame());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNametagCardFrame()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_get_nametag_card_frame_155_comment =
    "C++ Interface:\n"
    "getNametagCardFrame()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::get_nametag_card_frame\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the size of the geometry returned by\n"
    "//               get_nametag_card().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_get_nametag_card_frame_155_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void NametagGlobals::set_rollover_sound(AudioSound *sound)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_set_rollover_sound_156(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static inline void NametagGlobals::set_rollover_sound(AudioSound *sound)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"sound", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setRolloverSound", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:setRolloverSound", &param0));
            if(!PyErr_Occurred())
            {
                AudioSound *param0_this = (AudioSound *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_AudioSound, 0, "NametagGlobals.setRolloverSound", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    NametagGlobals::set_rollover_sound(param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRolloverSound(non-const AudioSound sound)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_set_rollover_sound_156_comment =
    "C++ Interface:\n"
    "setRolloverSound(non-const AudioSound sound)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::set_rollover_sound\n"
    "//       Access: Published, Static\n"
    "//  Description: Sets the sound effect that will be played whenever\n"
    "//               the mouse rolls over a Nametag, either in the world\n"
    "//               or on the screen.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_set_rollover_sound_156_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline AudioSound *NametagGlobals::get_rollover_sound(void)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_get_rollover_sound_157(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline AudioSound *NametagGlobals::get_rollover_sound(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getRolloverSound", key_word_list))
        {
            AudioSound *return_value = NametagGlobals::get_rollover_sound();
            if (return_value != (AudioSound *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_AudioSound,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRolloverSound()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_get_rollover_sound_157_comment =
    "C++ Interface:\n"
    "getRolloverSound()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::set_rollover_sound\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the sound effect that will be played whenever\n"
    "//               the mouse rolls over a Nametag.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_get_rollover_sound_157_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void NametagGlobals::set_click_sound(AudioSound *sound)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_set_click_sound_158(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static inline void NametagGlobals::set_click_sound(AudioSound *sound)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"sound", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setClickSound", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:setClickSound", &param0));
            if(!PyErr_Occurred())
            {
                AudioSound *param0_this = (AudioSound *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_AudioSound, 0, "NametagGlobals.setClickSound", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    NametagGlobals::set_click_sound(param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setClickSound(non-const AudioSound sound)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_set_click_sound_158_comment =
    "C++ Interface:\n"
    "setClickSound(non-const AudioSound sound)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::set_click_sound\n"
    "//       Access: Published, Static\n"
    "//  Description: Sets the sound effect that will be played whenever\n"
    "//               the mouse clicks on a Nametag, either in the world\n"
    "//               or on the screen.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_set_click_sound_158_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline AudioSound *NametagGlobals::get_click_sound(void)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_get_click_sound_159(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline AudioSound *NametagGlobals::get_click_sound(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClickSound", key_word_list))
        {
            AudioSound *return_value = NametagGlobals::get_click_sound();
            if (return_value != (AudioSound *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_AudioSound,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClickSound()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_get_click_sound_159_comment =
    "C++ Interface:\n"
    "getClickSound()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::set_click_sound\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the sound effect that will be played whenever\n"
    "//               the mouse clicks on a Nametag.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_get_click_sound_159_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void NametagGlobals::set_mouse_watcher(MouseWatcher *watcher)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_set_mouse_watcher_160(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static inline void NametagGlobals::set_mouse_watcher(MouseWatcher *watcher)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"watcher", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setMouseWatcher", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:setMouseWatcher", &param0));
            if(!PyErr_Occurred())
            {
                MouseWatcher *param0_this = (MouseWatcher *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_MouseWatcher, 0, "NametagGlobals.setMouseWatcher", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    NametagGlobals::set_mouse_watcher(param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMouseWatcher(non-const MouseWatcher watcher)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_set_mouse_watcher_160_comment =
    "C++ Interface:\n"
    "setMouseWatcher(non-const MouseWatcher watcher)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::set_mouse_watcher\n"
    "//       Access: Published, Static\n"
    "//  Description: Sets a pointer to the MouseWatcher node in effect.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_set_mouse_watcher_160_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline MouseWatcher *NametagGlobals::get_mouse_watcher(void)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_get_mouse_watcher_161(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline MouseWatcher *NametagGlobals::get_mouse_watcher(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getMouseWatcher", key_word_list))
        {
            MouseWatcher *return_value = NametagGlobals::get_mouse_watcher();
            if (return_value != (MouseWatcher *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_MouseWatcher,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMouseWatcher()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_get_mouse_watcher_161_comment =
    "C++ Interface:\n"
    "getMouseWatcher()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::get_mouse_watcher\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a pointer to the MouseWatcher node in effect.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_get_mouse_watcher_161_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void NametagGlobals::set_speech_balloon_2d(ChatBalloon *balloon)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_set_speech_balloon_2d_162(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static inline void NametagGlobals::set_speech_balloon_2d(ChatBalloon *balloon)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"balloon", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setSpeechBalloon2d", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:setSpeechBalloon2d", &param0));
            if(!PyErr_Occurred())
            {
                ChatBalloon *param0_this = (ChatBalloon *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ChatBalloon, 0, "NametagGlobals.setSpeechBalloon2d", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    NametagGlobals::set_speech_balloon_2d(param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSpeechBalloon2d(non-const ChatBalloon balloon)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_set_speech_balloon_2d_162_comment =
    "C++ Interface:\n"
    "setSpeechBalloon2d(non-const ChatBalloon balloon)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::set_speech_balloon_2d\n"
    "//       Access: Published, Static\n"
    "//  Description: Sets the ChatBalloon geometry that will be used for\n"
    "//               rendering speech chat messages by Nametag2d objects.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_set_speech_balloon_2d_162_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline ChatBalloon *NametagGlobals::get_speech_balloon_2d(void)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_get_speech_balloon_2d_163(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline ChatBalloon *NametagGlobals::get_speech_balloon_2d(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getSpeechBalloon2d", key_word_list))
        {
            ChatBalloon *return_value = NametagGlobals::get_speech_balloon_2d();
            if (return_value != (ChatBalloon *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ChatBalloon,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSpeechBalloon2d()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_get_speech_balloon_2d_163_comment =
    "C++ Interface:\n"
    "getSpeechBalloon2d()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::get_speech_balloon_2d\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the ChatBalloon geometry that will be used\n"
    "//               for rendering speech chat messages by Nametag2d\n"
    "//               objects.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_get_speech_balloon_2d_163_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void NametagGlobals::set_thought_balloon_2d(ChatBalloon *balloon)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_set_thought_balloon_2d_164(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static inline void NametagGlobals::set_thought_balloon_2d(ChatBalloon *balloon)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"balloon", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setThoughtBalloon2d", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:setThoughtBalloon2d", &param0));
            if(!PyErr_Occurred())
            {
                ChatBalloon *param0_this = (ChatBalloon *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ChatBalloon, 0, "NametagGlobals.setThoughtBalloon2d", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    NametagGlobals::set_thought_balloon_2d(param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setThoughtBalloon2d(non-const ChatBalloon balloon)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_set_thought_balloon_2d_164_comment =
    "C++ Interface:\n"
    "setThoughtBalloon2d(non-const ChatBalloon balloon)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::set_thought_balloon_2d\n"
    "//       Access: Published, Static\n"
    "//  Description: Sets the ChatBalloon geometry that will be used for\n"
    "//               rendering thought chat messages by Nametag2d objects.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_set_thought_balloon_2d_164_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline ChatBalloon *NametagGlobals::get_thought_balloon_2d(void)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_get_thought_balloon_2d_165(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline ChatBalloon *NametagGlobals::get_thought_balloon_2d(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getThoughtBalloon2d", key_word_list))
        {
            ChatBalloon *return_value = NametagGlobals::get_thought_balloon_2d();
            if (return_value != (ChatBalloon *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ChatBalloon,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getThoughtBalloon2d()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_get_thought_balloon_2d_165_comment =
    "C++ Interface:\n"
    "getThoughtBalloon2d()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::get_thought_balloon_2d\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the ChatBalloon geometry that will be used\n"
    "//               for rendering thought chat messages by Nametag2d\n"
    "//               objects.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_get_thought_balloon_2d_165_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void NametagGlobals::set_speech_balloon_3d(ChatBalloon *balloon)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_set_speech_balloon_3d_166(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static inline void NametagGlobals::set_speech_balloon_3d(ChatBalloon *balloon)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"balloon", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setSpeechBalloon3d", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:setSpeechBalloon3d", &param0));
            if(!PyErr_Occurred())
            {
                ChatBalloon *param0_this = (ChatBalloon *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ChatBalloon, 0, "NametagGlobals.setSpeechBalloon3d", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    NametagGlobals::set_speech_balloon_3d(param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSpeechBalloon3d(non-const ChatBalloon balloon)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_set_speech_balloon_3d_166_comment =
    "C++ Interface:\n"
    "setSpeechBalloon3d(non-const ChatBalloon balloon)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::set_speech_balloon_3d\n"
    "//       Access: Published, Static\n"
    "//  Description: Sets the ChatBalloon geometry that will be used for\n"
    "//               rendering speech chat messages by Nametag3d objects.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_set_speech_balloon_3d_166_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline ChatBalloon *NametagGlobals::get_speech_balloon_3d(void)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_get_speech_balloon_3d_167(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline ChatBalloon *NametagGlobals::get_speech_balloon_3d(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getSpeechBalloon3d", key_word_list))
        {
            ChatBalloon *return_value = NametagGlobals::get_speech_balloon_3d();
            if (return_value != (ChatBalloon *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ChatBalloon,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSpeechBalloon3d()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_get_speech_balloon_3d_167_comment =
    "C++ Interface:\n"
    "getSpeechBalloon3d()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::get_speech_balloon_3d\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the ChatBalloon geometry that will be used\n"
    "//               for rendering speech chat messages by Nametag3d\n"
    "//               objects.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_get_speech_balloon_3d_167_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void NametagGlobals::set_thought_balloon_3d(ChatBalloon *balloon)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_set_thought_balloon_3d_168(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static inline void NametagGlobals::set_thought_balloon_3d(ChatBalloon *balloon)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"balloon", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setThoughtBalloon3d", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:setThoughtBalloon3d", &param0));
            if(!PyErr_Occurred())
            {
                ChatBalloon *param0_this = (ChatBalloon *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ChatBalloon, 0, "NametagGlobals.setThoughtBalloon3d", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    NametagGlobals::set_thought_balloon_3d(param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setThoughtBalloon3d(non-const ChatBalloon balloon)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_set_thought_balloon_3d_168_comment =
    "C++ Interface:\n"
    "setThoughtBalloon3d(non-const ChatBalloon balloon)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::set_thought_balloon_3d\n"
    "//       Access: Published, Static\n"
    "//  Description: Sets the ChatBalloon geometry that will be used for\n"
    "//               rendering thought chat messages by Nametag3d objects.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_set_thought_balloon_3d_168_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline ChatBalloon *NametagGlobals::get_thought_balloon_3d(void)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_get_thought_balloon_3d_169(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline ChatBalloon *NametagGlobals::get_thought_balloon_3d(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getThoughtBalloon3d", key_word_list))
        {
            ChatBalloon *return_value = NametagGlobals::get_thought_balloon_3d();
            if (return_value != (ChatBalloon *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ChatBalloon,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getThoughtBalloon3d()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_get_thought_balloon_3d_169_comment =
    "C++ Interface:\n"
    "getThoughtBalloon3d()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::get_thought_balloon_3d\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the ChatBalloon geometry that will be used\n"
    "//               for rendering thought chat messages by Nametag3d\n"
    "//               objects.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_get_thought_balloon_3d_169_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void NametagGlobals::set_master_nametags_active(bool active)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_set_master_nametags_active_170(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void NametagGlobals::set_master_nametags_active(bool active)
        PyObject *param0;
        static char * key_word_list[] = {(char *)"active", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setMasterNametagsActive", key_word_list, &param0));
        else
            (PyArg_Parse(args, "O:setMasterNametagsActive", &param0));
        if(!PyErr_Occurred())
        {
            NametagGlobals::set_master_nametags_active((PyObject_IsTrue(param0)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMasterNametagsActive(bool active)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_set_master_nametags_active_170_comment =
    "C++ Interface:\n"
    "setMasterNametagsActive(bool active)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::set_master_nametags_active\n"
    "//       Access: Published, Static\n"
    "//  Description: Changes the global flag to disable all Nametags at\n"
    "//               once.  Setting this flag to false makes all Nametags\n"
    "//               in the world inactive (i.e. not pickable); setting\n"
    "//               this to true allows individual Nametags to be active\n"
    "//               or inactive.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_set_master_nametags_active_170_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool NametagGlobals::get_master_nametags_active(void)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_get_master_nametags_active_171(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool NametagGlobals::get_master_nametags_active(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getMasterNametagsActive", key_word_list))
        {
            bool return_value = NametagGlobals::get_master_nametags_active();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMasterNametagsActive()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_get_master_nametags_active_171_comment =
    "C++ Interface:\n"
    "getMasterNametagsActive()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::get_master_nametags_active\n"
    "//       Access: Published, Static\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_get_master_nametags_active_171_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void NametagGlobals::set_master_nametags_visible(bool visible)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_set_master_nametags_visible_172(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void NametagGlobals::set_master_nametags_visible(bool visible)
        PyObject *param0;
        static char * key_word_list[] = {(char *)"visible", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setMasterNametagsVisible", key_word_list, &param0));
        else
            (PyArg_Parse(args, "O:setMasterNametagsVisible", &param0));
        if(!PyErr_Occurred())
        {
            NametagGlobals::set_master_nametags_visible((PyObject_IsTrue(param0)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMasterNametagsVisible(bool visible)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_set_master_nametags_visible_172_comment =
    "C++ Interface:\n"
    "setMasterNametagsVisible(bool visible)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::set_master_nametags_visible\n"
    "//       Access: Published, Static\n"
    "//  Description: Changes the global flag to hide all Nametags at\n"
    "//               once.  Setting this flag to false makes all Nametags\n"
    "//               in the world invisible, including onscreen nametags.\n"
    "//               It affects only the display of names; it does not\n"
    "//               affect chat bubbles or onscreen chat balloons.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_set_master_nametags_visible_172_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool NametagGlobals::get_master_nametags_visible(void)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_get_master_nametags_visible_173(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool NametagGlobals::get_master_nametags_visible(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getMasterNametagsVisible", key_word_list))
        {
            bool return_value = NametagGlobals::get_master_nametags_visible();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMasterNametagsVisible()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_get_master_nametags_visible_173_comment =
    "C++ Interface:\n"
    "getMasterNametagsVisible()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::get_master_nametags_visible\n"
    "//       Access: Published, Static\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_get_master_nametags_visible_173_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void NametagGlobals::set_master_arrows_on(bool active)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_set_master_arrows_on_174(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void NametagGlobals::set_master_arrows_on(bool active)
        PyObject *param0;
        static char * key_word_list[] = {(char *)"active", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setMasterArrowsOn", key_word_list, &param0));
        else
            (PyArg_Parse(args, "O:setMasterArrowsOn", &param0));
        if(!PyErr_Occurred())
        {
            NametagGlobals::set_master_arrows_on((PyObject_IsTrue(param0)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMasterArrowsOn(bool active)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_set_master_arrows_on_174_comment =
    "C++ Interface:\n"
    "setMasterArrowsOn(bool active)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::set_master_arrows_on\n"
    "//       Access: Published, Static\n"
    "//  Description: Changes the global flag to disable all Nametag2d\n"
    "//               names & arrows at once.  Setting this flag to false\n"
    "//               makes all Nametag2ds in the world not display a name\n"
    "//               or arrow (but they will still display speech for\n"
    "//               nearby avatars).  Setting this true lets the\n"
    "//               Nametag2ds display what they want.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_set_master_arrows_on_174_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool NametagGlobals::get_master_arrows_on(void)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_get_master_arrows_on_175(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool NametagGlobals::get_master_arrows_on(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getMasterArrowsOn", key_word_list))
        {
            bool return_value = NametagGlobals::get_master_arrows_on();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMasterArrowsOn()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_get_master_arrows_on_175_comment =
    "C++ Interface:\n"
    "getMasterArrowsOn()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::get_master_arrows_on\n"
    "//       Access: Published, Static\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_get_master_arrows_on_175_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void NametagGlobals::set_onscreen_chat_forced(bool active)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_set_onscreen_chat_forced_176(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void NametagGlobals::set_onscreen_chat_forced(bool active)
        PyObject *param0;
        static char * key_word_list[] = {(char *)"active", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setOnscreenChatForced", key_word_list, &param0));
        else
            (PyArg_Parse(args, "O:setOnscreenChatForced", &param0));
        if(!PyErr_Occurred())
        {
            NametagGlobals::set_onscreen_chat_forced((PyObject_IsTrue(param0)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setOnscreenChatForced(bool active)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_set_onscreen_chat_forced_176_comment =
    "C++ Interface:\n"
    "setOnscreenChatForced(bool active)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::set_onscreen_chat_forced\n"
    "//       Access: Published, Static\n"
    "//  Description: Changes the global flag force all chat messages to\n"
    "//               also be displayed as onscreen chat messages, even if\n"
    "//               their corresponding 3-d nametag appears to be\n"
    "//               onscreen.  This can be used when we're confident that\n"
    "//               that 3-d nametag is obscured by some large onscreen\n"
    "//               panel (like the battle menu).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_set_onscreen_chat_forced_176_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool NametagGlobals::get_onscreen_chat_forced(void)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_get_onscreen_chat_forced_177(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool NametagGlobals::get_onscreen_chat_forced(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getOnscreenChatForced", key_word_list))
        {
            bool return_value = NametagGlobals::get_onscreen_chat_forced();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOnscreenChatForced()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_get_onscreen_chat_forced_177_comment =
    "C++ Interface:\n"
    "getOnscreenChatForced()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::get_onscreen_chat_forced\n"
    "//       Access: Published, Static\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_get_onscreen_chat_forced_177_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void NametagGlobals::set_max_2d_alpha(float alpha)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_set_max_2d_alpha_178(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void NametagGlobals::set_max_2d_alpha(float alpha)
        double param0;
        static char * key_word_list[] = {(char *)"alpha", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setMax2dAlpha", key_word_list, &param0));
        else
            (PyArg_Parse(args, "d:setMax2dAlpha", &param0));
        if(!PyErr_Occurred())
        {
            NametagGlobals::set_max_2d_alpha((float)param0);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMax2dAlpha(float alpha)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_set_max_2d_alpha_178_comment =
    "C++ Interface:\n"
    "setMax2dAlpha(float alpha)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::set_max_2d_alpha\n"
    "//       Access: Published, Static\n"
    "//  Description: Sets the highest level of alpha that is allowed for a\n"
    "//               Nametag2d background.  The Nametag2d will never be\n"
    "//               more opaque than this, despite its color setting in\n"
    "//               NametagGlobals.cxx.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_set_max_2d_alpha_178_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline float NametagGlobals::get_max_2d_alpha(void)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_get_max_2d_alpha_179(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline float NametagGlobals::get_max_2d_alpha(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getMax2dAlpha", key_word_list))
        {
            float return_value = NametagGlobals::get_max_2d_alpha();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMax2dAlpha()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_get_max_2d_alpha_179_comment =
    "C++ Interface:\n"
    "getMax2dAlpha()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::get_max_2d_alpha\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the highest level of alpha that is allowed\n"
    "//               for a Nametag2d background.  See set_max_2d_alpha().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_get_max_2d_alpha_179_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void NametagGlobals::set_min_2d_alpha(float alpha)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_set_min_2d_alpha_180(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void NametagGlobals::set_min_2d_alpha(float alpha)
        double param0;
        static char * key_word_list[] = {(char *)"alpha", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setMin2dAlpha", key_word_list, &param0));
        else
            (PyArg_Parse(args, "d:setMin2dAlpha", &param0));
        if(!PyErr_Occurred())
        {
            NametagGlobals::set_min_2d_alpha((float)param0);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMin2dAlpha(float alpha)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_set_min_2d_alpha_180_comment =
    "C++ Interface:\n"
    "setMin2dAlpha(float alpha)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::set_min_2d_alpha\n"
    "//       Access: Published, Static\n"
    "//  Description: Sets the lowest level of alpha that is allowed for a\n"
    "//               Nametag2d background.  The Nametag2d will never be\n"
    "//               less opaque than this, despite its color setting in\n"
    "//               NametagGlobals.cxx.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_set_min_2d_alpha_180_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline float NametagGlobals::get_min_2d_alpha(void)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_get_min_2d_alpha_181(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline float NametagGlobals::get_min_2d_alpha(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getMin2dAlpha", key_word_list))
        {
            float return_value = NametagGlobals::get_min_2d_alpha();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMin2dAlpha()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_get_min_2d_alpha_181_comment =
    "C++ Interface:\n"
    "getMin2dAlpha()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::get_min_2d_alpha\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the lowest level of alpha that is allowed\n"
    "//               for a Nametag2d background.  See set_min_2d_alpha().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_get_min_2d_alpha_181_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void NametagGlobals::set_global_nametag_scale(float scale)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_set_global_nametag_scale_182(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void NametagGlobals::set_global_nametag_scale(float scale)
        double param0;
        static char * key_word_list[] = {(char *)"scale", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setGlobalNametagScale", key_word_list, &param0));
        else
            (PyArg_Parse(args, "d:setGlobalNametagScale", &param0));
        if(!PyErr_Occurred())
        {
            NametagGlobals::set_global_nametag_scale((float)param0);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setGlobalNametagScale(float scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_set_global_nametag_scale_182_comment =
    "C++ Interface:\n"
    "setGlobalNametagScale(float scale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::set_global_nametag_scale\n"
    "//       Access: Published, Static\n"
    "//  Description: Specifies a global scale factor on all the 3-d\n"
    "//               nametags in the world.  This is in addition to the\n"
    "//               scaling to match the distance from the camera.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_set_global_nametag_scale_182_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline float NametagGlobals::get_global_nametag_scale(void)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_get_global_nametag_scale_183(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline float NametagGlobals::get_global_nametag_scale(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getGlobalNametagScale", key_word_list))
        {
            float return_value = NametagGlobals::get_global_nametag_scale();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGlobalNametagScale()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_get_global_nametag_scale_183_comment =
    "C++ Interface:\n"
    "getGlobalNametagScale()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::get_global_nametag_scale\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the global scale factor on all the 3-d\n"
    "//               nametags in the world.  Normally, this will be 1.0,\n"
    "//               but it might be temporarily adjusted for special\n"
    "//               purposes.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_get_global_nametag_scale_183_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline LVecBase4f const &NametagGlobals::get_name_fg(NametagGroup::ColorCode color_code, PGButton::State state)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_get_name_fg_184(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline LVecBase4f const &NametagGlobals::get_name_fg(NametagGroup::ColorCode color_code, PGButton::State state)
        int param0;
        int param1;
        static char * key_word_list[] = {(char *)"color_code", (char *)"state", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getNameFg", key_word_list, &param0, &param1))
        {
            LVecBase4f const *return_value = &(NametagGlobals::get_name_fg((NametagGroup::ColorCode)param0, (PGButton::State)param1));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNameFg(int color_code, int state)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_get_name_fg_184_comment =
    "C++ Interface:\n"
    "getNameFg(int color_code, int state)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::get_name_fg\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the color of the indicated type of nametag.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_get_name_fg_184_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline LVecBase4f const &NametagGlobals::get_name_bg(NametagGroup::ColorCode color_code, PGButton::State state)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_get_name_bg_185(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline LVecBase4f const &NametagGlobals::get_name_bg(NametagGroup::ColorCode color_code, PGButton::State state)
        int param0;
        int param1;
        static char * key_word_list[] = {(char *)"color_code", (char *)"state", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getNameBg", key_word_list, &param0, &param1))
        {
            LVecBase4f const *return_value = &(NametagGlobals::get_name_bg((NametagGroup::ColorCode)param0, (PGButton::State)param1));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNameBg(int color_code, int state)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_get_name_bg_185_comment =
    "C++ Interface:\n"
    "getNameBg(int color_code, int state)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::get_name_bg\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the color of the indicated type of nametag.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_get_name_bg_185_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline LVecBase4f const &NametagGlobals::get_balloon_modulation_color(void)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_get_balloon_modulation_color_186(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline LVecBase4f const &NametagGlobals::get_balloon_modulation_color(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getBalloonModulationColor", key_word_list))
        {
            LVecBase4f const *return_value = &(NametagGlobals::get_balloon_modulation_color());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBalloonModulationColor()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_get_balloon_modulation_color_186_comment =
    "C++ Interface:\n"
    "getBalloonModulationColor()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::get_balloon_modulation_color\n"
    "//       Access: Public, Static\n"
    "//  Description: Returns the balloon modulation color.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_get_balloon_modulation_color_186_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void NametagGlobals::set_balloon_modulation_color(LVecBase4f const &color)
 *******************************************************************/
static PyObject *Dtool_NametagGlobals_set_balloon_modulation_color_187(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static inline void NametagGlobals::set_balloon_modulation_color(LVecBase4f const &color)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"color", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setBalloonModulationColor", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:setBalloonModulationColor", &param0));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param0_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LVecBase4f, 0, "NametagGlobals.setBalloonModulationColor", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    NametagGlobals::set_balloon_modulation_color(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBalloonModulationColor(const VBase4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NametagGlobals_set_balloon_modulation_color_187_comment =
    "C++ Interface:\n"
    "setBalloonModulationColor(const VBase4 color)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NametagGlobals::set_balloon_modulation_color\n"
    "//       Access: Public, Static\n"
    "//  Description: Sets the balloon modulation color.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NametagGlobals_set_balloon_modulation_color_187_comment = NULL;
#endif

int  Dtool_Init_NametagGlobals(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (NametagGlobals)");
       return -1;
}
inline void  * Dtool_UpcastInterface_NametagGlobals(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_NametagGlobals)
    {
        printf("NametagGlobals ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    NametagGlobals * local_this = (NametagGlobals *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_NametagGlobals)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_NametagGlobals(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_NametagGlobals)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. ChatBalloon | ChatBalloon
//********************************************************************
PyMethodDef Dtool_Methods_ChatBalloon[]= {
  { "generate",(PyCFunction ) &Dtool_ChatBalloon_generate_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ChatBalloon_generate_4_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ChatBalloon(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ChatBalloon.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ChatBalloon\n"
          "// Description : This class encapsulates a model specifically made for\n"
          "//               putting text into as a speech or thought balloon that\n"
          "//               floats over an avatar's head, or appears in a little\n"
          "//               rectangle in the margins onscreen.\n"
          "//\n"
          "//               It is created with a particular model loaded from\n"
          "//               disk, which is expected to include a node named\n"
          "//               \"chatBalloon\", with three children named \"bottom\",\n"
          "//               \"middle\", and \"top\".\n"
          "//\n"
          "//               These nodes will be sized and translated\n"
          "//               appropriately to frame the text as generated.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ReferenceCount._Dtool_ClassInit(NULL);
        Dtool_ChatBalloon.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ReferenceCount.As_PyTypeObject());
        Dtool_ChatBalloon.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ChatBalloon.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ChatBalloon.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ChatBalloon.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ChatBalloon)");
             printf(" Error In PyType_ReadyChatBalloon");
             return;
        }
        Py_INCREF(&Dtool_ChatBalloon.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ChatBalloon.As_PyTypeObject().tp_dict,"ChatBalloon",&Dtool_ChatBalloon.As_PyObject());
        RegisterRuntimeClass(&Dtool_ChatBalloon,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ChatBalloon.As_PyTypeObject());
        PyModule_AddObject(module, "ChatBalloon",(PyObject *)&Dtool_ChatBalloon.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ClickablePopup | ClickablePopup
//********************************************************************
PyMethodDef Dtool_Methods_ClickablePopup[]= {
  { "getClassType",(PyCFunction ) &Dtool_ClickablePopup_get_class_type_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClickablePopup_get_class_type_8_comment},
  { "getType",(PyCFunction ) &Dtool_ClickablePopup_get_type_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClickablePopup_get_type_9_comment},
  { "downcastToNametag",(PyCFunction ) &Dtool_ClickablePopup_downcast_to_Nametag_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClickablePopup_downcast_to_Nametag_25_comment},
  { "downcastToWhisperPopup",(PyCFunction ) &Dtool_ClickablePopup_downcast_to_WhisperPopup_132, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ClickablePopup_downcast_to_WhisperPopup_132_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ClickablePopup(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ClickablePopup.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ClickablePopup\n"
          "// Description : An abstract base class defining the interface to\n"
          "//               something other than a GUI button that appears\n"
          "//               onscreen and may be clicked on with the mouse.  This\n"
          "//               includes 2-d nametags, 3-d nametags, and margin\n"
          "//               messages like whispers.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_ClickablePopup.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_ClickablePopup.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ClickablePopup.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ClickablePopup.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ClickablePopup.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ClickablePopup)");
             printf(" Error In PyType_ReadyClickablePopup");
             return;
        }
        Py_INCREF(&Dtool_ClickablePopup.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ClickablePopup.As_PyTypeObject().tp_dict,"ClickablePopup",&Dtool_ClickablePopup.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_ClickablePopup.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_ClickablePopup[0],&Dtool_ClickablePopup.As_PyObject()));
        RegisterRuntimeClass(&Dtool_ClickablePopup,ClickablePopup::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ClickablePopup.As_PyTypeObject());
        PyModule_AddObject(module, "ClickablePopup",(PyObject *)&Dtool_ClickablePopup.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. MarginPopup | MarginPopup
//********************************************************************
PyMethodDef Dtool_Methods_MarginPopup[]= {
  { "isManaged",(PyCFunction ) &Dtool_MarginPopup_is_managed_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MarginPopup_is_managed_12_comment},
  { "isVisible",(PyCFunction ) &Dtool_MarginPopup_is_visible_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MarginPopup_is_visible_13_comment},
  { "getClassType",(PyCFunction ) &Dtool_MarginPopup_get_class_type_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MarginPopup_get_class_type_14_comment},
  { "downcastToNametag2d",(PyCFunction ) &Dtool_MarginPopup_downcast_to_Nametag2d_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MarginPopup_downcast_to_Nametag2d_48_comment},
  { "downcastToWhisperPopup",(PyCFunction ) &Dtool_MarginPopup_downcast_to_WhisperPopup_130, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MarginPopup_downcast_to_WhisperPopup_130_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_MarginPopup(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_MarginPopup.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : MarginPopup\n"
          "// Description : This is a special kind of Node that represents\n"
          "//               geometry that may appear along the edges of the\n"
          "//               screen during gameplay.  In particular, this will be\n"
          "//               a Nametag2d or a WhisperPopup message.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PandaNode._Dtool_ClassInit(NULL);
        Dtool_MarginPopup.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PandaNode.As_PyTypeObject());
        Dtool_MarginPopup.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_MarginPopup.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_MarginPopup.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_MarginPopup.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(MarginPopup)");
             printf(" Error In PyType_ReadyMarginPopup");
             return;
        }
        Py_INCREF(&Dtool_MarginPopup.As_PyTypeObject());
        PyDict_SetItemString(Dtool_MarginPopup.As_PyTypeObject().tp_dict,"MarginPopup",&Dtool_MarginPopup.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_MarginPopup.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_MarginPopup[2],&Dtool_MarginPopup.As_PyObject()));
        RegisterRuntimeClass(&Dtool_MarginPopup,MarginPopup::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_MarginPopup.As_PyTypeObject());
        PyModule_AddObject(module, "MarginPopup",(PyObject *)&Dtool_MarginPopup.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. MarginManager | MarginManager
//********************************************************************
PyMethodDef Dtool_Methods_MarginManager[]= {
  { "addGridCell",(PyCFunction ) &Dtool_MarginManager_add_grid_cell_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MarginManager_add_grid_cell_17_comment},
  { "addCell",(PyCFunction ) &Dtool_MarginManager_add_cell_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MarginManager_add_cell_18_comment},
  { "setCellAvailable",(PyCFunction ) &Dtool_MarginManager_set_cell_available_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MarginManager_set_cell_available_19_comment},
  { "getCellAvailable",(PyCFunction ) &Dtool_MarginManager_get_cell_available_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MarginManager_get_cell_available_20_comment},
  { "getClassType",(PyCFunction ) &Dtool_MarginManager_get_class_type_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MarginManager_get_class_type_21_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_MarginManager(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_MarginManager.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : MarginManager\n"
          "// Description : This class manages the collection of MarginPopup\n"
          "//               objects visible in the world.  It's responsible for\n"
          "//               parenting them and setting their initial transforms\n"
          "//               to place them properly margin.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PandaNode._Dtool_ClassInit(NULL);
        Dtool_MarginManager.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PandaNode.As_PyTypeObject());
        Dtool_MarginManager.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_MarginManager.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_MarginManager.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_MarginManager.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(MarginManager)");
             printf(" Error In PyType_ReadyMarginManager");
             return;
        }
        Py_INCREF(&Dtool_MarginManager.As_PyTypeObject());
        PyDict_SetItemString(Dtool_MarginManager.As_PyTypeObject().tp_dict,"MarginManager",&Dtool_MarginManager.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_MarginManager.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_MarginManager[4],&Dtool_MarginManager.As_PyObject()));
        RegisterRuntimeClass(&Dtool_MarginManager,MarginManager::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_MarginManager.As_PyTypeObject());
        PyModule_AddObject(module, "MarginManager",(PyObject *)&Dtool_MarginManager.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Nametag | Nametag
//********************************************************************
PyMethodDef Dtool_Methods_Nametag[]= {
  { "setContents",(PyCFunction ) &Dtool_Nametag_set_contents_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Nametag_set_contents_28_comment},
  { "getContents",(PyCFunction ) &Dtool_Nametag_get_contents_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Nametag_get_contents_29_comment},
  { "setActive",(PyCFunction ) &Dtool_Nametag_set_active_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Nametag_set_active_30_comment},
  { "isActive",(PyCFunction ) &Dtool_Nametag_is_active_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Nametag_is_active_31_comment},
  { "displayAsActive",(PyCFunction ) &Dtool_Nametag_display_as_active_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Nametag_display_as_active_32_comment},
  { "hasGroup",(PyCFunction ) &Dtool_Nametag_has_group_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Nametag_has_group_33_comment},
  { "getGroup",(PyCFunction ) &Dtool_Nametag_get_group_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Nametag_get_group_34_comment},
  { "setDrawOrder",(PyCFunction ) &Dtool_Nametag_set_draw_order_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Nametag_set_draw_order_35_comment},
  { "clearDrawOrder",(PyCFunction ) &Dtool_Nametag_clear_draw_order_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Nametag_clear_draw_order_36_comment},
  { "setChatWordwrap",(PyCFunction ) &Dtool_Nametag_set_chat_wordwrap_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Nametag_set_chat_wordwrap_37_comment},
  { "getChatWordwrap",(PyCFunction ) &Dtool_Nametag_get_chat_wordwrap_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Nametag_get_chat_wordwrap_38_comment},
  { "setAvatar",(PyCFunction ) &Dtool_Nametag_set_avatar_39, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Nametag_set_avatar_39_comment},
  { "clearAvatar",(PyCFunction ) &Dtool_Nametag_clear_avatar_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Nametag_clear_avatar_40_comment},
  { "getAvatar",(PyCFunction ) &Dtool_Nametag_get_avatar_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Nametag_get_avatar_41_comment},
  { "getClassType",(PyCFunction ) &Dtool_Nametag_get_class_type_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Nametag_get_class_type_42_comment},
  { "getType",(PyCFunction ) &Dtool_Nametag_get_type_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Nametag_get_type_43_comment},
  { "upcastToReferenceCount",(PyCFunction ) &Dtool_Nametag_upcast_to_ReferenceCount_23, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Nametag_upcast_to_ReferenceCount_23_comment},
  { "upcastToClickablePopup",(PyCFunction ) &Dtool_Nametag_upcast_to_ClickablePopup_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Nametag_upcast_to_ClickablePopup_24_comment},
  { "downcastToNametag2d",(PyCFunction ) &Dtool_Nametag_downcast_to_Nametag2d_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Nametag_downcast_to_Nametag2d_46_comment},
  { "downcastToNametag3d",(PyCFunction ) &Dtool_Nametag_downcast_to_Nametag3d_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Nametag_downcast_to_Nametag3d_53_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Nametag(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Nametag.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : Nametag\n"
          "// Description : This is an abstract base class defining the interface\n"
          "//               to a nametag object.  This is an object that may be\n"
          "//               attached to a NametagGroup and is typically\n"
          "//               associated with an avatar; it displays the avatar's\n"
          "//               name and/or his chat messages, and can be clicked on\n"
          "//               to select the avatar.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ReferenceCount._Dtool_ClassInit(NULL);
        Dtool_ClickablePopup._Dtool_ClassInit(NULL);
        Dtool_Nametag.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_ReferenceCount.As_PyTypeObject(),&Dtool_ClickablePopup.As_PyTypeObject());
        Dtool_Nametag.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Nametag.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Nametag.As_PyTypeObject().tp_dict);
        // Enum  Nametag::Contents;
        PyDict_SetItemString(Dtool_Nametag.As_PyTypeObject().tp_dict,"CName",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_Nametag.As_PyTypeObject().tp_dict,"CSpeech",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_Nametag.As_PyTypeObject().tp_dict,"CThought",PyInt_FromLong(4));
        if(PyType_Ready(&Dtool_Nametag.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Nametag)");
             printf(" Error In PyType_ReadyNametag");
             return;
        }
        Py_INCREF(&Dtool_Nametag.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Nametag.As_PyTypeObject().tp_dict,"Nametag",&Dtool_Nametag.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_Nametag.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_Nametag[14],&Dtool_Nametag.As_PyObject()));
        RegisterRuntimeClass(&Dtool_Nametag,Nametag::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Nametag.As_PyTypeObject());
        PyModule_AddObject(module, "Nametag",(PyObject *)&Dtool_Nametag.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Nametag2d | Nametag2d
//********************************************************************
PyMethodDef Dtool_Methods_Nametag2d[]= {
  { "getClassType",(PyCFunction ) &Dtool_Nametag2d_get_class_type_50, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Nametag2d_get_class_type_50_comment},
  { "upcastToNametag",(PyCFunction ) &Dtool_Nametag2d_upcast_to_Nametag_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Nametag2d_upcast_to_Nametag_45_comment},
  { "upcastToMarginPopup",(PyCFunction ) &Dtool_Nametag2d_upcast_to_MarginPopup_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Nametag2d_upcast_to_MarginPopup_47_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Nametag2d(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Nametag2d.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : Nametag2d\n"
          "// Description : This is a particular kind of Nametag that appears on\n"
          "//               the margins of the screen.\n"
          "//\n"
          "//               Unlike a Nametag3d, a Nametag2d need not be\n"
          "//               explicitly parented to any node.  Instead, it should\n"
          "//               be managed() by an MarginManager, which will be\n"
          "//               responsible for parenting it in an out of the scene\n"
          "//               graph as appropriate.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_Nametag._Dtool_ClassInit(NULL);
        Dtool_MarginPopup._Dtool_ClassInit(NULL);
        Dtool_Nametag2d.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_Nametag.As_PyTypeObject(),&Dtool_MarginPopup.As_PyTypeObject());
        Dtool_Nametag2d.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Nametag2d.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Nametag2d.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Nametag2d.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Nametag2d)");
             printf(" Error In PyType_ReadyNametag2d");
             return;
        }
        Py_INCREF(&Dtool_Nametag2d.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Nametag2d.As_PyTypeObject().tp_dict,"Nametag2d",&Dtool_Nametag2d.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_Nametag2d.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_Nametag2d[0],&Dtool_Nametag2d.As_PyObject()));
        RegisterRuntimeClass(&Dtool_Nametag2d,Nametag2d::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Nametag2d.As_PyTypeObject());
        PyModule_AddObject(module, "Nametag2d",(PyObject *)&Dtool_Nametag2d.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Nametag3d | Nametag3d
//********************************************************************
PyMethodDef Dtool_Methods_Nametag3d[]= {
  { "setBillboardOffset",(PyCFunction ) &Dtool_Nametag3d_set_billboard_offset_57, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Nametag3d_set_billboard_offset_57_comment},
  { "getBillboardOffset",(PyCFunction ) &Dtool_Nametag3d_get_billboard_offset_58, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Nametag3d_get_billboard_offset_58_comment},
  { "getClassType",(PyCFunction ) &Dtool_Nametag3d_get_class_type_59, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Nametag3d_get_class_type_59_comment},
  { "upcastToNametag",(PyCFunction ) &Dtool_Nametag3d_upcast_to_Nametag_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Nametag3d_upcast_to_Nametag_52_comment},
  { "upcastToPandaNode",(PyCFunction ) &Dtool_Nametag3d_upcast_to_PandaNode_54, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Nametag3d_upcast_to_PandaNode_54_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Nametag3d(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Nametag3d.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : Nametag3d\n"
          "// Description : This is a particular kind of Nametag that hovers over\n"
          "//               the avatar's head in the 3-d world.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_Nametag._Dtool_ClassInit(NULL);
        Dtool_PandaNode._Dtool_ClassInit(NULL);
        Dtool_Nametag3d.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_Nametag.As_PyTypeObject(),&Dtool_PandaNode.As_PyTypeObject());
        Dtool_Nametag3d.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Nametag3d.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Nametag3d.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Nametag3d.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Nametag3d)");
             printf(" Error In PyType_ReadyNametag3d");
             return;
        }
        Py_INCREF(&Dtool_Nametag3d.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Nametag3d.As_PyTypeObject().tp_dict,"Nametag3d",&Dtool_Nametag3d.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_Nametag3d.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_Nametag3d[2],&Dtool_Nametag3d.As_PyObject()));
        RegisterRuntimeClass(&Dtool_Nametag3d,Nametag3d::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Nametag3d.As_PyTypeObject());
        PyModule_AddObject(module, "Nametag3d",(PyObject *)&Dtool_Nametag3d.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. NametagFloat2d | NametagFloat2d
//********************************************************************
PyMethodDef Dtool_Methods_NametagFloat2d[]= {
  { "getClassType",(PyCFunction ) &Dtool_NametagFloat2d_get_class_type_62, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagFloat2d_get_class_type_62_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_NametagFloat2d(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_NametagFloat2d.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : NametagFloat2d\n"
          "// Description : This is a user-created Nametag that can be parented\n"
          "//               to some object, not necessarily the avatar, in the\n"
          "//               3-d scene graph.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_Nametag3d._Dtool_ClassInit(NULL);
        Dtool_NametagFloat2d.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_Nametag3d.As_PyTypeObject());
        Dtool_NametagFloat2d.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_NametagFloat2d.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_NametagFloat2d.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_NametagFloat2d.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(NametagFloat2d)");
             printf(" Error In PyType_ReadyNametagFloat2d");
             return;
        }
        Py_INCREF(&Dtool_NametagFloat2d.As_PyTypeObject());
        PyDict_SetItemString(Dtool_NametagFloat2d.As_PyTypeObject().tp_dict,"NametagFloat2d",&Dtool_NametagFloat2d.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_NametagFloat2d.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_NametagFloat2d[0],&Dtool_NametagFloat2d.As_PyObject()));
        RegisterRuntimeClass(&Dtool_NametagFloat2d,NametagFloat2d::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_NametagFloat2d.As_PyTypeObject());
        PyModule_AddObject(module, "NametagFloat2d",(PyObject *)&Dtool_NametagFloat2d.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. NametagFloat3d | NametagFloat3d
//********************************************************************
PyMethodDef Dtool_Methods_NametagFloat3d[]= {
  { "getClassType",(PyCFunction ) &Dtool_NametagFloat3d_get_class_type_65, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagFloat3d_get_class_type_65_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_NametagFloat3d(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_NametagFloat3d.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : NametagFloat3d\n"
          "// Description : This is a user-created Nametag that can be parented\n"
          "//               to some object, not necessarily the avatar, in the\n"
          "//               3-d scene graph.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_Nametag3d._Dtool_ClassInit(NULL);
        Dtool_NametagFloat3d.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_Nametag3d.As_PyTypeObject());
        Dtool_NametagFloat3d.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_NametagFloat3d.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_NametagFloat3d.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_NametagFloat3d.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(NametagFloat3d)");
             printf(" Error In PyType_ReadyNametagFloat3d");
             return;
        }
        Py_INCREF(&Dtool_NametagFloat3d.As_PyTypeObject());
        PyDict_SetItemString(Dtool_NametagFloat3d.As_PyTypeObject().tp_dict,"NametagFloat3d",&Dtool_NametagFloat3d.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_NametagFloat3d.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_NametagFloat3d[0],&Dtool_NametagFloat3d.As_PyObject()));
        RegisterRuntimeClass(&Dtool_NametagFloat3d,NametagFloat3d::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_NametagFloat3d.As_PyTypeObject());
        PyModule_AddObject(module, "NametagFloat3d",(PyObject *)&Dtool_NametagFloat3d.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. NametagGroup | NametagGroup
//********************************************************************
PyMethodDef Dtool_Methods_NametagGroup[]= {
  { "getNametag2d",(PyCFunction ) &Dtool_NametagGroup_get_nametag2d_70, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_get_nametag2d_70_comment},
  { "getNametag3d",(PyCFunction ) &Dtool_NametagGroup_get_nametag3d_71, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_get_nametag3d_71_comment},
  { "addNametag",(PyCFunction ) &Dtool_NametagGroup_add_nametag_72, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_add_nametag_72_comment},
  { "removeNametag",(PyCFunction ) &Dtool_NametagGroup_remove_nametag_73, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_remove_nametag_73_comment},
  { "clearAuxNametags",(PyCFunction ) &Dtool_NametagGroup_clear_aux_nametags_74, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_clear_aux_nametags_74_comment},
  { "getNumNametags",(PyCFunction ) &Dtool_NametagGroup_get_num_nametags_75, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_get_num_nametags_75_comment},
  { "getNametag",(PyCFunction ) &Dtool_NametagGroup_get_nametag_76, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_get_nametag_76_comment},
  { "setFont",(PyCFunction ) &Dtool_NametagGroup_set_font_77, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_set_font_77_comment},
  { "setNameFont",(PyCFunction ) &Dtool_NametagGroup_set_name_font_78, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_set_name_font_78_comment},
  { "getNameFont",(PyCFunction ) &Dtool_NametagGroup_get_name_font_79, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_get_name_font_79_comment},
  { "setChatFont",(PyCFunction ) &Dtool_NametagGroup_set_chat_font_80, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_set_chat_font_80_comment},
  { "getChatFont",(PyCFunction ) &Dtool_NametagGroup_get_chat_font_81, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_get_chat_font_81_comment},
  { "setAvatar",(PyCFunction ) &Dtool_NametagGroup_set_avatar_82, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_set_avatar_82_comment},
  { "getAvatar",(PyCFunction ) &Dtool_NametagGroup_get_avatar_83, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_get_avatar_83_comment},
  { "getNameIcon",(PyCFunction ) &Dtool_NametagGroup_get_name_icon_84, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_get_name_icon_84_comment},
  { "setNameWordwrap",(PyCFunction ) &Dtool_NametagGroup_set_name_wordwrap_85, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_set_name_wordwrap_85_comment},
  { "getNameWordwrap",(PyCFunction ) &Dtool_NametagGroup_get_name_wordwrap_86, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_get_name_wordwrap_86_comment},
  { "setColorCode",(PyCFunction ) &Dtool_NametagGroup_set_color_code_87, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_set_color_code_87_comment},
  { "getColorCode",(PyCFunction ) &Dtool_NametagGroup_get_color_code_88, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_get_color_code_88_comment},
  { "setQtColor",(PyCFunction ) &Dtool_NametagGroup_set_qt_color_89, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_set_qt_color_89_comment},
  { "getQtColor",(PyCFunction ) &Dtool_NametagGroup_get_qt_color_90, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_get_qt_color_90_comment},
  { "getBalloonModulationColor",(PyCFunction ) &Dtool_NametagGroup_get_balloon_modulation_color_91, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_get_balloon_modulation_color_91_comment},
  { "setShadow",(PyCFunction ) &Dtool_NametagGroup_set_shadow_92, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_set_shadow_92_comment},
  { "clearShadow",(PyCFunction ) &Dtool_NametagGroup_clear_shadow_93, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_clear_shadow_93_comment},
  { "hasShadow",(PyCFunction ) &Dtool_NametagGroup_has_shadow_94, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_has_shadow_94_comment},
  { "getShadow",(PyCFunction ) &Dtool_NametagGroup_get_shadow_95, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_get_shadow_95_comment},
  { "setName",(PyCFunction ) &Dtool_NametagGroup_set_name_96, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_set_name_96_comment},
  { "getName",(PyCFunction ) &Dtool_NametagGroup_get_name_97, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_get_name_97_comment},
  { "setDisplayName",(PyCFunction ) &Dtool_NametagGroup_set_display_name_98, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_set_display_name_98_comment},
  { "getDisplayName",(PyCFunction ) &Dtool_NametagGroup_get_display_name_99, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_get_display_name_99_comment},
  { "setChat",(PyCFunction ) &Dtool_NametagGroup_set_chat_100, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_set_chat_100_comment},
  { "clearChat",(PyCFunction ) &Dtool_NametagGroup_clear_chat_101, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_clear_chat_101_comment},
  { "getChat",(PyCFunction ) &Dtool_NametagGroup_get_chat_102, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_get_chat_102_comment},
  { "getStompText",(PyCFunction ) &Dtool_NametagGroup_get_stomp_text_103, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_get_stomp_text_103_comment},
  { "getChatFlags",(PyCFunction ) &Dtool_NametagGroup_get_chat_flags_104, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_get_chat_flags_104_comment},
  { "setPageNumber",(PyCFunction ) &Dtool_NametagGroup_set_page_number_105, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_set_page_number_105_comment},
  { "getPageNumber",(PyCFunction ) &Dtool_NametagGroup_get_page_number_106, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_get_page_number_106_comment},
  { "getNumChatPages",(PyCFunction ) &Dtool_NametagGroup_get_num_chat_pages_107, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_get_num_chat_pages_107_comment},
  { "getChatStomp",(PyCFunction ) &Dtool_NametagGroup_get_chat_stomp_108, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_get_chat_stomp_108_comment},
  { "getStompDelay",(PyCFunction ) &Dtool_NametagGroup_get_stomp_delay_109, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_get_stomp_delay_109_comment},
  { "setUniqueId",(PyCFunction ) &Dtool_NametagGroup_set_unique_id_110, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_set_unique_id_110_comment},
  { "getUniqueId",(PyCFunction ) &Dtool_NametagGroup_get_unique_id_111, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_get_unique_id_111_comment},
  { "setObjectCode",(PyCFunction ) &Dtool_NametagGroup_set_object_code_112, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_set_object_code_112_comment},
  { "getObjectCode",(PyCFunction ) &Dtool_NametagGroup_get_object_code_113, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_get_object_code_113_comment},
  { "click",(PyCFunction ) &Dtool_NametagGroup_click_114, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_click_114_comment},
  { "manage",(PyCFunction ) &Dtool_NametagGroup_manage_115, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_manage_115_comment},
  { "unmanage",(PyCFunction ) &Dtool_NametagGroup_unmanage_116, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_unmanage_116_comment},
  { "isManaged",(PyCFunction ) &Dtool_NametagGroup_is_managed_117, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_is_managed_117_comment},
  { "setContents",(PyCFunction ) &Dtool_NametagGroup_set_contents_118, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_set_contents_118_comment},
  { "getContents",(PyCFunction ) &Dtool_NametagGroup_get_contents_119, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_get_contents_119_comment},
  { "setActive",(PyCFunction ) &Dtool_NametagGroup_set_active_120, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_set_active_120_comment},
  { "isActive",(PyCFunction ) &Dtool_NametagGroup_is_active_121, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_is_active_121_comment},
  { "hasPageButton",(PyCFunction ) &Dtool_NametagGroup_has_page_button_122, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_has_page_button_122_comment},
  { "hasQuitButton",(PyCFunction ) &Dtool_NametagGroup_has_quit_button_123, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_has_quit_button_123_comment},
  { "hasNoQuitButton",(PyCFunction ) &Dtool_NametagGroup_has_no_quit_button_124, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_has_no_quit_button_124_comment},
  { "hasButton",(PyCFunction ) &Dtool_NametagGroup_has_button_125, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_has_button_125_comment},
  { "willHaveButton",(PyCFunction ) &Dtool_NametagGroup_will_have_button_126, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_will_have_button_126_comment},
  { "displayAsActive",(PyCFunction ) &Dtool_NametagGroup_display_as_active_127, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGroup_display_as_active_127_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_NametagGroup(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_NametagGroup.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : NametagGroup\n"
          "// Description : This is a collection of Nametags that are associated\n"
          "//               with a particular avatar.  The primary interface to\n"
          "//               all the nametags is through this Group object.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_NametagGroup.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_NametagGroup.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_NametagGroup.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_NametagGroup.As_PyTypeObject().tp_dict);
        // Enum  NametagGroup::ColorCode;
        PyDict_SetItemString(Dtool_NametagGroup.As_PyTypeObject().tp_dict,"CCNormal",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_NametagGroup.As_PyTypeObject().tp_dict,"CCNoChat",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_NametagGroup.As_PyTypeObject().tp_dict,"CCNonPlayer",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_NametagGroup.As_PyTypeObject().tp_dict,"CCSuit",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_NametagGroup.As_PyTypeObject().tp_dict,"CCToonBuilding",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_NametagGroup.As_PyTypeObject().tp_dict,"CCSuitBuilding",PyInt_FromLong(5));
        PyDict_SetItemString(Dtool_NametagGroup.As_PyTypeObject().tp_dict,"CCHouseBuilding",PyInt_FromLong(6));
        PyDict_SetItemString(Dtool_NametagGroup.As_PyTypeObject().tp_dict,"CCSpeedChat",PyInt_FromLong(7));
        PyDict_SetItemString(Dtool_NametagGroup.As_PyTypeObject().tp_dict,"CCFreeChat",PyInt_FromLong(8));
        if(PyType_Ready(&Dtool_NametagGroup.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(NametagGroup)");
             printf(" Error In PyType_ReadyNametagGroup");
             return;
        }
        Py_INCREF(&Dtool_NametagGroup.As_PyTypeObject());
        PyDict_SetItemString(Dtool_NametagGroup.As_PyTypeObject().tp_dict,"NametagGroup",&Dtool_NametagGroup.As_PyObject());
        RegisterRuntimeClass(&Dtool_NametagGroup,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_NametagGroup.As_PyTypeObject());
        PyModule_AddObject(module, "NametagGroup",(PyObject *)&Dtool_NametagGroup.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. WhisperPopup | WhisperPopup
//********************************************************************
PyMethodDef Dtool_Methods_WhisperPopup[]= {
  { "setClickable",(PyCFunction ) &Dtool_WhisperPopup_set_clickable_136, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WhisperPopup_set_clickable_136_comment},
  { "manage",(PyCFunction ) &Dtool_WhisperPopup_manage_137, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WhisperPopup_manage_137_comment},
  { "unmanage",(PyCFunction ) &Dtool_WhisperPopup_unmanage_138, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WhisperPopup_unmanage_138_comment},
  { "getClassType",(PyCFunction ) &Dtool_WhisperPopup_get_class_type_139, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WhisperPopup_get_class_type_139_comment},
  { "upcastToMarginPopup",(PyCFunction ) &Dtool_WhisperPopup_upcast_to_MarginPopup_129, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WhisperPopup_upcast_to_MarginPopup_129_comment},
  { "upcastToClickablePopup",(PyCFunction ) &Dtool_WhisperPopup_upcast_to_ClickablePopup_131, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WhisperPopup_upcast_to_ClickablePopup_131_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_WhisperPopup(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_WhisperPopup.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : WhisperPopup\n"
          "// Description : This is a whisper message that pops up on the screen\n"
          "//               from someone else in the game.  It's not associated\n"
          "//               with a Nametag, but it occupies the same space in the\n"
          "//               screen that Nametag2d's occupy.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_MarginPopup._Dtool_ClassInit(NULL);
        Dtool_ClickablePopup._Dtool_ClassInit(NULL);
        Dtool_WhisperPopup.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_MarginPopup.As_PyTypeObject(),&Dtool_ClickablePopup.As_PyTypeObject());
        Dtool_WhisperPopup.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_WhisperPopup.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_WhisperPopup.As_PyTypeObject().tp_dict);
        // Enum  WhisperPopup::WhisperType;
        PyDict_SetItemString(Dtool_WhisperPopup.As_PyTypeObject().tp_dict,"WTNormal",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_WhisperPopup.As_PyTypeObject().tp_dict,"WTQuickTalker",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_WhisperPopup.As_PyTypeObject().tp_dict,"WTSystem",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_WhisperPopup.As_PyTypeObject().tp_dict,"WTBattleSOS",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_WhisperPopup.As_PyTypeObject().tp_dict,"WTEmote",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_WhisperPopup.As_PyTypeObject().tp_dict,"WTToontownBoardingGroup",PyInt_FromLong(5));
        if(PyType_Ready(&Dtool_WhisperPopup.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(WhisperPopup)");
             printf(" Error In PyType_ReadyWhisperPopup");
             return;
        }
        Py_INCREF(&Dtool_WhisperPopup.As_PyTypeObject());
        PyDict_SetItemString(Dtool_WhisperPopup.As_PyTypeObject().tp_dict,"WhisperPopup",&Dtool_WhisperPopup.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_WhisperPopup.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_WhisperPopup[3],&Dtool_WhisperPopup.As_PyObject()));
        RegisterRuntimeClass(&Dtool_WhisperPopup,WhisperPopup::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_WhisperPopup.As_PyTypeObject());
        PyModule_AddObject(module, "WhisperPopup",(PyObject *)&Dtool_WhisperPopup.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. NametagGlobals | NametagGlobals
//********************************************************************
PyMethodDef Dtool_Methods_NametagGlobals[]= {
  { "getNameWordwrap",(PyCFunction ) &Dtool_NametagGlobals_get_name_wordwrap_141, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_get_name_wordwrap_141_comment},
  { "getCardPad",(PyCFunction ) &Dtool_NametagGlobals_get_card_pad_142, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_get_card_pad_142_comment},
  { "setCamera",(PyCFunction ) &Dtool_NametagGlobals_set_camera_143, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_set_camera_143_comment},
  { "getCamera",(PyCFunction ) &Dtool_NametagGlobals_get_camera_144, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_get_camera_144_comment},
  { "setToon",(PyCFunction ) &Dtool_NametagGlobals_set_toon_145, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_set_toon_145_comment},
  { "getToon",(PyCFunction ) &Dtool_NametagGlobals_get_toon_146, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_get_toon_146_comment},
  { "setArrowModel",(PyCFunction ) &Dtool_NametagGlobals_set_arrow_model_147, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_set_arrow_model_147_comment},
  { "getArrowModel",(PyCFunction ) &Dtool_NametagGlobals_get_arrow_model_148, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_get_arrow_model_148_comment},
  { "setPageButton",(PyCFunction ) &Dtool_NametagGlobals_set_page_button_149, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_set_page_button_149_comment},
  { "getPageButton",(PyCFunction ) &Dtool_NametagGlobals_get_page_button_150, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_get_page_button_150_comment},
  { "setQuitButton",(PyCFunction ) &Dtool_NametagGlobals_set_quit_button_151, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_set_quit_button_151_comment},
  { "getQuitButton",(PyCFunction ) &Dtool_NametagGlobals_get_quit_button_152, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_get_quit_button_152_comment},
  { "setNametagCard",(PyCFunction ) &Dtool_NametagGlobals_set_nametag_card_153, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_set_nametag_card_153_comment},
  { "getNametagCard",(PyCFunction ) &Dtool_NametagGlobals_get_nametag_card_154, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_get_nametag_card_154_comment},
  { "getNametagCardFrame",(PyCFunction ) &Dtool_NametagGlobals_get_nametag_card_frame_155, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_get_nametag_card_frame_155_comment},
  { "setRolloverSound",(PyCFunction ) &Dtool_NametagGlobals_set_rollover_sound_156, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_set_rollover_sound_156_comment},
  { "getRolloverSound",(PyCFunction ) &Dtool_NametagGlobals_get_rollover_sound_157, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_get_rollover_sound_157_comment},
  { "setClickSound",(PyCFunction ) &Dtool_NametagGlobals_set_click_sound_158, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_set_click_sound_158_comment},
  { "getClickSound",(PyCFunction ) &Dtool_NametagGlobals_get_click_sound_159, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_get_click_sound_159_comment},
  { "setMouseWatcher",(PyCFunction ) &Dtool_NametagGlobals_set_mouse_watcher_160, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_set_mouse_watcher_160_comment},
  { "getMouseWatcher",(PyCFunction ) &Dtool_NametagGlobals_get_mouse_watcher_161, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_get_mouse_watcher_161_comment},
  { "setSpeechBalloon2d",(PyCFunction ) &Dtool_NametagGlobals_set_speech_balloon_2d_162, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_set_speech_balloon_2d_162_comment},
  { "getSpeechBalloon2d",(PyCFunction ) &Dtool_NametagGlobals_get_speech_balloon_2d_163, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_get_speech_balloon_2d_163_comment},
  { "setThoughtBalloon2d",(PyCFunction ) &Dtool_NametagGlobals_set_thought_balloon_2d_164, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_set_thought_balloon_2d_164_comment},
  { "getThoughtBalloon2d",(PyCFunction ) &Dtool_NametagGlobals_get_thought_balloon_2d_165, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_get_thought_balloon_2d_165_comment},
  { "setSpeechBalloon3d",(PyCFunction ) &Dtool_NametagGlobals_set_speech_balloon_3d_166, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_set_speech_balloon_3d_166_comment},
  { "getSpeechBalloon3d",(PyCFunction ) &Dtool_NametagGlobals_get_speech_balloon_3d_167, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_get_speech_balloon_3d_167_comment},
  { "setThoughtBalloon3d",(PyCFunction ) &Dtool_NametagGlobals_set_thought_balloon_3d_168, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_set_thought_balloon_3d_168_comment},
  { "getThoughtBalloon3d",(PyCFunction ) &Dtool_NametagGlobals_get_thought_balloon_3d_169, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_get_thought_balloon_3d_169_comment},
  { "setMasterNametagsActive",(PyCFunction ) &Dtool_NametagGlobals_set_master_nametags_active_170, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_set_master_nametags_active_170_comment},
  { "getMasterNametagsActive",(PyCFunction ) &Dtool_NametagGlobals_get_master_nametags_active_171, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_get_master_nametags_active_171_comment},
  { "setMasterNametagsVisible",(PyCFunction ) &Dtool_NametagGlobals_set_master_nametags_visible_172, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_set_master_nametags_visible_172_comment},
  { "getMasterNametagsVisible",(PyCFunction ) &Dtool_NametagGlobals_get_master_nametags_visible_173, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_get_master_nametags_visible_173_comment},
  { "setMasterArrowsOn",(PyCFunction ) &Dtool_NametagGlobals_set_master_arrows_on_174, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_set_master_arrows_on_174_comment},
  { "getMasterArrowsOn",(PyCFunction ) &Dtool_NametagGlobals_get_master_arrows_on_175, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_get_master_arrows_on_175_comment},
  { "setOnscreenChatForced",(PyCFunction ) &Dtool_NametagGlobals_set_onscreen_chat_forced_176, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_set_onscreen_chat_forced_176_comment},
  { "getOnscreenChatForced",(PyCFunction ) &Dtool_NametagGlobals_get_onscreen_chat_forced_177, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_get_onscreen_chat_forced_177_comment},
  { "setMax2dAlpha",(PyCFunction ) &Dtool_NametagGlobals_set_max_2d_alpha_178, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_set_max_2d_alpha_178_comment},
  { "getMax2dAlpha",(PyCFunction ) &Dtool_NametagGlobals_get_max_2d_alpha_179, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_get_max_2d_alpha_179_comment},
  { "setMin2dAlpha",(PyCFunction ) &Dtool_NametagGlobals_set_min_2d_alpha_180, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_set_min_2d_alpha_180_comment},
  { "getMin2dAlpha",(PyCFunction ) &Dtool_NametagGlobals_get_min_2d_alpha_181, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_get_min_2d_alpha_181_comment},
  { "setGlobalNametagScale",(PyCFunction ) &Dtool_NametagGlobals_set_global_nametag_scale_182, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_set_global_nametag_scale_182_comment},
  { "getGlobalNametagScale",(PyCFunction ) &Dtool_NametagGlobals_get_global_nametag_scale_183, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_get_global_nametag_scale_183_comment},
  { "getNameFg",(PyCFunction ) &Dtool_NametagGlobals_get_name_fg_184, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_get_name_fg_184_comment},
  { "getNameBg",(PyCFunction ) &Dtool_NametagGlobals_get_name_bg_185, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_get_name_bg_185_comment},
  { "getBalloonModulationColor",(PyCFunction ) &Dtool_NametagGlobals_get_balloon_modulation_color_186, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_get_balloon_modulation_color_186_comment},
  { "setBalloonModulationColor",(PyCFunction ) &Dtool_NametagGlobals_set_balloon_modulation_color_187, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NametagGlobals_set_balloon_modulation_color_187_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_NametagGlobals(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_NametagGlobals.As_PyTypeObject().tp_doc =
          "// From PGButton::State.\n"
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : NametagGlobals\n"
          "// Description : This class serves primarily as a storage point for\n"
          "//               global parameters that affect Nametags, both of the\n"
          "//               2-d and 3-d variety.  Some of these can be (and must\n"
          "//               be!) defined at runtime by the Python code; others\n"
          "//               are compiled in.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_NametagGlobals.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_NametagGlobals.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_NametagGlobals.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_NametagGlobals.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(NametagGlobals)");
             printf(" Error In PyType_ReadyNametagGlobals");
             return;
        }
        Py_INCREF(&Dtool_NametagGlobals.As_PyTypeObject());
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"NametagGlobals",&Dtool_NametagGlobals.As_PyObject());
        //  Static Method getNameWordwrap
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"getNameWordwrap",PyCFunction_New(&Dtool_Methods_NametagGlobals[0],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method getCardPad
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"getCardPad",PyCFunction_New(&Dtool_Methods_NametagGlobals[1],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method setCamera
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"setCamera",PyCFunction_New(&Dtool_Methods_NametagGlobals[2],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method getCamera
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"getCamera",PyCFunction_New(&Dtool_Methods_NametagGlobals[3],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method setToon
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"setToon",PyCFunction_New(&Dtool_Methods_NametagGlobals[4],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method getToon
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"getToon",PyCFunction_New(&Dtool_Methods_NametagGlobals[5],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method setArrowModel
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"setArrowModel",PyCFunction_New(&Dtool_Methods_NametagGlobals[6],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method getArrowModel
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"getArrowModel",PyCFunction_New(&Dtool_Methods_NametagGlobals[7],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method setPageButton
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"setPageButton",PyCFunction_New(&Dtool_Methods_NametagGlobals[8],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method getPageButton
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"getPageButton",PyCFunction_New(&Dtool_Methods_NametagGlobals[9],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method setQuitButton
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"setQuitButton",PyCFunction_New(&Dtool_Methods_NametagGlobals[10],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method getQuitButton
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"getQuitButton",PyCFunction_New(&Dtool_Methods_NametagGlobals[11],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method setNametagCard
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"setNametagCard",PyCFunction_New(&Dtool_Methods_NametagGlobals[12],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method getNametagCard
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"getNametagCard",PyCFunction_New(&Dtool_Methods_NametagGlobals[13],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method getNametagCardFrame
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"getNametagCardFrame",PyCFunction_New(&Dtool_Methods_NametagGlobals[14],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method setRolloverSound
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"setRolloverSound",PyCFunction_New(&Dtool_Methods_NametagGlobals[15],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method getRolloverSound
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"getRolloverSound",PyCFunction_New(&Dtool_Methods_NametagGlobals[16],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method setClickSound
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"setClickSound",PyCFunction_New(&Dtool_Methods_NametagGlobals[17],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method getClickSound
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"getClickSound",PyCFunction_New(&Dtool_Methods_NametagGlobals[18],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method setMouseWatcher
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"setMouseWatcher",PyCFunction_New(&Dtool_Methods_NametagGlobals[19],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method getMouseWatcher
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"getMouseWatcher",PyCFunction_New(&Dtool_Methods_NametagGlobals[20],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method setSpeechBalloon2d
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"setSpeechBalloon2d",PyCFunction_New(&Dtool_Methods_NametagGlobals[21],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method getSpeechBalloon2d
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"getSpeechBalloon2d",PyCFunction_New(&Dtool_Methods_NametagGlobals[22],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method setThoughtBalloon2d
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"setThoughtBalloon2d",PyCFunction_New(&Dtool_Methods_NametagGlobals[23],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method getThoughtBalloon2d
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"getThoughtBalloon2d",PyCFunction_New(&Dtool_Methods_NametagGlobals[24],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method setSpeechBalloon3d
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"setSpeechBalloon3d",PyCFunction_New(&Dtool_Methods_NametagGlobals[25],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method getSpeechBalloon3d
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"getSpeechBalloon3d",PyCFunction_New(&Dtool_Methods_NametagGlobals[26],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method setThoughtBalloon3d
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"setThoughtBalloon3d",PyCFunction_New(&Dtool_Methods_NametagGlobals[27],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method getThoughtBalloon3d
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"getThoughtBalloon3d",PyCFunction_New(&Dtool_Methods_NametagGlobals[28],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method setMasterNametagsActive
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"setMasterNametagsActive",PyCFunction_New(&Dtool_Methods_NametagGlobals[29],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method getMasterNametagsActive
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"getMasterNametagsActive",PyCFunction_New(&Dtool_Methods_NametagGlobals[30],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method setMasterNametagsVisible
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"setMasterNametagsVisible",PyCFunction_New(&Dtool_Methods_NametagGlobals[31],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method getMasterNametagsVisible
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"getMasterNametagsVisible",PyCFunction_New(&Dtool_Methods_NametagGlobals[32],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method setMasterArrowsOn
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"setMasterArrowsOn",PyCFunction_New(&Dtool_Methods_NametagGlobals[33],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method getMasterArrowsOn
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"getMasterArrowsOn",PyCFunction_New(&Dtool_Methods_NametagGlobals[34],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method setOnscreenChatForced
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"setOnscreenChatForced",PyCFunction_New(&Dtool_Methods_NametagGlobals[35],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method getOnscreenChatForced
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"getOnscreenChatForced",PyCFunction_New(&Dtool_Methods_NametagGlobals[36],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method setMax2dAlpha
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"setMax2dAlpha",PyCFunction_New(&Dtool_Methods_NametagGlobals[37],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method getMax2dAlpha
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"getMax2dAlpha",PyCFunction_New(&Dtool_Methods_NametagGlobals[38],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method setMin2dAlpha
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"setMin2dAlpha",PyCFunction_New(&Dtool_Methods_NametagGlobals[39],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method getMin2dAlpha
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"getMin2dAlpha",PyCFunction_New(&Dtool_Methods_NametagGlobals[40],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method setGlobalNametagScale
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"setGlobalNametagScale",PyCFunction_New(&Dtool_Methods_NametagGlobals[41],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method getGlobalNametagScale
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"getGlobalNametagScale",PyCFunction_New(&Dtool_Methods_NametagGlobals[42],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method getNameFg
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"getNameFg",PyCFunction_New(&Dtool_Methods_NametagGlobals[43],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method getNameBg
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"getNameBg",PyCFunction_New(&Dtool_Methods_NametagGlobals[44],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method getBalloonModulationColor
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"getBalloonModulationColor",PyCFunction_New(&Dtool_Methods_NametagGlobals[45],&Dtool_NametagGlobals.As_PyObject()));
        //  Static Method setBalloonModulationColor
        PyDict_SetItemString(Dtool_NametagGlobals.As_PyTypeObject().tp_dict,"setBalloonModulationColor",PyCFunction_New(&Dtool_Methods_NametagGlobals[46],&Dtool_NametagGlobals.As_PyObject()));
        RegisterRuntimeClass(&Dtool_NametagGlobals,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_NametagGlobals.As_PyTypeObject());
        PyModule_AddObject(module, "NametagGlobals",(PyObject *)&Dtool_NametagGlobals.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Enums  ..ChatFlags
//********************************************************************
   PyModule_AddIntConstant(module,"CFSpeech",1);
   PyModule_AddIntConstant(module,"CFThought",2);
   PyModule_AddIntConstant(module,"CFQuicktalker",4);
   PyModule_AddIntConstant(module,"CFTimeout",8);
   PyModule_AddIntConstant(module,"CFPageButton",16);
   PyModule_AddIntConstant(module,"CFQuitButton",32);
   PyModule_AddIntConstant(module,"CFReversed",64);
   PyModule_AddIntConstant(module,"CFSndOpenchat",128);
   PyModule_AddIntConstant(module,"CFNoQuitButton",256);
//********************************************************************
//*** Module Init Updcall ..ChatBalloon
//********************************************************************
   Dtool_PyModuleClassInit_ChatBalloon(module);
//********************************************************************
//*** Module Init Updcall ..ClickablePopup
//********************************************************************
   Dtool_PyModuleClassInit_ClickablePopup(module);
//********************************************************************
//*** Module Init Updcall ..MarginPopup
//********************************************************************
   Dtool_PyModuleClassInit_MarginPopup(module);
//********************************************************************
//*** Module Init Updcall ..MarginManager
//********************************************************************
   Dtool_PyModuleClassInit_MarginManager(module);
//********************************************************************
//*** Module Init Updcall ..Nametag
//********************************************************************
   Dtool_PyModuleClassInit_Nametag(module);
//********************************************************************
//*** Module Init Updcall ..Nametag2d
//********************************************************************
   Dtool_PyModuleClassInit_Nametag2d(module);
//********************************************************************
//*** Module Init Updcall ..Nametag3d
//********************************************************************
   Dtool_PyModuleClassInit_Nametag3d(module);
//********************************************************************
//*** Module Init Updcall ..NametagFloat2d
//********************************************************************
   Dtool_PyModuleClassInit_NametagFloat2d(module);
//********************************************************************
//*** Module Init Updcall ..NametagFloat3d
//********************************************************************
   Dtool_PyModuleClassInit_NametagFloat3d(module);
//********************************************************************
//*** Module Init Updcall ..NametagGroup
//********************************************************************
   Dtool_PyModuleClassInit_NametagGroup(module);
//********************************************************************
//*** Module Init Updcall ..WhisperPopup
//********************************************************************
   Dtool_PyModuleClassInit_WhisperPopup(module);
//********************************************************************
//*** Module Init Updcall ..NametagGlobals
//********************************************************************
   Dtool_PyModuleClassInit_NametagGlobals(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libnametag_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687213909,  /* file_identifier */
  "libnametag",  /* library_name */
  "Pj7b",  /* library_hash_name */
  "otp",  /* module_name */
  "libnametag.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  405  /* next_index */
};

Configure(_in_configure_libnametag);
ConfigureFn(_in_configure_libnametag) {
  interrogate_request_module(&_in_module_def);
}

