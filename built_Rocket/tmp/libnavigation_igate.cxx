/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir otp/navigation -Iotp/navigation -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libnavigation_igate.cxx -od built_Rocket/pandac/input/libnavigation.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Iotp/navigation -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_OTP -module otp -library libnavigation navigation_composite1.cxx pathTable.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libnavigation
#include "py_panda.h"  

#include "pathTable.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. PathTable
//********************************************************************
typedef  PathTable  PathTable_localtype;
Define_Module_Class(otp,PathTable,PathTable_localtype,PathTable);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. PathTable 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void PathTable::initTable(PyObject *pathData, PyObject *connections)
 *******************************************************************/
static PyObject *Dtool_PathTable_initTable_4(PyObject *self, PyObject *args,PyObject *kwds) {
    PathTable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PathTable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PathTable::initTable(PyObject *pathData, PyObject *connections)
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"pathData", (char *)"connections", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:initTable", key_word_list, &param1, &param2))
        {
            (local_this)->initTable(param1, param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PathTable.initTable() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "initTable(non-const PathTable this, any pathData, any connections)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PathTable_initTable_4_comment =
    "C++ Interface:\n"
    "initTable(non-const PathTable this, any pathData, any connections)\n"
    "\n"
    "";
#else
static const char * Dtool_PathTable_initTable_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PyObject *PathTable::findRoute(unsigned short int startNode, unsigned short int goalNode)
 *******************************************************************/
static PyObject *Dtool_PathTable_findRoute_5(PyObject *self, PyObject *args,PyObject *kwds) {
    PathTable * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PathTable,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline PyObject *PathTable::findRoute(unsigned short int startNode, unsigned short int goalNode)
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"startNode", (char *)"goalNode", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:findRoute", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                PyObject *return_value = (local_this)->findRoute(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return  return_value;
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PathTable.findRoute() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findRoute(non-const PathTable this, unsigned int startNode, unsigned int goalNode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PathTable_findRoute_5_comment =
    "C++ Interface:\n"
    "findRoute(non-const PathTable this, unsigned int startNode, unsigned int goalNode)\n"
    "\n"
    "// findRoute: Finds all nodes in the optimal path from startNode to goalNode.\n"
    "";
#else
static const char * Dtool_PathTable_findRoute_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PathTable::PathTable(void)
 * PathTable::PathTable(PyObject *pathData, PyObject *connections)
 *******************************************************************/
int  Dtool_Init_PathTable(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-PathTable::PathTable(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PathTable", key_word_list))
            {
                PathTable *return_value = new PathTable();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PathTable,true,false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-PathTable::PathTable(PyObject *pathData, PyObject *connections)
            PyObject *param0;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"pathData", (char *)"connections", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:PathTable", key_word_list, &param0, &param1))
            {
                PathTable *return_value = new PathTable(param0, param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PathTable,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PathTable() takes 0 or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PathTable()\n"
          "PathTable(any pathData, any connections)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PathTable(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PathTable)
    {
        printf("PathTable ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PathTable * local_this = (PathTable *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PathTable)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PathTable(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PathTable)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. PathTable | PathTable
//********************************************************************
PyMethodDef Dtool_Methods_PathTable[]= {
  { "initTable",(PyCFunction ) &Dtool_PathTable_initTable_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PathTable_initTable_4_comment},
  { "findRoute",(PyCFunction ) &Dtool_PathTable_findRoute_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PathTable_findRoute_5_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PathTable(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PathTable.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PathTable\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_PathTable.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_PathTable.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PathTable.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PathTable.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PathTable.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PathTable)");
             printf(" Error In PyType_ReadyPathTable");
             return;
        }
        Py_INCREF(&Dtool_PathTable.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PathTable.As_PyTypeObject().tp_dict,"PathTable",&Dtool_PathTable.As_PyObject());
        RegisterRuntimeClass(&Dtool_PathTable,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PathTable.As_PyTypeObject());
        PyModule_AddObject(module, "PathTable",(PyObject *)&Dtool_PathTable.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..PathTable
//********************************************************************
   Dtool_PyModuleClassInit_PathTable(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libnavigation_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687213916,  /* file_identifier */
  "libnavigation",  /* library_name */
  "nZdk",  /* library_hash_name */
  "otp",  /* module_name */
  "libnavigation.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  15  /* next_index */
};

Configure(_in_configure_libnavigation);
ConfigureFn(_in_configure_libnavigation) {
  interrogate_request_module(&_in_module_def);
}

