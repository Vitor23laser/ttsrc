/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir otp/movement -Iotp/movement -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libmovement_igate.cxx -od built_Rocket/pandac/input/libmovement.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Iotp/movement -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_OTP -module otp -library libmovement cImpulse.cxx cImpulse.h cMover.cxx cMover.h cMoverGroup.cxx cMoverGroup.h config_movement.cxx config_movement.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libmovement
#include "py_panda.h"  

#include "cImpulse.h"
#include "cMover.h"
#include "cMoverGroup.h"
#include "clockObject.h"
#include "config_movement.h"
#include "dconfig.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. CImpulse
//********************************************************************
typedef  CImpulse  CImpulse_localtype;
Define_Module_ClassRef(otp,CImpulse,CImpulse_localtype,CImpulse);
//********************************************************************
//*** prototypes for .. CMover
//********************************************************************
typedef  CMover  CMover_localtype;
Define_Module_ClassRef(otp,CMover,CMover_localtype,CMover);
//********************************************************************
//*** prototypes for .. CMoverGroup
//********************************************************************
typedef  CMoverGroup  CMoverGroup_localtype;
Define_Module_ClassRef(otp,CMoverGroup,CMoverGroup_localtype,CMoverGroup);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVector3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_NodePath;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedReferenceCount;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. CImpulse 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual void CImpulse::process(float dt)
 *******************************************************************/
static PyObject *Dtool_CImpulse_process_4(PyObject *self, PyObject *args,PyObject *kwds) {
    CImpulse * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CImpulse,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void CImpulse::process(float dt)
        double param1;
        static char * key_word_list[] = {(char *)"dt", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:process", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:process", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->process((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CImpulse.process() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "process(non-const CImpulse this, float dt)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CImpulse_process_4_comment =
    "C++ Interface:\n"
    "process(non-const CImpulse this, float dt)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CImpulse::process\n"
    "//       Access: Public, Virtual\n"
    "//  Description: override this and set your impulse's influence for\n"
    "//               this pass on its mover\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CImpulse_process_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void CImpulse::set_mover(CMover &mover)
 *******************************************************************/
static PyObject *Dtool_CImpulse_set_mover_5(PyObject *self, PyObject *args,PyObject *kwds) {
    CImpulse * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CImpulse,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void CImpulse::set_mover(CMover &mover)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"mover", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setMover", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setMover", &param1));
            if(!PyErr_Occurred())
            {
                CMover *param1_this = (CMover *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_CMover, 1, "CImpulse.setMover", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_mover(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CImpulse.setMover() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMover(non-const CImpulse this, non-const CMover mover)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CImpulse_set_mover_5_comment =
    "C++ Interface:\n"
    "setMover(non-const CImpulse this, non-const CMover mover)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CImpulse::set_mover\n"
    "//       Access: Public, Virtual\n"
    "//  Description: called internally by cMover when we're added\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CImpulse_set_mover_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void CImpulse::clear_mover(CMover &mover)
 *******************************************************************/
static PyObject *Dtool_CImpulse_clear_mover_6(PyObject *self, PyObject *args,PyObject *kwds) {
    CImpulse * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CImpulse,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void CImpulse::clear_mover(CMover &mover)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"mover", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:clearMover", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:clearMover", &param1));
            if(!PyErr_Occurred())
            {
                CMover *param1_this = (CMover *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_CMover, 1, "CImpulse.clearMover", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->clear_mover(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CImpulse.clearMover() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearMover(non-const CImpulse this, non-const CMover mover)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CImpulse_clear_mover_6_comment =
    "C++ Interface:\n"
    "clearMover(non-const CImpulse this, non-const CMover mover)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CImpulse::clear_mover\n"
    "//       Access: Public, Virtual\n"
    "//  Description: called internally by cMover when we're removed\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CImpulse_clear_mover_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CMover *CImpulse::get_mover(void) const
 *******************************************************************/
static PyObject *Dtool_CImpulse_get_mover_7(PyObject *self, PyObject *args,PyObject *kwds) {
    CImpulse * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CImpulse,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline CMover *CImpulse::get_mover(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMover", key_word_list));
        else
            (PyArg_Parse(args, ":getMover"));
        if(!PyErr_Occurred())
        {
            CMover *return_value = ((const CImpulse*)local_this)->get_mover();
            if (return_value != (CMover *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_CMover,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMover(const CImpulse this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CImpulse_get_mover_7_comment =
    "C++ Interface:\n"
    "getMover(const CImpulse this)\n"
    "\n"
    "// Filename: cImpulse.I\n"
    "// Created by:  darren (13Jul04)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CImpulse::get_mover\n"
    "//       Access: Published\n"
    "//  Description: Returns pointer to mover obj that we're attached to;\n"
    "//               may be 0.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CImpulse_get_mover_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NodePath CImpulse::get_node_path(void) const
 *******************************************************************/
static PyObject *Dtool_CImpulse_get_node_path_8(PyObject *self, PyObject *args,PyObject *kwds) {
    CImpulse * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CImpulse,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NodePath CImpulse::get_node_path(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNodePath", key_word_list));
        else
            (PyArg_Parse(args, ":getNodePath"));
        if(!PyErr_Occurred())
        {
            NodePath result = ((const CImpulse*)local_this)->get_node_path();
            NodePath *return_value = new NodePath(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNodePath(const CImpulse this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CImpulse_get_node_path_8_comment =
    "C++ Interface:\n"
    "getNodePath(const CImpulse this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CImpulse::get_node_path\n"
    "//       Access: Published\n"
    "//  Description: Returns NodePath that our mover is moving around.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CImpulse_get_node_path_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CImpulse::is_cpp(void) const
 *******************************************************************/
static PyObject *Dtool_CImpulse_is_cpp_9(PyObject *self, PyObject *args,PyObject *kwds) {
    CImpulse * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CImpulse,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CImpulse::is_cpp(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isCpp", key_word_list));
        else
            (PyArg_Parse(args, ":isCpp"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CImpulse*)local_this)->is_cpp();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isCpp(const CImpulse this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CImpulse_is_cpp_9_comment =
    "C++ Interface:\n"
    "isCpp(const CImpulse this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CImpulse::is_cpp\n"
    "//       Access: Published\n"
    "//  Description: Indicates the state the interval believes it is in:\n"
    "//               whether it has been started, is currently in the\n"
    "//               middle, or has been finalized.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CImpulse_is_cpp_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CImpulse::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CImpulse_get_class_type_10(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CImpulse::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CImpulse::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CImpulse_get_class_type_10_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CImpulse_get_class_type_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CImpulse::CImpulse(void)
 *******************************************************************/
int  Dtool_Init_CImpulse(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-CImpulse::CImpulse(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":CImpulse", key_word_list))
        {
            CImpulse *return_value = new CImpulse();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_CImpulse,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "CImpulse()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CImpulse(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CImpulse)
    {
        printf("CImpulse ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CImpulse * local_this = (CImpulse *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CImpulse)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CImpulse(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CImpulse)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CImpulse*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CImpulse*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (CImpulse*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CMover 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void CMover::set_fwd_speed(float fwd_speed)
 *******************************************************************/
static PyObject *Dtool_CMover_set_fwd_speed_13(PyObject *self, PyObject *args,PyObject *kwds) {
    CMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CMover::set_fwd_speed(float fwd_speed)
        double param1;
        static char * key_word_list[] = {(char *)"fwd_speed", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setFwdSpeed", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setFwdSpeed", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_fwd_speed((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CMover.setFwdSpeed() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFwdSpeed(non-const CMover this, float fwd_speed)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMover_set_fwd_speed_13_comment =
    "C++ Interface:\n"
    "setFwdSpeed(non-const CMover this, float fwd_speed)\n"
    "\n"
    "// Filename: cMover.I\n"
    "// Created by:  darren (13Jul04)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMover::set_fwd_speed\n"
    "//       Access: Published\n"
    "//  Description: Sets the speed that impulses should use when moving\n"
    "//               forward\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMover_set_fwd_speed_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CMover::set_rot_speed(float rot_speed)
 *******************************************************************/
static PyObject *Dtool_CMover_set_rot_speed_14(PyObject *self, PyObject *args,PyObject *kwds) {
    CMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CMover::set_rot_speed(float rot_speed)
        double param1;
        static char * key_word_list[] = {(char *)"rot_speed", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setRotSpeed", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setRotSpeed", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_rot_speed((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CMover.setRotSpeed() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRotSpeed(non-const CMover this, float rot_speed)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMover_set_rot_speed_14_comment =
    "C++ Interface:\n"
    "setRotSpeed(non-const CMover this, float rot_speed)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMover::set_rot_speed\n"
    "//       Access: Published\n"
    "//  Description: Sets the speed that impulses should use when rotating\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMover_set_rot_speed_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float CMover::get_fwd_speed(void) const
 *******************************************************************/
static PyObject *Dtool_CMover_get_fwd_speed_15(PyObject *self, PyObject *args,PyObject *kwds) {
    CMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float CMover::get_fwd_speed(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFwdSpeed", key_word_list));
        else
            (PyArg_Parse(args, ":getFwdSpeed"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const CMover*)local_this)->get_fwd_speed();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFwdSpeed(const CMover this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMover_get_fwd_speed_15_comment =
    "C++ Interface:\n"
    "getFwdSpeed(const CMover this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMover::get_fwd_speed\n"
    "//       Access: Published\n"
    "//  Description: Returns the speed that impulses should use when moving\n"
    "//               forward\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMover_get_fwd_speed_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float CMover::get_rot_speed(void) const
 *******************************************************************/
static PyObject *Dtool_CMover_get_rot_speed_16(PyObject *self, PyObject *args,PyObject *kwds) {
    CMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float CMover::get_rot_speed(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRotSpeed", key_word_list));
        else
            (PyArg_Parse(args, ":getRotSpeed"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const CMover*)local_this)->get_rot_speed();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRotSpeed(const CMover this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMover_get_rot_speed_16_comment =
    "C++ Interface:\n"
    "getRotSpeed(const CMover this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMover::get_rot_speed\n"
    "//       Access: Published\n"
    "//  Description: Returns the speed that impulses should use when rotating\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMover_get_rot_speed_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CMover::add_c_impulse(basic_string< char > const &name, CImpulse *impulse)
 *******************************************************************/
static PyObject *Dtool_CMover_add_c_impulse_17(PyObject *self, PyObject *args,PyObject *kwds) {
    CMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void CMover::add_c_impulse(basic_string< char > const &name, CImpulse *impulse)
            char *param1_str; int param1_len;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"name", (char *)"impulse", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:addCImpulse", key_word_list, &param1_str, &param1_len, &param2))
            {
                CImpulse *param2_this = (CImpulse *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_CImpulse, 2, "CMover.addCImpulse", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->add_c_impulse(basic_string<char>(param1_str, param1_len), param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CMover.addCImpulse() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addCImpulse(non-const CMover this, string name, non-const CImpulse impulse)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMover_add_c_impulse_17_comment =
    "C++ Interface:\n"
    "addCImpulse(non-const CMover this, string name, non-const CImpulse impulse)\n"
    "\n"
    "";
#else
static const char * Dtool_CMover_add_c_impulse_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool CMover::remove_c_impulse(basic_string< char > const &name)
 *******************************************************************/
static PyObject *Dtool_CMover_remove_c_impulse_18(PyObject *self, PyObject *args,PyObject *kwds) {
    CMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool CMover::remove_c_impulse(basic_string< char > const &name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:removeCImpulse", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:removeCImpulse", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->remove_c_impulse(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CMover.removeCImpulse() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeCImpulse(non-const CMover this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMover_remove_c_impulse_18_comment =
    "C++ Interface:\n"
    "removeCImpulse(non-const CMover this, string name)\n"
    "\n"
    "";
#else
static const char * Dtool_CMover_remove_c_impulse_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CMover::process_c_impulses(float dt)
 * void CMover::process_c_impulses(float dt = (-1))
 *******************************************************************/
static PyObject *Dtool_CMover_process_c_impulses_19(PyObject *self, PyObject *args,PyObject *kwds) {
    CMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void CMover::process_c_impulses(float dt = (-1))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":processCImpulses", key_word_list));
            else
                (PyArg_Parse(args, ":processCImpulses"));
            if(!PyErr_Occurred())
            {
                (local_this)->process_c_impulses();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CMover.processCImpulses() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void CMover::process_c_impulses(float dt)
            double param1;
            static char * key_word_list[] = {(char *)"dt", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:processCImpulses", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:processCImpulses", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->process_c_impulses((float)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CMover.processCImpulses() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "processCImpulses() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "processCImpulses(non-const CMover this)\n"
          "processCImpulses(non-const CMover this, float dt)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMover_process_c_impulses_19_comment =
    "C++ Interface:\n"
    "processCImpulses(non-const CMover this)\n"
    "processCImpulses(non-const CMover this, float dt)\n"
    "\n"
    "";
#else
static const char * Dtool_CMover_process_c_impulses_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CMover::integrate(void)
 *******************************************************************/
static PyObject *Dtool_CMover_integrate_20(PyObject *self, PyObject *args,PyObject *kwds) {
    CMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CMover::integrate(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":integrate", key_word_list));
        else
            (PyArg_Parse(args, ":integrate"));
        if(!PyErr_Occurred())
        {
            (local_this)->integrate();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CMover.integrate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "integrate(non-const CMover this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMover_integrate_20_comment =
    "C++ Interface:\n"
    "integrate(non-const CMover this)\n"
    "\n"
    "";
#else
static const char * Dtool_CMover_integrate_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CMover::add_force(LVector3f const &force)
 *******************************************************************/
static PyObject *Dtool_CMover_add_force_21(PyObject *self, PyObject *args,PyObject *kwds) {
    CMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CMover::add_force(LVector3f const &force)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"force", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addForce", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addForce", &param1));
            if(!PyErr_Occurred())
            {
                LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "CMover.addForce", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_force(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CMover.addForce() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addForce(non-const CMover this, const Vec3 force)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMover_add_force_21_comment =
    "C++ Interface:\n"
    "addForce(non-const CMover this, const Vec3 force)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMover::add_force\n"
    "//       Access: Published\n"
    "//  Description: Called by impulses during CMover::move()\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMover_add_force_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CMover::add_rot_force(LVector3f const &rot_force)
 *******************************************************************/
static PyObject *Dtool_CMover_add_rot_force_22(PyObject *self, PyObject *args,PyObject *kwds) {
    CMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CMover::add_rot_force(LVector3f const &rot_force)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"rot_force", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addRotForce", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addRotForce", &param1));
            if(!PyErr_Occurred())
            {
                LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "CMover.addRotForce", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_rot_force(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CMover.addRotForce() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addRotForce(non-const CMover this, const Vec3 rot_force)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMover_add_rot_force_22_comment =
    "C++ Interface:\n"
    "addRotForce(non-const CMover this, const Vec3 rot_force)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMover::add_rot_force\n"
    "//       Access: Published\n"
    "//  Description: Called by impulses during CMover::move()\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMover_add_rot_force_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CMover::add_shove(LVector3f const &shove)
 *******************************************************************/
static PyObject *Dtool_CMover_add_shove_23(PyObject *self, PyObject *args,PyObject *kwds) {
    CMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CMover::add_shove(LVector3f const &shove)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"shove", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addShove", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addShove", &param1));
            if(!PyErr_Occurred())
            {
                LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "CMover.addShove", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_shove(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CMover.addShove() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addShove(non-const CMover this, const Vec3 shove)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMover_add_shove_23_comment =
    "C++ Interface:\n"
    "addShove(non-const CMover this, const Vec3 shove)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMover::add_shove\n"
    "//       Access: Published\n"
    "//  Description: Called by impulses during CMover::move()\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMover_add_shove_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CMover::add_rot_shove(LVector3f const &rot_shove)
 *******************************************************************/
static PyObject *Dtool_CMover_add_rot_shove_24(PyObject *self, PyObject *args,PyObject *kwds) {
    CMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CMover::add_rot_shove(LVector3f const &rot_shove)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"rot_shove", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addRotShove", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addRotShove", &param1));
            if(!PyErr_Occurred())
            {
                LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "CMover.addRotShove", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_rot_shove(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CMover.addRotShove() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addRotShove(non-const CMover this, const Vec3 rot_shove)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMover_add_rot_shove_24_comment =
    "C++ Interface:\n"
    "addRotShove(non-const CMover this, const Vec3 rot_shove)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMover::add_rot_shove\n"
    "//       Access: Published\n"
    "//  Description: Called by impulses during CMover::move()\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMover_add_rot_shove_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NodePath CMover::get_node_path(void) const
 *******************************************************************/
static PyObject *Dtool_CMover_get_node_path_25(PyObject *self, PyObject *args,PyObject *kwds) {
    CMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NodePath CMover::get_node_path(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNodePath", key_word_list));
        else
            (PyArg_Parse(args, ":getNodePath"));
        if(!PyErr_Occurred())
        {
            NodePath result = ((const CMover*)local_this)->get_node_path();
            NodePath *return_value = new NodePath(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNodePath(const CMover this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMover_get_node_path_25_comment =
    "C++ Interface:\n"
    "getNodePath(const CMover this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMover::get_node_path\n"
    "//       Access: Published\n"
    "//  Description: Returns nodepath being moved by this mover\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMover_get_node_path_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float CMover::get_dt(void) const
 *******************************************************************/
static PyObject *Dtool_CMover_get_dt_26(PyObject *self, PyObject *args,PyObject *kwds) {
    CMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float CMover::get_dt(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDt", key_word_list));
        else
            (PyArg_Parse(args, ":getDt"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const CMover*)local_this)->get_dt();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDt(const CMover this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMover_get_dt_26_comment =
    "C++ Interface:\n"
    "getDt(const CMover this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMover::get_dt\n"
    "//       Access: Published\n"
    "//  Description: Returns dt from last call to move()\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMover_get_dt_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CMover::reset_dt(void)
 *******************************************************************/
static PyObject *Dtool_CMover_reset_dt_27(PyObject *self, PyObject *args,PyObject *kwds) {
    CMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CMover::reset_dt(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":resetDt", key_word_list));
        else
            (PyArg_Parse(args, ":resetDt"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_dt();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CMover.resetDt() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetDt(non-const CMover this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMover_reset_dt_27_comment =
    "C++ Interface:\n"
    "resetDt(non-const CMover this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMoverGroup::reset_dt\n"
    "//       Access: Published\n"
    "//  Description: ignores time elapsed since last set_dt, call if\n"
    "//               mover group has not been moved in a long time\n"
    "//               and you don't want objects to move as if they\n"
    "//               were moving the whole time\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMover_reset_dt_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CMover::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CMover_get_class_type_28(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CMover::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CMover::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMover_get_class_type_28_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CMover_get_class_type_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CMover::CMover(NodePath &objNodePath, float fwd_speed, float rot_speed)
 * CMover::CMover(NodePath &objNodePath, float fwd_speed, float rot_speed = (1))
 * CMover::CMover(NodePath &objNodePath, float fwd_speed = (1), float rot_speed = (1))
 *******************************************************************/
int  Dtool_Init_CMover(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-CMover::CMover(NodePath &objNodePath, float fwd_speed = (1), float rot_speed = (1))
                PyObject *param0;
                static char * key_word_list[] = {(char *)"objNodePath", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:CMover", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:CMover", &param0));
                if(!PyErr_Occurred())
                {
                    NodePath *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_NodePath, 0, "CMover.CMover", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        CMover *return_value = new CMover(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_CMover,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-CMover::CMover(NodePath &objNodePath, float fwd_speed, float rot_speed = (1))
                PyObject *param0;
                double param1;
                static char * key_word_list[] = {(char *)"objNodePath", (char *)"fwd_speed", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Od:CMover", key_word_list, &param0, &param1))
                {
                    NodePath *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_NodePath, 0, "CMover.CMover", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        CMover *return_value = new CMover(*param0_this, (float)param1);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_CMover,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-CMover::CMover(NodePath &objNodePath, float fwd_speed, float rot_speed)
                PyObject *param0;
                double param1;
                double param2;
                static char * key_word_list[] = {(char *)"objNodePath", (char *)"fwd_speed", (char *)"rot_speed", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Odd:CMover", key_word_list, &param0, &param1, &param2))
                {
                    NodePath *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_NodePath, 0, "CMover.CMover", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        CMover *return_value = new CMover(*param0_this, (float)param1, (float)param2);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_CMover,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "CMover() takes 1, 2, or 3 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "CMover(non-const NodePath objNodePath)\n"
          "CMover(non-const NodePath objNodePath, float fwd_speed)\n"
          "CMover(non-const NodePath objNodePath, float fwd_speed, float rot_speed)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CMover(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CMover)
    {
        printf("CMover ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CMover * local_this = (CMover *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CMover)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CMover(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CMover)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CMover*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CMover*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (CMover*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CMoverGroup 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void CMoverGroup::add_c_mover(basic_string< char > const &name, CMover *mover)
 *******************************************************************/
static PyObject *Dtool_CMoverGroup_add_c_mover_31(PyObject *self, PyObject *args,PyObject *kwds) {
    CMoverGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMoverGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void CMoverGroup::add_c_mover(basic_string< char > const &name, CMover *mover)
            char *param1_str; int param1_len;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"name", (char *)"mover", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:addCMover", key_word_list, &param1_str, &param1_len, &param2))
            {
                CMover *param2_this = (CMover *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_CMover, 2, "CMoverGroup.addCMover", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->add_c_mover(basic_string<char>(param1_str, param1_len), param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CMoverGroup.addCMover() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addCMover(non-const CMoverGroup this, string name, non-const CMover mover)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMoverGroup_add_c_mover_31_comment =
    "C++ Interface:\n"
    "addCMover(non-const CMoverGroup this, string name, non-const CMover mover)\n"
    "\n"
    "";
#else
static const char * Dtool_CMoverGroup_add_c_mover_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool CMoverGroup::remove_c_mover(basic_string< char > const &name)
 *******************************************************************/
static PyObject *Dtool_CMoverGroup_remove_c_mover_32(PyObject *self, PyObject *args,PyObject *kwds) {
    CMoverGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMoverGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool CMoverGroup::remove_c_mover(basic_string< char > const &name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:removeCMover", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:removeCMover", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->remove_c_mover(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CMoverGroup.removeCMover() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeCMover(non-const CMoverGroup this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMoverGroup_remove_c_mover_32_comment =
    "C++ Interface:\n"
    "removeCMover(non-const CMoverGroup this, string name)\n"
    "\n"
    "";
#else
static const char * Dtool_CMoverGroup_remove_c_mover_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float CMoverGroup::set_dt(float dt)
 * inline float CMoverGroup::set_dt(float dt = (-1))
 *******************************************************************/
static PyObject *Dtool_CMoverGroup_set_dt_33(PyObject *self, PyObject *args,PyObject *kwds) {
    CMoverGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMoverGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline float CMoverGroup::set_dt(float dt = (-1))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":setDt", key_word_list));
            else
                (PyArg_Parse(args, ":setDt"));
            if(!PyErr_Occurred())
            {
                float return_value = (local_this)->set_dt();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CMoverGroup.setDt() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline float CMoverGroup::set_dt(float dt)
            double param1;
            static char * key_word_list[] = {(char *)"dt", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:setDt", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:setDt", &param1));
            if(!PyErr_Occurred())
            {
                float return_value = (local_this)->set_dt((float)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CMoverGroup.setDt() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setDt() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setDt(non-const CMoverGroup this)\n"
          "setDt(non-const CMoverGroup this, float dt)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMoverGroup_set_dt_33_comment =
    "C++ Interface:\n"
    "setDt(non-const CMoverGroup this)\n"
    "setDt(non-const CMoverGroup this, float dt)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMoverGroup::set_dt\n"
    "//       Access: Published\n"
    "//  Description: sets dt for current frame, calculates if -1 is passed\n"
    "//               returns dt for current frame\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMoverGroup_set_dt_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float CMoverGroup::get_dt(void) const
 *******************************************************************/
static PyObject *Dtool_CMoverGroup_get_dt_34(PyObject *self, PyObject *args,PyObject *kwds) {
    CMoverGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMoverGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float CMoverGroup::get_dt(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDt", key_word_list));
        else
            (PyArg_Parse(args, ":getDt"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const CMoverGroup*)local_this)->get_dt();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDt(const CMoverGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMoverGroup_get_dt_34_comment =
    "C++ Interface:\n"
    "getDt(const CMoverGroup this)\n"
    "\n"
    "// Filename: cMoverGroup.I\n"
    "// Created by:  darren (13Mar07)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMoverGroup::get_dt\n"
    "//       Access: Published\n"
    "//  Description: Returns dt from last call to set_dt\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMoverGroup_get_dt_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CMoverGroup::reset_dt(void)
 *******************************************************************/
static PyObject *Dtool_CMoverGroup_reset_dt_35(PyObject *self, PyObject *args,PyObject *kwds) {
    CMoverGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMoverGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CMoverGroup::reset_dt(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":resetDt", key_word_list));
        else
            (PyArg_Parse(args, ":resetDt"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_dt();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CMoverGroup.resetDt() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetDt(non-const CMoverGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMoverGroup_reset_dt_35_comment =
    "C++ Interface:\n"
    "resetDt(non-const CMoverGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMoverGroup::reset_dt\n"
    "//       Access: Published\n"
    "//  Description: ignores time elapsed since last set_dt, call if\n"
    "//               mover group has not been moved in a long time\n"
    "//               and you don't want objects to move as if they\n"
    "//               were moving the whole time\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMoverGroup_reset_dt_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CMoverGroup::process_c_impulses_and_integrate(void)
 *******************************************************************/
static PyObject *Dtool_CMoverGroup_process_c_impulses_and_integrate_36(PyObject *self, PyObject *args,PyObject *kwds) {
    CMoverGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMoverGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CMoverGroup::process_c_impulses_and_integrate(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":processCImpulsesAndIntegrate", key_word_list));
        else
            (PyArg_Parse(args, ":processCImpulsesAndIntegrate"));
        if(!PyErr_Occurred())
        {
            (local_this)->process_c_impulses_and_integrate();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CMoverGroup.processCImpulsesAndIntegrate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "processCImpulsesAndIntegrate(non-const CMoverGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMoverGroup_process_c_impulses_and_integrate_36_comment =
    "C++ Interface:\n"
    "processCImpulsesAndIntegrate(non-const CMoverGroup this)\n"
    "\n"
    "// processes C++ impulses and integrates; call set_dt first\n"
    "";
#else
static const char * Dtool_CMoverGroup_process_c_impulses_and_integrate_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CMoverGroup::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CMoverGroup_get_class_type_37(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CMoverGroup::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CMoverGroup::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMoverGroup_get_class_type_37_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CMoverGroup_get_class_type_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CMoverGroup::CMoverGroup(void)
 *******************************************************************/
int  Dtool_Init_CMoverGroup(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-CMoverGroup::CMoverGroup(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":CMoverGroup", key_word_list))
        {
            CMoverGroup *return_value = new CMoverGroup();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_CMoverGroup,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "CMoverGroup()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CMoverGroup(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CMoverGroup)
    {
        printf("CMoverGroup ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CMoverGroup * local_this = (CMoverGroup *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CMoverGroup)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CMoverGroup(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CMoverGroup)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CMoverGroup*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CMoverGroup*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (CMoverGroup*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. CImpulse | CImpulse
//********************************************************************
PyMethodDef Dtool_Methods_CImpulse[]= {
  { "process",(PyCFunction ) &Dtool_CImpulse_process_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CImpulse_process_4_comment},
  { "setMover",(PyCFunction ) &Dtool_CImpulse_set_mover_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CImpulse_set_mover_5_comment},
  { "clearMover",(PyCFunction ) &Dtool_CImpulse_clear_mover_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CImpulse_clear_mover_6_comment},
  { "getMover",(PyCFunction ) &Dtool_CImpulse_get_mover_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CImpulse_get_mover_7_comment},
  { "getNodePath",(PyCFunction ) &Dtool_CImpulse_get_node_path_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CImpulse_get_node_path_8_comment},
  { "isCpp",(PyCFunction ) &Dtool_CImpulse_is_cpp_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CImpulse_is_cpp_9_comment},
  { "getClassType",(PyCFunction ) &Dtool_CImpulse_get_class_type_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CImpulse_get_class_type_10_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CImpulse(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_CImpulse.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_CImpulse.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CImpulse.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CImpulse.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CImpulse.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CImpulse)");
             printf(" Error In PyType_ReadyCImpulse");
             return;
        }
        Py_INCREF(&Dtool_CImpulse.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CImpulse.As_PyTypeObject().tp_dict,"CImpulse",&Dtool_CImpulse.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CImpulse.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CImpulse[6],&Dtool_CImpulse.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CImpulse,CImpulse::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CImpulse.As_PyTypeObject());
        PyModule_AddObject(module, "CImpulse",(PyObject *)&Dtool_CImpulse.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CMover | CMover
//********************************************************************
PyMethodDef Dtool_Methods_CMover[]= {
  { "setFwdSpeed",(PyCFunction ) &Dtool_CMover_set_fwd_speed_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMover_set_fwd_speed_13_comment},
  { "setRotSpeed",(PyCFunction ) &Dtool_CMover_set_rot_speed_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMover_set_rot_speed_14_comment},
  { "getFwdSpeed",(PyCFunction ) &Dtool_CMover_get_fwd_speed_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMover_get_fwd_speed_15_comment},
  { "getRotSpeed",(PyCFunction ) &Dtool_CMover_get_rot_speed_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMover_get_rot_speed_16_comment},
  { "addCImpulse",(PyCFunction ) &Dtool_CMover_add_c_impulse_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMover_add_c_impulse_17_comment},
  { "removeCImpulse",(PyCFunction ) &Dtool_CMover_remove_c_impulse_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMover_remove_c_impulse_18_comment},
  { "processCImpulses",(PyCFunction ) &Dtool_CMover_process_c_impulses_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMover_process_c_impulses_19_comment},
  { "integrate",(PyCFunction ) &Dtool_CMover_integrate_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMover_integrate_20_comment},
  { "addForce",(PyCFunction ) &Dtool_CMover_add_force_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMover_add_force_21_comment},
  { "addRotForce",(PyCFunction ) &Dtool_CMover_add_rot_force_22, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMover_add_rot_force_22_comment},
  { "addShove",(PyCFunction ) &Dtool_CMover_add_shove_23, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMover_add_shove_23_comment},
  { "addRotShove",(PyCFunction ) &Dtool_CMover_add_rot_shove_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMover_add_rot_shove_24_comment},
  { "getNodePath",(PyCFunction ) &Dtool_CMover_get_node_path_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMover_get_node_path_25_comment},
  { "getDt",(PyCFunction ) &Dtool_CMover_get_dt_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMover_get_dt_26_comment},
  { "resetDt",(PyCFunction ) &Dtool_CMover_reset_dt_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMover_reset_dt_27_comment},
  { "getClassType",(PyCFunction ) &Dtool_CMover_get_class_type_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMover_get_class_type_28_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CMover(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_CMover.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_CMover.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CMover.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CMover.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CMover.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CMover)");
             printf(" Error In PyType_ReadyCMover");
             return;
        }
        Py_INCREF(&Dtool_CMover.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CMover.As_PyTypeObject().tp_dict,"CMover",&Dtool_CMover.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CMover.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CMover[15],&Dtool_CMover.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CMover,CMover::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CMover.As_PyTypeObject());
        PyModule_AddObject(module, "CMover",(PyObject *)&Dtool_CMover.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CMoverGroup | CMoverGroup
//********************************************************************
PyMethodDef Dtool_Methods_CMoverGroup[]= {
  { "addCMover",(PyCFunction ) &Dtool_CMoverGroup_add_c_mover_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMoverGroup_add_c_mover_31_comment},
  { "removeCMover",(PyCFunction ) &Dtool_CMoverGroup_remove_c_mover_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMoverGroup_remove_c_mover_32_comment},
  { "setDt",(PyCFunction ) &Dtool_CMoverGroup_set_dt_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMoverGroup_set_dt_33_comment},
  { "getDt",(PyCFunction ) &Dtool_CMoverGroup_get_dt_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMoverGroup_get_dt_34_comment},
  { "resetDt",(PyCFunction ) &Dtool_CMoverGroup_reset_dt_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMoverGroup_reset_dt_35_comment},
  { "processCImpulsesAndIntegrate",(PyCFunction ) &Dtool_CMoverGroup_process_c_impulses_and_integrate_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMoverGroup_process_c_impulses_and_integrate_36_comment},
  { "getClassType",(PyCFunction ) &Dtool_CMoverGroup_get_class_type_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMoverGroup_get_class_type_37_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CMoverGroup(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_CMoverGroup.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_CMoverGroup.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CMoverGroup.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CMoverGroup.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CMoverGroup.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CMoverGroup)");
             printf(" Error In PyType_ReadyCMoverGroup");
             return;
        }
        Py_INCREF(&Dtool_CMoverGroup.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CMoverGroup.As_PyTypeObject().tp_dict,"CMoverGroup",&Dtool_CMoverGroup.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CMoverGroup.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CMoverGroup[6],&Dtool_CMoverGroup.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CMoverGroup,CMoverGroup::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CMoverGroup.As_PyTypeObject());
        PyModule_AddObject(module, "CMoverGroup",(PyObject *)&Dtool_CMoverGroup.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..CImpulse
//********************************************************************
   Dtool_PyModuleClassInit_CImpulse(module);
//********************************************************************
//*** Module Init Updcall ..CMover
//********************************************************************
   Dtool_PyModuleClassInit_CMover(module);
//********************************************************************
//*** Module Init Updcall ..CMoverGroup
//********************************************************************
   Dtool_PyModuleClassInit_CMoverGroup(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libmovement_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687213936,  /* file_identifier */
  "libmovement",  /* library_name */
  "Ye45",  /* library_hash_name */
  "otp",  /* module_name */
  "libmovement.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  97  /* next_index */
};

Configure(_in_configure_libmovement);
ConfigureFn(_in_configure_libmovement) {
  interrogate_request_module(&_in_module_def);
}

