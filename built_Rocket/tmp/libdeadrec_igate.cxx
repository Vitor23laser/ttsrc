/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir direct/src/deadrec -Idirect/src/deadrec -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libdeadrec_igate.cxx -od built_Rocket/pandac/input/libdeadrec.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Idirect/src/deadrec -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_DIRECT -module p3direct -library libdeadrec config_deadrec.h deadrec_composite.cxx smoothMover.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libdeadrec
#include "py_panda.h"  

#include "configVariableBool.h"
#include "config_deadrec.h"
#include "directbase.h"
#include "notifyCategoryProxy.h"
#include "smoothMover.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. SmoothMover
//********************************************************************
typedef  SmoothMover  SmoothMover_localtype;
Define_Module_Class(p3direct,SmoothMover,SmoothMover_localtype,SmoothMover);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LPoint3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_NodePath;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. SmoothMover 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline bool SmoothMover::set_pos(LVecBase3f const &pos)
 * inline bool SmoothMover::set_pos(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_set_pos_4(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline bool SmoothMover::set_pos(LVecBase3f const &pos)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"pos", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setPos", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setPos", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "SmoothMover.setPos", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = (local_this)->set_pos(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call SmoothMover.setPos() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool SmoothMover::set_pos(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setPos", key_word_list, &param1, &param2, &param3))
            {
                bool return_value = (local_this)->set_pos((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SmoothMover.setPos() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setPos() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setPos(non-const SmoothMover this, const VBase3 pos)\n"
          "setPos(non-const SmoothMover this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_set_pos_4_comment =
    "C++ Interface:\n"
    "setPos(non-const SmoothMover this, const VBase3 pos)\n"
    "setPos(non-const SmoothMover this, float x, float y, float z)\n"
    "\n"
    "// These methods are used to specify each position update.  Call the\n"
    "// appropriate set_* function(s), as needed, and then call\n"
    "// mark_position().  The return value of each function is true if\n"
    "// the parameter value has changed, or false if it remains the same\n"
    "// as last time.\n"
    "\n"
    "// These methods are used to specify each position update.  Call the\n"
    "// appropriate set_* function(s), as needed, and then call\n"
    "// mark_position().  The return value of each function is true if\n"
    "// the parameter value has changed, or false if it remains the same\n"
    "// as last time.\n"
    "\n"
    "// Filename: smoothMover.I\n"
    "// Created by:  drose (19Oct01)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::set_pos\n"
    "//       Access: Published\n"
    "//  Description: Specifies the position of the SmoothMover at a\n"
    "//               particular time in the past.  When mark_position() is\n"
    "//               called, this will be recorded (along with hpr and\n"
    "//               timestamp) in a position report, which will then be\n"
    "//               used along with all other position reports to\n"
    "//               determine the smooth position at any particular\n"
    "//               instant.\n"
    "//\n"
    "//               The return value is true if any parameter has changed\n"
    "//               since the last call to set_pos(), or false if they\n"
    "//               are the same.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::set_pos\n"
    "//       Access: Published\n"
    "//  Description: Specifies the position of the SmoothMover at a\n"
    "//               particular time in the past.  When mark_position() is\n"
    "//               called, this will be recorded (along with hpr and\n"
    "//               timestamp) in a position report, which will then be\n"
    "//               used along with all other position reports to\n"
    "//               determine the smooth position at any particular\n"
    "//               instant.\n"
    "//\n"
    "//               The return value is true if any parameter has changed\n"
    "//               since the last call to set_pos(), or false if they\n"
    "//               are the same.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_set_pos_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SmoothMover::set_x(float x)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_set_x_5(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool SmoothMover::set_x(float x)
        double param1;
        static char * key_word_list[] = {(char *)"x", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setX", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setX", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->set_x((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SmoothMover.setX() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setX(non-const SmoothMover this, float x)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_set_x_5_comment =
    "C++ Interface:\n"
    "setX(non-const SmoothMover this, float x)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::set_x\n"
    "//       Access: Published\n"
    "//  Description: Sets the X position only.  See set_pos().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_set_x_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SmoothMover::set_y(float y)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_set_y_6(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool SmoothMover::set_y(float y)
        double param1;
        static char * key_word_list[] = {(char *)"y", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setY", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setY", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->set_y((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SmoothMover.setY() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setY(non-const SmoothMover this, float y)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_set_y_6_comment =
    "C++ Interface:\n"
    "setY(non-const SmoothMover this, float y)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::set_y\n"
    "//       Access: Published\n"
    "//  Description: Sets the Y position only.  See set_pos().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_set_y_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SmoothMover::set_z(float z)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_set_z_7(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool SmoothMover::set_z(float z)
        double param1;
        static char * key_word_list[] = {(char *)"z", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setZ", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setZ", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->set_z((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SmoothMover.setZ() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setZ(non-const SmoothMover this, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_set_z_7_comment =
    "C++ Interface:\n"
    "setZ(non-const SmoothMover this, float z)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::set_z\n"
    "//       Access: Published\n"
    "//  Description: Sets the Z position only.  See set_pos().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_set_z_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SmoothMover::set_hpr(LVecBase3f const &hpr)
 * inline bool SmoothMover::set_hpr(float h, float p, float r)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_set_hpr_8(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline bool SmoothMover::set_hpr(LVecBase3f const &hpr)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"hpr", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setHpr", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setHpr", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "SmoothMover.setHpr", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = (local_this)->set_hpr(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call SmoothMover.setHpr() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool SmoothMover::set_hpr(float h, float p, float r)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"h", (char *)"p", (char *)"r", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setHpr", key_word_list, &param1, &param2, &param3))
            {
                bool return_value = (local_this)->set_hpr((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SmoothMover.setHpr() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setHpr() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setHpr(non-const SmoothMover this, const VBase3 hpr)\n"
          "setHpr(non-const SmoothMover this, float h, float p, float r)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_set_hpr_8_comment =
    "C++ Interface:\n"
    "setHpr(non-const SmoothMover this, const VBase3 hpr)\n"
    "setHpr(non-const SmoothMover this, float h, float p, float r)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::set_hpr\n"
    "//       Access: Published\n"
    "//  Description: Specifies the orientation of the SmoothMover at a\n"
    "//               particular time in the past.  When mark_position() is\n"
    "//               called, this will be recorded (along with hpr and\n"
    "//               timestamp) in a position report, which will then be\n"
    "//               used along with all other position reports to\n"
    "//               determine the smooth position at any particular\n"
    "//               instant.\n"
    "//\n"
    "//               The return value is true if any parameter has changed\n"
    "//               since the last call to set_hpr(), or false if they\n"
    "//               are the same.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::set_hpr\n"
    "//       Access: Published\n"
    "//  Description: Specifies the orientation of the SmoothMover at a\n"
    "//               particular time in the past.  When mark_position() is\n"
    "//               called, this will be recorded (along with hpr and\n"
    "//               timestamp) in a position report, which will then be\n"
    "//               used along with all other position reports to\n"
    "//               determine the smooth position at any particular\n"
    "//               instant.\n"
    "//\n"
    "//               The return value is true if any parameter has changed\n"
    "//               since the last call to set_hpr(), or false if they\n"
    "//               are the same.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_set_hpr_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SmoothMover::set_h(float h)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_set_h_9(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool SmoothMover::set_h(float h)
        double param1;
        static char * key_word_list[] = {(char *)"h", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setH", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setH", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->set_h((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SmoothMover.setH() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setH(non-const SmoothMover this, float h)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_set_h_9_comment =
    "C++ Interface:\n"
    "setH(non-const SmoothMover this, float h)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::set_h\n"
    "//       Access: Published\n"
    "//  Description: Sets the heading only.  See set_hpr().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_set_h_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SmoothMover::set_p(float p)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_set_p_10(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool SmoothMover::set_p(float p)
        double param1;
        static char * key_word_list[] = {(char *)"p", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setP", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setP", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->set_p((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SmoothMover.setP() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setP(non-const SmoothMover this, float p)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_set_p_10_comment =
    "C++ Interface:\n"
    "setP(non-const SmoothMover this, float p)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::set_p\n"
    "//       Access: Published\n"
    "//  Description: Sets the pitch only.  See set_hpr().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_set_p_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SmoothMover::set_r(float r)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_set_r_11(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool SmoothMover::set_r(float r)
        double param1;
        static char * key_word_list[] = {(char *)"r", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setR", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setR", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->set_r((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SmoothMover.setR() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setR(non-const SmoothMover this, float r)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_set_r_11_comment =
    "C++ Interface:\n"
    "setR(non-const SmoothMover this, float r)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::set_r\n"
    "//       Access: Published\n"
    "//  Description: Sets the roll only.  See set_hpr().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_set_r_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SmoothMover::set_pos_hpr(LVecBase3f const &pos, LVecBase3f const &hpr)
 * inline bool SmoothMover::set_pos_hpr(float x, float y, float z, float h, float p, float r)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_set_pos_hpr_12(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline bool SmoothMover::set_pos_hpr(LVecBase3f const &pos, LVecBase3f const &hpr)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"pos", (char *)"hpr", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:setPosHpr", key_word_list, &param1, &param2))
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "SmoothMover.setPosHpr", 1, coerced_ptr, report_errors);
LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "SmoothMover.setPosHpr", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        bool return_value = (local_this)->set_pos_hpr(*param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call SmoothMover.setPosHpr() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool SmoothMover::set_pos_hpr(float x, float y, float z, float h, float p, float r)
            double param1;
            double param2;
            double param3;
            double param4;
            double param5;
            double param6;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", (char *)"h", (char *)"p", (char *)"r", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddddd:setPosHpr", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6))
            {
                bool return_value = (local_this)->set_pos_hpr((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SmoothMover.setPosHpr() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setPosHpr() takes 3 or 7 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setPosHpr(non-const SmoothMover this, const VBase3 pos, const VBase3 hpr)\n"
          "setPosHpr(non-const SmoothMover this, float x, float y, float z, float h, float p, float r)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_set_pos_hpr_12_comment =
    "C++ Interface:\n"
    "setPosHpr(non-const SmoothMover this, const VBase3 pos, const VBase3 hpr)\n"
    "setPosHpr(non-const SmoothMover this, float x, float y, float z, float h, float p, float r)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::set_pos_hpr\n"
    "//       Access: Published\n"
    "//  Description: Specifies the position and orientation of the SmoothMover at a\n"
    "//               particular time in the past.  When mark_position() is\n"
    "//               called, this will be recorded (along with\n"
    "//               timestamp) in a position report, which will then be\n"
    "//               used along with all other position reports to\n"
    "//               determine the smooth position at any particular\n"
    "//               instant.\n"
    "//\n"
    "//               The return value is true if any parameter has changed\n"
    "//               since the last call to set_pos_hpr(), or false if they\n"
    "//               are the same.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::set_pos_hpr\n"
    "//       Access: Published\n"
    "//  Description: Specifies the position of the SmoothMover at a\n"
    "//               particular time in the past.  When mark_position() is\n"
    "//               called, this will be recorded (along with\n"
    "//               timestamp) in a position report, which will then be\n"
    "//               used along with all other position reports to\n"
    "//               determine the smooth position at any particular\n"
    "//               instant.\n"
    "//\n"
    "//               The return value is true if any parameter has changed\n"
    "//               since the last call to set_pos_hpr(), or false if they\n"
    "//               are the same.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_set_pos_hpr_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f const &SmoothMover::get_sample_pos(void) const
 *******************************************************************/
static PyObject *Dtool_SmoothMover_get_sample_pos_13(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f const &SmoothMover::get_sample_pos(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSamplePos", key_word_list));
        else
            (PyArg_Parse(args, ":getSamplePos"));
        if(!PyErr_Occurred())
        {
            LPoint3f const *return_value = &(((const SmoothMover*)local_this)->get_sample_pos());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSamplePos(const SmoothMover this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_get_sample_pos_13_comment =
    "C++ Interface:\n"
    "getSamplePos(const SmoothMover this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::get_sample_pos\n"
    "//       Access: Published\n"
    "//  Description: Returns the current position of the working sample\n"
    "//               point.  This position is updated periodically by\n"
    "//               set_x(), set_y(), etc., and its current value is\n"
    "//               copied to the sample point table when\n"
    "//               mark_position() is called.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_get_sample_pos_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f const &SmoothMover::get_sample_hpr(void) const
 *******************************************************************/
static PyObject *Dtool_SmoothMover_get_sample_hpr_14(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f const &SmoothMover::get_sample_hpr(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSampleHpr", key_word_list));
        else
            (PyArg_Parse(args, ":getSampleHpr"));
        if(!PyErr_Occurred())
        {
            LVecBase3f const *return_value = &(((const SmoothMover*)local_this)->get_sample_hpr());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSampleHpr(const SmoothMover this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_get_sample_hpr_14_comment =
    "C++ Interface:\n"
    "getSampleHpr(const SmoothMover this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::get_sample_hpr\n"
    "//       Access: Published\n"
    "//  Description: Returns the current orientation of the working sample\n"
    "//               point.  This orientation is updated periodically by\n"
    "//               set_h(), set_p(), etc., and its current value is\n"
    "//               copied to the sample point table when\n"
    "//               mark_position() is called.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_get_sample_hpr_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SmoothMover::set_phony_timestamp(double timestamp, bool period_adjust)
 * inline void SmoothMover::set_phony_timestamp(double timestamp, bool period_adjust = (0))
 * inline void SmoothMover::set_phony_timestamp(double timestamp = (0), bool period_adjust = (0))
 *******************************************************************/
static PyObject *Dtool_SmoothMover_set_phony_timestamp_15(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void SmoothMover::set_phony_timestamp(double timestamp = (0), bool period_adjust = (0))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":setPhonyTimestamp", key_word_list));
            else
                (PyArg_Parse(args, ":setPhonyTimestamp"));
            if(!PyErr_Occurred())
            {
                (local_this)->set_phony_timestamp();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SmoothMover.setPhonyTimestamp() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void SmoothMover::set_phony_timestamp(double timestamp, bool period_adjust = (0))
            double param1;
            static char * key_word_list[] = {(char *)"timestamp", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:setPhonyTimestamp", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:setPhonyTimestamp", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->set_phony_timestamp((double)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SmoothMover.setPhonyTimestamp() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void SmoothMover::set_phony_timestamp(double timestamp, bool period_adjust)
            double param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"timestamp", (char *)"period_adjust", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dO:setPhonyTimestamp", key_word_list, &param1, &param2))
            {
                (local_this)->set_phony_timestamp((double)param1, (PyObject_IsTrue(param2)!=0));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SmoothMover.setPhonyTimestamp() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setPhonyTimestamp() takes 1, 2, or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setPhonyTimestamp(non-const SmoothMover this)\n"
          "setPhonyTimestamp(non-const SmoothMover this, float timestamp)\n"
          "setPhonyTimestamp(non-const SmoothMover this, float timestamp, bool period_adjust)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_set_phony_timestamp_15_comment =
    "C++ Interface:\n"
    "setPhonyTimestamp(non-const SmoothMover this)\n"
    "setPhonyTimestamp(non-const SmoothMover this, float timestamp)\n"
    "setPhonyTimestamp(non-const SmoothMover this, float timestamp, bool period_adjust)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::set_phony_timestamp\n"
    "//       Access: Published\n"
    "//  Description: Lies and specifies that the current position report\n"
    "//               was received now.  This is usually used for very old\n"
    "//               position reports for which we're not sure of the\n"
    "//               actual receipt time.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_set_phony_timestamp_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SmoothMover::set_timestamp(double timestamp)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_set_timestamp_16(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SmoothMover::set_timestamp(double timestamp)
        double param1;
        static char * key_word_list[] = {(char *)"timestamp", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setTimestamp", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setTimestamp", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_timestamp((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SmoothMover.setTimestamp() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTimestamp(non-const SmoothMover this, float timestamp)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_set_timestamp_16_comment =
    "C++ Interface:\n"
    "setTimestamp(non-const SmoothMover this, float timestamp)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::set_timestamp\n"
    "//       Access: Published\n"
    "//  Description: Specifies the time that the current position report\n"
    "//               applies.  This should be called, along with set_pos()\n"
    "//               and set_hpr(), before a call to mark_position().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_set_timestamp_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SmoothMover::has_most_recent_timestamp(void) const
 *******************************************************************/
static PyObject *Dtool_SmoothMover_has_most_recent_timestamp_17(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool SmoothMover::has_most_recent_timestamp(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasMostRecentTimestamp", key_word_list));
        else
            (PyArg_Parse(args, ":hasMostRecentTimestamp"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const SmoothMover*)local_this)->has_most_recent_timestamp();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasMostRecentTimestamp(const SmoothMover this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_has_most_recent_timestamp_17_comment =
    "C++ Interface:\n"
    "hasMostRecentTimestamp(const SmoothMover this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::has_most_recent_timestamp\n"
    "//       Access: Published\n"
    "//  Description: Returns true if we have most recently recorded timestamp\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_has_most_recent_timestamp_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double SmoothMover::get_most_recent_timestamp(void) const
 *******************************************************************/
static PyObject *Dtool_SmoothMover_get_most_recent_timestamp_18(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double SmoothMover::get_most_recent_timestamp(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMostRecentTimestamp", key_word_list));
        else
            (PyArg_Parse(args, ":getMostRecentTimestamp"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const SmoothMover*)local_this)->get_most_recent_timestamp();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMostRecentTimestamp(const SmoothMover this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_get_most_recent_timestamp_18_comment =
    "C++ Interface:\n"
    "getMostRecentTimestamp(const SmoothMover this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::get_most_recent_timestamp\n"
    "//       Access: Published\n"
    "//  Description: Returns most recently recorded timestamp\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_get_most_recent_timestamp_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void SmoothMover::mark_position(void)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_mark_position_19(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void SmoothMover::mark_position(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":markPosition", key_word_list));
        else
            (PyArg_Parse(args, ":markPosition"));
        if(!PyErr_Occurred())
        {
            (local_this)->mark_position();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SmoothMover.markPosition() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "markPosition(non-const SmoothMover this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_mark_position_19_comment =
    "C++ Interface:\n"
    "markPosition(non-const SmoothMover this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::mark_position\n"
    "//       Access: Published\n"
    "//  Description: Stores the position, orientation, and timestamp (if\n"
    "//               relevant) indicated by previous calls to set_pos(),\n"
    "//               set_hpr(), and set_timestamp() in a new position\n"
    "//               report.\n"
    "//\n"
    "//               When compute_smooth_position() is called, it uses\n"
    "//               these stored position reports to base its computation\n"
    "//               of the known position.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_mark_position_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void SmoothMover::clear_positions(bool reset_velocity)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_clear_positions_20(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void SmoothMover::clear_positions(bool reset_velocity)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"reset_velocity", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:clearPositions", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:clearPositions", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_positions((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SmoothMover.clearPositions() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearPositions(non-const SmoothMover this, bool reset_velocity)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_clear_positions_20_comment =
    "C++ Interface:\n"
    "clearPositions(non-const SmoothMover this, bool reset_velocity)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::clear_positions\n"
    "//       Access: Published\n"
    "//  Description: Erases all the old position reports.  This should be\n"
    "//               done, for instance, prior to teleporting the avatar\n"
    "//               to a new position; otherwise, the smoother might try\n"
    "//               to lerp the avatar there.  If reset_velocity is true,\n"
    "//               the velocity is also reset to 0.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_clear_positions_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SmoothMover::compute_smooth_position(void)
 * bool SmoothMover::compute_smooth_position(double timestamp)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_compute_smooth_position_21(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool SmoothMover::compute_smooth_position(void)
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":computeSmoothPosition", key_word_list));
            else
                (PyArg_Parse(args, ":computeSmoothPosition"));
            if(!PyErr_Occurred())
            {
                bool return_value = (local_this)->compute_smooth_position();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SmoothMover.computeSmoothPosition() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool SmoothMover::compute_smooth_position(double timestamp)
            double param1;
            static char * key_word_list[] = {(char *)"timestamp", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:computeSmoothPosition", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:computeSmoothPosition", &param1));
            if(!PyErr_Occurred())
            {
                bool return_value = (local_this)->compute_smooth_position((double)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SmoothMover.computeSmoothPosition() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "computeSmoothPosition() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "computeSmoothPosition(non-const SmoothMover this)\n"
          "computeSmoothPosition(non-const SmoothMover this, float timestamp)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_compute_smooth_position_21_comment =
    "C++ Interface:\n"
    "computeSmoothPosition(non-const SmoothMover this)\n"
    "computeSmoothPosition(non-const SmoothMover this, float timestamp)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::compute_smooth_position\n"
    "//       Access: Published\n"
    "//  Description: Computes the smoothed position (and orientation) of\n"
    "//               the mover at the indicated point in time, based on\n"
    "//               the previous position reports.  After this call has\n"
    "//               been made, get_smooth_pos() etc. may be called to\n"
    "//               retrieve the smoothed position.\n"
    "//\n"
    "//               With no parameter, the function uses\n"
    "//               ClockObject::get_frame_time() as the default time.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::compute_smooth_position\n"
    "//       Access: Published\n"
    "//  Description: Computes the smoothed position (and orientation) of\n"
    "//               the mover at the indicated point in time, based on\n"
    "//               the previous position reports.  After this call has\n"
    "//               been made, get_smooth_pos() etc. may be called to\n"
    "//               retrieve the smoothed position.\n"
    "//\n"
    "//               The return value is true if the value has changed (or\n"
    "//               might have changed) since the last call to\n"
    "//               compute_smooth_position(), or false if it remains the\n"
    "//               same.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_compute_smooth_position_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool SmoothMover::get_latest_position(void)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_get_latest_position_22(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool SmoothMover::get_latest_position(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLatestPosition", key_word_list));
        else
            (PyArg_Parse(args, ":getLatestPosition"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->get_latest_position();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SmoothMover.getLatestPosition() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLatestPosition(non-const SmoothMover this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_get_latest_position_22_comment =
    "C++ Interface:\n"
    "getLatestPosition(non-const SmoothMover this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::get_latest_position\n"
    "//       Access: Published\n"
    "//  Description: Updates the smooth_pos (and smooth_hpr, etc.) members\n"
    "//               to reflect the absolute latest position known for\n"
    "//               this avatar.  This may result in a pop to the most\n"
    "//               recent position.\n"
    "//\n"
    "//               Returns true if the latest position is known, false\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_get_latest_position_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f const &SmoothMover::get_smooth_pos(void) const
 *******************************************************************/
static PyObject *Dtool_SmoothMover_get_smooth_pos_23(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f const &SmoothMover::get_smooth_pos(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSmoothPos", key_word_list));
        else
            (PyArg_Parse(args, ":getSmoothPos"));
        if(!PyErr_Occurred())
        {
            LPoint3f const *return_value = &(((const SmoothMover*)local_this)->get_smooth_pos());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSmoothPos(const SmoothMover this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_get_smooth_pos_23_comment =
    "C++ Interface:\n"
    "getSmoothPos(const SmoothMover this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::get_smooth_pos\n"
    "//       Access: Published\n"
    "//  Description: Returns the smoothed position as computed by a\n"
    "//               previous call to compute_smooth_position().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_get_smooth_pos_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f const &SmoothMover::get_smooth_hpr(void) const
 *******************************************************************/
static PyObject *Dtool_SmoothMover_get_smooth_hpr_24(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f const &SmoothMover::get_smooth_hpr(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSmoothHpr", key_word_list));
        else
            (PyArg_Parse(args, ":getSmoothHpr"));
        if(!PyErr_Occurred())
        {
            LVecBase3f const *return_value = &(((const SmoothMover*)local_this)->get_smooth_hpr());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSmoothHpr(const SmoothMover this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_get_smooth_hpr_24_comment =
    "C++ Interface:\n"
    "getSmoothHpr(const SmoothMover this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::get_smooth_hpr\n"
    "//       Access: Published\n"
    "//  Description: Returns the smoothed orientation as computed by a\n"
    "//               previous call to compute_smooth_position().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_get_smooth_hpr_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SmoothMover::apply_smooth_pos(NodePath &node) const
 *******************************************************************/
static PyObject *Dtool_SmoothMover_apply_smooth_pos_25(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline void SmoothMover::apply_smooth_pos(NodePath &node) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:applySmoothPos", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:applySmoothPos", &param1));
            if(!PyErr_Occurred())
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "SmoothMover.applySmoothPos", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const SmoothMover*)local_this)->apply_smooth_pos(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "applySmoothPos(const SmoothMover this, non-const NodePath node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_apply_smooth_pos_25_comment =
    "C++ Interface:\n"
    "applySmoothPos(const SmoothMover this, non-const NodePath node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::apply_smooth_pos\n"
    "//       Access: Published\n"
    "//  Description: Applies the smoothed position to the indicated\n"
    "//               NodePath.  This is equivalent to calling\n"
    "//               node.set_pos(smooth_mover->get_smooth_pos()).  It\n"
    "//               exists as an optimization only, to avoid the overhead\n"
    "//               of passing the return value through Python.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_apply_smooth_pos_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SmoothMover::apply_smooth_pos_hpr(NodePath &pos_node, NodePath &hpr_node) const
 *******************************************************************/
static PyObject *Dtool_SmoothMover_apply_smooth_pos_hpr_26(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline void SmoothMover::apply_smooth_pos_hpr(NodePath &pos_node, NodePath &hpr_node) const
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"pos_node", (char *)"hpr_node", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:applySmoothPosHpr", key_word_list, &param1, &param2))
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "SmoothMover.applySmoothPosHpr", 0, coerced_ptr, report_errors);
NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "SmoothMover.applySmoothPosHpr", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    ((const SmoothMover*)local_this)->apply_smooth_pos_hpr(*param1_this, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "applySmoothPosHpr(const SmoothMover this, non-const NodePath pos_node, non-const NodePath hpr_node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_apply_smooth_pos_hpr_26_comment =
    "C++ Interface:\n"
    "applySmoothPosHpr(const SmoothMover this, non-const NodePath pos_node, non-const NodePath hpr_node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::apply_smooth_pos_hpr\n"
    "//       Access: Published\n"
    "//  Description: Applies the smoothed position and orientation to the\n"
    "//               indicated NodePath.  This is equivalent to calling\n"
    "//               node.set_pos_hpr(smooth_mover->get_smooth_pos(),\n"
    "//               smooth_mover->get_smooth_hpr()).  It exists as an\n"
    "//               optimization only, to avoid the overhead of passing\n"
    "//               the return value through Python.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_apply_smooth_pos_hpr_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SmoothMover::apply_smooth_hpr(NodePath &node) const
 *******************************************************************/
static PyObject *Dtool_SmoothMover_apply_smooth_hpr_27(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline void SmoothMover::apply_smooth_hpr(NodePath &node) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:applySmoothHpr", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:applySmoothHpr", &param1));
            if(!PyErr_Occurred())
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "SmoothMover.applySmoothHpr", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const SmoothMover*)local_this)->apply_smooth_hpr(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "applySmoothHpr(const SmoothMover this, non-const NodePath node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_apply_smooth_hpr_27_comment =
    "C++ Interface:\n"
    "applySmoothHpr(const SmoothMover this, non-const NodePath node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::apply_smooth_hpr\n"
    "//       Access: Published\n"
    "//  Description: Applies the smoothed orientation to the indicated\n"
    "//               NodePath.  This is equivalent to calling\n"
    "//               node.set_hpr(smooth_mover->get_smooth_hpr()).  It\n"
    "//               exists as an optimization only, to avoid the overhead\n"
    "//               of passing the return value through Python.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_apply_smooth_hpr_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SmoothMover::compute_and_apply_smooth_pos(NodePath &node)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_compute_and_apply_smooth_pos_28(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void SmoothMover::compute_and_apply_smooth_pos(NodePath &node)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:computeAndApplySmoothPos", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:computeAndApplySmoothPos", &param1));
            if(!PyErr_Occurred())
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "SmoothMover.computeAndApplySmoothPos", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->compute_and_apply_smooth_pos(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SmoothMover.computeAndApplySmoothPos() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "computeAndApplySmoothPos(non-const SmoothMover this, non-const NodePath node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_compute_and_apply_smooth_pos_28_comment =
    "C++ Interface:\n"
    "computeAndApplySmoothPos(non-const SmoothMover this, non-const NodePath node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::compute_and_apply_smooth_pos\n"
    "//       Access: Published\n"
    "//  Description: A further optimization to reduce Python calls.  This\n"
    "//               computes the smooth position and applies it to the\n"
    "//               indicated node in one call.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_compute_and_apply_smooth_pos_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SmoothMover::compute_and_apply_smooth_pos_hpr(NodePath &pos_node, NodePath &hpr_node)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_compute_and_apply_smooth_pos_hpr_29(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void SmoothMover::compute_and_apply_smooth_pos_hpr(NodePath &pos_node, NodePath &hpr_node)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"pos_node", (char *)"hpr_node", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:computeAndApplySmoothPosHpr", key_word_list, &param1, &param2))
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "SmoothMover.computeAndApplySmoothPosHpr", 0, coerced_ptr, report_errors);
NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "SmoothMover.computeAndApplySmoothPosHpr", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    (local_this)->compute_and_apply_smooth_pos_hpr(*param1_this, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SmoothMover.computeAndApplySmoothPosHpr() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "computeAndApplySmoothPosHpr(non-const SmoothMover this, non-const NodePath pos_node, non-const NodePath hpr_node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_compute_and_apply_smooth_pos_hpr_29_comment =
    "C++ Interface:\n"
    "computeAndApplySmoothPosHpr(non-const SmoothMover this, non-const NodePath pos_node, non-const NodePath hpr_node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::compute_and_apply_smooth_pos_hpr\n"
    "//       Access: Published\n"
    "//  Description: A further optimization to reduce Python calls.  This\n"
    "//               computes the smooth position and applies it to the\n"
    "//               indicated node or nodes in one call.  The pos_node\n"
    "//               and hpr_node might be the same NodePath.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_compute_and_apply_smooth_pos_hpr_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SmoothMover::compute_and_apply_smooth_hpr(NodePath &hpr_node)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_compute_and_apply_smooth_hpr_30(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void SmoothMover::compute_and_apply_smooth_hpr(NodePath &hpr_node)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"hpr_node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:computeAndApplySmoothHpr", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:computeAndApplySmoothHpr", &param1));
            if(!PyErr_Occurred())
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "SmoothMover.computeAndApplySmoothHpr", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->compute_and_apply_smooth_hpr(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SmoothMover.computeAndApplySmoothHpr() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "computeAndApplySmoothHpr(non-const SmoothMover this, non-const NodePath hpr_node)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_compute_and_apply_smooth_hpr_30_comment =
    "C++ Interface:\n"
    "computeAndApplySmoothHpr(non-const SmoothMover this, non-const NodePath hpr_node)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::compute_and_apply_smooth_pos_hpr\n"
    "//       Access: Published\n"
    "//  Description: A further optimization to reduce Python calls.  This\n"
    "//               computes the smooth position and applies it to the\n"
    "//               indicated node or nodes in one call.  The pos_node\n"
    "//               and hpr_node might be the same NodePath.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_compute_and_apply_smooth_hpr_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float SmoothMover::get_smooth_forward_velocity(void) const
 *******************************************************************/
static PyObject *Dtool_SmoothMover_get_smooth_forward_velocity_31(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float SmoothMover::get_smooth_forward_velocity(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSmoothForwardVelocity", key_word_list));
        else
            (PyArg_Parse(args, ":getSmoothForwardVelocity"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const SmoothMover*)local_this)->get_smooth_forward_velocity();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSmoothForwardVelocity(const SmoothMover this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_get_smooth_forward_velocity_31_comment =
    "C++ Interface:\n"
    "getSmoothForwardVelocity(const SmoothMover this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::get_smooth_forward_velocity\n"
    "//       Access: Published\n"
    "//  Description: Returns the speed at which the avatar is moving, in\n"
    "//               feet per second, along its own forward axis (after\n"
    "//               applying the avatar's hpr).  This will be a positive\n"
    "//               number if the avatar is moving forward, and a\n"
    "//               negative number if it is moving backward.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_get_smooth_forward_velocity_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float SmoothMover::get_smooth_lateral_velocity(void) const
 *******************************************************************/
static PyObject *Dtool_SmoothMover_get_smooth_lateral_velocity_32(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float SmoothMover::get_smooth_lateral_velocity(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSmoothLateralVelocity", key_word_list));
        else
            (PyArg_Parse(args, ":getSmoothLateralVelocity"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const SmoothMover*)local_this)->get_smooth_lateral_velocity();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSmoothLateralVelocity(const SmoothMover this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_get_smooth_lateral_velocity_32_comment =
    "C++ Interface:\n"
    "getSmoothLateralVelocity(const SmoothMover this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::get_smooth_lateral_velocity\n"
    "//       Access: Published\n"
    "//  Description: Returns the speed at which the avatar is moving, in\n"
    "//               feet per second, along its own lateral axis (after\n"
    "//               applying the avatar's hpr).  This will be a positive\n"
    "//               number if the avatar is moving right, and a\n"
    "//               negative number if it is moving left.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_get_smooth_lateral_velocity_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float SmoothMover::get_smooth_rotational_velocity(void) const
 *******************************************************************/
static PyObject *Dtool_SmoothMover_get_smooth_rotational_velocity_33(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float SmoothMover::get_smooth_rotational_velocity(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSmoothRotationalVelocity", key_word_list));
        else
            (PyArg_Parse(args, ":getSmoothRotationalVelocity"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const SmoothMover*)local_this)->get_smooth_rotational_velocity();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSmoothRotationalVelocity(const SmoothMover this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_get_smooth_rotational_velocity_33_comment =
    "C++ Interface:\n"
    "getSmoothRotationalVelocity(const SmoothMover this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::get_smooth_rotational_velocity\n"
    "//       Access: Published\n"
    "//  Description: Returns the speed at which the avatar is rotating in\n"
    "//               the horizontal plane (i.e. heading), in degrees per\n"
    "//               second.  This may be positive or negative, according\n"
    "//               to the direction of rotation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_get_smooth_rotational_velocity_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f const &SmoothMover::get_forward_axis(void) const
 *******************************************************************/
static PyObject *Dtool_SmoothMover_get_forward_axis_34(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f const &SmoothMover::get_forward_axis(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getForwardAxis", key_word_list));
        else
            (PyArg_Parse(args, ":getForwardAxis"));
        if(!PyErr_Occurred())
        {
            LVecBase3f const *return_value = &(((const SmoothMover*)local_this)->get_forward_axis());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getForwardAxis(const SmoothMover this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_get_forward_axis_34_comment =
    "C++ Interface:\n"
    "getForwardAxis(const SmoothMover this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::get_forward_axis\n"
    "//       Access: Published\n"
    "//  Description: Returns the smoothed position as computed by a\n"
    "//               previous call to compute_smooth_position().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_get_forward_axis_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void SmoothMover::handle_wrt_reparent(NodePath &old_parent, NodePath &new_parent)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_handle_wrt_reparent_35(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void SmoothMover::handle_wrt_reparent(NodePath &old_parent, NodePath &new_parent)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"old_parent", (char *)"new_parent", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:handleWrtReparent", key_word_list, &param1, &param2))
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "SmoothMover.handleWrtReparent", 0, coerced_ptr, report_errors);
NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "SmoothMover.handleWrtReparent", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    (local_this)->handle_wrt_reparent(*param1_this, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call SmoothMover.handleWrtReparent() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "handleWrtReparent(non-const SmoothMover this, non-const NodePath old_parent, non-const NodePath new_parent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_handle_wrt_reparent_35_comment =
    "C++ Interface:\n"
    "handleWrtReparent(non-const SmoothMover this, non-const NodePath old_parent, non-const NodePath new_parent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::handle_wrt_reparent\n"
    "//       Access: Private\n"
    "//  Description: Node is being wrtReparented, update recorded\n"
    "//               sample positions to reflect new parent\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_handle_wrt_reparent_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SmoothMover::set_smooth_mode(SmoothMover::SmoothMode mode)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_set_smooth_mode_38(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SmoothMover::set_smooth_mode(SmoothMover::SmoothMode mode)
        int param1;
        static char * key_word_list[] = {(char *)"mode", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setSmoothMode", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setSmoothMode", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_smooth_mode((SmoothMover::SmoothMode)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SmoothMover.setSmoothMode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSmoothMode(non-const SmoothMover this, int mode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_set_smooth_mode_38_comment =
    "C++ Interface:\n"
    "setSmoothMode(non-const SmoothMover this, int mode)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::set_smooth_mode\n"
    "//       Access: Published, Static\n"
    "//  Description: Sets the smoothing mode of all SmoothMovers in the\n"
    "//               world.  If this is SM_off, no smoothing or prediction\n"
    "//               will be performed, and get_smooth_pos() will simply\n"
    "//               return the position last set by mark_position().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_set_smooth_mode_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline SmoothMover::SmoothMode SmoothMover::get_smooth_mode(void)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_get_smooth_mode_39(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline SmoothMover::SmoothMode SmoothMover::get_smooth_mode(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSmoothMode", key_word_list));
        else
            (PyArg_Parse(args, ":getSmoothMode"));
        if(!PyErr_Occurred())
        {
            SmoothMover::SmoothMode return_value = (local_this)->get_smooth_mode();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SmoothMover.getSmoothMode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSmoothMode(non-const SmoothMover this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_get_smooth_mode_39_comment =
    "C++ Interface:\n"
    "getSmoothMode(non-const SmoothMover this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::get_smooth_mode\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the smoothing mode of all SmoothMovers in the\n"
    "//               world.  See set_smooth_mode().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_get_smooth_mode_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SmoothMover::set_prediction_mode(SmoothMover::PredictionMode mode)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_set_prediction_mode_40(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SmoothMover::set_prediction_mode(SmoothMover::PredictionMode mode)
        int param1;
        static char * key_word_list[] = {(char *)"mode", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setPredictionMode", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setPredictionMode", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_prediction_mode((SmoothMover::PredictionMode)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SmoothMover.setPredictionMode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPredictionMode(non-const SmoothMover this, int mode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_set_prediction_mode_40_comment =
    "C++ Interface:\n"
    "setPredictionMode(non-const SmoothMover this, int mode)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::set_prediction_mode\n"
    "//       Access: Published, Static\n"
    "//  Description: Sets the predictioning mode of all SmoothMovers in the\n"
    "//               world.  If this is PM_off, no prediction will be\n"
    "//               performed, but smoothing might still be performed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_set_prediction_mode_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline SmoothMover::PredictionMode SmoothMover::get_prediction_mode(void)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_get_prediction_mode_41(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline SmoothMover::PredictionMode SmoothMover::get_prediction_mode(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPredictionMode", key_word_list));
        else
            (PyArg_Parse(args, ":getPredictionMode"));
        if(!PyErr_Occurred())
        {
            SmoothMover::PredictionMode return_value = (local_this)->get_prediction_mode();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SmoothMover.getPredictionMode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPredictionMode(non-const SmoothMover this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_get_prediction_mode_41_comment =
    "C++ Interface:\n"
    "getPredictionMode(non-const SmoothMover this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::get_prediction_mode\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the predictioning mode of all SmoothMovers in the\n"
    "//               world.  See set_prediction_mode().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_get_prediction_mode_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SmoothMover::set_delay(double delay)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_set_delay_42(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SmoothMover::set_delay(double delay)
        double param1;
        static char * key_word_list[] = {(char *)"delay", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setDelay", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setDelay", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_delay((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SmoothMover.setDelay() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDelay(non-const SmoothMover this, float delay)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_set_delay_42_comment =
    "C++ Interface:\n"
    "setDelay(non-const SmoothMover this, float delay)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::set_delay\n"
    "//       Access: Published, Static\n"
    "//  Description: Sets the amount of time, in seconds, to delay the\n"
    "//               computed position of a SmoothMover.  This is\n"
    "//               particularly useful when the prediction mode is off,\n"
    "//               because it can allow the apparent motion of an avatar\n"
    "//               to appear smooth without relying on prediction, at\n"
    "//               the cost of introducing additional lag in the\n"
    "//               avatar's apparent position.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_set_delay_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double SmoothMover::get_delay(void)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_get_delay_43(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline double SmoothMover::get_delay(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDelay", key_word_list));
        else
            (PyArg_Parse(args, ":getDelay"));
        if(!PyErr_Occurred())
        {
            double return_value = (local_this)->get_delay();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SmoothMover.getDelay() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDelay(non-const SmoothMover this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_get_delay_43_comment =
    "C++ Interface:\n"
    "getDelay(non-const SmoothMover this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::get_delay\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the amount of time, in seconds, to delay the\n"
    "//               computed position of a SmoothMover.  See set_delay().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_get_delay_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SmoothMover::set_accept_clock_skew(bool flag)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_set_accept_clock_skew_44(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SmoothMover::set_accept_clock_skew(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAcceptClockSkew", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setAcceptClockSkew", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_accept_clock_skew((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SmoothMover.setAcceptClockSkew() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAcceptClockSkew(non-const SmoothMover this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_set_accept_clock_skew_44_comment =
    "C++ Interface:\n"
    "setAcceptClockSkew(non-const SmoothMover this, bool flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::set_accept_clock_skew\n"
    "//       Access: Published, Static\n"
    "//  Description: Sets the 'accept clock skew' flag.  When this flag is\n"
    "//               true, clock skew from the other clients will be\n"
    "//               tolerated by delaying each smooth mover's position an\n"
    "//               additional amount, on top of that specified by\n"
    "//               set_delay(), based on the measured average latency\n"
    "//               for timestamp messages received by the client.\n"
    "//\n"
    "//               In this way, if the other client has significant\n"
    "//               clock skew with respect to our clock, it will be\n"
    "//               evident as a large positive or negative average\n"
    "//               latency for timestamps.  By subtracting out this\n"
    "//               average latency, we compensate for poor clock sync.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_set_accept_clock_skew_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SmoothMover::get_accept_clock_skew(void)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_get_accept_clock_skew_45(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool SmoothMover::get_accept_clock_skew(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAcceptClockSkew", key_word_list));
        else
            (PyArg_Parse(args, ":getAcceptClockSkew"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->get_accept_clock_skew();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SmoothMover.getAcceptClockSkew() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAcceptClockSkew(non-const SmoothMover this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_get_accept_clock_skew_45_comment =
    "C++ Interface:\n"
    "getAcceptClockSkew(non-const SmoothMover this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::get_accept_clock_skew\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the current state of the 'accept clock skew'\n"
    "//               flag.  See set_accept_clock_skew().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_get_accept_clock_skew_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SmoothMover::set_max_position_age(double age)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_set_max_position_age_46(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SmoothMover::set_max_position_age(double age)
        double param1;
        static char * key_word_list[] = {(char *)"age", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setMaxPositionAge", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setMaxPositionAge", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_max_position_age((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SmoothMover.setMaxPositionAge() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMaxPositionAge(non-const SmoothMover this, float age)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_set_max_position_age_46_comment =
    "C++ Interface:\n"
    "setMaxPositionAge(non-const SmoothMover this, float age)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::set_max_position_age\n"
    "//       Access: Published, Static\n"
    "//  Description: Sets the maximum amount of time a position is allowed\n"
    "//               to remain unchanged before assuming it represents the\n"
    "//               avatar actually standing still.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_set_max_position_age_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double SmoothMover::get_max_position_age(void)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_get_max_position_age_47(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline double SmoothMover::get_max_position_age(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxPositionAge", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxPositionAge"));
        if(!PyErr_Occurred())
        {
            double return_value = (local_this)->get_max_position_age();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SmoothMover.getMaxPositionAge() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxPositionAge(non-const SmoothMover this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_get_max_position_age_47_comment =
    "C++ Interface:\n"
    "getMaxPositionAge(non-const SmoothMover this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::get_max_position_age\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the maximum amount of time a position is\n"
    "//               allowed to remain unchanged before assuming it\n"
    "//               represents the avatar actually standing still.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_get_max_position_age_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SmoothMover::set_expected_broadcast_period(double period)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_set_expected_broadcast_period_48(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SmoothMover::set_expected_broadcast_period(double period)
        double param1;
        static char * key_word_list[] = {(char *)"period", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setExpectedBroadcastPeriod", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setExpectedBroadcastPeriod", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_expected_broadcast_period((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SmoothMover.setExpectedBroadcastPeriod() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setExpectedBroadcastPeriod(non-const SmoothMover this, float period)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_set_expected_broadcast_period_48_comment =
    "C++ Interface:\n"
    "setExpectedBroadcastPeriod(non-const SmoothMover this, float period)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::set_expected_broadcast_period\n"
    "//       Access: Published, Static\n"
    "//  Description: Sets the interval at which we expect the SmoothNodes\n"
    "//               to broadcast their position, in elapsed seconds.\n"
    "//               This controls the length of time we assume the object\n"
    "//               has truly stopped, when we receive a long sequence of\n"
    "//               no updates.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_set_expected_broadcast_period_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double SmoothMover::get_expected_broadcast_period(void)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_get_expected_broadcast_period_49(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline double SmoothMover::get_expected_broadcast_period(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getExpectedBroadcastPeriod", key_word_list));
        else
            (PyArg_Parse(args, ":getExpectedBroadcastPeriod"));
        if(!PyErr_Occurred())
        {
            double return_value = (local_this)->get_expected_broadcast_period();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SmoothMover.getExpectedBroadcastPeriod() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getExpectedBroadcastPeriod(non-const SmoothMover this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_get_expected_broadcast_period_49_comment =
    "C++ Interface:\n"
    "getExpectedBroadcastPeriod(non-const SmoothMover this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::get_expected_broadcast_period\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the interval at which we expect the SmoothNodes\n"
    "//               to broadcast their position, in elapsed seconds.  See\n"
    "//               set_expected_broadcast_period().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_get_expected_broadcast_period_49_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SmoothMover::set_reset_velocity_age(double age)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_set_reset_velocity_age_50(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SmoothMover::set_reset_velocity_age(double age)
        double param1;
        static char * key_word_list[] = {(char *)"age", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setResetVelocityAge", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setResetVelocityAge", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_reset_velocity_age((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SmoothMover.setResetVelocityAge() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setResetVelocityAge(non-const SmoothMover this, float age)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_set_reset_velocity_age_50_comment =
    "C++ Interface:\n"
    "setResetVelocityAge(non-const SmoothMover this, float age)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::set_reset_velocity_age\n"
    "//       Access: Published, Static\n"
    "//  Description: Sets the amount of time that should elapse after the\n"
    "//               last position report before the velocity is reset to\n"
    "//               0.  This is similar to max_position_age, but it is\n"
    "//               only used to determine the resetting of the reported\n"
    "//               velocity.  It should always be greater than or equal\n"
    "//               to max_position_age.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_set_reset_velocity_age_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double SmoothMover::get_reset_velocity_age(void)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_get_reset_velocity_age_51(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline double SmoothMover::get_reset_velocity_age(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getResetVelocityAge", key_word_list));
        else
            (PyArg_Parse(args, ":getResetVelocityAge"));
        if(!PyErr_Occurred())
        {
            double return_value = (local_this)->get_reset_velocity_age();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SmoothMover.getResetVelocityAge() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getResetVelocityAge(non-const SmoothMover this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_get_reset_velocity_age_51_comment =
    "C++ Interface:\n"
    "getResetVelocityAge(non-const SmoothMover this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::get_reset_velocity_age\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the amount of time that should elapse after\n"
    "//               the last position report before the velocity is reset\n"
    "//               to 0.  See set_reset_velocity_age().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_get_reset_velocity_age_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SmoothMover::set_directional_velocity(bool flag)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_set_directional_velocity_52(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SmoothMover::set_directional_velocity(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setDirectionalVelocity", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setDirectionalVelocity", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_directional_velocity((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SmoothMover.setDirectionalVelocity() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDirectionalVelocity(non-const SmoothMover this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_set_directional_velocity_52_comment =
    "C++ Interface:\n"
    "setDirectionalVelocity(non-const SmoothMover this, bool flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::set_directional_velocity\n"
    "//       Access: Published, Static\n"
    "//  Description: Sets the flag that indicates whether the avatar's\n"
    "//               direction is considered in computing the velocity.\n"
    "//               When this is true, velocity is automatically\n"
    "//               decomposed into a forward and a lateral velocity (and\n"
    "//               both may be positive or negative); when it is false,\n"
    "//               all velocity is always returned as forward velocity\n"
    "//               (and it is always positive).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_set_directional_velocity_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SmoothMover::get_directional_velocity(void)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_get_directional_velocity_53(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool SmoothMover::get_directional_velocity(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDirectionalVelocity", key_word_list));
        else
            (PyArg_Parse(args, ":getDirectionalVelocity"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->get_directional_velocity();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SmoothMover.getDirectionalVelocity() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDirectionalVelocity(non-const SmoothMover this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_get_directional_velocity_53_comment =
    "C++ Interface:\n"
    "getDirectionalVelocity(non-const SmoothMover this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::get_directional_velocity\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the current state of the 'directional\n"
    "//               velocity' flag.  See set_directional_velocity().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_get_directional_velocity_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void SmoothMover::set_default_to_standing_still(bool flag)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_set_default_to_standing_still_54(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void SmoothMover::set_default_to_standing_still(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setDefaultToStandingStill", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setDefaultToStandingStill", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_default_to_standing_still((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SmoothMover.setDefaultToStandingStill() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDefaultToStandingStill(non-const SmoothMover this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_set_default_to_standing_still_54_comment =
    "C++ Interface:\n"
    "setDefaultToStandingStill(non-const SmoothMover this, bool flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::set_default_to_standing_still\n"
    "//       Access: Published, Static\n"
    "//  Description: Sets the flag that indicates whether to assume that\n"
    "//               the node stopped moving during periods when we don't\n"
    "//               get enough position updates. If true, the object will\n"
    "//               stand still momentarily. If false, the object will\n"
    "//               continuously lerp between the position updates that\n"
    "//               we did get.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_set_default_to_standing_still_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool SmoothMover::get_default_to_standing_still(void)
 *******************************************************************/
static PyObject *Dtool_SmoothMover_get_default_to_standing_still_55(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool SmoothMover::get_default_to_standing_still(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDefaultToStandingStill", key_word_list));
        else
            (PyArg_Parse(args, ":getDefaultToStandingStill"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->get_default_to_standing_still();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SmoothMover.getDefaultToStandingStill() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDefaultToStandingStill(non-const SmoothMover this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_get_default_to_standing_still_55_comment =
    "C++ Interface:\n"
    "getDefaultToStandingStill(non-const SmoothMover this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::get_default_to_standing_still\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the current state of the 'default to standing\n"
    "//               still' flag.  See set_default_to_standing_still().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_get_default_to_standing_still_55_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void SmoothMover::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_SmoothMover_output_56(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void SmoothMover::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "SmoothMover.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const SmoothMover*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const SmoothMover this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_output_56_comment =
    "C++ Interface:\n"
    "output(const SmoothMover this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_output_56_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void SmoothMover::write(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_SmoothMover_write_57(PyObject *self, PyObject *args,PyObject *kwds) {
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void SmoothMover::write(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:write", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "SmoothMover.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const SmoothMover*)local_this)->write(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const SmoothMover this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SmoothMover_write_57_comment =
    "C++ Interface:\n"
    "write(const SmoothMover this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: SmoothMover::write\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_SmoothMover_write_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * SmoothMover::SmoothMover(void)
 *******************************************************************/
int  Dtool_Init_SmoothMover(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-SmoothMover::SmoothMover(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":SmoothMover", key_word_list))
        {
            SmoothMover *return_value = new SmoothMover();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_SmoothMover,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "SmoothMover()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_SmoothMover(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SmoothMover)
    {
        printf("SmoothMover ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SmoothMover * local_this = (SmoothMover *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SmoothMover)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SmoothMover(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SmoothMover)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. SmoothMover | SmoothMover
//********************************************************************
PyMethodDef Dtool_Methods_SmoothMover[]= {
  { "setPos",(PyCFunction ) &Dtool_SmoothMover_set_pos_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_set_pos_4_comment},
  { "setX",(PyCFunction ) &Dtool_SmoothMover_set_x_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_set_x_5_comment},
  { "setY",(PyCFunction ) &Dtool_SmoothMover_set_y_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_set_y_6_comment},
  { "setZ",(PyCFunction ) &Dtool_SmoothMover_set_z_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_set_z_7_comment},
  { "setHpr",(PyCFunction ) &Dtool_SmoothMover_set_hpr_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_set_hpr_8_comment},
  { "setH",(PyCFunction ) &Dtool_SmoothMover_set_h_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_set_h_9_comment},
  { "setP",(PyCFunction ) &Dtool_SmoothMover_set_p_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_set_p_10_comment},
  { "setR",(PyCFunction ) &Dtool_SmoothMover_set_r_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_set_r_11_comment},
  { "setPosHpr",(PyCFunction ) &Dtool_SmoothMover_set_pos_hpr_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_set_pos_hpr_12_comment},
  { "getSamplePos",(PyCFunction ) &Dtool_SmoothMover_get_sample_pos_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_get_sample_pos_13_comment},
  { "getSampleHpr",(PyCFunction ) &Dtool_SmoothMover_get_sample_hpr_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_get_sample_hpr_14_comment},
  { "setPhonyTimestamp",(PyCFunction ) &Dtool_SmoothMover_set_phony_timestamp_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_set_phony_timestamp_15_comment},
  { "setTimestamp",(PyCFunction ) &Dtool_SmoothMover_set_timestamp_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_set_timestamp_16_comment},
  { "hasMostRecentTimestamp",(PyCFunction ) &Dtool_SmoothMover_has_most_recent_timestamp_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_has_most_recent_timestamp_17_comment},
  { "getMostRecentTimestamp",(PyCFunction ) &Dtool_SmoothMover_get_most_recent_timestamp_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_get_most_recent_timestamp_18_comment},
  { "markPosition",(PyCFunction ) &Dtool_SmoothMover_mark_position_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_mark_position_19_comment},
  { "clearPositions",(PyCFunction ) &Dtool_SmoothMover_clear_positions_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_clear_positions_20_comment},
  { "computeSmoothPosition",(PyCFunction ) &Dtool_SmoothMover_compute_smooth_position_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_compute_smooth_position_21_comment},
  { "getLatestPosition",(PyCFunction ) &Dtool_SmoothMover_get_latest_position_22, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_get_latest_position_22_comment},
  { "getSmoothPos",(PyCFunction ) &Dtool_SmoothMover_get_smooth_pos_23, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_get_smooth_pos_23_comment},
  { "getSmoothHpr",(PyCFunction ) &Dtool_SmoothMover_get_smooth_hpr_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_get_smooth_hpr_24_comment},
  { "applySmoothPos",(PyCFunction ) &Dtool_SmoothMover_apply_smooth_pos_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_apply_smooth_pos_25_comment},
  { "applySmoothPosHpr",(PyCFunction ) &Dtool_SmoothMover_apply_smooth_pos_hpr_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_apply_smooth_pos_hpr_26_comment},
  { "applySmoothHpr",(PyCFunction ) &Dtool_SmoothMover_apply_smooth_hpr_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_apply_smooth_hpr_27_comment},
  { "computeAndApplySmoothPos",(PyCFunction ) &Dtool_SmoothMover_compute_and_apply_smooth_pos_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_compute_and_apply_smooth_pos_28_comment},
  { "computeAndApplySmoothPosHpr",(PyCFunction ) &Dtool_SmoothMover_compute_and_apply_smooth_pos_hpr_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_compute_and_apply_smooth_pos_hpr_29_comment},
  { "computeAndApplySmoothHpr",(PyCFunction ) &Dtool_SmoothMover_compute_and_apply_smooth_hpr_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_compute_and_apply_smooth_hpr_30_comment},
  { "getSmoothForwardVelocity",(PyCFunction ) &Dtool_SmoothMover_get_smooth_forward_velocity_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_get_smooth_forward_velocity_31_comment},
  { "getSmoothLateralVelocity",(PyCFunction ) &Dtool_SmoothMover_get_smooth_lateral_velocity_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_get_smooth_lateral_velocity_32_comment},
  { "getSmoothRotationalVelocity",(PyCFunction ) &Dtool_SmoothMover_get_smooth_rotational_velocity_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_get_smooth_rotational_velocity_33_comment},
  { "getForwardAxis",(PyCFunction ) &Dtool_SmoothMover_get_forward_axis_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_get_forward_axis_34_comment},
  { "handleWrtReparent",(PyCFunction ) &Dtool_SmoothMover_handle_wrt_reparent_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_handle_wrt_reparent_35_comment},
  { "setSmoothMode",(PyCFunction ) &Dtool_SmoothMover_set_smooth_mode_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_set_smooth_mode_38_comment},
  { "getSmoothMode",(PyCFunction ) &Dtool_SmoothMover_get_smooth_mode_39, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_get_smooth_mode_39_comment},
  { "setPredictionMode",(PyCFunction ) &Dtool_SmoothMover_set_prediction_mode_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_set_prediction_mode_40_comment},
  { "getPredictionMode",(PyCFunction ) &Dtool_SmoothMover_get_prediction_mode_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_get_prediction_mode_41_comment},
  { "setDelay",(PyCFunction ) &Dtool_SmoothMover_set_delay_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_set_delay_42_comment},
  { "getDelay",(PyCFunction ) &Dtool_SmoothMover_get_delay_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_get_delay_43_comment},
  { "setAcceptClockSkew",(PyCFunction ) &Dtool_SmoothMover_set_accept_clock_skew_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_set_accept_clock_skew_44_comment},
  { "getAcceptClockSkew",(PyCFunction ) &Dtool_SmoothMover_get_accept_clock_skew_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_get_accept_clock_skew_45_comment},
  { "setMaxPositionAge",(PyCFunction ) &Dtool_SmoothMover_set_max_position_age_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_set_max_position_age_46_comment},
  { "getMaxPositionAge",(PyCFunction ) &Dtool_SmoothMover_get_max_position_age_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_get_max_position_age_47_comment},
  { "setExpectedBroadcastPeriod",(PyCFunction ) &Dtool_SmoothMover_set_expected_broadcast_period_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_set_expected_broadcast_period_48_comment},
  { "getExpectedBroadcastPeriod",(PyCFunction ) &Dtool_SmoothMover_get_expected_broadcast_period_49, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_get_expected_broadcast_period_49_comment},
  { "setResetVelocityAge",(PyCFunction ) &Dtool_SmoothMover_set_reset_velocity_age_50, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_set_reset_velocity_age_50_comment},
  { "getResetVelocityAge",(PyCFunction ) &Dtool_SmoothMover_get_reset_velocity_age_51, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_get_reset_velocity_age_51_comment},
  { "setDirectionalVelocity",(PyCFunction ) &Dtool_SmoothMover_set_directional_velocity_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_set_directional_velocity_52_comment},
  { "getDirectionalVelocity",(PyCFunction ) &Dtool_SmoothMover_get_directional_velocity_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_get_directional_velocity_53_comment},
  { "setDefaultToStandingStill",(PyCFunction ) &Dtool_SmoothMover_set_default_to_standing_still_54, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_set_default_to_standing_still_54_comment},
  { "getDefaultToStandingStill",(PyCFunction ) &Dtool_SmoothMover_get_default_to_standing_still_55, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_get_default_to_standing_still_55_comment},
  { "output",(PyCFunction ) &Dtool_SmoothMover_output_56, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_output_56_comment},
  { "write",(PyCFunction ) &Dtool_SmoothMover_write_57, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SmoothMover_write_57_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     SmoothMover
//////////////////
static PyObject *  Dtool_Repr_SmoothMover(PyObject * self)
{
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     SmoothMover
//////////////////
static PyObject *  Dtool_Str_SmoothMover(PyObject * self)
{
    SmoothMover * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SmoothMover,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_SmoothMover(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_SmoothMover.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : SmoothMover\n"
          "// Description : This class handles smoothing of sampled motion points\n"
          "//               over time, e.g. for smoothing the apparent movement\n"
          "//               of remote avatars, whose positions are sent via\n"
          "//               occasional telemetry updates.\n"
          "//\n"
          "//               It can operate in any of three modes: off, in which\n"
          "//               it does not smooth any motion but provides the last\n"
          "//               position it was told; smoothing only, in which it\n"
          "//               smooths motion information but never tries to\n"
          "//               anticipate where the avatar might be going; or full\n"
          "//               prediction, in which it smooths motion as well as\n"
          "//               tries to predict the avatar's position in lead of the\n"
          "//               last position update.  The assumption is that all\n"
          "//               SmoothMovers in the world will be operating in the\n"
          "//               same mode together.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_SmoothMover.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_SmoothMover.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SmoothMover.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SmoothMover.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_SmoothMover.As_PyTypeObject().tp_repr = & Dtool_Repr_SmoothMover;
        // __str__
        Dtool_SmoothMover.As_PyTypeObject().tp_str = & Dtool_Str_SmoothMover;
        // Enum  SmoothMover::SmoothMode;
        PyDict_SetItemString(Dtool_SmoothMover.As_PyTypeObject().tp_dict,"SMOff",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_SmoothMover.As_PyTypeObject().tp_dict,"SMOn",PyInt_FromLong(1));
        // Enum  SmoothMover::PredictionMode;
        PyDict_SetItemString(Dtool_SmoothMover.As_PyTypeObject().tp_dict,"PMOff",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_SmoothMover.As_PyTypeObject().tp_dict,"PMOn",PyInt_FromLong(1));
        if(PyType_Ready(&Dtool_SmoothMover.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SmoothMover)");
             printf(" Error In PyType_ReadySmoothMover");
             return;
        }
        Py_INCREF(&Dtool_SmoothMover.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SmoothMover.As_PyTypeObject().tp_dict,"SmoothMover",&Dtool_SmoothMover.As_PyObject());
        RegisterRuntimeClass(&Dtool_SmoothMover,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SmoothMover.As_PyTypeObject());
        PyModule_AddObject(module, "SmoothMover",(PyObject *)&Dtool_SmoothMover.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..SmoothMover
//********************************************************************
   Dtool_PyModuleClassInit_SmoothMover(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libdeadrec_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687213723,  /* file_identifier */
  "libdeadrec",  /* library_name */
  "w5Y6",  /* library_hash_name */
  "p3direct",  /* module_name */
  "libdeadrec.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  136  /* next_index */
};

Configure(_in_configure_libdeadrec);
ConfigureFn(_in_configure_libdeadrec) {
  interrogate_request_module(&_in_module_def);
}

