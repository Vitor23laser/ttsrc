/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/distort -Ipanda/src/distort -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libdistort_igate.cxx -od built_Rocket/pandac/input/libdistort.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/distort -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDAFX -module pandafx -library libdistort config_distort.h cylindricalLens.h distort_composite.cxx fisheyeLens.h nonlinearImager.h pSphereLens.h projectionScreen.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libdistort
#include "py_panda.h"  

#include "configVariableBool.h"
#include "config_distort.h"
#include "cylindricalLens.h"
#include "fisheyeLens.h"
#include "lens.h"
#include "nonlinearImager.h"
#include "notifyCategoryProxy.h"
#include "pSphereLens.h"
#include "pandabase.h"
#include "projectionScreen.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. CylindricalLens
//********************************************************************
typedef  CylindricalLens  CylindricalLens_localtype;
Define_Module_ClassRef(pandafx,CylindricalLens,CylindricalLens_localtype,CylindricalLens);
//********************************************************************
//*** prototypes for .. FisheyeLens
//********************************************************************
typedef  FisheyeLens  FisheyeLens_localtype;
Define_Module_ClassRef(pandafx,FisheyeLens,FisheyeLens_localtype,FisheyeLens);
//********************************************************************
//*** prototypes for .. PSphereLens
//********************************************************************
typedef  PSphereLens  PSphereLens_localtype;
Define_Module_ClassRef(pandafx,PSphereLens,PSphereLens_localtype,PSphereLens);
//********************************************************************
//*** prototypes for .. ProjectionScreen
//********************************************************************
typedef  ProjectionScreen  ProjectionScreen_localtype;
Define_Module_ClassRef(pandafx,ProjectionScreen,ProjectionScreen_localtype,ProjectionScreen);
//********************************************************************
//*** prototypes for .. NonlinearImager
//********************************************************************
typedef  NonlinearImager  NonlinearImager_localtype;
Define_Module_Class(pandafx,NonlinearImager,NonlinearImager_localtype,NonlinearImager);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_DisplayRegion;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_GeomNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_GraphicsEngine;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_GraphicsOutput;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Lens;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Namable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_NodePath;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PandaNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. CylindricalLens 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CylindricalLens::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CylindricalLens_get_class_type_4(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CylindricalLens::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CylindricalLens::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CylindricalLens_get_class_type_4_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CylindricalLens_get_class_type_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CylindricalLens::CylindricalLens(void)
 *******************************************************************/
int  Dtool_Init_CylindricalLens(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline CylindricalLens::CylindricalLens(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":CylindricalLens", key_word_list))
        {
            CylindricalLens *return_value = new CylindricalLens();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_CylindricalLens,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "CylindricalLens()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CylindricalLens(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CylindricalLens)
    {
        printf("CylindricalLens ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CylindricalLens * local_this = (CylindricalLens *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CylindricalLens)
        return local_this;
    if(requested_type == &Dtool_Lens)
        return ( Lens *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( Lens *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( Lens *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( Lens *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( Lens *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CylindricalLens(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CylindricalLens)
        return from_this;
    if(from_type == &Dtool_Lens)
    {
          Lens* other_this = (Lens*)from_this;
          return (CylindricalLens*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CylindricalLens*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CylindricalLens*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (CylindricalLens*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (CylindricalLens*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. FisheyeLens 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle FisheyeLens::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_FisheyeLens_get_class_type_8(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle FisheyeLens::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = FisheyeLens::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_FisheyeLens_get_class_type_8_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_FisheyeLens_get_class_type_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline FisheyeLens::FisheyeLens(void)
 *******************************************************************/
int  Dtool_Init_FisheyeLens(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline FisheyeLens::FisheyeLens(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":FisheyeLens", key_word_list))
        {
            FisheyeLens *return_value = new FisheyeLens();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_FisheyeLens,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "FisheyeLens()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_FisheyeLens(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_FisheyeLens)
    {
        printf("FisheyeLens ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    FisheyeLens * local_this = (FisheyeLens *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_FisheyeLens)
        return local_this;
    if(requested_type == &Dtool_Lens)
        return ( Lens *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( Lens *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( Lens *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( Lens *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( Lens *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_FisheyeLens(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_FisheyeLens)
        return from_this;
    if(from_type == &Dtool_Lens)
    {
          Lens* other_this = (Lens*)from_this;
          return (FisheyeLens*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (FisheyeLens*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (FisheyeLens*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (FisheyeLens*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (FisheyeLens*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PSphereLens 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle PSphereLens::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_PSphereLens_get_class_type_12(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle PSphereLens::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = PSphereLens::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PSphereLens_get_class_type_12_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_PSphereLens_get_class_type_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PSphereLens::PSphereLens(void)
 *******************************************************************/
int  Dtool_Init_PSphereLens(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline PSphereLens::PSphereLens(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":PSphereLens", key_word_list))
        {
            PSphereLens *return_value = new PSphereLens();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_PSphereLens,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "PSphereLens()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PSphereLens(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PSphereLens)
    {
        printf("PSphereLens ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PSphereLens * local_this = (PSphereLens *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PSphereLens)
        return local_this;
    if(requested_type == &Dtool_Lens)
        return ( Lens *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedWritableReferenceCount *)( Lens *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( TypedWritableReferenceCount *)( Lens *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( TypedWritableReferenceCount *)( Lens *) local_this;
    if(requested_type == &Dtool_TypedWritableReferenceCount)
        return ( TypedWritableReferenceCount *)( Lens *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PSphereLens(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PSphereLens)
        return from_this;
    if(from_type == &Dtool_Lens)
    {
          Lens* other_this = (Lens*)from_this;
          return (PSphereLens*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (PSphereLens*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (PSphereLens*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (PSphereLens*)other_this;
    }
    if(from_type == &Dtool_TypedWritableReferenceCount)
    {
          TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
          return (PSphereLens*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ProjectionScreen 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void ProjectionScreen::set_projector(NodePath const &projector)
 *******************************************************************/
static PyObject *Dtool_ProjectionScreen_set_projector_17(PyObject *self, PyObject *args,PyObject *kwds) {
    ProjectionScreen * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ProjectionScreen,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void ProjectionScreen::set_projector(NodePath const &projector)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"projector", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setProjector", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setProjector", &param1));
            if(!PyErr_Occurred())
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "ProjectionScreen.setProjector", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_projector(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ProjectionScreen.setProjector() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setProjector(non-const ProjectionScreen this, const NodePath projector)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ProjectionScreen_set_projector_17_comment =
    "C++ Interface:\n"
    "setProjector(non-const ProjectionScreen this, const NodePath projector)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ProjectionScreen::set_projector\n"
    "//       Access: Published\n"
    "//  Description: Specifies the LensNode that is to serve as the\n"
    "//               projector for this screen.  The relative position of\n"
    "//               the LensNode to the ProjectionScreen, as well as the\n"
    "//               properties of the lens associated with the LensNode,\n"
    "//               determines the UV's that will be assigned to the\n"
    "//               geometry within the ProjectionScreen.\n"
    "//\n"
    "//               The NodePath must refer to a LensNode (or a Camera).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ProjectionScreen_set_projector_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NodePath const &ProjectionScreen::get_projector(void) const
 *******************************************************************/
static PyObject *Dtool_ProjectionScreen_get_projector_18(PyObject *self, PyObject *args,PyObject *kwds) {
    ProjectionScreen * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ProjectionScreen,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NodePath const &ProjectionScreen::get_projector(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getProjector", key_word_list));
        else
            (PyArg_Parse(args, ":getProjector"));
        if(!PyErr_Occurred())
        {
            NodePath const *return_value = &(((const ProjectionScreen*)local_this)->get_projector());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getProjector(const ProjectionScreen this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ProjectionScreen_get_projector_18_comment =
    "C++ Interface:\n"
    "getProjector(const ProjectionScreen this)\n"
    "\n"
    "// Filename: projectionScreen.I\n"
    "// Created by:  drose (11Dec01)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ProjectionScreen::get_projector\n"
    "//       Access: Published\n"
    "//  Description: Returns the NodePath to the LensNode that is to serve\n"
    "//               as the projector for this screen, or empty if no\n"
    "//               projector is associated.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ProjectionScreen_get_projector_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< GeomNode > ProjectionScreen::generate_screen(NodePath const &projector, basic_string< char > const &screen_name, int num_x_verts, int num_y_verts, float distance, float fill_ratio)
 *******************************************************************/
static PyObject *Dtool_ProjectionScreen_generate_screen_19(PyObject *self, PyObject *args,PyObject *kwds) {
    ProjectionScreen * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ProjectionScreen,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-PointerTo< GeomNode > ProjectionScreen::generate_screen(NodePath const &projector, basic_string< char > const &screen_name, int num_x_verts, int num_y_verts, float distance, float fill_ratio)
            PyObject *param1;
            char *param2_str; int param2_len;
            int param3;
            int param4;
            double param5;
            double param6;
            static char * key_word_list[] = {(char *)"projector", (char *)"screen_name", (char *)"num_x_verts", (char *)"num_y_verts", (char *)"distance", (char *)"fill_ratio", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#iidd:generateScreen", key_word_list, &param1, &param2_str, &param2_len, &param3, &param4, &param5, &param6))
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "ProjectionScreen.generateScreen", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    PointerTo< GeomNode > return_value = (local_this)->generate_screen(*param1_this, basic_string<char>(param2_str, param2_len), (int)param3, (int)param4, (float)param5, (float)param6);
                    if (return_value != (GeomNode *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value.p() == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_GeomNode,true, false, (return_value.p())->as_typed_object()->get_type_index());
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ProjectionScreen.generateScreen() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "generateScreen(non-const ProjectionScreen this, const NodePath projector, string screen_name, int num_x_verts, int num_y_verts, float distance, float fill_ratio)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ProjectionScreen_generate_screen_19_comment =
    "C++ Interface:\n"
    "generateScreen(non-const ProjectionScreen this, const NodePath projector, string screen_name, int num_x_verts, int num_y_verts, float distance, float fill_ratio)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ProjectionScreen::generate_screen\n"
    "//       Access: Published\n"
    "//  Description: Synthesizes a polygon mesh based on the projection\n"
    "//               area of the indicated projector.  This generates and\n"
    "//               returns a new GeomNode but does not automatically\n"
    "//               parent it to the ProjectionScreen node; see\n"
    "//               regenerate_screen().\n"
    "//\n"
    "//               The specified projector need not be the same as the\n"
    "//               projector given to the ProjectionScreen with\n"
    "//               set_projector() (although this is often what you\n"
    "//               want).\n"
    "//\n"
    "//               num_x_verts and num_y_verts specify the number of\n"
    "//               vertices to make in the grid across the horizontal\n"
    "//               and vertical dimension of the projector,\n"
    "//               respectively; distance represents the approximate\n"
    "//               distance of the screen from the lens center.\n"
    "//\n"
    "//               The fill_ratio parameter specifies the fraction of\n"
    "//               the image to cover.  If it is 1.0, the entire image\n"
    "//               is shown full-size; if it is 0.9, 10% of the image\n"
    "//               around the edges is not part of the grid (and the\n"
    "//               grid is drawn smaller by the same 10%).  This is\n"
    "//               intended to work around graphics drivers that tend to\n"
    "//               show dark edges or other unsatisfactory artifacts\n"
    "//               around the edges of textures: render the texture\n"
    "//               larger than necessary by a certain fraction, and make\n"
    "//               the screen smaller by the inverse fraction.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ProjectionScreen_generate_screen_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ProjectionScreen::regenerate_screen(NodePath const &projector, basic_string< char > const &screen_name, int num_x_verts, int num_y_verts, float distance, float fill_ratio)
 *******************************************************************/
static PyObject *Dtool_ProjectionScreen_regenerate_screen_20(PyObject *self, PyObject *args,PyObject *kwds) {
    ProjectionScreen * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ProjectionScreen,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void ProjectionScreen::regenerate_screen(NodePath const &projector, basic_string< char > const &screen_name, int num_x_verts, int num_y_verts, float distance, float fill_ratio)
            PyObject *param1;
            char *param2_str; int param2_len;
            int param3;
            int param4;
            double param5;
            double param6;
            static char * key_word_list[] = {(char *)"projector", (char *)"screen_name", (char *)"num_x_verts", (char *)"num_y_verts", (char *)"distance", (char *)"fill_ratio", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#iidd:regenerateScreen", key_word_list, &param1, &param2_str, &param2_len, &param3, &param4, &param5, &param6))
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "ProjectionScreen.regenerateScreen", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->regenerate_screen(*param1_this, basic_string<char>(param2_str, param2_len), (int)param3, (int)param4, (float)param5, (float)param6);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ProjectionScreen.regenerateScreen() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "regenerateScreen(non-const ProjectionScreen this, const NodePath projector, string screen_name, int num_x_verts, int num_y_verts, float distance, float fill_ratio)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ProjectionScreen_regenerate_screen_20_comment =
    "C++ Interface:\n"
    "regenerateScreen(non-const ProjectionScreen this, const NodePath projector, string screen_name, int num_x_verts, int num_y_verts, float distance, float fill_ratio)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ProjectionScreen::regenerate_screen\n"
    "//       Access: Published\n"
    "//  Description: Removes all the children from the ProjectionScreen\n"
    "//               node, and adds the newly generated child returned by\n"
    "//               generate_screen().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ProjectionScreen_regenerate_screen_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< PandaNode > ProjectionScreen::make_flat_mesh(NodePath const &this_np, NodePath const &camera)
 *******************************************************************/
static PyObject *Dtool_ProjectionScreen_make_flat_mesh_21(PyObject *self, PyObject *args,PyObject *kwds) {
    ProjectionScreen * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ProjectionScreen,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-PointerTo< PandaNode > ProjectionScreen::make_flat_mesh(NodePath const &this_np, NodePath const &camera)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"this_np", (char *)"camera", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:makeFlatMesh", key_word_list, &param1, &param2))
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "ProjectionScreen.makeFlatMesh", 1, coerced_ptr, report_errors);
NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "ProjectionScreen.makeFlatMesh", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    PointerTo< PandaNode > return_value = (local_this)->make_flat_mesh(*param1_this, *param2_this);
                    if (return_value != (PandaNode *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value.p() == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_PandaNode,true, false, (return_value.p())->as_typed_object()->get_type_index());
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ProjectionScreen.makeFlatMesh() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeFlatMesh(non-const ProjectionScreen this, const NodePath this_np, const NodePath camera)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ProjectionScreen_make_flat_mesh_21_comment =
    "C++ Interface:\n"
    "makeFlatMesh(non-const ProjectionScreen this, const NodePath this_np, const NodePath camera)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ProjectionScreen::make_flat_mesh\n"
    "//       Access: Published\n"
    "//  Description: Generates a deep copy of the hierarchy at the\n"
    "//               ProjectionScreen node and below, with vertices\n"
    "//               flattened into two dimensions as if they were seen by\n"
    "//               the indicated camera node.\n"
    "//\n"
    "//               This is useful for rendering an image as seen through\n"
    "//               a non-linear lens.  The resulting mesh will have\n"
    "//               vertices in the range [-1, 1] in both x and y, and\n"
    "//               may be then rendered with an ordinary orthographic\n"
    "//               lens, to generate the effect of seeing the image\n"
    "//               through the specified non-linear lens.\n"
    "//\n"
    "//               The returned node has no parent; it is up to the\n"
    "//               caller to parent it somewhere or store it so that it\n"
    "//               does not get dereferenced and deleted.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ProjectionScreen_make_flat_mesh_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ProjectionScreen::set_texcoord_name(basic_string< char > const &texcoord_name)
 *******************************************************************/
static PyObject *Dtool_ProjectionScreen_set_texcoord_name_22(PyObject *self, PyObject *args,PyObject *kwds) {
    ProjectionScreen * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ProjectionScreen,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ProjectionScreen::set_texcoord_name(basic_string< char > const &texcoord_name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"texcoord_name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setTexcoordName", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setTexcoordName", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_texcoord_name(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ProjectionScreen.setTexcoordName() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTexcoordName(non-const ProjectionScreen this, string texcoord_name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ProjectionScreen_set_texcoord_name_22_comment =
    "C++ Interface:\n"
    "setTexcoordName(non-const ProjectionScreen this, string texcoord_name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ProjectionScreen::set_texcoord_name\n"
    "//       Access: Published\n"
    "//  Description: Specifies the name of the texture coordinates that\n"
    "//               are generated by this particular ProjectionScreen.\n"
    "//               This can be used in the presence of multitexturing to\n"
    "//               compute the UV's for just a subset of all of the\n"
    "//               active stages of the multitexture pipeline.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ProjectionScreen_set_texcoord_name_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > ProjectionScreen::get_texcoord_name(void) const
 *******************************************************************/
static PyObject *Dtool_ProjectionScreen_get_texcoord_name_23(PyObject *self, PyObject *args,PyObject *kwds) {
    ProjectionScreen * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ProjectionScreen,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > ProjectionScreen::get_texcoord_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTexcoordName", key_word_list));
        else
            (PyArg_Parse(args, ":getTexcoordName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const ProjectionScreen*)local_this)->get_texcoord_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTexcoordName(const ProjectionScreen this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ProjectionScreen_get_texcoord_name_23_comment =
    "C++ Interface:\n"
    "getTexcoordName(const ProjectionScreen this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ProjectionScreen::get_texcoord_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the name of the texture coordinates that\n"
    "//               will be generated by this particular\n"
    "//               ProjectionScreen, as set by set_texcoord_name().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ProjectionScreen_get_texcoord_name_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ProjectionScreen::set_invert_uvs(bool invert_uvs)
 *******************************************************************/
static PyObject *Dtool_ProjectionScreen_set_invert_uvs_24(PyObject *self, PyObject *args,PyObject *kwds) {
    ProjectionScreen * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ProjectionScreen,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ProjectionScreen::set_invert_uvs(bool invert_uvs)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"invert_uvs", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setInvertUvs", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setInvertUvs", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_invert_uvs((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ProjectionScreen.setInvertUvs() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setInvertUvs(non-const ProjectionScreen this, bool invert_uvs)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ProjectionScreen_set_invert_uvs_24_comment =
    "C++ Interface:\n"
    "setInvertUvs(non-const ProjectionScreen this, bool invert_uvs)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ProjectionScreen::set_invert_uvs\n"
    "//       Access: Published\n"
    "//  Description: Some OpenGL graphics drivers are known to invert the\n"
    "//               framebuffer image when they copy it to texture.\n"
    "//               (This is arguably a problem with the OpenGL spec,\n"
    "//               which seems to be unclear about the proper ordering\n"
    "//               of pixels in this operation.)\n"
    "//\n"
    "//               In any case, set this true to compensate for this\n"
    "//               effect by inverting the UV's of the projection\n"
    "//               screen.  The default is taken from the Configrc\n"
    "//               variable project-invert-uvs.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ProjectionScreen_set_invert_uvs_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ProjectionScreen::get_invert_uvs(void) const
 *******************************************************************/
static PyObject *Dtool_ProjectionScreen_get_invert_uvs_25(PyObject *self, PyObject *args,PyObject *kwds) {
    ProjectionScreen * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ProjectionScreen,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ProjectionScreen::get_invert_uvs(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInvertUvs", key_word_list));
        else
            (PyArg_Parse(args, ":getInvertUvs"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ProjectionScreen*)local_this)->get_invert_uvs();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInvertUvs(const ProjectionScreen this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ProjectionScreen_get_invert_uvs_25_comment =
    "C++ Interface:\n"
    "getInvertUvs(const ProjectionScreen this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ProjectionScreen::get_invert_uvs\n"
    "//       Access: Published\n"
    "//  Description: Returns whether this screen is compensating for a\n"
    "//               graphics driver inverting the framebuffer image.  See\n"
    "//               set_invert_uvs().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ProjectionScreen_get_invert_uvs_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ProjectionScreen::set_vignette_on(bool vignette_on)
 *******************************************************************/
static PyObject *Dtool_ProjectionScreen_set_vignette_on_26(PyObject *self, PyObject *args,PyObject *kwds) {
    ProjectionScreen * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ProjectionScreen,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ProjectionScreen::set_vignette_on(bool vignette_on)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"vignette_on", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setVignetteOn", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setVignetteOn", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_vignette_on((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ProjectionScreen.setVignetteOn() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setVignetteOn(non-const ProjectionScreen this, bool vignette_on)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ProjectionScreen_set_vignette_on_26_comment =
    "C++ Interface:\n"
    "setVignetteOn(non-const ProjectionScreen this, bool vignette_on)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ProjectionScreen::set_vignette_on\n"
    "//       Access: Published\n"
    "//  Description: Specifies whether vertex-based vignetting should be\n"
    "//               on.  When this is enabled, vertex color will be set\n"
    "//               on the screen vertices to color the screen two\n"
    "//               distinct colors, usually white and black, for the\n"
    "//               parts of the screen in front of and outside the lens'\n"
    "//               frustum, respectively.  When this is not enabled, the\n"
    "//               screen color will be left alone.\n"
    "//\n"
    "//               This effect generally looks terrible, but it does\n"
    "//               at least make the boundaries of the lens clear.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ProjectionScreen_set_vignette_on_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool ProjectionScreen::get_vignette_on(void) const
 *******************************************************************/
static PyObject *Dtool_ProjectionScreen_get_vignette_on_27(PyObject *self, PyObject *args,PyObject *kwds) {
    ProjectionScreen * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ProjectionScreen,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool ProjectionScreen::get_vignette_on(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getVignetteOn", key_word_list));
        else
            (PyArg_Parse(args, ":getVignetteOn"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const ProjectionScreen*)local_this)->get_vignette_on();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVignetteOn(const ProjectionScreen this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ProjectionScreen_get_vignette_on_27_comment =
    "C++ Interface:\n"
    "getVignetteOn(const ProjectionScreen this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ProjectionScreen::get_vignette_on\n"
    "//       Access: Published\n"
    "//  Description: Returns true if vertex-based vignetting is on, false\n"
    "//               otherwise.  See set_vignette_on().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ProjectionScreen_get_vignette_on_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ProjectionScreen::set_vignette_color(LVecBase4f const &vignette_color)
 *******************************************************************/
static PyObject *Dtool_ProjectionScreen_set_vignette_color_28(PyObject *self, PyObject *args,PyObject *kwds) {
    ProjectionScreen * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ProjectionScreen,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ProjectionScreen::set_vignette_color(LVecBase4f const &vignette_color)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"vignette_color", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setVignetteColor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setVignetteColor", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "ProjectionScreen.setVignetteColor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_vignette_color(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ProjectionScreen.setVignetteColor() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setVignetteColor(non-const ProjectionScreen this, const VBase4 vignette_color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ProjectionScreen_set_vignette_color_28_comment =
    "C++ Interface:\n"
    "setVignetteColor(non-const ProjectionScreen this, const VBase4 vignette_color)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ProjectionScreen::set_vignette_color\n"
    "//       Access: Published\n"
    "//  Description: Specifies the color the screen will be painted at the\n"
    "//               portions outside of the lens' frustum; i.e. where the\n"
    "//               lens can't see it or illuminate it.  This color is\n"
    "//               only used if the vignette_on flag is true; see\n"
    "//               set_vignette_on().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ProjectionScreen_set_vignette_color_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &ProjectionScreen::get_vignette_color(void) const
 *******************************************************************/
static PyObject *Dtool_ProjectionScreen_get_vignette_color_29(PyObject *self, PyObject *args,PyObject *kwds) {
    ProjectionScreen * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ProjectionScreen,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &ProjectionScreen::get_vignette_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getVignetteColor", key_word_list));
        else
            (PyArg_Parse(args, ":getVignetteColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f const *return_value = &(((const ProjectionScreen*)local_this)->get_vignette_color());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVignetteColor(const ProjectionScreen this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ProjectionScreen_get_vignette_color_29_comment =
    "C++ Interface:\n"
    "getVignetteColor(const ProjectionScreen this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ProjectionScreen::get_vignette_color\n"
    "//       Access: Published\n"
    "//  Description: Returns the color the screen will be painted at the\n"
    "//               portions outside of the lens' frustum.  See\n"
    "//               set_vignette_color().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ProjectionScreen_get_vignette_color_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ProjectionScreen::set_frame_color(LVecBase4f const &frame_color)
 *******************************************************************/
static PyObject *Dtool_ProjectionScreen_set_frame_color_30(PyObject *self, PyObject *args,PyObject *kwds) {
    ProjectionScreen * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ProjectionScreen,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ProjectionScreen::set_frame_color(LVecBase4f const &frame_color)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"frame_color", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFrameColor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setFrameColor", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "ProjectionScreen.setFrameColor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_frame_color(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ProjectionScreen.setFrameColor() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFrameColor(non-const ProjectionScreen this, const VBase4 frame_color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ProjectionScreen_set_frame_color_30_comment =
    "C++ Interface:\n"
    "setFrameColor(non-const ProjectionScreen this, const VBase4 frame_color)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ProjectionScreen::set_frame_color\n"
    "//       Access: Published\n"
    "//  Description: Specifies the color the screen will be painted at the\n"
    "//               portions outside of the lens' frustum; i.e. where the\n"
    "//               lens can't see it or illuminate it.  This color is\n"
    "//               only used if the vignette_on flag is true; see\n"
    "//               set_vignette_on().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ProjectionScreen_set_frame_color_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &ProjectionScreen::get_frame_color(void) const
 *******************************************************************/
static PyObject *Dtool_ProjectionScreen_get_frame_color_31(PyObject *self, PyObject *args,PyObject *kwds) {
    ProjectionScreen * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ProjectionScreen,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &ProjectionScreen::get_frame_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFrameColor", key_word_list));
        else
            (PyArg_Parse(args, ":getFrameColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f const *return_value = &(((const ProjectionScreen*)local_this)->get_frame_color());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFrameColor(const ProjectionScreen this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ProjectionScreen_get_frame_color_31_comment =
    "C++ Interface:\n"
    "getFrameColor(const ProjectionScreen this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ProjectionScreen::get_frame_color\n"
    "//       Access: Published\n"
    "//  Description: Returns the color the screen will be painted at the\n"
    "//               portions outside of the lens' frustum.  See\n"
    "//               set_frame_color().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ProjectionScreen_get_frame_color_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ProjectionScreen::recompute(void)
 *******************************************************************/
static PyObject *Dtool_ProjectionScreen_recompute_32(PyObject *self, PyObject *args,PyObject *kwds) {
    ProjectionScreen * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ProjectionScreen,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ProjectionScreen::recompute(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":recompute", key_word_list));
        else
            (PyArg_Parse(args, ":recompute"));
        if(!PyErr_Occurred())
        {
            (local_this)->recompute();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ProjectionScreen.recompute() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "recompute(non-const ProjectionScreen this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ProjectionScreen_recompute_32_comment =
    "C++ Interface:\n"
    "recompute(non-const ProjectionScreen this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: ProjectionScreen::recompute\n"
    "//       Access: Published\n"
    "//  Description: Recomputes all the UV's for geometry below the\n"
    "//               ProjectionScreen node, as if the texture were\n"
    "//               projected from the associated projector.\n"
    "//\n"
    "//               This function is normally called automatically\n"
    "//               whenever the relevant properties change, so it should\n"
    "//               not normally need to be called directly by the user.\n"
    "//               However, it does no harm to call this if there is any\n"
    "//               doubt.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ProjectionScreen_recompute_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ProjectionScreen::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_ProjectionScreen_get_class_type_33(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ProjectionScreen::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ProjectionScreen::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ProjectionScreen_get_class_type_33_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_ProjectionScreen_get_class_type_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ProjectionScreen::ProjectionScreen(basic_string< char > const &name)
 * ProjectionScreen::ProjectionScreen(basic_string< char > const &name = (""))
 *******************************************************************/
int  Dtool_Init_ProjectionScreen(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-ProjectionScreen::ProjectionScreen(basic_string< char > const &name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":ProjectionScreen", key_word_list))
            {
                ProjectionScreen *return_value = new ProjectionScreen();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ProjectionScreen,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-ProjectionScreen::ProjectionScreen(basic_string< char > const &name)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:ProjectionScreen", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:ProjectionScreen", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                ProjectionScreen *return_value = new ProjectionScreen(basic_string<char>(param0_str, param0_len));
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ProjectionScreen,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "ProjectionScreen() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "ProjectionScreen()\n"
          "ProjectionScreen(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ProjectionScreen(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ProjectionScreen)
    {
        printf("ProjectionScreen ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ProjectionScreen * local_this = (ProjectionScreen *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ProjectionScreen)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ProjectionScreen(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ProjectionScreen)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (ProjectionScreen*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (ProjectionScreen*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (ProjectionScreen*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (ProjectionScreen*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. NonlinearImager 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * int NonlinearImager::add_screen(NodePath const &screen, basic_string< char > const &name)
 * int NonlinearImager::add_screen(ProjectionScreen *screen)
 *******************************************************************/
static PyObject *Dtool_NonlinearImager_add_screen_37(PyObject *self, PyObject *args,PyObject *kwds) {
    NonlinearImager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NonlinearImager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-int NonlinearImager::add_screen(ProjectionScreen *screen)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"screen", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:addScreen", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:addScreen", &param1));
                if(!PyErr_Occurred())
                {
                    ProjectionScreen *param1_this = (ProjectionScreen *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ProjectionScreen, 1, "NonlinearImager.addScreen", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        int return_value = (local_this)->add_screen(param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call NonlinearImager.addScreen() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-int NonlinearImager::add_screen(NodePath const &screen, basic_string< char > const &name)
                PyObject *param1;
                char *param2_str; int param2_len;
                static char * key_word_list[] = {(char *)"screen", (char *)"name", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:addScreen", key_word_list, &param1, &param2_str, &param2_len))
                {
                    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "NonlinearImager.addScreen", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        int return_value = (local_this)->add_screen(*param1_this, basic_string<char>(param2_str, param2_len));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call NonlinearImager.addScreen() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "addScreen() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "addScreen(non-const NonlinearImager this, non-const ProjectionScreen screen)\n"
          "addScreen(non-const NonlinearImager this, const NodePath screen, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NonlinearImager_add_screen_37_comment =
    "C++ Interface:\n"
    "addScreen(non-const NonlinearImager this, non-const ProjectionScreen screen)\n"
    "addScreen(non-const NonlinearImager this, const NodePath screen, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NonlinearImager::add_screen\n"
    "//       Access: Published\n"
    "//               This version of this method is deprecated and will\n"
    "//               soon be removed.  Use the version that takes two\n"
    "//               parameters instead.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NonlinearImager::add_screen\n"
    "//       Access: Published\n"
    "//  Description: Adds a new ProjectionScreen to the list of screens\n"
    "//               that will be processed by the NonlinearImager.  Each\n"
    "//               ProjectionScreen represents a view into the world.\n"
    "//               It must be based on a linear camera (or whatever kind\n"
    "//               of camera is respected by the graphics engine).\n"
    "//\n"
    "//               Each ProjectionScreen object should already have some\n"
    "//               screen geometry created.\n"
    "//\n"
    "//               As each frame is rendered, an offscreen image will be\n"
    "//               rendered from the source camera associated with each\n"
    "//               ProjectionScreen, and the resulting image will be\n"
    "//               applied to the screen geometry.\n"
    "//\n"
    "//               The return value is the index number of the new\n"
    "//               screen.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NonlinearImager_add_screen_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int NonlinearImager::find_screen(NodePath const &screen) const
 *******************************************************************/
static PyObject *Dtool_NonlinearImager_find_screen_38(PyObject *self, PyObject *args,PyObject *kwds) {
    NonlinearImager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NonlinearImager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-int NonlinearImager::find_screen(NodePath const &screen) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"screen", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:findScreen", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:findScreen", &param1));
            if(!PyErr_Occurred())
            {
                NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "NonlinearImager.findScreen", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = ((const NonlinearImager*)local_this)->find_screen(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findScreen(const NonlinearImager this, const NodePath screen)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NonlinearImager_find_screen_38_comment =
    "C++ Interface:\n"
    "findScreen(const NonlinearImager this, const NodePath screen)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NonlinearImager::find_screen\n"
    "//       Access: Published\n"
    "//  Description: Returns the index number of the first appearance of\n"
    "//               the indicated screen within the imager's list, or -1\n"
    "//               if it does not appear.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NonlinearImager_find_screen_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NonlinearImager::remove_screen(int index)
 *******************************************************************/
static PyObject *Dtool_NonlinearImager_remove_screen_39(PyObject *self, PyObject *args,PyObject *kwds) {
    NonlinearImager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NonlinearImager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void NonlinearImager::remove_screen(int index)
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:removeScreen", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:removeScreen", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->remove_screen((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NonlinearImager.removeScreen() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeScreen(non-const NonlinearImager this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NonlinearImager_remove_screen_39_comment =
    "C++ Interface:\n"
    "removeScreen(non-const NonlinearImager this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NonlinearImager::remove_screen\n"
    "//       Access: Published\n"
    "//  Description: Removes the screen with the indicated index number\n"
    "//               from the imager.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NonlinearImager_remove_screen_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NonlinearImager::remove_all_screens(void)
 *******************************************************************/
static PyObject *Dtool_NonlinearImager_remove_all_screens_40(PyObject *self, PyObject *args,PyObject *kwds) {
    NonlinearImager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NonlinearImager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void NonlinearImager::remove_all_screens(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":removeAllScreens", key_word_list));
        else
            (PyArg_Parse(args, ":removeAllScreens"));
        if(!PyErr_Occurred())
        {
            (local_this)->remove_all_screens();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NonlinearImager.removeAllScreens() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeAllScreens(non-const NonlinearImager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NonlinearImager_remove_all_screens_40_comment =
    "C++ Interface:\n"
    "removeAllScreens(non-const NonlinearImager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NonlinearImager::remove_all_screens\n"
    "//       Access: Published\n"
    "//  Description: Removes all screens from the imager.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NonlinearImager_remove_all_screens_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int NonlinearImager::get_num_screens(void) const
 *******************************************************************/
static PyObject *Dtool_NonlinearImager_get_num_screens_41(PyObject *self, PyObject *args,PyObject *kwds) {
    NonlinearImager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NonlinearImager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int NonlinearImager::get_num_screens(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumScreens", key_word_list));
        else
            (PyArg_Parse(args, ":getNumScreens"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NonlinearImager*)local_this)->get_num_screens();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumScreens(const NonlinearImager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NonlinearImager_get_num_screens_41_comment =
    "C++ Interface:\n"
    "getNumScreens(const NonlinearImager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NonlinearImager::get_num_screens\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of screens that have been added to\n"
    "//               the imager.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NonlinearImager_get_num_screens_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NodePath NonlinearImager::get_screen(int index) const
 *******************************************************************/
static PyObject *Dtool_NonlinearImager_get_screen_42(PyObject *self, PyObject *args,PyObject *kwds) {
    NonlinearImager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NonlinearImager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-NodePath NonlinearImager::get_screen(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getScreen", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getScreen", &param1));
        if(!PyErr_Occurred())
        {
            NodePath result = ((const NonlinearImager*)local_this)->get_screen((int)param1);
            NodePath *return_value = new NodePath(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getScreen(const NonlinearImager this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NonlinearImager_get_screen_42_comment =
    "C++ Interface:\n"
    "getScreen(const NonlinearImager this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NonlinearImager::get_screen\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth screen that has been added to the\n"
    "//               imager.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NonlinearImager_get_screen_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * GraphicsOutput *NonlinearImager::get_buffer(int index) const
 *******************************************************************/
static PyObject *Dtool_NonlinearImager_get_buffer_43(PyObject *self, PyObject *args,PyObject *kwds) {
    NonlinearImager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NonlinearImager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-GraphicsOutput *NonlinearImager::get_buffer(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getBuffer", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getBuffer", &param1));
        if(!PyErr_Occurred())
        {
            GraphicsOutput *return_value = ((const NonlinearImager*)local_this)->get_buffer((int)param1);
            if (return_value != (GraphicsOutput *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_GraphicsOutput,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBuffer(const NonlinearImager this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NonlinearImager_get_buffer_43_comment =
    "C++ Interface:\n"
    "getBuffer(const NonlinearImager this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NonlinearImager::get_buffer\n"
    "//       Access: Published\n"
    "//  Description: Returns the offscreen buffer that is automatically\n"
    "//               created for the nth projection screen.  This may\n"
    "//               return NULL if the screen is inactive or if it has\n"
    "//               not been rendered yet.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NonlinearImager_get_buffer_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NonlinearImager::set_texture_size(int index, int width, int height)
 *******************************************************************/
static PyObject *Dtool_NonlinearImager_set_texture_size_44(PyObject *self, PyObject *args,PyObject *kwds) {
    NonlinearImager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NonlinearImager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void NonlinearImager::set_texture_size(int index, int width, int height)
        int param1;
        int param2;
        int param3;
        static char * key_word_list[] = {(char *)"index", (char *)"width", (char *)"height", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iii:setTextureSize", key_word_list, &param1, &param2, &param3))
        {
            (local_this)->set_texture_size((int)param1, (int)param2, (int)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NonlinearImager.setTextureSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTextureSize(non-const NonlinearImager this, int index, int width, int height)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NonlinearImager_set_texture_size_44_comment =
    "C++ Interface:\n"
    "setTextureSize(non-const NonlinearImager this, int index, int width, int height)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NonlinearImager::set_texture_size\n"
    "//       Access: Published\n"
    "//  Description: Sets the width and height of the texture used to\n"
    "//               render the scene for the indicated screen.  This must\n"
    "//               be less than or equal to the window size, and it\n"
    "//               should be a power of two.\n"
    "//\n"
    "//               In general, the larger the texture, the greater the\n"
    "//               detail of the rendered scene.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NonlinearImager_set_texture_size_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NonlinearImager::set_source_camera(int index, NodePath const &source_camera)
 *******************************************************************/
static PyObject *Dtool_NonlinearImager_set_source_camera_45(PyObject *self, PyObject *args,PyObject *kwds) {
    NonlinearImager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NonlinearImager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void NonlinearImager::set_source_camera(int index, NodePath const &source_camera)
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"index", (char *)"source_camera", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setSourceCamera", key_word_list, &param1, &param2))
            {
                NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "NonlinearImager.setSourceCamera", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->set_source_camera((int)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call NonlinearImager.setSourceCamera() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSourceCamera(non-const NonlinearImager this, int index, const NodePath source_camera)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NonlinearImager_set_source_camera_45_comment =
    "C++ Interface:\n"
    "setSourceCamera(non-const NonlinearImager this, int index, const NodePath source_camera)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NonlinearImager::set_source_camera\n"
    "//       Access: Published\n"
    "//  Description: Specifies the camera that will be used to render the\n"
    "//               image for this particular screen.\n"
    "//\n"
    "//               The parameter must be a NodePath whose node is a\n"
    "//               Camera.  The camera itself indicates the scene that\n"
    "//               is to be rendered.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NonlinearImager_set_source_camera_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NonlinearImager::set_screen_active(int index, bool active)
 *******************************************************************/
static PyObject *Dtool_NonlinearImager_set_screen_active_46(PyObject *self, PyObject *args,PyObject *kwds) {
    NonlinearImager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NonlinearImager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void NonlinearImager::set_screen_active(int index, bool active)
        int param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"index", (char *)"active", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setScreenActive", key_word_list, &param1, &param2))
        {
            (local_this)->set_screen_active((int)param1, (PyObject_IsTrue(param2)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NonlinearImager.setScreenActive() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setScreenActive(non-const NonlinearImager this, int index, bool active)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NonlinearImager_set_screen_active_46_comment =
    "C++ Interface:\n"
    "setScreenActive(non-const NonlinearImager this, int index, bool active)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NonlinearImager::set_screen_active\n"
    "//       Access: Published\n"
    "//  Description: Sets the active flag on the indicated screen.  If the\n"
    "//               active flag is true, the screen will be used;\n"
    "//               otherwise, it will not appear.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NonlinearImager_set_screen_active_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool NonlinearImager::get_screen_active(int index) const
 *******************************************************************/
static PyObject *Dtool_NonlinearImager_get_screen_active_47(PyObject *self, PyObject *args,PyObject *kwds) {
    NonlinearImager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NonlinearImager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool NonlinearImager::get_screen_active(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getScreenActive", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getScreenActive", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const NonlinearImager*)local_this)->get_screen_active((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getScreenActive(const NonlinearImager this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NonlinearImager_get_screen_active_47_comment =
    "C++ Interface:\n"
    "getScreenActive(const NonlinearImager this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NonlinearImager::get_screen_active\n"
    "//       Access: Published\n"
    "//  Description: Returns the active flag on the indicated screen.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NonlinearImager_get_screen_active_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int NonlinearImager::add_viewer(DisplayRegion *dr)
 *******************************************************************/
static PyObject *Dtool_NonlinearImager_add_viewer_48(PyObject *self, PyObject *args,PyObject *kwds) {
    NonlinearImager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NonlinearImager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int NonlinearImager::add_viewer(DisplayRegion *dr)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"dr", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addViewer", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addViewer", &param1));
            if(!PyErr_Occurred())
            {
                DisplayRegion *param1_this = (DisplayRegion *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DisplayRegion, 1, "NonlinearImager.addViewer", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = (local_this)->add_viewer(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call NonlinearImager.addViewer() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addViewer(non-const NonlinearImager this, non-const DisplayRegion dr)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NonlinearImager_add_viewer_48_comment =
    "C++ Interface:\n"
    "addViewer(non-const NonlinearImager this, non-const DisplayRegion dr)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NonlinearImager::add_viewer\n"
    "//       Access: Published\n"
    "//  Description: Adds the indicated DisplayRegion as a viewer into the\n"
    "//               NonlinearImager room.  The camera associated with the\n"
    "//               DisplayRegion at the time add_viewer() is called is\n"
    "//               used as the initial viewer camera; it may have a\n"
    "//               nonlinear lens, like a fisheye or cylindrical lens.\n"
    "//\n"
    "//               This sets up a special scene graph for this\n"
    "//               DisplayRegion alone and sets up the DisplayRegion\n"
    "//               with a specialty camera.  If future changes to the\n"
    "//               camera are desired, you should use the\n"
    "//               set_viewer_camera() interface.\n"
    "//\n"
    "//               All viewers must share the same GraphicsEngine.\n"
    "//\n"
    "//               The return value is the index of the new viewer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NonlinearImager_add_viewer_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int NonlinearImager::find_viewer(DisplayRegion *dr) const
 *******************************************************************/
static PyObject *Dtool_NonlinearImager_find_viewer_49(PyObject *self, PyObject *args,PyObject *kwds) {
    NonlinearImager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NonlinearImager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-int NonlinearImager::find_viewer(DisplayRegion *dr) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"dr", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:findViewer", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:findViewer", &param1));
            if(!PyErr_Occurred())
            {
                DisplayRegion *param1_this = (DisplayRegion *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DisplayRegion, 1, "NonlinearImager.findViewer", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = ((const NonlinearImager*)local_this)->find_viewer(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findViewer(const NonlinearImager this, non-const DisplayRegion dr)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NonlinearImager_find_viewer_49_comment =
    "C++ Interface:\n"
    "findViewer(const NonlinearImager this, non-const DisplayRegion dr)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NonlinearImager::find_viewer\n"
    "//       Access: Published\n"
    "//  Description: Returns the index number of the indicated\n"
    "//               DisplayRegion within the list of viewers, or -1 if it\n"
    "//               is not found.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NonlinearImager_find_viewer_49_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NonlinearImager::remove_viewer(int index)
 *******************************************************************/
static PyObject *Dtool_NonlinearImager_remove_viewer_50(PyObject *self, PyObject *args,PyObject *kwds) {
    NonlinearImager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NonlinearImager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void NonlinearImager::remove_viewer(int index)
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:removeViewer", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:removeViewer", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->remove_viewer((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NonlinearImager.removeViewer() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeViewer(non-const NonlinearImager this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NonlinearImager_remove_viewer_50_comment =
    "C++ Interface:\n"
    "removeViewer(non-const NonlinearImager this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NonlinearImager::remove_viewer\n"
    "//       Access: Published\n"
    "//  Description: Removes the viewer with the indicated index number\n"
    "//               from the imager.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NonlinearImager_remove_viewer_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NonlinearImager::remove_all_viewers(void)
 *******************************************************************/
static PyObject *Dtool_NonlinearImager_remove_all_viewers_51(PyObject *self, PyObject *args,PyObject *kwds) {
    NonlinearImager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NonlinearImager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void NonlinearImager::remove_all_viewers(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":removeAllViewers", key_word_list));
        else
            (PyArg_Parse(args, ":removeAllViewers"));
        if(!PyErr_Occurred())
        {
            (local_this)->remove_all_viewers();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NonlinearImager.removeAllViewers() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeAllViewers(non-const NonlinearImager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NonlinearImager_remove_all_viewers_51_comment =
    "C++ Interface:\n"
    "removeAllViewers(non-const NonlinearImager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NonlinearImager::remove_all_viewers\n"
    "//       Access: Published\n"
    "//  Description: Removes all viewers from the imager.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NonlinearImager_remove_all_viewers_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NonlinearImager::set_viewer_camera(int index, NodePath const &viewer_camera)
 *******************************************************************/
static PyObject *Dtool_NonlinearImager_set_viewer_camera_52(PyObject *self, PyObject *args,PyObject *kwds) {
    NonlinearImager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NonlinearImager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void NonlinearImager::set_viewer_camera(int index, NodePath const &viewer_camera)
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"index", (char *)"viewer_camera", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setViewerCamera", key_word_list, &param1, &param2))
            {
                NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "NonlinearImager.setViewerCamera", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->set_viewer_camera((int)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call NonlinearImager.setViewerCamera() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setViewerCamera(non-const NonlinearImager this, int index, const NodePath viewer_camera)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NonlinearImager_set_viewer_camera_52_comment =
    "C++ Interface:\n"
    "setViewerCamera(non-const NonlinearImager this, int index, const NodePath viewer_camera)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NonlinearImager::set_viewer_camera\n"
    "//       Access: Published\n"
    "//  Description: Specifies the LensNode that is to serve as the\n"
    "//               viewer for this screen.  The relative position of\n"
    "//               the LensNode to the NonlinearImager, as well as the\n"
    "//               properties of the lens associated with the LensNode,\n"
    "//               determines the UV's that will be assigned to the\n"
    "//               geometry within the NonlinearImager.\n"
    "//\n"
    "//               It is not necessary to call this except to change the\n"
    "//               camera after a viewer has been added, since the\n"
    "//               default is to use whatever camera is associated with\n"
    "//               the DisplayRegion at the time the viewer is added.\n"
    "//\n"
    "//               The NodePath must refer to a LensNode (or a Camera).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NonlinearImager_set_viewer_camera_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NodePath NonlinearImager::get_viewer_camera(int index) const
 *******************************************************************/
static PyObject *Dtool_NonlinearImager_get_viewer_camera_53(PyObject *self, PyObject *args,PyObject *kwds) {
    NonlinearImager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NonlinearImager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-NodePath NonlinearImager::get_viewer_camera(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getViewerCamera", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getViewerCamera", &param1));
        if(!PyErr_Occurred())
        {
            NodePath result = ((const NonlinearImager*)local_this)->get_viewer_camera((int)param1);
            NodePath *return_value = new NodePath(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getViewerCamera(const NonlinearImager this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NonlinearImager_get_viewer_camera_53_comment =
    "C++ Interface:\n"
    "getViewerCamera(const NonlinearImager this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NonlinearImager::get_viewer_camera\n"
    "//       Access: Published\n"
    "//  Description: Returns the NodePath to the LensNode that is to serve\n"
    "//               as nth viewer for this screen.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NonlinearImager_get_viewer_camera_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NodePath NonlinearImager::get_viewer_scene(int index) const
 *******************************************************************/
static PyObject *Dtool_NonlinearImager_get_viewer_scene_54(PyObject *self, PyObject *args,PyObject *kwds) {
    NonlinearImager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NonlinearImager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-NodePath NonlinearImager::get_viewer_scene(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getViewerScene", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getViewerScene", &param1));
        if(!PyErr_Occurred())
        {
            NodePath result = ((const NonlinearImager*)local_this)->get_viewer_scene((int)param1);
            NodePath *return_value = new NodePath(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getViewerScene(const NonlinearImager this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NonlinearImager_get_viewer_scene_54_comment =
    "C++ Interface:\n"
    "getViewerScene(const NonlinearImager this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NonlinearImager::get_viewer_scene\n"
    "//       Access: Published\n"
    "//  Description: Returns a pointer to the root node of the internal\n"
    "//               scene graph for the nth viewer, which is used to\n"
    "//               render all of the screen meshes for this viewer.\n"
    "//\n"
    "//               This is the scene graph in which the screen meshes\n"
    "//               within the dark room have been flattened into the\n"
    "//               appropriate transformation according to the viewer's\n"
    "//               lens properties (and position relative to the\n"
    "//               screens).  It is this scene graph that is finally\n"
    "//               rendered to the window.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NonlinearImager_get_viewer_scene_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int NonlinearImager::get_num_viewers(void) const
 *******************************************************************/
static PyObject *Dtool_NonlinearImager_get_num_viewers_55(PyObject *self, PyObject *args,PyObject *kwds) {
    NonlinearImager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NonlinearImager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int NonlinearImager::get_num_viewers(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumViewers", key_word_list));
        else
            (PyArg_Parse(args, ":getNumViewers"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const NonlinearImager*)local_this)->get_num_viewers();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumViewers(const NonlinearImager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NonlinearImager_get_num_viewers_55_comment =
    "C++ Interface:\n"
    "getNumViewers(const NonlinearImager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NonlinearImager::get_num_viewers\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of viewers that have been added to\n"
    "//               the imager.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NonlinearImager_get_num_viewers_55_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DisplayRegion *NonlinearImager::get_viewer(int index) const
 *******************************************************************/
static PyObject *Dtool_NonlinearImager_get_viewer_56(PyObject *self, PyObject *args,PyObject *kwds) {
    NonlinearImager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NonlinearImager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DisplayRegion *NonlinearImager::get_viewer(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getViewer", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getViewer", &param1));
        if(!PyErr_Occurred())
        {
            DisplayRegion *return_value = ((const NonlinearImager*)local_this)->get_viewer((int)param1);
            if (return_value != (DisplayRegion *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_DisplayRegion,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getViewer(const NonlinearImager this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NonlinearImager_get_viewer_56_comment =
    "C++ Interface:\n"
    "getViewer(const NonlinearImager this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NonlinearImager::get_viewer\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth viewer's DisplayRegion that has been\n"
    "//               added to the imager.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NonlinearImager_get_viewer_56_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NodePath NonlinearImager::get_dark_room(void) const
 *******************************************************************/
static PyObject *Dtool_NonlinearImager_get_dark_room_57(PyObject *self, PyObject *args,PyObject *kwds) {
    NonlinearImager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NonlinearImager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-NodePath NonlinearImager::get_dark_room(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDarkRoom", key_word_list));
        else
            (PyArg_Parse(args, ":getDarkRoom"));
        if(!PyErr_Occurred())
        {
            NodePath result = ((const NonlinearImager*)local_this)->get_dark_room();
            NodePath *return_value = new NodePath(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDarkRoom(const NonlinearImager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NonlinearImager_get_dark_room_57_comment =
    "C++ Interface:\n"
    "getDarkRoom(const NonlinearImager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NonlinearImager::get_dark_room\n"
    "//       Access: Published\n"
    "//  Description: Returns the NodePath to the root of the dark room\n"
    "//               scene.  This is the scene in which all of the\n"
    "//               ProjectionScreens and the viewer cameras reside.\n"
    "//               It's a standalone scene with a few projection screens\n"
    "//               arranged artfully around one or more viewers; it's so\n"
    "//               named because it's a little virtual theater.\n"
    "//\n"
    "//               Normally this scene is not rendered directly; it only\n"
    "//               exists as an abstract concept, and to define the\n"
    "//               relation between the ProjectionScreens and the\n"
    "//               viewers.  But it may be rendered to help visualize\n"
    "//               the NonlinearImager's behavior.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NonlinearImager_get_dark_room_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * GraphicsEngine *NonlinearImager::get_graphics_engine(void) const
 *******************************************************************/
static PyObject *Dtool_NonlinearImager_get_graphics_engine_58(PyObject *self, PyObject *args,PyObject *kwds) {
    NonlinearImager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NonlinearImager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-GraphicsEngine *NonlinearImager::get_graphics_engine(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getGraphicsEngine", key_word_list));
        else
            (PyArg_Parse(args, ":getGraphicsEngine"));
        if(!PyErr_Occurred())
        {
            GraphicsEngine *return_value = ((const NonlinearImager*)local_this)->get_graphics_engine();
            if (return_value != (GraphicsEngine *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_GraphicsEngine,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGraphicsEngine(const NonlinearImager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NonlinearImager_get_graphics_engine_58_comment =
    "C++ Interface:\n"
    "getGraphicsEngine(const NonlinearImager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NonlinearImager::get_graphics_engine\n"
    "//       Access: Published\n"
    "//  Description: Returns the GraphicsEngine that all of the viewers\n"
    "//               added to the NonlinearImager have in common.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NonlinearImager_get_graphics_engine_58_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void NonlinearImager::recompute(void)
 *******************************************************************/
static PyObject *Dtool_NonlinearImager_recompute_59(PyObject *self, PyObject *args,PyObject *kwds) {
    NonlinearImager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_NonlinearImager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void NonlinearImager::recompute(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":recompute", key_word_list));
        else
            (PyArg_Parse(args, ":recompute"));
        if(!PyErr_Occurred())
        {
            (local_this)->recompute();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call NonlinearImager.recompute() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "recompute(non-const NonlinearImager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NonlinearImager_recompute_59_comment =
    "C++ Interface:\n"
    "recompute(non-const NonlinearImager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: NonlinearImager::recompute\n"
    "//       Access: Published\n"
    "//  Description: Forces a regeneration of all the mesh objects, etc.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_NonlinearImager_recompute_59_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NonlinearImager::NonlinearImager(void)
 *******************************************************************/
int  Dtool_Init_NonlinearImager(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-NonlinearImager::NonlinearImager(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":NonlinearImager", key_word_list))
        {
            NonlinearImager *return_value = new NonlinearImager();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_NonlinearImager,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "NonlinearImager()\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_NonlinearImager_get_screens(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumScreens", "getScreen");
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_NonlinearImager_get_buffers(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumScreens", "getBuffer");
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_NonlinearImager_get_viewers(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumViewers", "getViewer");
}
inline void  * Dtool_UpcastInterface_NonlinearImager(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_NonlinearImager)
    {
        printf("NonlinearImager ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    NonlinearImager * local_this = (NonlinearImager *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_NonlinearImager)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_NonlinearImager(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_NonlinearImager)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. CylindricalLens | CylindricalLens
//********************************************************************
PyMethodDef Dtool_Methods_CylindricalLens[]= {
  { "getClassType",(PyCFunction ) &Dtool_CylindricalLens_get_class_type_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CylindricalLens_get_class_type_4_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CylindricalLens(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CylindricalLens.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CylindricalLens\n"
          "// Description : A cylindrical lens.  This is the kind of lens\n"
          "//               generally used for extremely wide panoramic shots.\n"
          "//               It behaves like a normal perspective lens in the\n"
          "//               vertical direction, but it is non-linear in the\n"
          "//               horizontal dimension: a point on the film corresponds\n"
          "//               to a point in space in linear proportion to its angle\n"
          "//               to the camera, not to its straight-line distance from\n"
          "//               the center.\n"
          "//\n"
          "//               This allows up to 360 degree lenses in the horizontal\n"
          "//               dimension, with relatively little distortion.  The\n"
          "//               distortion is not very apparent between two\n"
          "//               relatively nearby points on the film, but it becomes\n"
          "//               increasingly evident as you compare points widely\n"
          "//               spaced on the film.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_Lens._Dtool_ClassInit(NULL);
        Dtool_CylindricalLens.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_Lens.As_PyTypeObject());
        Dtool_CylindricalLens.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CylindricalLens.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CylindricalLens.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CylindricalLens.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CylindricalLens)");
             printf(" Error In PyType_ReadyCylindricalLens");
             return;
        }
        Py_INCREF(&Dtool_CylindricalLens.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CylindricalLens.As_PyTypeObject().tp_dict,"CylindricalLens",&Dtool_CylindricalLens.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CylindricalLens.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CylindricalLens[0],&Dtool_CylindricalLens.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CylindricalLens,CylindricalLens::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CylindricalLens.As_PyTypeObject());
        PyModule_AddObject(module, "CylindricalLens",(PyObject *)&Dtool_CylindricalLens.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. FisheyeLens | FisheyeLens
//********************************************************************
PyMethodDef Dtool_Methods_FisheyeLens[]= {
  { "getClassType",(PyCFunction ) &Dtool_FisheyeLens_get_class_type_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_FisheyeLens_get_class_type_8_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_FisheyeLens(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_FisheyeLens.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : FisheyeLens\n"
          "// Description : A fisheye lens.  This nonlinear lens introduces a\n"
          "//               spherical distortion to the image, which is minimal\n"
          "//               at small angles from the lens, and increases at\n"
          "//               larger angles from the lens.  The field of view may\n"
          "//               extend to 360 degrees.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_Lens._Dtool_ClassInit(NULL);
        Dtool_FisheyeLens.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_Lens.As_PyTypeObject());
        Dtool_FisheyeLens.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_FisheyeLens.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_FisheyeLens.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_FisheyeLens.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(FisheyeLens)");
             printf(" Error In PyType_ReadyFisheyeLens");
             return;
        }
        Py_INCREF(&Dtool_FisheyeLens.As_PyTypeObject());
        PyDict_SetItemString(Dtool_FisheyeLens.As_PyTypeObject().tp_dict,"FisheyeLens",&Dtool_FisheyeLens.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_FisheyeLens.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_FisheyeLens[0],&Dtool_FisheyeLens.As_PyObject()));
        RegisterRuntimeClass(&Dtool_FisheyeLens,FisheyeLens::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_FisheyeLens.As_PyTypeObject());
        PyModule_AddObject(module, "FisheyeLens",(PyObject *)&Dtool_FisheyeLens.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PSphereLens | PSphereLens
//********************************************************************
PyMethodDef Dtool_Methods_PSphereLens[]= {
  { "getClassType",(PyCFunction ) &Dtool_PSphereLens_get_class_type_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PSphereLens_get_class_type_12_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PSphereLens(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PSphereLens.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PSphereLens\n"
          "// Description : A PSphereLens is a special nonlinear lens that\n"
          "//               doesn't correspond to any real physical lenses.  It's\n"
          "//               primarily useful for generating 360-degree wraparound\n"
          "//               images while avoiding the distortion associated with\n"
          "//               fisheye images.\n"
          "//\n"
          "//               A PSphereLens is similar to a cylindrical lens,\n"
          "//               except it is also curved in the vertical direction.\n"
          "//               This allows it to extend to both poles in the\n"
          "//               vertical direction.  The mapping is similar to what\n"
          "//               many modeling packages call a sphere mapping: the x\n"
          "//               coordinate is proportional to azimuth, while the y\n"
          "//               coordinate is proportional to altitude.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_Lens._Dtool_ClassInit(NULL);
        Dtool_PSphereLens.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_Lens.As_PyTypeObject());
        Dtool_PSphereLens.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PSphereLens.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PSphereLens.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PSphereLens.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PSphereLens)");
             printf(" Error In PyType_ReadyPSphereLens");
             return;
        }
        Py_INCREF(&Dtool_PSphereLens.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PSphereLens.As_PyTypeObject().tp_dict,"PSphereLens",&Dtool_PSphereLens.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_PSphereLens.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_PSphereLens[0],&Dtool_PSphereLens.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PSphereLens,PSphereLens::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PSphereLens.As_PyTypeObject());
        PyModule_AddObject(module, "PSphereLens",(PyObject *)&Dtool_PSphereLens.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ProjectionScreen | ProjectionScreen
//********************************************************************
PyMethodDef Dtool_Methods_ProjectionScreen[]= {
  { "setProjector",(PyCFunction ) &Dtool_ProjectionScreen_set_projector_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ProjectionScreen_set_projector_17_comment},
  { "getProjector",(PyCFunction ) &Dtool_ProjectionScreen_get_projector_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ProjectionScreen_get_projector_18_comment},
  { "generateScreen",(PyCFunction ) &Dtool_ProjectionScreen_generate_screen_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ProjectionScreen_generate_screen_19_comment},
  { "regenerateScreen",(PyCFunction ) &Dtool_ProjectionScreen_regenerate_screen_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ProjectionScreen_regenerate_screen_20_comment},
  { "makeFlatMesh",(PyCFunction ) &Dtool_ProjectionScreen_make_flat_mesh_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ProjectionScreen_make_flat_mesh_21_comment},
  { "setTexcoordName",(PyCFunction ) &Dtool_ProjectionScreen_set_texcoord_name_22, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ProjectionScreen_set_texcoord_name_22_comment},
  { "getTexcoordName",(PyCFunction ) &Dtool_ProjectionScreen_get_texcoord_name_23, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ProjectionScreen_get_texcoord_name_23_comment},
  { "setInvertUvs",(PyCFunction ) &Dtool_ProjectionScreen_set_invert_uvs_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ProjectionScreen_set_invert_uvs_24_comment},
  { "getInvertUvs",(PyCFunction ) &Dtool_ProjectionScreen_get_invert_uvs_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ProjectionScreen_get_invert_uvs_25_comment},
  { "setVignetteOn",(PyCFunction ) &Dtool_ProjectionScreen_set_vignette_on_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ProjectionScreen_set_vignette_on_26_comment},
  { "getVignetteOn",(PyCFunction ) &Dtool_ProjectionScreen_get_vignette_on_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ProjectionScreen_get_vignette_on_27_comment},
  { "setVignetteColor",(PyCFunction ) &Dtool_ProjectionScreen_set_vignette_color_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ProjectionScreen_set_vignette_color_28_comment},
  { "getVignetteColor",(PyCFunction ) &Dtool_ProjectionScreen_get_vignette_color_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ProjectionScreen_get_vignette_color_29_comment},
  { "setFrameColor",(PyCFunction ) &Dtool_ProjectionScreen_set_frame_color_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ProjectionScreen_set_frame_color_30_comment},
  { "getFrameColor",(PyCFunction ) &Dtool_ProjectionScreen_get_frame_color_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ProjectionScreen_get_frame_color_31_comment},
  { "recompute",(PyCFunction ) &Dtool_ProjectionScreen_recompute_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ProjectionScreen_recompute_32_comment},
  { "getClassType",(PyCFunction ) &Dtool_ProjectionScreen_get_class_type_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ProjectionScreen_get_class_type_33_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ProjectionScreen(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ProjectionScreen.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ProjectionScreen\n"
          "// Description : A ProjectionScreen implements a simple system for\n"
          "//               projective texturing.  The ProjectionScreen node is\n"
          "//               the parent of a hierarchy of geometry that is\n"
          "//               considered a \"screen\"; the ProjectionScreen will\n"
          "//               automatically recompute all the UV's (for a\n"
          "//               particular texture stage) on its subordinate geometry\n"
          "//               according to the relative position and lens\n"
          "//               parameters of the indicated LensNode.\n"
          "//\n"
          "//               All this does is recompute UV's; the caller is\n"
          "//               responsible for applying the appropriate texture(s)\n"
          "//               to the geometry.\n"
          "//\n"
          "//               This does not take advantage of any hardware-assisted\n"
          "//               projective texturing; all of the UV's are computed in\n"
          "//               the CPU.  (Use NodePath::project_texture() to enable\n"
          "//               hardware-assisted projective texturing.)  However,\n"
          "//               the ProjectionScreen interface does support any kind\n"
          "//               of lens, linear or nonlinear, that might be defined\n"
          "//               using the Lens interface, including fisheye and\n"
          "//               cylindrical lenses.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PandaNode._Dtool_ClassInit(NULL);
        Dtool_ProjectionScreen.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PandaNode.As_PyTypeObject());
        Dtool_ProjectionScreen.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ProjectionScreen.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ProjectionScreen.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ProjectionScreen.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ProjectionScreen)");
             printf(" Error In PyType_ReadyProjectionScreen");
             return;
        }
        Py_INCREF(&Dtool_ProjectionScreen.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ProjectionScreen.As_PyTypeObject().tp_dict,"ProjectionScreen",&Dtool_ProjectionScreen.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_ProjectionScreen.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_ProjectionScreen[16],&Dtool_ProjectionScreen.As_PyObject()));
        RegisterRuntimeClass(&Dtool_ProjectionScreen,ProjectionScreen::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ProjectionScreen.As_PyTypeObject());
        PyModule_AddObject(module, "ProjectionScreen",(PyObject *)&Dtool_ProjectionScreen.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. NonlinearImager | NonlinearImager
//********************************************************************
PyMethodDef Dtool_Methods_NonlinearImager[]= {
  { "addScreen",(PyCFunction ) &Dtool_NonlinearImager_add_screen_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NonlinearImager_add_screen_37_comment},
  { "findScreen",(PyCFunction ) &Dtool_NonlinearImager_find_screen_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NonlinearImager_find_screen_38_comment},
  { "removeScreen",(PyCFunction ) &Dtool_NonlinearImager_remove_screen_39, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NonlinearImager_remove_screen_39_comment},
  { "removeAllScreens",(PyCFunction ) &Dtool_NonlinearImager_remove_all_screens_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NonlinearImager_remove_all_screens_40_comment},
  { "getNumScreens",(PyCFunction ) &Dtool_NonlinearImager_get_num_screens_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NonlinearImager_get_num_screens_41_comment},
  { "getScreen",(PyCFunction ) &Dtool_NonlinearImager_get_screen_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NonlinearImager_get_screen_42_comment},
  { "getBuffer",(PyCFunction ) &Dtool_NonlinearImager_get_buffer_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NonlinearImager_get_buffer_43_comment},
  { "setTextureSize",(PyCFunction ) &Dtool_NonlinearImager_set_texture_size_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NonlinearImager_set_texture_size_44_comment},
  { "setSourceCamera",(PyCFunction ) &Dtool_NonlinearImager_set_source_camera_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NonlinearImager_set_source_camera_45_comment},
  { "setScreenActive",(PyCFunction ) &Dtool_NonlinearImager_set_screen_active_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NonlinearImager_set_screen_active_46_comment},
  { "getScreenActive",(PyCFunction ) &Dtool_NonlinearImager_get_screen_active_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NonlinearImager_get_screen_active_47_comment},
  { "addViewer",(PyCFunction ) &Dtool_NonlinearImager_add_viewer_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NonlinearImager_add_viewer_48_comment},
  { "findViewer",(PyCFunction ) &Dtool_NonlinearImager_find_viewer_49, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NonlinearImager_find_viewer_49_comment},
  { "removeViewer",(PyCFunction ) &Dtool_NonlinearImager_remove_viewer_50, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NonlinearImager_remove_viewer_50_comment},
  { "removeAllViewers",(PyCFunction ) &Dtool_NonlinearImager_remove_all_viewers_51, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NonlinearImager_remove_all_viewers_51_comment},
  { "setViewerCamera",(PyCFunction ) &Dtool_NonlinearImager_set_viewer_camera_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NonlinearImager_set_viewer_camera_52_comment},
  { "getViewerCamera",(PyCFunction ) &Dtool_NonlinearImager_get_viewer_camera_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NonlinearImager_get_viewer_camera_53_comment},
  { "getViewerScene",(PyCFunction ) &Dtool_NonlinearImager_get_viewer_scene_54, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NonlinearImager_get_viewer_scene_54_comment},
  { "getNumViewers",(PyCFunction ) &Dtool_NonlinearImager_get_num_viewers_55, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NonlinearImager_get_num_viewers_55_comment},
  { "getViewer",(PyCFunction ) &Dtool_NonlinearImager_get_viewer_56, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NonlinearImager_get_viewer_56_comment},
  { "getDarkRoom",(PyCFunction ) &Dtool_NonlinearImager_get_dark_room_57, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NonlinearImager_get_dark_room_57_comment},
  { "getGraphicsEngine",(PyCFunction ) &Dtool_NonlinearImager_get_graphics_engine_58, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NonlinearImager_get_graphics_engine_58_comment},
  { "recompute",(PyCFunction ) &Dtool_NonlinearImager_recompute_59, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NonlinearImager_recompute_59_comment},
  { "getScreens",(PyCFunction) &MakeSeq_NonlinearImager_get_screens, METH_NOARGS, NULL},
  { "getBuffers",(PyCFunction) &MakeSeq_NonlinearImager_get_buffers, METH_NOARGS, NULL},
  { "getViewers",(PyCFunction) &MakeSeq_NonlinearImager_get_viewers, METH_NOARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_NonlinearImager(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_NonlinearImager.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : NonlinearImager\n"
          "// Description : This class object combines the rendered output of a\n"
          "//               3-d from one or more linear (e.g. perspective)\n"
          "//               cameras, as seen through a single, possibly nonlinear\n"
          "//               camera.\n"
          "//\n"
          "//               This can be used to generate real-time imagery of a\n"
          "//               3-d scene using a nonlinear camera, for instance a\n"
          "//               fisheye camera, even though the underlying graphics\n"
          "//               engine may only support linear cameras.  It can also\n"
          "//               pre-distort imagery to compensate for off-axis\n"
          "//               projectors, and/or curved screens of any complexity.\n"
          "//\n"
          "//               \n"
          "//               A NonlinearImager may be visualized as a dark room\n"
          "//               into which a number of projection screens have been\n"
          "//               placed, of arbitrary size and shape and at any\n"
          "//               arbitrary position and orientation to each other.\n"
          "//               Onto each of these screens is projected the view as\n"
          "//               seen by a normal perspective camera that exists in\n"
          "//               the world (that is, under render).\n"
          "//\n"
          "//               There also exist in the room one or more (possibly\n"
          "//               nonlinear) cameras, called viewers, that observe\n"
          "//               these screens.  The image of the projection screens\n"
          "//               seen by each viewer is finally displayed on the\n"
          "//               viewer's associated DisplayRegion.  By placing the\n"
          "//               viewer(s) appropriately relative to the screens, and\n"
          "//               by choosing suitable lens properties for the\n"
          "//               viewer(s), you can achieve a wide variety of\n"
          "//               distortion effects.\n"
          "//\n"
          "//\n"
          "//               There are several different LensNode (Camera) objects\n"
          "//               involved at each stage in the process.  To help keep\n"
          "//               them all straight, different words are used to refer\n"
          "//               to each different kind of Camera used within this\n"
          "//               object.  The camera(s) under render, that capture the\n"
          "//               original view of the world to be projected onto the\n"
          "//               screens, are called source cameras, and are set per\n"
          "//               screen via set_source_camera().  The LensNode that is\n"
          "//               associated with each screen to project the image as\n"
          "//               seen from the screen's source camera is called a\n"
          "//               projector; these are set via the\n"
          "//               ProjectionScreen::set_projector() interface.\n"
          "//               Finally, the cameras that view the whole\n"
          "//               configuration of screens are called viewers; each of\n"
          "//               these is associated with a DisplayRegion, and they\n"
          "//               are set via set_viewer_camera().\n"
          "//\n"
          "//               Of all these lenses, only the source cameras must use\n"
          "//               linear (that is, perspective or orthographic) lenses.\n"
          "//               The projectors and viewers may be any arbitrary lens,\n"
          "//               linear or otherwise.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_NonlinearImager.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_NonlinearImager.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_NonlinearImager.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_NonlinearImager.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_NonlinearImager.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(NonlinearImager)");
             printf(" Error In PyType_ReadyNonlinearImager");
             return;
        }
        Py_INCREF(&Dtool_NonlinearImager.As_PyTypeObject());
        PyDict_SetItemString(Dtool_NonlinearImager.As_PyTypeObject().tp_dict,"NonlinearImager",&Dtool_NonlinearImager.As_PyObject());
        RegisterRuntimeClass(&Dtool_NonlinearImager,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_NonlinearImager.As_PyTypeObject());
        PyModule_AddObject(module, "NonlinearImager",(PyObject *)&Dtool_NonlinearImager.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..CylindricalLens
//********************************************************************
   Dtool_PyModuleClassInit_CylindricalLens(module);
//********************************************************************
//*** Module Init Updcall ..FisheyeLens
//********************************************************************
   Dtool_PyModuleClassInit_FisheyeLens(module);
//********************************************************************
//*** Module Init Updcall ..PSphereLens
//********************************************************************
   Dtool_PyModuleClassInit_PSphereLens(module);
//********************************************************************
//*** Module Init Updcall ..ProjectionScreen
//********************************************************************
   Dtool_PyModuleClassInit_ProjectionScreen(module);
//********************************************************************
//*** Module Init Updcall ..NonlinearImager
//********************************************************************
   Dtool_PyModuleClassInit_NonlinearImager(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libdistort_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687213506,  /* file_identifier */
  "libdistort",  /* library_name */
  "1uO4",  /* library_hash_name */
  "pandafx",  /* module_name */
  "libdistort.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  152  /* next_index */
};

Configure(_in_configure_libdistort);
ConfigureFn(_in_configure_libdistort) {
  interrogate_request_module(&_in_module_def);
}

