/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/lerp -Ipanda/src/lerp -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/liblerp_igate.cxx -od built_Rocket/pandac/input/liblerp.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/lerp -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDA -module panda -library liblerp config_lerp.h lerp.h lerp_composite.cxx lerpblend.h lerpfunctor.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_liblerp
#include "py_panda.h"  

#include "config_lerp.h"
#include "dconfig.h"
#include "eventHandler.h"
#include "lerp.h"
#include "lerpblend.h"
#include "lerpfunctor.h"
#include "notifyCategoryProxy.h"
#include "pandabase.h"
#include "typedReferenceCount.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. LerpFunctor
//********************************************************************
typedef  LerpFunctor  LerpFunctor_localtype;
Define_Module_ClassRef(panda,LerpFunctor,LerpFunctor_localtype,LerpFunctor);
//********************************************************************
//*** prototypes for .. SimpleLerpFunctor_int
//********************************************************************
typedef  SimpleLerpFunctor< int >  SimpleLerpFunctor_int_localtype;
Define_Module_ClassRef(panda,SimpleLerpFunctor_int,SimpleLerpFunctor_int_localtype,SimpleLerpFunctorInt);
//********************************************************************
//*** prototypes for .. SimpleLerpFunctor_float
//********************************************************************
typedef  SimpleLerpFunctor< float >  SimpleLerpFunctor_float_localtype;
Define_Module_ClassRef(panda,SimpleLerpFunctor_float,SimpleLerpFunctor_float_localtype,SimpleLerpFunctorFloat);
//********************************************************************
//*** prototypes for .. SimpleLerpFunctor_LPoint2f
//********************************************************************
typedef  SimpleLerpFunctor< LPoint2f >  SimpleLerpFunctor_LPoint2f_localtype;
Define_Module_ClassRef(panda,SimpleLerpFunctor_LPoint2f,SimpleLerpFunctor_LPoint2f_localtype,SimpleLerpFunctorLPoint2f);
//********************************************************************
//*** prototypes for .. SimpleLerpFunctor_LPoint3f
//********************************************************************
typedef  SimpleLerpFunctor< LPoint3f >  SimpleLerpFunctor_LPoint3f_localtype;
Define_Module_ClassRef(panda,SimpleLerpFunctor_LPoint3f,SimpleLerpFunctor_LPoint3f_localtype,SimpleLerpFunctorLPoint3f);
//********************************************************************
//*** prototypes for .. SimpleLerpFunctor_LPoint4f
//********************************************************************
typedef  SimpleLerpFunctor< LPoint4f >  SimpleLerpFunctor_LPoint4f_localtype;
Define_Module_ClassRef(panda,SimpleLerpFunctor_LPoint4f,SimpleLerpFunctor_LPoint4f_localtype,SimpleLerpFunctorLPoint4f);
//********************************************************************
//*** prototypes for .. SimpleLerpFunctor_LVecBase2f
//********************************************************************
typedef  SimpleLerpFunctor< LVecBase2f >  SimpleLerpFunctor_LVecBase2f_localtype;
Define_Module_ClassRef(panda,SimpleLerpFunctor_LVecBase2f,SimpleLerpFunctor_LVecBase2f_localtype,SimpleLerpFunctorLVecBase2f);
//********************************************************************
//*** prototypes for .. SimpleLerpFunctor_LVecBase3f
//********************************************************************
typedef  SimpleLerpFunctor< LVecBase3f >  SimpleLerpFunctor_LVecBase3f_localtype;
Define_Module_ClassRef(panda,SimpleLerpFunctor_LVecBase3f,SimpleLerpFunctor_LVecBase3f_localtype,SimpleLerpFunctorLVecBase3f);
//********************************************************************
//*** prototypes for .. SimpleLerpFunctor_LVecBase4f
//********************************************************************
typedef  SimpleLerpFunctor< LVecBase4f >  SimpleLerpFunctor_LVecBase4f_localtype;
Define_Module_ClassRef(panda,SimpleLerpFunctor_LVecBase4f,SimpleLerpFunctor_LVecBase4f_localtype,SimpleLerpFunctorLVecBase4f);
//********************************************************************
//*** prototypes for .. SimpleLerpFunctor_LVector2f
//********************************************************************
typedef  SimpleLerpFunctor< LVector2f >  SimpleLerpFunctor_LVector2f_localtype;
Define_Module_ClassRef(panda,SimpleLerpFunctor_LVector2f,SimpleLerpFunctor_LVector2f_localtype,SimpleLerpFunctorLVector2f);
//********************************************************************
//*** prototypes for .. SimpleLerpFunctor_LVector3f
//********************************************************************
typedef  SimpleLerpFunctor< LVector3f >  SimpleLerpFunctor_LVector3f_localtype;
Define_Module_ClassRef(panda,SimpleLerpFunctor_LVector3f,SimpleLerpFunctor_LVector3f_localtype,SimpleLerpFunctorLVector3f);
//********************************************************************
//*** prototypes for .. SimpleLerpFunctor_LVector4f
//********************************************************************
typedef  SimpleLerpFunctor< LVector4f >  SimpleLerpFunctor_LVector4f_localtype;
Define_Module_ClassRef(panda,SimpleLerpFunctor_LVector4f,SimpleLerpFunctor_LVector4f_localtype,SimpleLerpFunctorLVector4f);
//********************************************************************
//*** prototypes for .. SimpleQueryLerpFunctor_int
//********************************************************************
typedef  SimpleQueryLerpFunctor< int >  SimpleQueryLerpFunctor_int_localtype;
Define_Module_ClassRef(panda,SimpleQueryLerpFunctor_int,SimpleQueryLerpFunctor_int_localtype,SimpleQueryLerpFunctorInt);
//********************************************************************
//*** prototypes for .. SimpleQueryLerpFunctor_float
//********************************************************************
typedef  SimpleQueryLerpFunctor< float >  SimpleQueryLerpFunctor_float_localtype;
Define_Module_ClassRef(panda,SimpleQueryLerpFunctor_float,SimpleQueryLerpFunctor_float_localtype,SimpleQueryLerpFunctorFloat);
//********************************************************************
//*** prototypes for .. SimpleQueryLerpFunctor_LPoint2f
//********************************************************************
typedef  SimpleQueryLerpFunctor< LPoint2f >  SimpleQueryLerpFunctor_LPoint2f_localtype;
Define_Module_ClassRef(panda,SimpleQueryLerpFunctor_LPoint2f,SimpleQueryLerpFunctor_LPoint2f_localtype,SimpleQueryLerpFunctorLPoint2f);
//********************************************************************
//*** prototypes for .. SimpleQueryLerpFunctor_LPoint3f
//********************************************************************
typedef  SimpleQueryLerpFunctor< LPoint3f >  SimpleQueryLerpFunctor_LPoint3f_localtype;
Define_Module_ClassRef(panda,SimpleQueryLerpFunctor_LPoint3f,SimpleQueryLerpFunctor_LPoint3f_localtype,SimpleQueryLerpFunctorLPoint3f);
//********************************************************************
//*** prototypes for .. SimpleQueryLerpFunctor_LPoint4f
//********************************************************************
typedef  SimpleQueryLerpFunctor< LPoint4f >  SimpleQueryLerpFunctor_LPoint4f_localtype;
Define_Module_ClassRef(panda,SimpleQueryLerpFunctor_LPoint4f,SimpleQueryLerpFunctor_LPoint4f_localtype,SimpleQueryLerpFunctorLPoint4f);
//********************************************************************
//*** prototypes for .. SimpleQueryLerpFunctor_LVecBase2f
//********************************************************************
typedef  SimpleQueryLerpFunctor< LVecBase2f >  SimpleQueryLerpFunctor_LVecBase2f_localtype;
Define_Module_ClassRef(panda,SimpleQueryLerpFunctor_LVecBase2f,SimpleQueryLerpFunctor_LVecBase2f_localtype,SimpleQueryLerpFunctorLVecBase2f);
//********************************************************************
//*** prototypes for .. SimpleQueryLerpFunctor_LVecBase3f
//********************************************************************
typedef  SimpleQueryLerpFunctor< LVecBase3f >  SimpleQueryLerpFunctor_LVecBase3f_localtype;
Define_Module_ClassRef(panda,SimpleQueryLerpFunctor_LVecBase3f,SimpleQueryLerpFunctor_LVecBase3f_localtype,SimpleQueryLerpFunctorLVecBase3f);
//********************************************************************
//*** prototypes for .. SimpleQueryLerpFunctor_LVecBase4f
//********************************************************************
typedef  SimpleQueryLerpFunctor< LVecBase4f >  SimpleQueryLerpFunctor_LVecBase4f_localtype;
Define_Module_ClassRef(panda,SimpleQueryLerpFunctor_LVecBase4f,SimpleQueryLerpFunctor_LVecBase4f_localtype,SimpleQueryLerpFunctorLVecBase4f);
//********************************************************************
//*** prototypes for .. SimpleQueryLerpFunctor_LVector2f
//********************************************************************
typedef  SimpleQueryLerpFunctor< LVector2f >  SimpleQueryLerpFunctor_LVector2f_localtype;
Define_Module_ClassRef(panda,SimpleQueryLerpFunctor_LVector2f,SimpleQueryLerpFunctor_LVector2f_localtype,SimpleQueryLerpFunctorLVector2f);
//********************************************************************
//*** prototypes for .. SimpleQueryLerpFunctor_LVector3f
//********************************************************************
typedef  SimpleQueryLerpFunctor< LVector3f >  SimpleQueryLerpFunctor_LVector3f_localtype;
Define_Module_ClassRef(panda,SimpleQueryLerpFunctor_LVector3f,SimpleQueryLerpFunctor_LVector3f_localtype,SimpleQueryLerpFunctorLVector3f);
//********************************************************************
//*** prototypes for .. SimpleQueryLerpFunctor_LVector4f
//********************************************************************
typedef  SimpleQueryLerpFunctor< LVector4f >  SimpleQueryLerpFunctor_LVector4f_localtype;
Define_Module_ClassRef(panda,SimpleQueryLerpFunctor_LVector4f,SimpleQueryLerpFunctor_LVector4f_localtype,SimpleQueryLerpFunctorLVector4f);
//********************************************************************
//*** prototypes for .. MultiLerpFunctor
//********************************************************************
typedef  MultiLerpFunctor  MultiLerpFunctor_localtype;
Define_Module_ClassRef(panda,MultiLerpFunctor,MultiLerpFunctor_localtype,MultiLerpFunctor);
//********************************************************************
//*** prototypes for .. LerpBlendType
//********************************************************************
typedef  LerpBlendType  LerpBlendType_localtype;
Define_Module_ClassRef(panda,LerpBlendType,LerpBlendType_localtype,LerpBlendType);
//********************************************************************
//*** prototypes for .. EaseInBlendType
//********************************************************************
typedef  EaseInBlendType  EaseInBlendType_localtype;
Define_Module_ClassRef(panda,EaseInBlendType,EaseInBlendType_localtype,EaseInBlendType);
//********************************************************************
//*** prototypes for .. EaseOutBlendType
//********************************************************************
typedef  EaseOutBlendType  EaseOutBlendType_localtype;
Define_Module_ClassRef(panda,EaseOutBlendType,EaseOutBlendType_localtype,EaseOutBlendType);
//********************************************************************
//*** prototypes for .. EaseInOutBlendType
//********************************************************************
typedef  EaseInOutBlendType  EaseInOutBlendType_localtype;
Define_Module_ClassRef(panda,EaseInOutBlendType,EaseInOutBlendType_localtype,EaseInOutBlendType);
//********************************************************************
//*** prototypes for .. NoBlendType
//********************************************************************
typedef  NoBlendType  NoBlendType_localtype;
Define_Module_ClassRef(panda,NoBlendType,NoBlendType_localtype,NoBlendType);
//********************************************************************
//*** prototypes for .. Lerp
//********************************************************************
typedef  Lerp  Lerp_localtype;
Define_Module_ClassRef(panda,Lerp,Lerp_localtype,Lerp);
//********************************************************************
//*** prototypes for .. AutonomousLerp
//********************************************************************
typedef  AutonomousLerp  AutonomousLerp_localtype;
Define_Module_ClassRef(panda,AutonomousLerp,AutonomousLerp_localtype,AutonomousLerp);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_EventHandler;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LPoint2f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LPoint3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LPoint4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase2f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVector2f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVector3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVector4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedReferenceCount;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. LerpFunctor 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle LerpFunctor::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_LerpFunctor_get_class_type_3(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle LerpFunctor::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = LerpFunctor::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LerpFunctor_get_class_type_3_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_LerpFunctor_get_class_type_3_comment = NULL;
#endif

int  Dtool_Init_LerpFunctor(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (LerpFunctor)");
       return -1;
}
inline void  * Dtool_UpcastInterface_LerpFunctor(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_LerpFunctor)
    {
        printf("LerpFunctor ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    LerpFunctor * local_this = (LerpFunctor *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_LerpFunctor)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_LerpFunctor(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_LerpFunctor)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (LerpFunctor*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (LerpFunctor*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (LerpFunctor*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SimpleLerpFunctor< int > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * int ::SimpleLerpFunctor< int >::interpolate(float )
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_int_interpolate_5(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int ::SimpleLerpFunctor< int >::interpolate(float )
        double param1;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:interpolate", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:interpolate", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->interpolate((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SimpleLerpFunctor.interpolate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "interpolate(non-const SimpleLerpFunctor this, float)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_int_interpolate_5_comment =
    "C++ Interface:\n"
    "interpolate(non-const SimpleLerpFunctor this, float)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_int_interpolate_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int const &::SimpleLerpFunctor< int >::get_start(void) const
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_int_get_start_6(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int const &::SimpleLerpFunctor< int >::get_start(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStart", key_word_list));
        else
            (PyArg_Parse(args, ":getStart"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SimpleLerpFunctor< int >*)local_this)->get_start();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStart(const SimpleLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_int_get_start_6_comment =
    "C++ Interface:\n"
    "getStart(const SimpleLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_int_get_start_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int const &::SimpleLerpFunctor< int >::get_end(void) const
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_int_get_end_7(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int const &::SimpleLerpFunctor< int >::get_end(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEnd", key_word_list));
        else
            (PyArg_Parse(args, ":getEnd"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const SimpleLerpFunctor< int >*)local_this)->get_end();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEnd(const SimpleLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_int_get_end_7_comment =
    "C++ Interface:\n"
    "getEnd(const SimpleLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_int_get_end_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ::SimpleLerpFunctor< int >::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_int_get_class_type_8(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ::SimpleLerpFunctor< int >::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ::SimpleLerpFunctor< int >::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_int_get_class_type_8_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_int_get_class_type_8_comment = NULL;
#endif

int  Dtool_Init_SimpleLerpFunctor_int(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (SimpleLerpFunctor< int >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_SimpleLerpFunctor_int(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SimpleLerpFunctor_int)
    {
        printf("SimpleLerpFunctor_int ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SimpleLerpFunctor< int > * local_this = (SimpleLerpFunctor< int > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SimpleLerpFunctor_int)
        return local_this;
    if(requested_type == &Dtool_LerpFunctor)
        return ( LerpFunctor *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( LerpFunctor *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( LerpFunctor *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( LerpFunctor *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SimpleLerpFunctor_int(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SimpleLerpFunctor_int)
        return from_this;
    if(from_type == &Dtool_LerpFunctor)
    {
          LerpFunctor* other_this = (LerpFunctor*)from_this;
          return (SimpleLerpFunctor< int >*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (SimpleLerpFunctor< int >*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (SimpleLerpFunctor< int >*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (SimpleLerpFunctor< int >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SimpleLerpFunctor< float > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * float ::SimpleLerpFunctor< float >::interpolate(float )
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_float_interpolate_10(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< float > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_float,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-float ::SimpleLerpFunctor< float >::interpolate(float )
        double param1;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:interpolate", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:interpolate", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = (local_this)->interpolate((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SimpleLerpFunctor.interpolate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "interpolate(non-const SimpleLerpFunctor this, float)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_float_interpolate_10_comment =
    "C++ Interface:\n"
    "interpolate(non-const SimpleLerpFunctor this, float)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_float_interpolate_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float const &::SimpleLerpFunctor< float >::get_start(void) const
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_float_get_start_11(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< float > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_float,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float const &::SimpleLerpFunctor< float >::get_start(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStart", key_word_list));
        else
            (PyArg_Parse(args, ":getStart"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const SimpleLerpFunctor< float >*)local_this)->get_start();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStart(const SimpleLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_float_get_start_11_comment =
    "C++ Interface:\n"
    "getStart(const SimpleLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_float_get_start_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float const &::SimpleLerpFunctor< float >::get_end(void) const
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_float_get_end_12(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< float > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_float,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float const &::SimpleLerpFunctor< float >::get_end(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEnd", key_word_list));
        else
            (PyArg_Parse(args, ":getEnd"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const SimpleLerpFunctor< float >*)local_this)->get_end();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEnd(const SimpleLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_float_get_end_12_comment =
    "C++ Interface:\n"
    "getEnd(const SimpleLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_float_get_end_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ::SimpleLerpFunctor< float >::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_float_get_class_type_13(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ::SimpleLerpFunctor< float >::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ::SimpleLerpFunctor< float >::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_float_get_class_type_13_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_float_get_class_type_13_comment = NULL;
#endif

int  Dtool_Init_SimpleLerpFunctor_float(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (SimpleLerpFunctor< float >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_SimpleLerpFunctor_float(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SimpleLerpFunctor_float)
    {
        printf("SimpleLerpFunctor_float ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SimpleLerpFunctor< float > * local_this = (SimpleLerpFunctor< float > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SimpleLerpFunctor_float)
        return local_this;
    if(requested_type == &Dtool_LerpFunctor)
        return ( LerpFunctor *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( LerpFunctor *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( LerpFunctor *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( LerpFunctor *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SimpleLerpFunctor_float(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SimpleLerpFunctor_float)
        return from_this;
    if(from_type == &Dtool_LerpFunctor)
    {
          LerpFunctor* other_this = (LerpFunctor*)from_this;
          return (SimpleLerpFunctor< float >*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (SimpleLerpFunctor< float >*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (SimpleLerpFunctor< float >*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (SimpleLerpFunctor< float >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SimpleLerpFunctor< LPoint2f > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * LPoint2f ::SimpleLerpFunctor< LPoint2f >::interpolate(float )
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LPoint2f_interpolate_15(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< LPoint2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_LPoint2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-LPoint2f ::SimpleLerpFunctor< LPoint2f >::interpolate(float )
        double param1;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:interpolate", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:interpolate", &param1));
        if(!PyErr_Occurred())
        {
            LPoint2f result = (local_this)->interpolate((float)param1);
            LPoint2f *return_value = new LPoint2f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint2f,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SimpleLerpFunctor.interpolate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "interpolate(non-const SimpleLerpFunctor this, float)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LPoint2f_interpolate_15_comment =
    "C++ Interface:\n"
    "interpolate(non-const SimpleLerpFunctor this, float)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LPoint2f_interpolate_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint2f const &::SimpleLerpFunctor< LPoint2f >::get_start(void) const
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LPoint2f_get_start_16(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< LPoint2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_LPoint2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint2f const &::SimpleLerpFunctor< LPoint2f >::get_start(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStart", key_word_list));
        else
            (PyArg_Parse(args, ":getStart"));
        if(!PyErr_Occurred())
        {
            LPoint2f const *return_value = &(((const SimpleLerpFunctor< LPoint2f >*)local_this)->get_start());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint2f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStart(const SimpleLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LPoint2f_get_start_16_comment =
    "C++ Interface:\n"
    "getStart(const SimpleLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LPoint2f_get_start_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint2f const &::SimpleLerpFunctor< LPoint2f >::get_end(void) const
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LPoint2f_get_end_17(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< LPoint2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_LPoint2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint2f const &::SimpleLerpFunctor< LPoint2f >::get_end(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEnd", key_word_list));
        else
            (PyArg_Parse(args, ":getEnd"));
        if(!PyErr_Occurred())
        {
            LPoint2f const *return_value = &(((const SimpleLerpFunctor< LPoint2f >*)local_this)->get_end());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint2f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEnd(const SimpleLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LPoint2f_get_end_17_comment =
    "C++ Interface:\n"
    "getEnd(const SimpleLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LPoint2f_get_end_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ::SimpleLerpFunctor< LPoint2f >::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LPoint2f_get_class_type_18(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ::SimpleLerpFunctor< LPoint2f >::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ::SimpleLerpFunctor< LPoint2f >::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LPoint2f_get_class_type_18_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LPoint2f_get_class_type_18_comment = NULL;
#endif

int  Dtool_Init_SimpleLerpFunctor_LPoint2f(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (SimpleLerpFunctor< LPoint2f >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_SimpleLerpFunctor_LPoint2f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SimpleLerpFunctor_LPoint2f)
    {
        printf("SimpleLerpFunctor_LPoint2f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SimpleLerpFunctor< LPoint2f > * local_this = (SimpleLerpFunctor< LPoint2f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SimpleLerpFunctor_LPoint2f)
        return local_this;
    if(requested_type == &Dtool_LerpFunctor)
        return ( LerpFunctor *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( LerpFunctor *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( LerpFunctor *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( LerpFunctor *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SimpleLerpFunctor_LPoint2f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SimpleLerpFunctor_LPoint2f)
        return from_this;
    if(from_type == &Dtool_LerpFunctor)
    {
          LerpFunctor* other_this = (LerpFunctor*)from_this;
          return (SimpleLerpFunctor< LPoint2f >*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (SimpleLerpFunctor< LPoint2f >*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (SimpleLerpFunctor< LPoint2f >*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (SimpleLerpFunctor< LPoint2f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SimpleLerpFunctor< LPoint3f > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * LPoint3f ::SimpleLerpFunctor< LPoint3f >::interpolate(float )
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LPoint3f_interpolate_20(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< LPoint3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_LPoint3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-LPoint3f ::SimpleLerpFunctor< LPoint3f >::interpolate(float )
        double param1;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:interpolate", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:interpolate", &param1));
        if(!PyErr_Occurred())
        {
            LPoint3f result = (local_this)->interpolate((float)param1);
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SimpleLerpFunctor.interpolate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "interpolate(non-const SimpleLerpFunctor this, float)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LPoint3f_interpolate_20_comment =
    "C++ Interface:\n"
    "interpolate(non-const SimpleLerpFunctor this, float)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LPoint3f_interpolate_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f const &::SimpleLerpFunctor< LPoint3f >::get_start(void) const
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LPoint3f_get_start_21(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< LPoint3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_LPoint3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f const &::SimpleLerpFunctor< LPoint3f >::get_start(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStart", key_word_list));
        else
            (PyArg_Parse(args, ":getStart"));
        if(!PyErr_Occurred())
        {
            LPoint3f const *return_value = &(((const SimpleLerpFunctor< LPoint3f >*)local_this)->get_start());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStart(const SimpleLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LPoint3f_get_start_21_comment =
    "C++ Interface:\n"
    "getStart(const SimpleLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LPoint3f_get_start_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f const &::SimpleLerpFunctor< LPoint3f >::get_end(void) const
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LPoint3f_get_end_22(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< LPoint3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_LPoint3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f const &::SimpleLerpFunctor< LPoint3f >::get_end(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEnd", key_word_list));
        else
            (PyArg_Parse(args, ":getEnd"));
        if(!PyErr_Occurred())
        {
            LPoint3f const *return_value = &(((const SimpleLerpFunctor< LPoint3f >*)local_this)->get_end());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEnd(const SimpleLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LPoint3f_get_end_22_comment =
    "C++ Interface:\n"
    "getEnd(const SimpleLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LPoint3f_get_end_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ::SimpleLerpFunctor< LPoint3f >::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LPoint3f_get_class_type_23(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ::SimpleLerpFunctor< LPoint3f >::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ::SimpleLerpFunctor< LPoint3f >::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LPoint3f_get_class_type_23_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LPoint3f_get_class_type_23_comment = NULL;
#endif

int  Dtool_Init_SimpleLerpFunctor_LPoint3f(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (SimpleLerpFunctor< LPoint3f >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_SimpleLerpFunctor_LPoint3f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SimpleLerpFunctor_LPoint3f)
    {
        printf("SimpleLerpFunctor_LPoint3f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SimpleLerpFunctor< LPoint3f > * local_this = (SimpleLerpFunctor< LPoint3f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SimpleLerpFunctor_LPoint3f)
        return local_this;
    if(requested_type == &Dtool_LerpFunctor)
        return ( LerpFunctor *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( LerpFunctor *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( LerpFunctor *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( LerpFunctor *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SimpleLerpFunctor_LPoint3f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SimpleLerpFunctor_LPoint3f)
        return from_this;
    if(from_type == &Dtool_LerpFunctor)
    {
          LerpFunctor* other_this = (LerpFunctor*)from_this;
          return (SimpleLerpFunctor< LPoint3f >*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (SimpleLerpFunctor< LPoint3f >*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (SimpleLerpFunctor< LPoint3f >*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (SimpleLerpFunctor< LPoint3f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SimpleLerpFunctor< LPoint4f > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * LPoint4f ::SimpleLerpFunctor< LPoint4f >::interpolate(float )
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LPoint4f_interpolate_25(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< LPoint4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_LPoint4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-LPoint4f ::SimpleLerpFunctor< LPoint4f >::interpolate(float )
        double param1;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:interpolate", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:interpolate", &param1));
        if(!PyErr_Occurred())
        {
            LPoint4f result = (local_this)->interpolate((float)param1);
            LPoint4f *return_value = new LPoint4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint4f,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SimpleLerpFunctor.interpolate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "interpolate(non-const SimpleLerpFunctor this, float)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LPoint4f_interpolate_25_comment =
    "C++ Interface:\n"
    "interpolate(non-const SimpleLerpFunctor this, float)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LPoint4f_interpolate_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint4f const &::SimpleLerpFunctor< LPoint4f >::get_start(void) const
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LPoint4f_get_start_26(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< LPoint4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_LPoint4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint4f const &::SimpleLerpFunctor< LPoint4f >::get_start(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStart", key_word_list));
        else
            (PyArg_Parse(args, ":getStart"));
        if(!PyErr_Occurred())
        {
            LPoint4f const *return_value = &(((const SimpleLerpFunctor< LPoint4f >*)local_this)->get_start());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStart(const SimpleLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LPoint4f_get_start_26_comment =
    "C++ Interface:\n"
    "getStart(const SimpleLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LPoint4f_get_start_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint4f const &::SimpleLerpFunctor< LPoint4f >::get_end(void) const
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LPoint4f_get_end_27(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< LPoint4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_LPoint4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint4f const &::SimpleLerpFunctor< LPoint4f >::get_end(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEnd", key_word_list));
        else
            (PyArg_Parse(args, ":getEnd"));
        if(!PyErr_Occurred())
        {
            LPoint4f const *return_value = &(((const SimpleLerpFunctor< LPoint4f >*)local_this)->get_end());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEnd(const SimpleLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LPoint4f_get_end_27_comment =
    "C++ Interface:\n"
    "getEnd(const SimpleLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LPoint4f_get_end_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ::SimpleLerpFunctor< LPoint4f >::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LPoint4f_get_class_type_28(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ::SimpleLerpFunctor< LPoint4f >::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ::SimpleLerpFunctor< LPoint4f >::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LPoint4f_get_class_type_28_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LPoint4f_get_class_type_28_comment = NULL;
#endif

int  Dtool_Init_SimpleLerpFunctor_LPoint4f(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (SimpleLerpFunctor< LPoint4f >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_SimpleLerpFunctor_LPoint4f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SimpleLerpFunctor_LPoint4f)
    {
        printf("SimpleLerpFunctor_LPoint4f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SimpleLerpFunctor< LPoint4f > * local_this = (SimpleLerpFunctor< LPoint4f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SimpleLerpFunctor_LPoint4f)
        return local_this;
    if(requested_type == &Dtool_LerpFunctor)
        return ( LerpFunctor *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( LerpFunctor *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( LerpFunctor *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( LerpFunctor *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SimpleLerpFunctor_LPoint4f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SimpleLerpFunctor_LPoint4f)
        return from_this;
    if(from_type == &Dtool_LerpFunctor)
    {
          LerpFunctor* other_this = (LerpFunctor*)from_this;
          return (SimpleLerpFunctor< LPoint4f >*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (SimpleLerpFunctor< LPoint4f >*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (SimpleLerpFunctor< LPoint4f >*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (SimpleLerpFunctor< LPoint4f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SimpleLerpFunctor< LVecBase2f > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * LVecBase2f ::SimpleLerpFunctor< LVecBase2f >::interpolate(float )
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LVecBase2f_interpolate_30(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< LVecBase2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_LVecBase2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-LVecBase2f ::SimpleLerpFunctor< LVecBase2f >::interpolate(float )
        double param1;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:interpolate", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:interpolate", &param1));
        if(!PyErr_Occurred())
        {
            LVecBase2f result = (local_this)->interpolate((float)param1);
            LVecBase2f *return_value = new LVecBase2f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase2f,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SimpleLerpFunctor.interpolate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "interpolate(non-const SimpleLerpFunctor this, float)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LVecBase2f_interpolate_30_comment =
    "C++ Interface:\n"
    "interpolate(non-const SimpleLerpFunctor this, float)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LVecBase2f_interpolate_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase2f const &::SimpleLerpFunctor< LVecBase2f >::get_start(void) const
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LVecBase2f_get_start_31(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< LVecBase2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_LVecBase2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase2f const &::SimpleLerpFunctor< LVecBase2f >::get_start(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStart", key_word_list));
        else
            (PyArg_Parse(args, ":getStart"));
        if(!PyErr_Occurred())
        {
            LVecBase2f const *return_value = &(((const SimpleLerpFunctor< LVecBase2f >*)local_this)->get_start());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase2f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStart(const SimpleLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LVecBase2f_get_start_31_comment =
    "C++ Interface:\n"
    "getStart(const SimpleLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LVecBase2f_get_start_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase2f const &::SimpleLerpFunctor< LVecBase2f >::get_end(void) const
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LVecBase2f_get_end_32(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< LVecBase2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_LVecBase2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase2f const &::SimpleLerpFunctor< LVecBase2f >::get_end(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEnd", key_word_list));
        else
            (PyArg_Parse(args, ":getEnd"));
        if(!PyErr_Occurred())
        {
            LVecBase2f const *return_value = &(((const SimpleLerpFunctor< LVecBase2f >*)local_this)->get_end());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase2f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEnd(const SimpleLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LVecBase2f_get_end_32_comment =
    "C++ Interface:\n"
    "getEnd(const SimpleLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LVecBase2f_get_end_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ::SimpleLerpFunctor< LVecBase2f >::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LVecBase2f_get_class_type_33(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ::SimpleLerpFunctor< LVecBase2f >::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ::SimpleLerpFunctor< LVecBase2f >::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LVecBase2f_get_class_type_33_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LVecBase2f_get_class_type_33_comment = NULL;
#endif

int  Dtool_Init_SimpleLerpFunctor_LVecBase2f(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (SimpleLerpFunctor< LVecBase2f >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_SimpleLerpFunctor_LVecBase2f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SimpleLerpFunctor_LVecBase2f)
    {
        printf("SimpleLerpFunctor_LVecBase2f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SimpleLerpFunctor< LVecBase2f > * local_this = (SimpleLerpFunctor< LVecBase2f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SimpleLerpFunctor_LVecBase2f)
        return local_this;
    if(requested_type == &Dtool_LerpFunctor)
        return ( LerpFunctor *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( LerpFunctor *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( LerpFunctor *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( LerpFunctor *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SimpleLerpFunctor_LVecBase2f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SimpleLerpFunctor_LVecBase2f)
        return from_this;
    if(from_type == &Dtool_LerpFunctor)
    {
          LerpFunctor* other_this = (LerpFunctor*)from_this;
          return (SimpleLerpFunctor< LVecBase2f >*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (SimpleLerpFunctor< LVecBase2f >*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (SimpleLerpFunctor< LVecBase2f >*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (SimpleLerpFunctor< LVecBase2f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SimpleLerpFunctor< LVecBase3f > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * LVecBase3f ::SimpleLerpFunctor< LVecBase3f >::interpolate(float )
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LVecBase3f_interpolate_35(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< LVecBase3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_LVecBase3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-LVecBase3f ::SimpleLerpFunctor< LVecBase3f >::interpolate(float )
        double param1;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:interpolate", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:interpolate", &param1));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = (local_this)->interpolate((float)param1);
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SimpleLerpFunctor.interpolate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "interpolate(non-const SimpleLerpFunctor this, float)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LVecBase3f_interpolate_35_comment =
    "C++ Interface:\n"
    "interpolate(non-const SimpleLerpFunctor this, float)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LVecBase3f_interpolate_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f const &::SimpleLerpFunctor< LVecBase3f >::get_start(void) const
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LVecBase3f_get_start_36(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< LVecBase3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_LVecBase3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f const &::SimpleLerpFunctor< LVecBase3f >::get_start(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStart", key_word_list));
        else
            (PyArg_Parse(args, ":getStart"));
        if(!PyErr_Occurred())
        {
            LVecBase3f const *return_value = &(((const SimpleLerpFunctor< LVecBase3f >*)local_this)->get_start());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStart(const SimpleLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LVecBase3f_get_start_36_comment =
    "C++ Interface:\n"
    "getStart(const SimpleLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LVecBase3f_get_start_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f const &::SimpleLerpFunctor< LVecBase3f >::get_end(void) const
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LVecBase3f_get_end_37(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< LVecBase3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_LVecBase3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f const &::SimpleLerpFunctor< LVecBase3f >::get_end(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEnd", key_word_list));
        else
            (PyArg_Parse(args, ":getEnd"));
        if(!PyErr_Occurred())
        {
            LVecBase3f const *return_value = &(((const SimpleLerpFunctor< LVecBase3f >*)local_this)->get_end());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEnd(const SimpleLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LVecBase3f_get_end_37_comment =
    "C++ Interface:\n"
    "getEnd(const SimpleLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LVecBase3f_get_end_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ::SimpleLerpFunctor< LVecBase3f >::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LVecBase3f_get_class_type_38(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ::SimpleLerpFunctor< LVecBase3f >::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ::SimpleLerpFunctor< LVecBase3f >::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LVecBase3f_get_class_type_38_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LVecBase3f_get_class_type_38_comment = NULL;
#endif

int  Dtool_Init_SimpleLerpFunctor_LVecBase3f(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (SimpleLerpFunctor< LVecBase3f >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_SimpleLerpFunctor_LVecBase3f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SimpleLerpFunctor_LVecBase3f)
    {
        printf("SimpleLerpFunctor_LVecBase3f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SimpleLerpFunctor< LVecBase3f > * local_this = (SimpleLerpFunctor< LVecBase3f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SimpleLerpFunctor_LVecBase3f)
        return local_this;
    if(requested_type == &Dtool_LerpFunctor)
        return ( LerpFunctor *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( LerpFunctor *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( LerpFunctor *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( LerpFunctor *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SimpleLerpFunctor_LVecBase3f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SimpleLerpFunctor_LVecBase3f)
        return from_this;
    if(from_type == &Dtool_LerpFunctor)
    {
          LerpFunctor* other_this = (LerpFunctor*)from_this;
          return (SimpleLerpFunctor< LVecBase3f >*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (SimpleLerpFunctor< LVecBase3f >*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (SimpleLerpFunctor< LVecBase3f >*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (SimpleLerpFunctor< LVecBase3f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SimpleLerpFunctor< LVecBase4f > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * LVecBase4f ::SimpleLerpFunctor< LVecBase4f >::interpolate(float )
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LVecBase4f_interpolate_40(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< LVecBase4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_LVecBase4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-LVecBase4f ::SimpleLerpFunctor< LVecBase4f >::interpolate(float )
        double param1;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:interpolate", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:interpolate", &param1));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = (local_this)->interpolate((float)param1);
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SimpleLerpFunctor.interpolate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "interpolate(non-const SimpleLerpFunctor this, float)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LVecBase4f_interpolate_40_comment =
    "C++ Interface:\n"
    "interpolate(non-const SimpleLerpFunctor this, float)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LVecBase4f_interpolate_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &::SimpleLerpFunctor< LVecBase4f >::get_start(void) const
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LVecBase4f_get_start_41(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< LVecBase4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_LVecBase4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &::SimpleLerpFunctor< LVecBase4f >::get_start(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStart", key_word_list));
        else
            (PyArg_Parse(args, ":getStart"));
        if(!PyErr_Occurred())
        {
            LVecBase4f const *return_value = &(((const SimpleLerpFunctor< LVecBase4f >*)local_this)->get_start());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStart(const SimpleLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LVecBase4f_get_start_41_comment =
    "C++ Interface:\n"
    "getStart(const SimpleLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LVecBase4f_get_start_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f const &::SimpleLerpFunctor< LVecBase4f >::get_end(void) const
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LVecBase4f_get_end_42(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< LVecBase4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_LVecBase4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f const &::SimpleLerpFunctor< LVecBase4f >::get_end(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEnd", key_word_list));
        else
            (PyArg_Parse(args, ":getEnd"));
        if(!PyErr_Occurred())
        {
            LVecBase4f const *return_value = &(((const SimpleLerpFunctor< LVecBase4f >*)local_this)->get_end());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEnd(const SimpleLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LVecBase4f_get_end_42_comment =
    "C++ Interface:\n"
    "getEnd(const SimpleLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LVecBase4f_get_end_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ::SimpleLerpFunctor< LVecBase4f >::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LVecBase4f_get_class_type_43(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ::SimpleLerpFunctor< LVecBase4f >::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ::SimpleLerpFunctor< LVecBase4f >::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LVecBase4f_get_class_type_43_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LVecBase4f_get_class_type_43_comment = NULL;
#endif

int  Dtool_Init_SimpleLerpFunctor_LVecBase4f(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (SimpleLerpFunctor< LVecBase4f >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_SimpleLerpFunctor_LVecBase4f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SimpleLerpFunctor_LVecBase4f)
    {
        printf("SimpleLerpFunctor_LVecBase4f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SimpleLerpFunctor< LVecBase4f > * local_this = (SimpleLerpFunctor< LVecBase4f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SimpleLerpFunctor_LVecBase4f)
        return local_this;
    if(requested_type == &Dtool_LerpFunctor)
        return ( LerpFunctor *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( LerpFunctor *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( LerpFunctor *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( LerpFunctor *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SimpleLerpFunctor_LVecBase4f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SimpleLerpFunctor_LVecBase4f)
        return from_this;
    if(from_type == &Dtool_LerpFunctor)
    {
          LerpFunctor* other_this = (LerpFunctor*)from_this;
          return (SimpleLerpFunctor< LVecBase4f >*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (SimpleLerpFunctor< LVecBase4f >*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (SimpleLerpFunctor< LVecBase4f >*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (SimpleLerpFunctor< LVecBase4f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SimpleLerpFunctor< LVector2f > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * LVector2f ::SimpleLerpFunctor< LVector2f >::interpolate(float )
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LVector2f_interpolate_45(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< LVector2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_LVector2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-LVector2f ::SimpleLerpFunctor< LVector2f >::interpolate(float )
        double param1;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:interpolate", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:interpolate", &param1));
        if(!PyErr_Occurred())
        {
            LVector2f result = (local_this)->interpolate((float)param1);
            LVector2f *return_value = new LVector2f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector2f,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SimpleLerpFunctor.interpolate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "interpolate(non-const SimpleLerpFunctor this, float)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LVector2f_interpolate_45_comment =
    "C++ Interface:\n"
    "interpolate(non-const SimpleLerpFunctor this, float)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LVector2f_interpolate_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector2f const &::SimpleLerpFunctor< LVector2f >::get_start(void) const
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LVector2f_get_start_46(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< LVector2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_LVector2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVector2f const &::SimpleLerpFunctor< LVector2f >::get_start(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStart", key_word_list));
        else
            (PyArg_Parse(args, ":getStart"));
        if(!PyErr_Occurred())
        {
            LVector2f const *return_value = &(((const SimpleLerpFunctor< LVector2f >*)local_this)->get_start());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector2f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStart(const SimpleLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LVector2f_get_start_46_comment =
    "C++ Interface:\n"
    "getStart(const SimpleLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LVector2f_get_start_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector2f const &::SimpleLerpFunctor< LVector2f >::get_end(void) const
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LVector2f_get_end_47(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< LVector2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_LVector2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVector2f const &::SimpleLerpFunctor< LVector2f >::get_end(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEnd", key_word_list));
        else
            (PyArg_Parse(args, ":getEnd"));
        if(!PyErr_Occurred())
        {
            LVector2f const *return_value = &(((const SimpleLerpFunctor< LVector2f >*)local_this)->get_end());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector2f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEnd(const SimpleLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LVector2f_get_end_47_comment =
    "C++ Interface:\n"
    "getEnd(const SimpleLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LVector2f_get_end_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ::SimpleLerpFunctor< LVector2f >::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LVector2f_get_class_type_48(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ::SimpleLerpFunctor< LVector2f >::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ::SimpleLerpFunctor< LVector2f >::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LVector2f_get_class_type_48_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LVector2f_get_class_type_48_comment = NULL;
#endif

int  Dtool_Init_SimpleLerpFunctor_LVector2f(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (SimpleLerpFunctor< LVector2f >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_SimpleLerpFunctor_LVector2f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SimpleLerpFunctor_LVector2f)
    {
        printf("SimpleLerpFunctor_LVector2f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SimpleLerpFunctor< LVector2f > * local_this = (SimpleLerpFunctor< LVector2f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SimpleLerpFunctor_LVector2f)
        return local_this;
    if(requested_type == &Dtool_LerpFunctor)
        return ( LerpFunctor *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( LerpFunctor *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( LerpFunctor *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( LerpFunctor *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SimpleLerpFunctor_LVector2f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SimpleLerpFunctor_LVector2f)
        return from_this;
    if(from_type == &Dtool_LerpFunctor)
    {
          LerpFunctor* other_this = (LerpFunctor*)from_this;
          return (SimpleLerpFunctor< LVector2f >*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (SimpleLerpFunctor< LVector2f >*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (SimpleLerpFunctor< LVector2f >*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (SimpleLerpFunctor< LVector2f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SimpleLerpFunctor< LVector3f > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * LVector3f ::SimpleLerpFunctor< LVector3f >::interpolate(float )
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LVector3f_interpolate_50(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< LVector3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_LVector3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-LVector3f ::SimpleLerpFunctor< LVector3f >::interpolate(float )
        double param1;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:interpolate", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:interpolate", &param1));
        if(!PyErr_Occurred())
        {
            LVector3f result = (local_this)->interpolate((float)param1);
            LVector3f *return_value = new LVector3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SimpleLerpFunctor.interpolate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "interpolate(non-const SimpleLerpFunctor this, float)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LVector3f_interpolate_50_comment =
    "C++ Interface:\n"
    "interpolate(non-const SimpleLerpFunctor this, float)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LVector3f_interpolate_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector3f const &::SimpleLerpFunctor< LVector3f >::get_start(void) const
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LVector3f_get_start_51(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< LVector3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_LVector3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVector3f const &::SimpleLerpFunctor< LVector3f >::get_start(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStart", key_word_list));
        else
            (PyArg_Parse(args, ":getStart"));
        if(!PyErr_Occurred())
        {
            LVector3f const *return_value = &(((const SimpleLerpFunctor< LVector3f >*)local_this)->get_start());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStart(const SimpleLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LVector3f_get_start_51_comment =
    "C++ Interface:\n"
    "getStart(const SimpleLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LVector3f_get_start_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector3f const &::SimpleLerpFunctor< LVector3f >::get_end(void) const
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LVector3f_get_end_52(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< LVector3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_LVector3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVector3f const &::SimpleLerpFunctor< LVector3f >::get_end(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEnd", key_word_list));
        else
            (PyArg_Parse(args, ":getEnd"));
        if(!PyErr_Occurred())
        {
            LVector3f const *return_value = &(((const SimpleLerpFunctor< LVector3f >*)local_this)->get_end());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEnd(const SimpleLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LVector3f_get_end_52_comment =
    "C++ Interface:\n"
    "getEnd(const SimpleLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LVector3f_get_end_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ::SimpleLerpFunctor< LVector3f >::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LVector3f_get_class_type_53(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ::SimpleLerpFunctor< LVector3f >::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ::SimpleLerpFunctor< LVector3f >::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LVector3f_get_class_type_53_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LVector3f_get_class_type_53_comment = NULL;
#endif

int  Dtool_Init_SimpleLerpFunctor_LVector3f(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (SimpleLerpFunctor< LVector3f >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_SimpleLerpFunctor_LVector3f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SimpleLerpFunctor_LVector3f)
    {
        printf("SimpleLerpFunctor_LVector3f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SimpleLerpFunctor< LVector3f > * local_this = (SimpleLerpFunctor< LVector3f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SimpleLerpFunctor_LVector3f)
        return local_this;
    if(requested_type == &Dtool_LerpFunctor)
        return ( LerpFunctor *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( LerpFunctor *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( LerpFunctor *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( LerpFunctor *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SimpleLerpFunctor_LVector3f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SimpleLerpFunctor_LVector3f)
        return from_this;
    if(from_type == &Dtool_LerpFunctor)
    {
          LerpFunctor* other_this = (LerpFunctor*)from_this;
          return (SimpleLerpFunctor< LVector3f >*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (SimpleLerpFunctor< LVector3f >*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (SimpleLerpFunctor< LVector3f >*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (SimpleLerpFunctor< LVector3f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SimpleLerpFunctor< LVector4f > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * LVector4f ::SimpleLerpFunctor< LVector4f >::interpolate(float )
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LVector4f_interpolate_55(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< LVector4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_LVector4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-LVector4f ::SimpleLerpFunctor< LVector4f >::interpolate(float )
        double param1;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:interpolate", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:interpolate", &param1));
        if(!PyErr_Occurred())
        {
            LVector4f result = (local_this)->interpolate((float)param1);
            LVector4f *return_value = new LVector4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector4f,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SimpleLerpFunctor.interpolate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "interpolate(non-const SimpleLerpFunctor this, float)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LVector4f_interpolate_55_comment =
    "C++ Interface:\n"
    "interpolate(non-const SimpleLerpFunctor this, float)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LVector4f_interpolate_55_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector4f const &::SimpleLerpFunctor< LVector4f >::get_start(void) const
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LVector4f_get_start_56(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< LVector4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_LVector4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVector4f const &::SimpleLerpFunctor< LVector4f >::get_start(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStart", key_word_list));
        else
            (PyArg_Parse(args, ":getStart"));
        if(!PyErr_Occurred())
        {
            LVector4f const *return_value = &(((const SimpleLerpFunctor< LVector4f >*)local_this)->get_start());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStart(const SimpleLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LVector4f_get_start_56_comment =
    "C++ Interface:\n"
    "getStart(const SimpleLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LVector4f_get_start_56_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector4f const &::SimpleLerpFunctor< LVector4f >::get_end(void) const
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LVector4f_get_end_57(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleLerpFunctor< LVector4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleLerpFunctor_LVector4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVector4f const &::SimpleLerpFunctor< LVector4f >::get_end(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEnd", key_word_list));
        else
            (PyArg_Parse(args, ":getEnd"));
        if(!PyErr_Occurred())
        {
            LVector4f const *return_value = &(((const SimpleLerpFunctor< LVector4f >*)local_this)->get_end());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEnd(const SimpleLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LVector4f_get_end_57_comment =
    "C++ Interface:\n"
    "getEnd(const SimpleLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LVector4f_get_end_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ::SimpleLerpFunctor< LVector4f >::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SimpleLerpFunctor_LVector4f_get_class_type_58(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ::SimpleLerpFunctor< LVector4f >::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ::SimpleLerpFunctor< LVector4f >::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleLerpFunctor_LVector4f_get_class_type_58_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleLerpFunctor_LVector4f_get_class_type_58_comment = NULL;
#endif

int  Dtool_Init_SimpleLerpFunctor_LVector4f(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (SimpleLerpFunctor< LVector4f >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_SimpleLerpFunctor_LVector4f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SimpleLerpFunctor_LVector4f)
    {
        printf("SimpleLerpFunctor_LVector4f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SimpleLerpFunctor< LVector4f > * local_this = (SimpleLerpFunctor< LVector4f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SimpleLerpFunctor_LVector4f)
        return local_this;
    if(requested_type == &Dtool_LerpFunctor)
        return ( LerpFunctor *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( LerpFunctor *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( LerpFunctor *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( LerpFunctor *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SimpleLerpFunctor_LVector4f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SimpleLerpFunctor_LVector4f)
        return from_this;
    if(from_type == &Dtool_LerpFunctor)
    {
          LerpFunctor* other_this = (LerpFunctor*)from_this;
          return (SimpleLerpFunctor< LVector4f >*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (SimpleLerpFunctor< LVector4f >*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (SimpleLerpFunctor< LVector4f >*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (SimpleLerpFunctor< LVector4f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SimpleQueryLerpFunctor< int > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * int ::SimpleQueryLerpFunctor< int >::get_value(void)
 *******************************************************************/
static PyObject *Dtool_SimpleQueryLerpFunctor_int_get_value_60(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleQueryLerpFunctor< int > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleQueryLerpFunctor_int,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int ::SimpleQueryLerpFunctor< int >::get_value(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValue", key_word_list));
        else
            (PyArg_Parse(args, ":getValue"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SimpleQueryLerpFunctor.getValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValue(non-const SimpleQueryLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleQueryLerpFunctor_int_get_value_60_comment =
    "C++ Interface:\n"
    "getValue(non-const SimpleQueryLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleQueryLerpFunctor_int_get_value_60_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ::SimpleQueryLerpFunctor< int >::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SimpleQueryLerpFunctor_int_get_class_type_61(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ::SimpleQueryLerpFunctor< int >::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ::SimpleQueryLerpFunctor< int >::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleQueryLerpFunctor_int_get_class_type_61_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleQueryLerpFunctor_int_get_class_type_61_comment = NULL;
#endif

int  Dtool_Init_SimpleQueryLerpFunctor_int(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (SimpleQueryLerpFunctor< int >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_SimpleQueryLerpFunctor_int(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SimpleQueryLerpFunctor_int)
    {
        printf("SimpleQueryLerpFunctor_int ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SimpleQueryLerpFunctor< int > * local_this = (SimpleQueryLerpFunctor< int > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SimpleQueryLerpFunctor_int)
        return local_this;
    if(requested_type == &Dtool_LerpFunctor)
        return ( LerpFunctor *)( SimpleLerpFunctor< int > *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< int > *) local_this;
    if(requested_type == &Dtool_SimpleLerpFunctor_int)
        return ( SimpleLerpFunctor< int > *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< int > *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< int > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SimpleQueryLerpFunctor_int(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SimpleQueryLerpFunctor_int)
        return from_this;
    if(from_type == &Dtool_LerpFunctor)
    {
          LerpFunctor* other_this = (LerpFunctor*)from_this;
          return (SimpleQueryLerpFunctor< int >*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (SimpleQueryLerpFunctor< int >*)other_this;
    }
    if(from_type == &Dtool_SimpleLerpFunctor_int)
    {
          SimpleLerpFunctor< int >* other_this = (SimpleLerpFunctor< int >*)from_this;
          return (SimpleQueryLerpFunctor< int >*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (SimpleQueryLerpFunctor< int >*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (SimpleQueryLerpFunctor< int >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SimpleQueryLerpFunctor< float > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * float ::SimpleQueryLerpFunctor< float >::get_value(void)
 *******************************************************************/
static PyObject *Dtool_SimpleQueryLerpFunctor_float_get_value_63(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleQueryLerpFunctor< float > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleQueryLerpFunctor_float,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-float ::SimpleQueryLerpFunctor< float >::get_value(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValue", key_word_list));
        else
            (PyArg_Parse(args, ":getValue"));
        if(!PyErr_Occurred())
        {
            float return_value = (local_this)->get_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SimpleQueryLerpFunctor.getValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValue(non-const SimpleQueryLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleQueryLerpFunctor_float_get_value_63_comment =
    "C++ Interface:\n"
    "getValue(non-const SimpleQueryLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleQueryLerpFunctor_float_get_value_63_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ::SimpleQueryLerpFunctor< float >::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SimpleQueryLerpFunctor_float_get_class_type_64(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ::SimpleQueryLerpFunctor< float >::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ::SimpleQueryLerpFunctor< float >::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleQueryLerpFunctor_float_get_class_type_64_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleQueryLerpFunctor_float_get_class_type_64_comment = NULL;
#endif

int  Dtool_Init_SimpleQueryLerpFunctor_float(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (SimpleQueryLerpFunctor< float >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_SimpleQueryLerpFunctor_float(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SimpleQueryLerpFunctor_float)
    {
        printf("SimpleQueryLerpFunctor_float ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SimpleQueryLerpFunctor< float > * local_this = (SimpleQueryLerpFunctor< float > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SimpleQueryLerpFunctor_float)
        return local_this;
    if(requested_type == &Dtool_LerpFunctor)
        return ( LerpFunctor *)( SimpleLerpFunctor< float > *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< float > *) local_this;
    if(requested_type == &Dtool_SimpleLerpFunctor_float)
        return ( SimpleLerpFunctor< float > *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< float > *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< float > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SimpleQueryLerpFunctor_float(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SimpleQueryLerpFunctor_float)
        return from_this;
    if(from_type == &Dtool_LerpFunctor)
    {
          LerpFunctor* other_this = (LerpFunctor*)from_this;
          return (SimpleQueryLerpFunctor< float >*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (SimpleQueryLerpFunctor< float >*)other_this;
    }
    if(from_type == &Dtool_SimpleLerpFunctor_float)
    {
          SimpleLerpFunctor< float >* other_this = (SimpleLerpFunctor< float >*)from_this;
          return (SimpleQueryLerpFunctor< float >*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (SimpleQueryLerpFunctor< float >*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (SimpleQueryLerpFunctor< float >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SimpleQueryLerpFunctor< LPoint2f > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * LPoint2f ::SimpleQueryLerpFunctor< LPoint2f >::get_value(void)
 *******************************************************************/
static PyObject *Dtool_SimpleQueryLerpFunctor_LPoint2f_get_value_66(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleQueryLerpFunctor< LPoint2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleQueryLerpFunctor_LPoint2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-LPoint2f ::SimpleQueryLerpFunctor< LPoint2f >::get_value(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValue", key_word_list));
        else
            (PyArg_Parse(args, ":getValue"));
        if(!PyErr_Occurred())
        {
            LPoint2f result = (local_this)->get_value();
            LPoint2f *return_value = new LPoint2f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint2f,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SimpleQueryLerpFunctor.getValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValue(non-const SimpleQueryLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleQueryLerpFunctor_LPoint2f_get_value_66_comment =
    "C++ Interface:\n"
    "getValue(non-const SimpleQueryLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleQueryLerpFunctor_LPoint2f_get_value_66_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ::SimpleQueryLerpFunctor< LPoint2f >::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SimpleQueryLerpFunctor_LPoint2f_get_class_type_67(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ::SimpleQueryLerpFunctor< LPoint2f >::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ::SimpleQueryLerpFunctor< LPoint2f >::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleQueryLerpFunctor_LPoint2f_get_class_type_67_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleQueryLerpFunctor_LPoint2f_get_class_type_67_comment = NULL;
#endif

int  Dtool_Init_SimpleQueryLerpFunctor_LPoint2f(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (SimpleQueryLerpFunctor< LPoint2f >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_SimpleQueryLerpFunctor_LPoint2f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SimpleQueryLerpFunctor_LPoint2f)
    {
        printf("SimpleQueryLerpFunctor_LPoint2f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SimpleQueryLerpFunctor< LPoint2f > * local_this = (SimpleQueryLerpFunctor< LPoint2f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SimpleQueryLerpFunctor_LPoint2f)
        return local_this;
    if(requested_type == &Dtool_LerpFunctor)
        return ( LerpFunctor *)( SimpleLerpFunctor< LPoint2f > *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< LPoint2f > *) local_this;
    if(requested_type == &Dtool_SimpleLerpFunctor_LPoint2f)
        return ( SimpleLerpFunctor< LPoint2f > *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< LPoint2f > *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< LPoint2f > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SimpleQueryLerpFunctor_LPoint2f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SimpleQueryLerpFunctor_LPoint2f)
        return from_this;
    if(from_type == &Dtool_LerpFunctor)
    {
          LerpFunctor* other_this = (LerpFunctor*)from_this;
          return (SimpleQueryLerpFunctor< LPoint2f >*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (SimpleQueryLerpFunctor< LPoint2f >*)other_this;
    }
    if(from_type == &Dtool_SimpleLerpFunctor_LPoint2f)
    {
          SimpleLerpFunctor< LPoint2f >* other_this = (SimpleLerpFunctor< LPoint2f >*)from_this;
          return (SimpleQueryLerpFunctor< LPoint2f >*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (SimpleQueryLerpFunctor< LPoint2f >*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (SimpleQueryLerpFunctor< LPoint2f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SimpleQueryLerpFunctor< LPoint3f > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * LPoint3f ::SimpleQueryLerpFunctor< LPoint3f >::get_value(void)
 *******************************************************************/
static PyObject *Dtool_SimpleQueryLerpFunctor_LPoint3f_get_value_69(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleQueryLerpFunctor< LPoint3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleQueryLerpFunctor_LPoint3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-LPoint3f ::SimpleQueryLerpFunctor< LPoint3f >::get_value(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValue", key_word_list));
        else
            (PyArg_Parse(args, ":getValue"));
        if(!PyErr_Occurred())
        {
            LPoint3f result = (local_this)->get_value();
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SimpleQueryLerpFunctor.getValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValue(non-const SimpleQueryLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleQueryLerpFunctor_LPoint3f_get_value_69_comment =
    "C++ Interface:\n"
    "getValue(non-const SimpleQueryLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleQueryLerpFunctor_LPoint3f_get_value_69_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ::SimpleQueryLerpFunctor< LPoint3f >::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SimpleQueryLerpFunctor_LPoint3f_get_class_type_70(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ::SimpleQueryLerpFunctor< LPoint3f >::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ::SimpleQueryLerpFunctor< LPoint3f >::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleQueryLerpFunctor_LPoint3f_get_class_type_70_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleQueryLerpFunctor_LPoint3f_get_class_type_70_comment = NULL;
#endif

int  Dtool_Init_SimpleQueryLerpFunctor_LPoint3f(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (SimpleQueryLerpFunctor< LPoint3f >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_SimpleQueryLerpFunctor_LPoint3f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SimpleQueryLerpFunctor_LPoint3f)
    {
        printf("SimpleQueryLerpFunctor_LPoint3f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SimpleQueryLerpFunctor< LPoint3f > * local_this = (SimpleQueryLerpFunctor< LPoint3f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SimpleQueryLerpFunctor_LPoint3f)
        return local_this;
    if(requested_type == &Dtool_LerpFunctor)
        return ( LerpFunctor *)( SimpleLerpFunctor< LPoint3f > *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< LPoint3f > *) local_this;
    if(requested_type == &Dtool_SimpleLerpFunctor_LPoint3f)
        return ( SimpleLerpFunctor< LPoint3f > *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< LPoint3f > *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< LPoint3f > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SimpleQueryLerpFunctor_LPoint3f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SimpleQueryLerpFunctor_LPoint3f)
        return from_this;
    if(from_type == &Dtool_LerpFunctor)
    {
          LerpFunctor* other_this = (LerpFunctor*)from_this;
          return (SimpleQueryLerpFunctor< LPoint3f >*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (SimpleQueryLerpFunctor< LPoint3f >*)other_this;
    }
    if(from_type == &Dtool_SimpleLerpFunctor_LPoint3f)
    {
          SimpleLerpFunctor< LPoint3f >* other_this = (SimpleLerpFunctor< LPoint3f >*)from_this;
          return (SimpleQueryLerpFunctor< LPoint3f >*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (SimpleQueryLerpFunctor< LPoint3f >*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (SimpleQueryLerpFunctor< LPoint3f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SimpleQueryLerpFunctor< LPoint4f > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * LPoint4f ::SimpleQueryLerpFunctor< LPoint4f >::get_value(void)
 *******************************************************************/
static PyObject *Dtool_SimpleQueryLerpFunctor_LPoint4f_get_value_72(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleQueryLerpFunctor< LPoint4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleQueryLerpFunctor_LPoint4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-LPoint4f ::SimpleQueryLerpFunctor< LPoint4f >::get_value(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValue", key_word_list));
        else
            (PyArg_Parse(args, ":getValue"));
        if(!PyErr_Occurred())
        {
            LPoint4f result = (local_this)->get_value();
            LPoint4f *return_value = new LPoint4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint4f,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SimpleQueryLerpFunctor.getValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValue(non-const SimpleQueryLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleQueryLerpFunctor_LPoint4f_get_value_72_comment =
    "C++ Interface:\n"
    "getValue(non-const SimpleQueryLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleQueryLerpFunctor_LPoint4f_get_value_72_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ::SimpleQueryLerpFunctor< LPoint4f >::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SimpleQueryLerpFunctor_LPoint4f_get_class_type_73(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ::SimpleQueryLerpFunctor< LPoint4f >::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ::SimpleQueryLerpFunctor< LPoint4f >::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleQueryLerpFunctor_LPoint4f_get_class_type_73_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleQueryLerpFunctor_LPoint4f_get_class_type_73_comment = NULL;
#endif

int  Dtool_Init_SimpleQueryLerpFunctor_LPoint4f(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (SimpleQueryLerpFunctor< LPoint4f >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_SimpleQueryLerpFunctor_LPoint4f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SimpleQueryLerpFunctor_LPoint4f)
    {
        printf("SimpleQueryLerpFunctor_LPoint4f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SimpleQueryLerpFunctor< LPoint4f > * local_this = (SimpleQueryLerpFunctor< LPoint4f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SimpleQueryLerpFunctor_LPoint4f)
        return local_this;
    if(requested_type == &Dtool_LerpFunctor)
        return ( LerpFunctor *)( SimpleLerpFunctor< LPoint4f > *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< LPoint4f > *) local_this;
    if(requested_type == &Dtool_SimpleLerpFunctor_LPoint4f)
        return ( SimpleLerpFunctor< LPoint4f > *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< LPoint4f > *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< LPoint4f > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SimpleQueryLerpFunctor_LPoint4f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SimpleQueryLerpFunctor_LPoint4f)
        return from_this;
    if(from_type == &Dtool_LerpFunctor)
    {
          LerpFunctor* other_this = (LerpFunctor*)from_this;
          return (SimpleQueryLerpFunctor< LPoint4f >*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (SimpleQueryLerpFunctor< LPoint4f >*)other_this;
    }
    if(from_type == &Dtool_SimpleLerpFunctor_LPoint4f)
    {
          SimpleLerpFunctor< LPoint4f >* other_this = (SimpleLerpFunctor< LPoint4f >*)from_this;
          return (SimpleQueryLerpFunctor< LPoint4f >*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (SimpleQueryLerpFunctor< LPoint4f >*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (SimpleQueryLerpFunctor< LPoint4f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SimpleQueryLerpFunctor< LVecBase2f > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * LVecBase2f ::SimpleQueryLerpFunctor< LVecBase2f >::get_value(void)
 *******************************************************************/
static PyObject *Dtool_SimpleQueryLerpFunctor_LVecBase2f_get_value_75(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleQueryLerpFunctor< LVecBase2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleQueryLerpFunctor_LVecBase2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-LVecBase2f ::SimpleQueryLerpFunctor< LVecBase2f >::get_value(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValue", key_word_list));
        else
            (PyArg_Parse(args, ":getValue"));
        if(!PyErr_Occurred())
        {
            LVecBase2f result = (local_this)->get_value();
            LVecBase2f *return_value = new LVecBase2f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase2f,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SimpleQueryLerpFunctor.getValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValue(non-const SimpleQueryLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleQueryLerpFunctor_LVecBase2f_get_value_75_comment =
    "C++ Interface:\n"
    "getValue(non-const SimpleQueryLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleQueryLerpFunctor_LVecBase2f_get_value_75_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ::SimpleQueryLerpFunctor< LVecBase2f >::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SimpleQueryLerpFunctor_LVecBase2f_get_class_type_76(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ::SimpleQueryLerpFunctor< LVecBase2f >::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ::SimpleQueryLerpFunctor< LVecBase2f >::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleQueryLerpFunctor_LVecBase2f_get_class_type_76_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleQueryLerpFunctor_LVecBase2f_get_class_type_76_comment = NULL;
#endif

int  Dtool_Init_SimpleQueryLerpFunctor_LVecBase2f(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (SimpleQueryLerpFunctor< LVecBase2f >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_SimpleQueryLerpFunctor_LVecBase2f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SimpleQueryLerpFunctor_LVecBase2f)
    {
        printf("SimpleQueryLerpFunctor_LVecBase2f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SimpleQueryLerpFunctor< LVecBase2f > * local_this = (SimpleQueryLerpFunctor< LVecBase2f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SimpleQueryLerpFunctor_LVecBase2f)
        return local_this;
    if(requested_type == &Dtool_LerpFunctor)
        return ( LerpFunctor *)( SimpleLerpFunctor< LVecBase2f > *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< LVecBase2f > *) local_this;
    if(requested_type == &Dtool_SimpleLerpFunctor_LVecBase2f)
        return ( SimpleLerpFunctor< LVecBase2f > *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< LVecBase2f > *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< LVecBase2f > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SimpleQueryLerpFunctor_LVecBase2f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SimpleQueryLerpFunctor_LVecBase2f)
        return from_this;
    if(from_type == &Dtool_LerpFunctor)
    {
          LerpFunctor* other_this = (LerpFunctor*)from_this;
          return (SimpleQueryLerpFunctor< LVecBase2f >*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (SimpleQueryLerpFunctor< LVecBase2f >*)other_this;
    }
    if(from_type == &Dtool_SimpleLerpFunctor_LVecBase2f)
    {
          SimpleLerpFunctor< LVecBase2f >* other_this = (SimpleLerpFunctor< LVecBase2f >*)from_this;
          return (SimpleQueryLerpFunctor< LVecBase2f >*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (SimpleQueryLerpFunctor< LVecBase2f >*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (SimpleQueryLerpFunctor< LVecBase2f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SimpleQueryLerpFunctor< LVecBase3f > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * LVecBase3f ::SimpleQueryLerpFunctor< LVecBase3f >::get_value(void)
 *******************************************************************/
static PyObject *Dtool_SimpleQueryLerpFunctor_LVecBase3f_get_value_78(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleQueryLerpFunctor< LVecBase3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleQueryLerpFunctor_LVecBase3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-LVecBase3f ::SimpleQueryLerpFunctor< LVecBase3f >::get_value(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValue", key_word_list));
        else
            (PyArg_Parse(args, ":getValue"));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = (local_this)->get_value();
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SimpleQueryLerpFunctor.getValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValue(non-const SimpleQueryLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleQueryLerpFunctor_LVecBase3f_get_value_78_comment =
    "C++ Interface:\n"
    "getValue(non-const SimpleQueryLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleQueryLerpFunctor_LVecBase3f_get_value_78_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ::SimpleQueryLerpFunctor< LVecBase3f >::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SimpleQueryLerpFunctor_LVecBase3f_get_class_type_79(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ::SimpleQueryLerpFunctor< LVecBase3f >::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ::SimpleQueryLerpFunctor< LVecBase3f >::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleQueryLerpFunctor_LVecBase3f_get_class_type_79_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleQueryLerpFunctor_LVecBase3f_get_class_type_79_comment = NULL;
#endif

int  Dtool_Init_SimpleQueryLerpFunctor_LVecBase3f(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (SimpleQueryLerpFunctor< LVecBase3f >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_SimpleQueryLerpFunctor_LVecBase3f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SimpleQueryLerpFunctor_LVecBase3f)
    {
        printf("SimpleQueryLerpFunctor_LVecBase3f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SimpleQueryLerpFunctor< LVecBase3f > * local_this = (SimpleQueryLerpFunctor< LVecBase3f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SimpleQueryLerpFunctor_LVecBase3f)
        return local_this;
    if(requested_type == &Dtool_LerpFunctor)
        return ( LerpFunctor *)( SimpleLerpFunctor< LVecBase3f > *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< LVecBase3f > *) local_this;
    if(requested_type == &Dtool_SimpleLerpFunctor_LVecBase3f)
        return ( SimpleLerpFunctor< LVecBase3f > *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< LVecBase3f > *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< LVecBase3f > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SimpleQueryLerpFunctor_LVecBase3f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SimpleQueryLerpFunctor_LVecBase3f)
        return from_this;
    if(from_type == &Dtool_LerpFunctor)
    {
          LerpFunctor* other_this = (LerpFunctor*)from_this;
          return (SimpleQueryLerpFunctor< LVecBase3f >*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (SimpleQueryLerpFunctor< LVecBase3f >*)other_this;
    }
    if(from_type == &Dtool_SimpleLerpFunctor_LVecBase3f)
    {
          SimpleLerpFunctor< LVecBase3f >* other_this = (SimpleLerpFunctor< LVecBase3f >*)from_this;
          return (SimpleQueryLerpFunctor< LVecBase3f >*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (SimpleQueryLerpFunctor< LVecBase3f >*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (SimpleQueryLerpFunctor< LVecBase3f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SimpleQueryLerpFunctor< LVecBase4f > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * LVecBase4f ::SimpleQueryLerpFunctor< LVecBase4f >::get_value(void)
 *******************************************************************/
static PyObject *Dtool_SimpleQueryLerpFunctor_LVecBase4f_get_value_81(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleQueryLerpFunctor< LVecBase4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleQueryLerpFunctor_LVecBase4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-LVecBase4f ::SimpleQueryLerpFunctor< LVecBase4f >::get_value(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValue", key_word_list));
        else
            (PyArg_Parse(args, ":getValue"));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = (local_this)->get_value();
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SimpleQueryLerpFunctor.getValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValue(non-const SimpleQueryLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleQueryLerpFunctor_LVecBase4f_get_value_81_comment =
    "C++ Interface:\n"
    "getValue(non-const SimpleQueryLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleQueryLerpFunctor_LVecBase4f_get_value_81_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ::SimpleQueryLerpFunctor< LVecBase4f >::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SimpleQueryLerpFunctor_LVecBase4f_get_class_type_82(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ::SimpleQueryLerpFunctor< LVecBase4f >::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ::SimpleQueryLerpFunctor< LVecBase4f >::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleQueryLerpFunctor_LVecBase4f_get_class_type_82_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleQueryLerpFunctor_LVecBase4f_get_class_type_82_comment = NULL;
#endif

int  Dtool_Init_SimpleQueryLerpFunctor_LVecBase4f(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (SimpleQueryLerpFunctor< LVecBase4f >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_SimpleQueryLerpFunctor_LVecBase4f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SimpleQueryLerpFunctor_LVecBase4f)
    {
        printf("SimpleQueryLerpFunctor_LVecBase4f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SimpleQueryLerpFunctor< LVecBase4f > * local_this = (SimpleQueryLerpFunctor< LVecBase4f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SimpleQueryLerpFunctor_LVecBase4f)
        return local_this;
    if(requested_type == &Dtool_LerpFunctor)
        return ( LerpFunctor *)( SimpleLerpFunctor< LVecBase4f > *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< LVecBase4f > *) local_this;
    if(requested_type == &Dtool_SimpleLerpFunctor_LVecBase4f)
        return ( SimpleLerpFunctor< LVecBase4f > *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< LVecBase4f > *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< LVecBase4f > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SimpleQueryLerpFunctor_LVecBase4f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SimpleQueryLerpFunctor_LVecBase4f)
        return from_this;
    if(from_type == &Dtool_LerpFunctor)
    {
          LerpFunctor* other_this = (LerpFunctor*)from_this;
          return (SimpleQueryLerpFunctor< LVecBase4f >*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (SimpleQueryLerpFunctor< LVecBase4f >*)other_this;
    }
    if(from_type == &Dtool_SimpleLerpFunctor_LVecBase4f)
    {
          SimpleLerpFunctor< LVecBase4f >* other_this = (SimpleLerpFunctor< LVecBase4f >*)from_this;
          return (SimpleQueryLerpFunctor< LVecBase4f >*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (SimpleQueryLerpFunctor< LVecBase4f >*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (SimpleQueryLerpFunctor< LVecBase4f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SimpleQueryLerpFunctor< LVector2f > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * LVector2f ::SimpleQueryLerpFunctor< LVector2f >::get_value(void)
 *******************************************************************/
static PyObject *Dtool_SimpleQueryLerpFunctor_LVector2f_get_value_84(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleQueryLerpFunctor< LVector2f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleQueryLerpFunctor_LVector2f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-LVector2f ::SimpleQueryLerpFunctor< LVector2f >::get_value(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValue", key_word_list));
        else
            (PyArg_Parse(args, ":getValue"));
        if(!PyErr_Occurred())
        {
            LVector2f result = (local_this)->get_value();
            LVector2f *return_value = new LVector2f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector2f,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SimpleQueryLerpFunctor.getValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValue(non-const SimpleQueryLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleQueryLerpFunctor_LVector2f_get_value_84_comment =
    "C++ Interface:\n"
    "getValue(non-const SimpleQueryLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleQueryLerpFunctor_LVector2f_get_value_84_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ::SimpleQueryLerpFunctor< LVector2f >::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SimpleQueryLerpFunctor_LVector2f_get_class_type_85(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ::SimpleQueryLerpFunctor< LVector2f >::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ::SimpleQueryLerpFunctor< LVector2f >::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleQueryLerpFunctor_LVector2f_get_class_type_85_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleQueryLerpFunctor_LVector2f_get_class_type_85_comment = NULL;
#endif

int  Dtool_Init_SimpleQueryLerpFunctor_LVector2f(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (SimpleQueryLerpFunctor< LVector2f >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_SimpleQueryLerpFunctor_LVector2f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SimpleQueryLerpFunctor_LVector2f)
    {
        printf("SimpleQueryLerpFunctor_LVector2f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SimpleQueryLerpFunctor< LVector2f > * local_this = (SimpleQueryLerpFunctor< LVector2f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SimpleQueryLerpFunctor_LVector2f)
        return local_this;
    if(requested_type == &Dtool_LerpFunctor)
        return ( LerpFunctor *)( SimpleLerpFunctor< LVector2f > *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< LVector2f > *) local_this;
    if(requested_type == &Dtool_SimpleLerpFunctor_LVector2f)
        return ( SimpleLerpFunctor< LVector2f > *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< LVector2f > *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< LVector2f > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SimpleQueryLerpFunctor_LVector2f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SimpleQueryLerpFunctor_LVector2f)
        return from_this;
    if(from_type == &Dtool_LerpFunctor)
    {
          LerpFunctor* other_this = (LerpFunctor*)from_this;
          return (SimpleQueryLerpFunctor< LVector2f >*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (SimpleQueryLerpFunctor< LVector2f >*)other_this;
    }
    if(from_type == &Dtool_SimpleLerpFunctor_LVector2f)
    {
          SimpleLerpFunctor< LVector2f >* other_this = (SimpleLerpFunctor< LVector2f >*)from_this;
          return (SimpleQueryLerpFunctor< LVector2f >*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (SimpleQueryLerpFunctor< LVector2f >*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (SimpleQueryLerpFunctor< LVector2f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SimpleQueryLerpFunctor< LVector3f > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * LVector3f ::SimpleQueryLerpFunctor< LVector3f >::get_value(void)
 *******************************************************************/
static PyObject *Dtool_SimpleQueryLerpFunctor_LVector3f_get_value_87(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleQueryLerpFunctor< LVector3f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleQueryLerpFunctor_LVector3f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-LVector3f ::SimpleQueryLerpFunctor< LVector3f >::get_value(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValue", key_word_list));
        else
            (PyArg_Parse(args, ":getValue"));
        if(!PyErr_Occurred())
        {
            LVector3f result = (local_this)->get_value();
            LVector3f *return_value = new LVector3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SimpleQueryLerpFunctor.getValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValue(non-const SimpleQueryLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleQueryLerpFunctor_LVector3f_get_value_87_comment =
    "C++ Interface:\n"
    "getValue(non-const SimpleQueryLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleQueryLerpFunctor_LVector3f_get_value_87_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ::SimpleQueryLerpFunctor< LVector3f >::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SimpleQueryLerpFunctor_LVector3f_get_class_type_88(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ::SimpleQueryLerpFunctor< LVector3f >::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ::SimpleQueryLerpFunctor< LVector3f >::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleQueryLerpFunctor_LVector3f_get_class_type_88_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleQueryLerpFunctor_LVector3f_get_class_type_88_comment = NULL;
#endif

int  Dtool_Init_SimpleQueryLerpFunctor_LVector3f(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (SimpleQueryLerpFunctor< LVector3f >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_SimpleQueryLerpFunctor_LVector3f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SimpleQueryLerpFunctor_LVector3f)
    {
        printf("SimpleQueryLerpFunctor_LVector3f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SimpleQueryLerpFunctor< LVector3f > * local_this = (SimpleQueryLerpFunctor< LVector3f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SimpleQueryLerpFunctor_LVector3f)
        return local_this;
    if(requested_type == &Dtool_LerpFunctor)
        return ( LerpFunctor *)( SimpleLerpFunctor< LVector3f > *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< LVector3f > *) local_this;
    if(requested_type == &Dtool_SimpleLerpFunctor_LVector3f)
        return ( SimpleLerpFunctor< LVector3f > *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< LVector3f > *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< LVector3f > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SimpleQueryLerpFunctor_LVector3f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SimpleQueryLerpFunctor_LVector3f)
        return from_this;
    if(from_type == &Dtool_LerpFunctor)
    {
          LerpFunctor* other_this = (LerpFunctor*)from_this;
          return (SimpleQueryLerpFunctor< LVector3f >*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (SimpleQueryLerpFunctor< LVector3f >*)other_this;
    }
    if(from_type == &Dtool_SimpleLerpFunctor_LVector3f)
    {
          SimpleLerpFunctor< LVector3f >* other_this = (SimpleLerpFunctor< LVector3f >*)from_this;
          return (SimpleQueryLerpFunctor< LVector3f >*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (SimpleQueryLerpFunctor< LVector3f >*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (SimpleQueryLerpFunctor< LVector3f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. SimpleQueryLerpFunctor< LVector4f > 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * LVector4f ::SimpleQueryLerpFunctor< LVector4f >::get_value(void)
 *******************************************************************/
static PyObject *Dtool_SimpleQueryLerpFunctor_LVector4f_get_value_90(PyObject *self, PyObject *args,PyObject *kwds) {
    SimpleQueryLerpFunctor< LVector4f > * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_SimpleQueryLerpFunctor_LVector4f,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-LVector4f ::SimpleQueryLerpFunctor< LVector4f >::get_value(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getValue", key_word_list));
        else
            (PyArg_Parse(args, ":getValue"));
        if(!PyErr_Occurred())
        {
            LVector4f result = (local_this)->get_value();
            LVector4f *return_value = new LVector4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector4f,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call SimpleQueryLerpFunctor.getValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValue(non-const SimpleQueryLerpFunctor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleQueryLerpFunctor_LVector4f_get_value_90_comment =
    "C++ Interface:\n"
    "getValue(non-const SimpleQueryLerpFunctor this)\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleQueryLerpFunctor_LVector4f_get_value_90_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ::SimpleQueryLerpFunctor< LVector4f >::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_SimpleQueryLerpFunctor_LVector4f_get_class_type_91(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ::SimpleQueryLerpFunctor< LVector4f >::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ::SimpleQueryLerpFunctor< LVector4f >::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_SimpleQueryLerpFunctor_LVector4f_get_class_type_91_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_SimpleQueryLerpFunctor_LVector4f_get_class_type_91_comment = NULL;
#endif

int  Dtool_Init_SimpleQueryLerpFunctor_LVector4f(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (SimpleQueryLerpFunctor< LVector4f >)");
       return -1;
}
inline void  * Dtool_UpcastInterface_SimpleQueryLerpFunctor_LVector4f(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_SimpleQueryLerpFunctor_LVector4f)
    {
        printf("SimpleQueryLerpFunctor_LVector4f ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    SimpleQueryLerpFunctor< LVector4f > * local_this = (SimpleQueryLerpFunctor< LVector4f > *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_SimpleQueryLerpFunctor_LVector4f)
        return local_this;
    if(requested_type == &Dtool_LerpFunctor)
        return ( LerpFunctor *)( SimpleLerpFunctor< LVector4f > *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< LVector4f > *) local_this;
    if(requested_type == &Dtool_SimpleLerpFunctor_LVector4f)
        return ( SimpleLerpFunctor< LVector4f > *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< LVector4f > *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( LerpFunctor *)( SimpleLerpFunctor< LVector4f > *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_SimpleQueryLerpFunctor_LVector4f(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_SimpleQueryLerpFunctor_LVector4f)
        return from_this;
    if(from_type == &Dtool_LerpFunctor)
    {
          LerpFunctor* other_this = (LerpFunctor*)from_this;
          return (SimpleQueryLerpFunctor< LVector4f >*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (SimpleQueryLerpFunctor< LVector4f >*)other_this;
    }
    if(from_type == &Dtool_SimpleLerpFunctor_LVector4f)
    {
          SimpleLerpFunctor< LVector4f >* other_this = (SimpleLerpFunctor< LVector4f >*)from_this;
          return (SimpleQueryLerpFunctor< LVector4f >*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (SimpleQueryLerpFunctor< LVector4f >*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (SimpleQueryLerpFunctor< LVector4f >*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. MultiLerpFunctor 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle MultiLerpFunctor::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_MultiLerpFunctor_get_class_type_93(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle MultiLerpFunctor::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = MultiLerpFunctor::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_MultiLerpFunctor_get_class_type_93_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_MultiLerpFunctor_get_class_type_93_comment = NULL;
#endif

int  Dtool_Init_MultiLerpFunctor(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (MultiLerpFunctor)");
       return -1;
}
inline void  * Dtool_UpcastInterface_MultiLerpFunctor(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_MultiLerpFunctor)
    {
        printf("MultiLerpFunctor ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    MultiLerpFunctor * local_this = (MultiLerpFunctor *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_MultiLerpFunctor)
        return local_this;
    if(requested_type == &Dtool_LerpFunctor)
        return ( LerpFunctor *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( LerpFunctor *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( LerpFunctor *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( LerpFunctor *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_MultiLerpFunctor(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_MultiLerpFunctor)
        return from_this;
    if(from_type == &Dtool_LerpFunctor)
    {
          LerpFunctor* other_this = (LerpFunctor*)from_this;
          return (MultiLerpFunctor*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (MultiLerpFunctor*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (MultiLerpFunctor*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (MultiLerpFunctor*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. LerpBlendType 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual float LerpBlendType::operator ()(float ) = 0
 *******************************************************************/
static PyObject *Dtool_LerpBlendType_operator_95(PyObject *self, PyObject *args,PyObject *kwds) {
    LerpBlendType * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LerpBlendType,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual float LerpBlendType::operator ()(float ) = 0
        double param1;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:__call__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:__call__", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = (local_this)->operator ()((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LerpBlendType.__call__() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__call__(non-const LerpBlendType this, float)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LerpBlendType_operator_95_comment =
    "C++ Interface:\n"
    "__call__(non-const LerpBlendType this, float)\n"
    "\n"
    "";
#else
static const char * Dtool_LerpBlendType_operator_95_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle LerpBlendType::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_LerpBlendType_get_class_type_96(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle LerpBlendType::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = LerpBlendType::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LerpBlendType_get_class_type_96_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "// now for typehandle stuff\n"
    "";
#else
static const char * Dtool_LerpBlendType_get_class_type_96_comment = NULL;
#endif

int  Dtool_Init_LerpBlendType(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (LerpBlendType)");
       return -1;
}
inline void  * Dtool_UpcastInterface_LerpBlendType(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_LerpBlendType)
    {
        printf("LerpBlendType ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    LerpBlendType * local_this = (LerpBlendType *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_LerpBlendType)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_LerpBlendType(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_LerpBlendType)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (LerpBlendType*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (LerpBlendType*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (LerpBlendType*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. EaseInBlendType 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle EaseInBlendType::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_EaseInBlendType_get_class_type_99(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle EaseInBlendType::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = EaseInBlendType::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EaseInBlendType_get_class_type_99_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "// now for typehandle stuff\n"
    "";
#else
static const char * Dtool_EaseInBlendType_get_class_type_99_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * EaseInBlendType::EaseInBlendType(void)
 *******************************************************************/
int  Dtool_Init_EaseInBlendType(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-EaseInBlendType::EaseInBlendType(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":EaseInBlendType", key_word_list))
        {
            EaseInBlendType *return_value = new EaseInBlendType();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_EaseInBlendType,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "EaseInBlendType()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_EaseInBlendType(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_EaseInBlendType)
    {
        printf("EaseInBlendType ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    EaseInBlendType * local_this = (EaseInBlendType *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_EaseInBlendType)
        return local_this;
    if(requested_type == &Dtool_LerpBlendType)
        return ( LerpBlendType *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( LerpBlendType *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( LerpBlendType *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( LerpBlendType *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_EaseInBlendType(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_EaseInBlendType)
        return from_this;
    if(from_type == &Dtool_LerpBlendType)
    {
          LerpBlendType* other_this = (LerpBlendType*)from_this;
          return (EaseInBlendType*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (EaseInBlendType*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (EaseInBlendType*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (EaseInBlendType*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. EaseOutBlendType 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle EaseOutBlendType::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_EaseOutBlendType_get_class_type_102(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle EaseOutBlendType::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = EaseOutBlendType::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EaseOutBlendType_get_class_type_102_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "// now for typehandle stuff\n"
    "";
#else
static const char * Dtool_EaseOutBlendType_get_class_type_102_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * EaseOutBlendType::EaseOutBlendType(void)
 *******************************************************************/
int  Dtool_Init_EaseOutBlendType(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-EaseOutBlendType::EaseOutBlendType(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":EaseOutBlendType", key_word_list))
        {
            EaseOutBlendType *return_value = new EaseOutBlendType();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_EaseOutBlendType,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "EaseOutBlendType()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_EaseOutBlendType(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_EaseOutBlendType)
    {
        printf("EaseOutBlendType ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    EaseOutBlendType * local_this = (EaseOutBlendType *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_EaseOutBlendType)
        return local_this;
    if(requested_type == &Dtool_LerpBlendType)
        return ( LerpBlendType *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( LerpBlendType *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( LerpBlendType *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( LerpBlendType *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_EaseOutBlendType(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_EaseOutBlendType)
        return from_this;
    if(from_type == &Dtool_LerpBlendType)
    {
          LerpBlendType* other_this = (LerpBlendType*)from_this;
          return (EaseOutBlendType*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (EaseOutBlendType*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (EaseOutBlendType*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (EaseOutBlendType*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. EaseInOutBlendType 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle EaseInOutBlendType::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_EaseInOutBlendType_get_class_type_105(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle EaseInOutBlendType::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = EaseInOutBlendType::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_EaseInOutBlendType_get_class_type_105_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "// now for typehandle stuff\n"
    "";
#else
static const char * Dtool_EaseInOutBlendType_get_class_type_105_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * EaseInOutBlendType::EaseInOutBlendType(void)
 *******************************************************************/
int  Dtool_Init_EaseInOutBlendType(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-EaseInOutBlendType::EaseInOutBlendType(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":EaseInOutBlendType", key_word_list))
        {
            EaseInOutBlendType *return_value = new EaseInOutBlendType();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_EaseInOutBlendType,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "EaseInOutBlendType()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_EaseInOutBlendType(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_EaseInOutBlendType)
    {
        printf("EaseInOutBlendType ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    EaseInOutBlendType * local_this = (EaseInOutBlendType *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_EaseInOutBlendType)
        return local_this;
    if(requested_type == &Dtool_LerpBlendType)
        return ( LerpBlendType *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( LerpBlendType *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( LerpBlendType *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( LerpBlendType *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_EaseInOutBlendType(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_EaseInOutBlendType)
        return from_this;
    if(from_type == &Dtool_LerpBlendType)
    {
          LerpBlendType* other_this = (LerpBlendType*)from_this;
          return (EaseInOutBlendType*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (EaseInOutBlendType*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (EaseInOutBlendType*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (EaseInOutBlendType*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. NoBlendType 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle NoBlendType::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_NoBlendType_get_class_type_108(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle NoBlendType::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = NoBlendType::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_NoBlendType_get_class_type_108_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "// now for typehandle stuff\n"
    "";
#else
static const char * Dtool_NoBlendType_get_class_type_108_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NoBlendType::NoBlendType(void)
 *******************************************************************/
int  Dtool_Init_NoBlendType(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-NoBlendType::NoBlendType(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":NoBlendType", key_word_list))
        {
            NoBlendType *return_value = new NoBlendType();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_NoBlendType,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "NoBlendType()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_NoBlendType(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_NoBlendType)
    {
        printf("NoBlendType ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    NoBlendType * local_this = (NoBlendType *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_NoBlendType)
        return local_this;
    if(requested_type == &Dtool_LerpBlendType)
        return ( LerpBlendType *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( LerpBlendType *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( LerpBlendType *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( LerpBlendType *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_NoBlendType(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_NoBlendType)
        return from_this;
    if(from_type == &Dtool_LerpBlendType)
    {
          LerpBlendType* other_this = (LerpBlendType*)from_this;
          return (NoBlendType*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (NoBlendType*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (NoBlendType*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (NoBlendType*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Lerp 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * Lerp &Lerp::operator =(Lerp const &)
 *******************************************************************/
static PyObject *Dtool_Lerp_operator_111(PyObject *self, PyObject *args,PyObject *kwds) {
    Lerp * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Lerp,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-Lerp &Lerp::operator =(Lerp const &)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                Lerp *param1_this = (Lerp *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Lerp, 1, "Lerp.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    Lerp *return_value = local_this;
                    if (return_value != (Lerp *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Lerp,true, false, (return_value)->as_typed_object()->get_type_index());
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Lerp.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const Lerp this, const Lerp)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Lerp_operator_111_comment =
    "C++ Interface:\n"
    "assign(non-const Lerp this, const Lerp)\n"
    "\n"
    "";
#else
static const char * Dtool_Lerp_operator_111_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Lerp::step(void)
 *******************************************************************/
static PyObject *Dtool_Lerp_step_112(PyObject *self, PyObject *args,PyObject *kwds) {
    Lerp * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Lerp,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Lerp::step(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":step", key_word_list));
        else
            (PyArg_Parse(args, ":step"));
        if(!PyErr_Occurred())
        {
            (local_this)->step();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Lerp.step() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "step(non-const Lerp this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Lerp_step_112_comment =
    "C++ Interface:\n"
    "step(non-const Lerp this)\n"
    "\n"
    "";
#else
static const char * Dtool_Lerp_step_112_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Lerp::set_step_size(float )
 *******************************************************************/
static PyObject *Dtool_Lerp_set_step_size_113(PyObject *self, PyObject *args,PyObject *kwds) {
    Lerp * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Lerp,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Lerp::set_step_size(float )
        double param1;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setStepSize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setStepSize", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_step_size((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Lerp.setStepSize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setStepSize(non-const Lerp this, float)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Lerp_set_step_size_113_comment =
    "C++ Interface:\n"
    "setStepSize(non-const Lerp this, float)\n"
    "\n"
    "";
#else
static const char * Dtool_Lerp_set_step_size_113_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float Lerp::get_step_size(void) const
 *******************************************************************/
static PyObject *Dtool_Lerp_get_step_size_114(PyObject *self, PyObject *args,PyObject *kwds) {
    Lerp * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Lerp,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-float Lerp::get_step_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStepSize", key_word_list));
        else
            (PyArg_Parse(args, ":getStepSize"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const Lerp*)local_this)->get_step_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStepSize(const Lerp this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Lerp_get_step_size_114_comment =
    "C++ Interface:\n"
    "getStepSize(const Lerp this)\n"
    "\n"
    "";
#else
static const char * Dtool_Lerp_get_step_size_114_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Lerp::set_t(float )
 *******************************************************************/
static PyObject *Dtool_Lerp_set_t_115(PyObject *self, PyObject *args,PyObject *kwds) {
    Lerp * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Lerp,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Lerp::set_t(float )
        double param1;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setT", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setT", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_t((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Lerp.setT() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setT(non-const Lerp this, float)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Lerp_set_t_115_comment =
    "C++ Interface:\n"
    "setT(non-const Lerp this, float)\n"
    "\n"
    "";
#else
static const char * Dtool_Lerp_set_t_115_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float Lerp::get_t(void) const
 *******************************************************************/
static PyObject *Dtool_Lerp_get_t_116(PyObject *self, PyObject *args,PyObject *kwds) {
    Lerp * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Lerp,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-float Lerp::get_t(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getT", key_word_list));
        else
            (PyArg_Parse(args, ":getT"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const Lerp*)local_this)->get_t();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getT(const Lerp this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Lerp_get_t_116_comment =
    "C++ Interface:\n"
    "getT(const Lerp this)\n"
    "\n"
    "";
#else
static const char * Dtool_Lerp_get_t_116_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool Lerp::is_done(void) const
 *******************************************************************/
static PyObject *Dtool_Lerp_is_done_117(PyObject *self, PyObject *args,PyObject *kwds) {
    Lerp * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Lerp,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool Lerp::is_done(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isDone", key_word_list));
        else
            (PyArg_Parse(args, ":isDone"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const Lerp*)local_this)->is_done();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isDone(const Lerp this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Lerp_is_done_117_comment =
    "C++ Interface:\n"
    "isDone(const Lerp this)\n"
    "\n"
    "";
#else
static const char * Dtool_Lerp_is_done_117_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LerpFunctor *Lerp::get_functor(void) const
 *******************************************************************/
static PyObject *Dtool_Lerp_get_functor_118(PyObject *self, PyObject *args,PyObject *kwds) {
    Lerp * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Lerp,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-LerpFunctor *Lerp::get_functor(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFunctor", key_word_list));
        else
            (PyArg_Parse(args, ":getFunctor"));
        if(!PyErr_Occurred())
        {
            LerpFunctor *return_value = ((const Lerp*)local_this)->get_functor();
            if (return_value != (LerpFunctor *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_LerpFunctor,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFunctor(const Lerp this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Lerp_get_functor_118_comment =
    "C++ Interface:\n"
    "getFunctor(const Lerp this)\n"
    "\n"
    "";
#else
static const char * Dtool_Lerp_get_functor_118_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void Lerp::set_end_event(basic_string< char > const &)
 *******************************************************************/
static PyObject *Dtool_Lerp_set_end_event_119(PyObject *self, PyObject *args,PyObject *kwds) {
    Lerp * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Lerp,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void Lerp::set_end_event(basic_string< char > const &)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setEndEvent", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setEndEvent", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_end_event(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Lerp.setEndEvent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEndEvent(non-const Lerp this, string)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Lerp_set_end_event_119_comment =
    "C++ Interface:\n"
    "setEndEvent(non-const Lerp this, string)\n"
    "\n"
    "";
#else
static const char * Dtool_Lerp_set_end_event_119_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > Lerp::get_end_event(void) const
 *******************************************************************/
static PyObject *Dtool_Lerp_get_end_event_120(PyObject *self, PyObject *args,PyObject *kwds) {
    Lerp * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Lerp,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > Lerp::get_end_event(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEndEvent", key_word_list));
        else
            (PyArg_Parse(args, ":getEndEvent"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const Lerp*)local_this)->get_end_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEndEvent(const Lerp this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Lerp_get_end_event_120_comment =
    "C++ Interface:\n"
    "getEndEvent(const Lerp this)\n"
    "\n"
    "";
#else
static const char * Dtool_Lerp_get_end_event_120_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle Lerp::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_Lerp_get_class_type_121(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle Lerp::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = Lerp::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Lerp_get_class_type_121_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "// now for typehandle stuff\n"
    "";
#else
static const char * Dtool_Lerp_get_class_type_121_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Lerp::Lerp(Lerp const &)
 * Lerp::Lerp(LerpFunctor *func, float endt, LerpBlendType *blend)
 * Lerp::Lerp(LerpFunctor *func, float startt, float endt, LerpBlendType *blend)
 *******************************************************************/
int  Dtool_Init_Lerp(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-Lerp::Lerp(Lerp const &)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"param0", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:Lerp", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:Lerp", &param0));
                if(!PyErr_Occurred())
                {
                    Lerp *param0_this = (Lerp *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Lerp, 0, "Lerp.Lerp", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        Lerp *return_value = new Lerp(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_Lerp,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-Lerp::Lerp(LerpFunctor *func, float endt, LerpBlendType *blend)
                PyObject *param0;
                double param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"func", (char *)"endt", (char *)"blend", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OdO:Lerp", key_word_list, &param0, &param1, &param2))
                {
                    LerpFunctor *param0_this = (LerpFunctor *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LerpFunctor, 0, "Lerp.Lerp", 0, coerced_ptr, report_errors);
LerpBlendType *param2_this = (LerpBlendType *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LerpBlendType, 2, "Lerp.Lerp", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param2_this == NULL)))
                    {
                        Lerp *return_value = new Lerp(param0_this, (float)param1, param2_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_Lerp,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-Lerp::Lerp(LerpFunctor *func, float startt, float endt, LerpBlendType *blend)
                PyObject *param0;
                double param1;
                double param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"func", (char *)"startt", (char *)"endt", (char *)"blend", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OddO:Lerp", key_word_list, &param0, &param1, &param2, &param3))
                {
                    LerpFunctor *param0_this = (LerpFunctor *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LerpFunctor, 0, "Lerp.Lerp", 0, coerced_ptr, report_errors);
LerpBlendType *param3_this = (LerpBlendType *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LerpBlendType, 3, "Lerp.Lerp", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param3_this == NULL)))
                    {
                        Lerp *return_value = new Lerp(param0_this, (float)param1, (float)param2, param3_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_Lerp,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "Lerp() takes 1, 3, or 4 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "Lerp(const Lerp)\n"
          "Lerp(non-const LerpFunctor func, float endt, non-const LerpBlendType blend)\n"
          "Lerp(non-const LerpFunctor func, float startt, float endt, non-const LerpBlendType blend)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_Lerp(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Lerp)
    {
        printf("Lerp ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Lerp * local_this = (Lerp *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Lerp)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Lerp(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Lerp)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (Lerp*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (Lerp*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (Lerp*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. AutonomousLerp 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * AutonomousLerp &AutonomousLerp::operator =(AutonomousLerp const &)
 *******************************************************************/
static PyObject *Dtool_AutonomousLerp_operator_124(PyObject *self, PyObject *args,PyObject *kwds) {
    AutonomousLerp * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AutonomousLerp,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-AutonomousLerp &AutonomousLerp::operator =(AutonomousLerp const &)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                AutonomousLerp *param1_this = (AutonomousLerp *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AutonomousLerp, 1, "AutonomousLerp.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    AutonomousLerp *return_value = local_this;
                    if (return_value != (AutonomousLerp *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_AutonomousLerp,true, false, (return_value)->as_typed_object()->get_type_index());
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AutonomousLerp.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const AutonomousLerp this, const AutonomousLerp)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AutonomousLerp_operator_124_comment =
    "C++ Interface:\n"
    "assign(non-const AutonomousLerp this, const AutonomousLerp)\n"
    "\n"
    "";
#else
static const char * Dtool_AutonomousLerp_operator_124_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AutonomousLerp::start(void)
 *******************************************************************/
static PyObject *Dtool_AutonomousLerp_start_125(PyObject *self, PyObject *args,PyObject *kwds) {
    AutonomousLerp * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AutonomousLerp,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AutonomousLerp::start(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":start", key_word_list));
        else
            (PyArg_Parse(args, ":start"));
        if(!PyErr_Occurred())
        {
            (local_this)->start();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AutonomousLerp.start() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "start(non-const AutonomousLerp this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AutonomousLerp_start_125_comment =
    "C++ Interface:\n"
    "start(non-const AutonomousLerp this)\n"
    "\n"
    "";
#else
static const char * Dtool_AutonomousLerp_start_125_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AutonomousLerp::stop(void)
 *******************************************************************/
static PyObject *Dtool_AutonomousLerp_stop_126(PyObject *self, PyObject *args,PyObject *kwds) {
    AutonomousLerp * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AutonomousLerp,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AutonomousLerp::stop(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":stop", key_word_list));
        else
            (PyArg_Parse(args, ":stop"));
        if(!PyErr_Occurred())
        {
            (local_this)->stop();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AutonomousLerp.stop() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "stop(non-const AutonomousLerp this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AutonomousLerp_stop_126_comment =
    "C++ Interface:\n"
    "stop(non-const AutonomousLerp this)\n"
    "\n"
    "";
#else
static const char * Dtool_AutonomousLerp_stop_126_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AutonomousLerp::resume(void)
 *******************************************************************/
static PyObject *Dtool_AutonomousLerp_resume_127(PyObject *self, PyObject *args,PyObject *kwds) {
    AutonomousLerp * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AutonomousLerp,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AutonomousLerp::resume(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":resume", key_word_list));
        else
            (PyArg_Parse(args, ":resume"));
        if(!PyErr_Occurred())
        {
            (local_this)->resume();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AutonomousLerp.resume() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resume(non-const AutonomousLerp this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AutonomousLerp_resume_127_comment =
    "C++ Interface:\n"
    "resume(non-const AutonomousLerp this)\n"
    "\n"
    "";
#else
static const char * Dtool_AutonomousLerp_resume_127_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool AutonomousLerp::is_done(void) const
 *******************************************************************/
static PyObject *Dtool_AutonomousLerp_is_done_128(PyObject *self, PyObject *args,PyObject *kwds) {
    AutonomousLerp * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AutonomousLerp,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool AutonomousLerp::is_done(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isDone", key_word_list));
        else
            (PyArg_Parse(args, ":isDone"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const AutonomousLerp*)local_this)->is_done();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isDone(const AutonomousLerp this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AutonomousLerp_is_done_128_comment =
    "C++ Interface:\n"
    "isDone(const AutonomousLerp this)\n"
    "\n"
    "";
#else
static const char * Dtool_AutonomousLerp_is_done_128_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LerpFunctor *AutonomousLerp::get_functor(void) const
 *******************************************************************/
static PyObject *Dtool_AutonomousLerp_get_functor_129(PyObject *self, PyObject *args,PyObject *kwds) {
    AutonomousLerp * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AutonomousLerp,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-LerpFunctor *AutonomousLerp::get_functor(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFunctor", key_word_list));
        else
            (PyArg_Parse(args, ":getFunctor"));
        if(!PyErr_Occurred())
        {
            LerpFunctor *return_value = ((const AutonomousLerp*)local_this)->get_functor();
            if (return_value != (LerpFunctor *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_LerpFunctor,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFunctor(const AutonomousLerp this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AutonomousLerp_get_functor_129_comment =
    "C++ Interface:\n"
    "getFunctor(const AutonomousLerp this)\n"
    "\n"
    "";
#else
static const char * Dtool_AutonomousLerp_get_functor_129_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AutonomousLerp::set_t(float )
 *******************************************************************/
static PyObject *Dtool_AutonomousLerp_set_t_130(PyObject *self, PyObject *args,PyObject *kwds) {
    AutonomousLerp * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AutonomousLerp,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AutonomousLerp::set_t(float )
        double param1;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setT", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setT", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_t((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AutonomousLerp.setT() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setT(non-const AutonomousLerp this, float)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AutonomousLerp_set_t_130_comment =
    "C++ Interface:\n"
    "setT(non-const AutonomousLerp this, float)\n"
    "\n"
    "";
#else
static const char * Dtool_AutonomousLerp_set_t_130_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float AutonomousLerp::get_t(void) const
 *******************************************************************/
static PyObject *Dtool_AutonomousLerp_get_t_131(PyObject *self, PyObject *args,PyObject *kwds) {
    AutonomousLerp * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AutonomousLerp,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-float AutonomousLerp::get_t(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getT", key_word_list));
        else
            (PyArg_Parse(args, ":getT"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const AutonomousLerp*)local_this)->get_t();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getT(const AutonomousLerp this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AutonomousLerp_get_t_131_comment =
    "C++ Interface:\n"
    "getT(const AutonomousLerp this)\n"
    "\n"
    "";
#else
static const char * Dtool_AutonomousLerp_get_t_131_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void AutonomousLerp::set_end_event(basic_string< char > const &)
 *******************************************************************/
static PyObject *Dtool_AutonomousLerp_set_end_event_132(PyObject *self, PyObject *args,PyObject *kwds) {
    AutonomousLerp * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AutonomousLerp,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void AutonomousLerp::set_end_event(basic_string< char > const &)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setEndEvent", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setEndEvent", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_end_event(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AutonomousLerp.setEndEvent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEndEvent(non-const AutonomousLerp this, string)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AutonomousLerp_set_end_event_132_comment =
    "C++ Interface:\n"
    "setEndEvent(non-const AutonomousLerp this, string)\n"
    "\n"
    "";
#else
static const char * Dtool_AutonomousLerp_set_end_event_132_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > AutonomousLerp::get_end_event(void) const
 *******************************************************************/
static PyObject *Dtool_AutonomousLerp_get_end_event_133(PyObject *self, PyObject *args,PyObject *kwds) {
    AutonomousLerp * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AutonomousLerp,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > AutonomousLerp::get_end_event(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEndEvent", key_word_list));
        else
            (PyArg_Parse(args, ":getEndEvent"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const AutonomousLerp*)local_this)->get_end_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEndEvent(const AutonomousLerp this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AutonomousLerp_get_end_event_133_comment =
    "C++ Interface:\n"
    "getEndEvent(const AutonomousLerp this)\n"
    "\n"
    "";
#else
static const char * Dtool_AutonomousLerp_get_end_event_133_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle AutonomousLerp::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_AutonomousLerp_get_class_type_134(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle AutonomousLerp::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = AutonomousLerp::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AutonomousLerp_get_class_type_134_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "// now for typehandle stuff\n"
    "";
#else
static const char * Dtool_AutonomousLerp_get_class_type_134_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AutonomousLerp::AutonomousLerp(AutonomousLerp const &)
 * AutonomousLerp::AutonomousLerp(LerpFunctor *func, float endt, LerpBlendType *blend, EventHandler *handler)
 * AutonomousLerp::AutonomousLerp(LerpFunctor *func, float startt, float endt, LerpBlendType *blend, EventHandler *handler)
 *******************************************************************/
int  Dtool_Init_AutonomousLerp(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-AutonomousLerp::AutonomousLerp(AutonomousLerp const &)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"param0", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:AutonomousLerp", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:AutonomousLerp", &param0));
                if(!PyErr_Occurred())
                {
                    AutonomousLerp *param0_this = (AutonomousLerp *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_AutonomousLerp, 0, "AutonomousLerp.AutonomousLerp", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        AutonomousLerp *return_value = new AutonomousLerp(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_AutonomousLerp,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-AutonomousLerp::AutonomousLerp(LerpFunctor *func, float endt, LerpBlendType *blend, EventHandler *handler)
                PyObject *param0;
                double param1;
                PyObject *param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"func", (char *)"endt", (char *)"blend", (char *)"handler", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OdOO:AutonomousLerp", key_word_list, &param0, &param1, &param2, &param3))
                {
                    LerpFunctor *param0_this = (LerpFunctor *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LerpFunctor, 0, "AutonomousLerp.AutonomousLerp", 0, coerced_ptr, report_errors);
LerpBlendType *param2_this = (LerpBlendType *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LerpBlendType, 2, "AutonomousLerp.AutonomousLerp", 0, coerced_ptr, report_errors);
EventHandler *param3_this = (EventHandler *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_EventHandler, 3, "AutonomousLerp.AutonomousLerp", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)))
                    {
                        AutonomousLerp *return_value = new AutonomousLerp(param0_this, (float)param1, param2_this, param3_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_AutonomousLerp,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(5):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-AutonomousLerp::AutonomousLerp(LerpFunctor *func, float startt, float endt, LerpBlendType *blend, EventHandler *handler)
                PyObject *param0;
                double param1;
                double param2;
                PyObject *param3;
                PyObject *param4;
                static char * key_word_list[] = {(char *)"func", (char *)"startt", (char *)"endt", (char *)"blend", (char *)"handler", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OddOO:AutonomousLerp", key_word_list, &param0, &param1, &param2, &param3, &param4))
                {
                    LerpFunctor *param0_this = (LerpFunctor *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LerpFunctor, 0, "AutonomousLerp.AutonomousLerp", 0, coerced_ptr, report_errors);
LerpBlendType *param3_this = (LerpBlendType *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LerpBlendType, 3, "AutonomousLerp.AutonomousLerp", 0, coerced_ptr, report_errors);
EventHandler *param4_this = (EventHandler *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_EventHandler, 4, "AutonomousLerp.AutonomousLerp", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param3_this == NULL)|| (param4_this == NULL)))
                    {
                        AutonomousLerp *return_value = new AutonomousLerp(param0_this, (float)param1, (float)param2, param3_this, param4_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_AutonomousLerp,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "AutonomousLerp() takes 1, 4, or 5 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "AutonomousLerp(const AutonomousLerp)\n"
          "AutonomousLerp(non-const LerpFunctor func, float endt, non-const LerpBlendType blend, non-const EventHandler handler)\n"
          "AutonomousLerp(non-const LerpFunctor func, float startt, float endt, non-const LerpBlendType blend, non-const EventHandler handler)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_AutonomousLerp(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_AutonomousLerp)
    {
        printf("AutonomousLerp ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    AutonomousLerp * local_this = (AutonomousLerp *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_AutonomousLerp)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_AutonomousLerp(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_AutonomousLerp)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (AutonomousLerp*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (AutonomousLerp*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (AutonomousLerp*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. LerpFunctor | LerpFunctor
//********************************************************************
PyMethodDef Dtool_Methods_LerpFunctor[]= {
  { "getClassType",(PyCFunction ) &Dtool_LerpFunctor_get_class_type_3, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LerpFunctor_get_class_type_3_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_LerpFunctor(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_LerpFunctor.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_LerpFunctor.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_LerpFunctor.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_LerpFunctor.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_LerpFunctor.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(LerpFunctor)");
             printf(" Error In PyType_ReadyLerpFunctor");
             return;
        }
        Py_INCREF(&Dtool_LerpFunctor.As_PyTypeObject());
        PyDict_SetItemString(Dtool_LerpFunctor.As_PyTypeObject().tp_dict,"LerpFunctor",&Dtool_LerpFunctor.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_LerpFunctor.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_LerpFunctor[0],&Dtool_LerpFunctor.As_PyObject()));
        RegisterRuntimeClass(&Dtool_LerpFunctor,LerpFunctor::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_LerpFunctor.As_PyTypeObject());
        PyModule_AddObject(module, "LerpFunctor",(PyObject *)&Dtool_LerpFunctor.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SimpleLerpFunctor_int | IntLerpFunctor
//********************************************************************
PyMethodDef Dtool_Methods_SimpleLerpFunctor_int[]= {
  { "interpolate",(PyCFunction ) &Dtool_SimpleLerpFunctor_int_interpolate_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_int_interpolate_5_comment},
  { "getStart",(PyCFunction ) &Dtool_SimpleLerpFunctor_int_get_start_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_int_get_start_6_comment},
  { "getEnd",(PyCFunction ) &Dtool_SimpleLerpFunctor_int_get_end_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_int_get_end_7_comment},
  { "getClassType",(PyCFunction ) &Dtool_SimpleLerpFunctor_int_get_class_type_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_int_get_class_type_8_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SimpleLerpFunctor_int(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_LerpFunctor._Dtool_ClassInit(NULL);
        Dtool_SimpleLerpFunctor_int.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LerpFunctor.As_PyTypeObject());
        Dtool_SimpleLerpFunctor_int.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_int.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SimpleLerpFunctor_int.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SimpleLerpFunctor_int.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SimpleLerpFunctor_int)");
             printf(" Error In PyType_ReadySimpleLerpFunctor_int");
             return;
        }
        Py_INCREF(&Dtool_SimpleLerpFunctor_int.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_int.As_PyTypeObject().tp_dict,"IntLerpFunctor",&Dtool_SimpleLerpFunctor_int.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_int.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_SimpleLerpFunctor_int[3],&Dtool_SimpleLerpFunctor_int.As_PyObject()));
        RegisterRuntimeClass(&Dtool_SimpleLerpFunctor_int,SimpleLerpFunctor< int >::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SimpleLerpFunctor_int.As_PyTypeObject());
        PyModule_AddObject(module, "IntLerpFunctor",(PyObject *)&Dtool_SimpleLerpFunctor_int.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SimpleLerpFunctor_float | FloatLerpFunctor
//********************************************************************
PyMethodDef Dtool_Methods_SimpleLerpFunctor_float[]= {
  { "interpolate",(PyCFunction ) &Dtool_SimpleLerpFunctor_float_interpolate_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_float_interpolate_10_comment},
  { "getStart",(PyCFunction ) &Dtool_SimpleLerpFunctor_float_get_start_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_float_get_start_11_comment},
  { "getEnd",(PyCFunction ) &Dtool_SimpleLerpFunctor_float_get_end_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_float_get_end_12_comment},
  { "getClassType",(PyCFunction ) &Dtool_SimpleLerpFunctor_float_get_class_type_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_float_get_class_type_13_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SimpleLerpFunctor_float(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_LerpFunctor._Dtool_ClassInit(NULL);
        Dtool_SimpleLerpFunctor_float.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LerpFunctor.As_PyTypeObject());
        Dtool_SimpleLerpFunctor_float.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_float.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SimpleLerpFunctor_float.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SimpleLerpFunctor_float.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SimpleLerpFunctor_float)");
             printf(" Error In PyType_ReadySimpleLerpFunctor_float");
             return;
        }
        Py_INCREF(&Dtool_SimpleLerpFunctor_float.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_float.As_PyTypeObject().tp_dict,"FloatLerpFunctor",&Dtool_SimpleLerpFunctor_float.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_float.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_SimpleLerpFunctor_float[3],&Dtool_SimpleLerpFunctor_float.As_PyObject()));
        RegisterRuntimeClass(&Dtool_SimpleLerpFunctor_float,SimpleLerpFunctor< float >::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SimpleLerpFunctor_float.As_PyTypeObject());
        PyModule_AddObject(module, "FloatLerpFunctor",(PyObject *)&Dtool_SimpleLerpFunctor_float.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SimpleLerpFunctor_LPoint2f | SimpleLerpFunctorLPoint2f
//********************************************************************
PyMethodDef Dtool_Methods_SimpleLerpFunctor_LPoint2f[]= {
  { "interpolate",(PyCFunction ) &Dtool_SimpleLerpFunctor_LPoint2f_interpolate_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LPoint2f_interpolate_15_comment},
  { "getStart",(PyCFunction ) &Dtool_SimpleLerpFunctor_LPoint2f_get_start_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LPoint2f_get_start_16_comment},
  { "getEnd",(PyCFunction ) &Dtool_SimpleLerpFunctor_LPoint2f_get_end_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LPoint2f_get_end_17_comment},
  { "getClassType",(PyCFunction ) &Dtool_SimpleLerpFunctor_LPoint2f_get_class_type_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LPoint2f_get_class_type_18_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SimpleLerpFunctor_LPoint2f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_LerpFunctor._Dtool_ClassInit(NULL);
        Dtool_SimpleLerpFunctor_LPoint2f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LerpFunctor.As_PyTypeObject());
        Dtool_SimpleLerpFunctor_LPoint2f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_LPoint2f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SimpleLerpFunctor_LPoint2f.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SimpleLerpFunctor_LPoint2f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SimpleLerpFunctor_LPoint2f)");
             printf(" Error In PyType_ReadySimpleLerpFunctor_LPoint2f");
             return;
        }
        Py_INCREF(&Dtool_SimpleLerpFunctor_LPoint2f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_LPoint2f.As_PyTypeObject().tp_dict,"SimpleLerpFunctorLPoint2f",&Dtool_SimpleLerpFunctor_LPoint2f.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_LPoint2f.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_SimpleLerpFunctor_LPoint2f[3],&Dtool_SimpleLerpFunctor_LPoint2f.As_PyObject()));
        RegisterRuntimeClass(&Dtool_SimpleLerpFunctor_LPoint2f,SimpleLerpFunctor< LPoint2f >::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SimpleLerpFunctor_LPoint2f.As_PyTypeObject());
        PyModule_AddObject(module, "SimpleLerpFunctorLPoint2f",(PyObject *)&Dtool_SimpleLerpFunctor_LPoint2f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SimpleLerpFunctor_LPoint3f | SimpleLerpFunctorLPoint3f
//********************************************************************
PyMethodDef Dtool_Methods_SimpleLerpFunctor_LPoint3f[]= {
  { "interpolate",(PyCFunction ) &Dtool_SimpleLerpFunctor_LPoint3f_interpolate_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LPoint3f_interpolate_20_comment},
  { "getStart",(PyCFunction ) &Dtool_SimpleLerpFunctor_LPoint3f_get_start_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LPoint3f_get_start_21_comment},
  { "getEnd",(PyCFunction ) &Dtool_SimpleLerpFunctor_LPoint3f_get_end_22, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LPoint3f_get_end_22_comment},
  { "getClassType",(PyCFunction ) &Dtool_SimpleLerpFunctor_LPoint3f_get_class_type_23, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LPoint3f_get_class_type_23_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SimpleLerpFunctor_LPoint3f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_LerpFunctor._Dtool_ClassInit(NULL);
        Dtool_SimpleLerpFunctor_LPoint3f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LerpFunctor.As_PyTypeObject());
        Dtool_SimpleLerpFunctor_LPoint3f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_LPoint3f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SimpleLerpFunctor_LPoint3f.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SimpleLerpFunctor_LPoint3f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SimpleLerpFunctor_LPoint3f)");
             printf(" Error In PyType_ReadySimpleLerpFunctor_LPoint3f");
             return;
        }
        Py_INCREF(&Dtool_SimpleLerpFunctor_LPoint3f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_LPoint3f.As_PyTypeObject().tp_dict,"SimpleLerpFunctorLPoint3f",&Dtool_SimpleLerpFunctor_LPoint3f.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_LPoint3f.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_SimpleLerpFunctor_LPoint3f[3],&Dtool_SimpleLerpFunctor_LPoint3f.As_PyObject()));
        RegisterRuntimeClass(&Dtool_SimpleLerpFunctor_LPoint3f,SimpleLerpFunctor< LPoint3f >::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SimpleLerpFunctor_LPoint3f.As_PyTypeObject());
        PyModule_AddObject(module, "SimpleLerpFunctorLPoint3f",(PyObject *)&Dtool_SimpleLerpFunctor_LPoint3f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SimpleLerpFunctor_LPoint4f | SimpleLerpFunctorLPoint4f
//********************************************************************
PyMethodDef Dtool_Methods_SimpleLerpFunctor_LPoint4f[]= {
  { "interpolate",(PyCFunction ) &Dtool_SimpleLerpFunctor_LPoint4f_interpolate_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LPoint4f_interpolate_25_comment},
  { "getStart",(PyCFunction ) &Dtool_SimpleLerpFunctor_LPoint4f_get_start_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LPoint4f_get_start_26_comment},
  { "getEnd",(PyCFunction ) &Dtool_SimpleLerpFunctor_LPoint4f_get_end_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LPoint4f_get_end_27_comment},
  { "getClassType",(PyCFunction ) &Dtool_SimpleLerpFunctor_LPoint4f_get_class_type_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LPoint4f_get_class_type_28_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SimpleLerpFunctor_LPoint4f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_LerpFunctor._Dtool_ClassInit(NULL);
        Dtool_SimpleLerpFunctor_LPoint4f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LerpFunctor.As_PyTypeObject());
        Dtool_SimpleLerpFunctor_LPoint4f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_LPoint4f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SimpleLerpFunctor_LPoint4f.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SimpleLerpFunctor_LPoint4f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SimpleLerpFunctor_LPoint4f)");
             printf(" Error In PyType_ReadySimpleLerpFunctor_LPoint4f");
             return;
        }
        Py_INCREF(&Dtool_SimpleLerpFunctor_LPoint4f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_LPoint4f.As_PyTypeObject().tp_dict,"SimpleLerpFunctorLPoint4f",&Dtool_SimpleLerpFunctor_LPoint4f.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_LPoint4f.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_SimpleLerpFunctor_LPoint4f[3],&Dtool_SimpleLerpFunctor_LPoint4f.As_PyObject()));
        RegisterRuntimeClass(&Dtool_SimpleLerpFunctor_LPoint4f,SimpleLerpFunctor< LPoint4f >::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SimpleLerpFunctor_LPoint4f.As_PyTypeObject());
        PyModule_AddObject(module, "SimpleLerpFunctorLPoint4f",(PyObject *)&Dtool_SimpleLerpFunctor_LPoint4f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SimpleLerpFunctor_LVecBase2f | SimpleLerpFunctorLVecBase2f
//********************************************************************
PyMethodDef Dtool_Methods_SimpleLerpFunctor_LVecBase2f[]= {
  { "interpolate",(PyCFunction ) &Dtool_SimpleLerpFunctor_LVecBase2f_interpolate_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LVecBase2f_interpolate_30_comment},
  { "getStart",(PyCFunction ) &Dtool_SimpleLerpFunctor_LVecBase2f_get_start_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LVecBase2f_get_start_31_comment},
  { "getEnd",(PyCFunction ) &Dtool_SimpleLerpFunctor_LVecBase2f_get_end_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LVecBase2f_get_end_32_comment},
  { "getClassType",(PyCFunction ) &Dtool_SimpleLerpFunctor_LVecBase2f_get_class_type_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LVecBase2f_get_class_type_33_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SimpleLerpFunctor_LVecBase2f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_LerpFunctor._Dtool_ClassInit(NULL);
        Dtool_SimpleLerpFunctor_LVecBase2f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LerpFunctor.As_PyTypeObject());
        Dtool_SimpleLerpFunctor_LVecBase2f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_LVecBase2f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SimpleLerpFunctor_LVecBase2f.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SimpleLerpFunctor_LVecBase2f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SimpleLerpFunctor_LVecBase2f)");
             printf(" Error In PyType_ReadySimpleLerpFunctor_LVecBase2f");
             return;
        }
        Py_INCREF(&Dtool_SimpleLerpFunctor_LVecBase2f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_LVecBase2f.As_PyTypeObject().tp_dict,"SimpleLerpFunctorLVecBase2f",&Dtool_SimpleLerpFunctor_LVecBase2f.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_LVecBase2f.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_SimpleLerpFunctor_LVecBase2f[3],&Dtool_SimpleLerpFunctor_LVecBase2f.As_PyObject()));
        RegisterRuntimeClass(&Dtool_SimpleLerpFunctor_LVecBase2f,SimpleLerpFunctor< LVecBase2f >::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SimpleLerpFunctor_LVecBase2f.As_PyTypeObject());
        PyModule_AddObject(module, "SimpleLerpFunctorLVecBase2f",(PyObject *)&Dtool_SimpleLerpFunctor_LVecBase2f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SimpleLerpFunctor_LVecBase3f | SimpleLerpFunctorLVecBase3f
//********************************************************************
PyMethodDef Dtool_Methods_SimpleLerpFunctor_LVecBase3f[]= {
  { "interpolate",(PyCFunction ) &Dtool_SimpleLerpFunctor_LVecBase3f_interpolate_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LVecBase3f_interpolate_35_comment},
  { "getStart",(PyCFunction ) &Dtool_SimpleLerpFunctor_LVecBase3f_get_start_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LVecBase3f_get_start_36_comment},
  { "getEnd",(PyCFunction ) &Dtool_SimpleLerpFunctor_LVecBase3f_get_end_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LVecBase3f_get_end_37_comment},
  { "getClassType",(PyCFunction ) &Dtool_SimpleLerpFunctor_LVecBase3f_get_class_type_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LVecBase3f_get_class_type_38_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SimpleLerpFunctor_LVecBase3f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_LerpFunctor._Dtool_ClassInit(NULL);
        Dtool_SimpleLerpFunctor_LVecBase3f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LerpFunctor.As_PyTypeObject());
        Dtool_SimpleLerpFunctor_LVecBase3f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_LVecBase3f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SimpleLerpFunctor_LVecBase3f.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SimpleLerpFunctor_LVecBase3f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SimpleLerpFunctor_LVecBase3f)");
             printf(" Error In PyType_ReadySimpleLerpFunctor_LVecBase3f");
             return;
        }
        Py_INCREF(&Dtool_SimpleLerpFunctor_LVecBase3f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_LVecBase3f.As_PyTypeObject().tp_dict,"SimpleLerpFunctorLVecBase3f",&Dtool_SimpleLerpFunctor_LVecBase3f.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_LVecBase3f.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_SimpleLerpFunctor_LVecBase3f[3],&Dtool_SimpleLerpFunctor_LVecBase3f.As_PyObject()));
        RegisterRuntimeClass(&Dtool_SimpleLerpFunctor_LVecBase3f,SimpleLerpFunctor< LVecBase3f >::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SimpleLerpFunctor_LVecBase3f.As_PyTypeObject());
        PyModule_AddObject(module, "SimpleLerpFunctorLVecBase3f",(PyObject *)&Dtool_SimpleLerpFunctor_LVecBase3f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SimpleLerpFunctor_LVecBase4f | SimpleLerpFunctorLVecBase4f
//********************************************************************
PyMethodDef Dtool_Methods_SimpleLerpFunctor_LVecBase4f[]= {
  { "interpolate",(PyCFunction ) &Dtool_SimpleLerpFunctor_LVecBase4f_interpolate_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LVecBase4f_interpolate_40_comment},
  { "getStart",(PyCFunction ) &Dtool_SimpleLerpFunctor_LVecBase4f_get_start_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LVecBase4f_get_start_41_comment},
  { "getEnd",(PyCFunction ) &Dtool_SimpleLerpFunctor_LVecBase4f_get_end_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LVecBase4f_get_end_42_comment},
  { "getClassType",(PyCFunction ) &Dtool_SimpleLerpFunctor_LVecBase4f_get_class_type_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LVecBase4f_get_class_type_43_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SimpleLerpFunctor_LVecBase4f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_LerpFunctor._Dtool_ClassInit(NULL);
        Dtool_SimpleLerpFunctor_LVecBase4f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LerpFunctor.As_PyTypeObject());
        Dtool_SimpleLerpFunctor_LVecBase4f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_LVecBase4f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SimpleLerpFunctor_LVecBase4f.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SimpleLerpFunctor_LVecBase4f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SimpleLerpFunctor_LVecBase4f)");
             printf(" Error In PyType_ReadySimpleLerpFunctor_LVecBase4f");
             return;
        }
        Py_INCREF(&Dtool_SimpleLerpFunctor_LVecBase4f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_LVecBase4f.As_PyTypeObject().tp_dict,"SimpleLerpFunctorLVecBase4f",&Dtool_SimpleLerpFunctor_LVecBase4f.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_LVecBase4f.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_SimpleLerpFunctor_LVecBase4f[3],&Dtool_SimpleLerpFunctor_LVecBase4f.As_PyObject()));
        RegisterRuntimeClass(&Dtool_SimpleLerpFunctor_LVecBase4f,SimpleLerpFunctor< LVecBase4f >::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SimpleLerpFunctor_LVecBase4f.As_PyTypeObject());
        PyModule_AddObject(module, "SimpleLerpFunctorLVecBase4f",(PyObject *)&Dtool_SimpleLerpFunctor_LVecBase4f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SimpleLerpFunctor_LVector2f | SimpleLerpFunctorLVector2f
//********************************************************************
PyMethodDef Dtool_Methods_SimpleLerpFunctor_LVector2f[]= {
  { "interpolate",(PyCFunction ) &Dtool_SimpleLerpFunctor_LVector2f_interpolate_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LVector2f_interpolate_45_comment},
  { "getStart",(PyCFunction ) &Dtool_SimpleLerpFunctor_LVector2f_get_start_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LVector2f_get_start_46_comment},
  { "getEnd",(PyCFunction ) &Dtool_SimpleLerpFunctor_LVector2f_get_end_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LVector2f_get_end_47_comment},
  { "getClassType",(PyCFunction ) &Dtool_SimpleLerpFunctor_LVector2f_get_class_type_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LVector2f_get_class_type_48_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SimpleLerpFunctor_LVector2f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_LerpFunctor._Dtool_ClassInit(NULL);
        Dtool_SimpleLerpFunctor_LVector2f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LerpFunctor.As_PyTypeObject());
        Dtool_SimpleLerpFunctor_LVector2f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_LVector2f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SimpleLerpFunctor_LVector2f.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SimpleLerpFunctor_LVector2f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SimpleLerpFunctor_LVector2f)");
             printf(" Error In PyType_ReadySimpleLerpFunctor_LVector2f");
             return;
        }
        Py_INCREF(&Dtool_SimpleLerpFunctor_LVector2f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_LVector2f.As_PyTypeObject().tp_dict,"SimpleLerpFunctorLVector2f",&Dtool_SimpleLerpFunctor_LVector2f.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_LVector2f.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_SimpleLerpFunctor_LVector2f[3],&Dtool_SimpleLerpFunctor_LVector2f.As_PyObject()));
        RegisterRuntimeClass(&Dtool_SimpleLerpFunctor_LVector2f,SimpleLerpFunctor< LVector2f >::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SimpleLerpFunctor_LVector2f.As_PyTypeObject());
        PyModule_AddObject(module, "SimpleLerpFunctorLVector2f",(PyObject *)&Dtool_SimpleLerpFunctor_LVector2f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SimpleLerpFunctor_LVector3f | SimpleLerpFunctorLVector3f
//********************************************************************
PyMethodDef Dtool_Methods_SimpleLerpFunctor_LVector3f[]= {
  { "interpolate",(PyCFunction ) &Dtool_SimpleLerpFunctor_LVector3f_interpolate_50, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LVector3f_interpolate_50_comment},
  { "getStart",(PyCFunction ) &Dtool_SimpleLerpFunctor_LVector3f_get_start_51, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LVector3f_get_start_51_comment},
  { "getEnd",(PyCFunction ) &Dtool_SimpleLerpFunctor_LVector3f_get_end_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LVector3f_get_end_52_comment},
  { "getClassType",(PyCFunction ) &Dtool_SimpleLerpFunctor_LVector3f_get_class_type_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LVector3f_get_class_type_53_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SimpleLerpFunctor_LVector3f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_LerpFunctor._Dtool_ClassInit(NULL);
        Dtool_SimpleLerpFunctor_LVector3f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LerpFunctor.As_PyTypeObject());
        Dtool_SimpleLerpFunctor_LVector3f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_LVector3f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SimpleLerpFunctor_LVector3f.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SimpleLerpFunctor_LVector3f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SimpleLerpFunctor_LVector3f)");
             printf(" Error In PyType_ReadySimpleLerpFunctor_LVector3f");
             return;
        }
        Py_INCREF(&Dtool_SimpleLerpFunctor_LVector3f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_LVector3f.As_PyTypeObject().tp_dict,"SimpleLerpFunctorLVector3f",&Dtool_SimpleLerpFunctor_LVector3f.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_LVector3f.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_SimpleLerpFunctor_LVector3f[3],&Dtool_SimpleLerpFunctor_LVector3f.As_PyObject()));
        RegisterRuntimeClass(&Dtool_SimpleLerpFunctor_LVector3f,SimpleLerpFunctor< LVector3f >::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SimpleLerpFunctor_LVector3f.As_PyTypeObject());
        PyModule_AddObject(module, "SimpleLerpFunctorLVector3f",(PyObject *)&Dtool_SimpleLerpFunctor_LVector3f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SimpleLerpFunctor_LVector4f | SimpleLerpFunctorLVector4f
//********************************************************************
PyMethodDef Dtool_Methods_SimpleLerpFunctor_LVector4f[]= {
  { "interpolate",(PyCFunction ) &Dtool_SimpleLerpFunctor_LVector4f_interpolate_55, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LVector4f_interpolate_55_comment},
  { "getStart",(PyCFunction ) &Dtool_SimpleLerpFunctor_LVector4f_get_start_56, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LVector4f_get_start_56_comment},
  { "getEnd",(PyCFunction ) &Dtool_SimpleLerpFunctor_LVector4f_get_end_57, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LVector4f_get_end_57_comment},
  { "getClassType",(PyCFunction ) &Dtool_SimpleLerpFunctor_LVector4f_get_class_type_58, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleLerpFunctor_LVector4f_get_class_type_58_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SimpleLerpFunctor_LVector4f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_LerpFunctor._Dtool_ClassInit(NULL);
        Dtool_SimpleLerpFunctor_LVector4f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LerpFunctor.As_PyTypeObject());
        Dtool_SimpleLerpFunctor_LVector4f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_LVector4f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SimpleLerpFunctor_LVector4f.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SimpleLerpFunctor_LVector4f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SimpleLerpFunctor_LVector4f)");
             printf(" Error In PyType_ReadySimpleLerpFunctor_LVector4f");
             return;
        }
        Py_INCREF(&Dtool_SimpleLerpFunctor_LVector4f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_LVector4f.As_PyTypeObject().tp_dict,"SimpleLerpFunctorLVector4f",&Dtool_SimpleLerpFunctor_LVector4f.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_SimpleLerpFunctor_LVector4f.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_SimpleLerpFunctor_LVector4f[3],&Dtool_SimpleLerpFunctor_LVector4f.As_PyObject()));
        RegisterRuntimeClass(&Dtool_SimpleLerpFunctor_LVector4f,SimpleLerpFunctor< LVector4f >::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SimpleLerpFunctor_LVector4f.As_PyTypeObject());
        PyModule_AddObject(module, "SimpleLerpFunctorLVector4f",(PyObject *)&Dtool_SimpleLerpFunctor_LVector4f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SimpleQueryLerpFunctor_int | IntQueryLerpFunctor
//********************************************************************
PyMethodDef Dtool_Methods_SimpleQueryLerpFunctor_int[]= {
  { "getValue",(PyCFunction ) &Dtool_SimpleQueryLerpFunctor_int_get_value_60, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleQueryLerpFunctor_int_get_value_60_comment},
  { "getClassType",(PyCFunction ) &Dtool_SimpleQueryLerpFunctor_int_get_class_type_61, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleQueryLerpFunctor_int_get_class_type_61_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SimpleQueryLerpFunctor_int(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_SimpleLerpFunctor_int._Dtool_ClassInit(NULL);
        Dtool_SimpleQueryLerpFunctor_int.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_SimpleLerpFunctor_int.As_PyTypeObject());
        Dtool_SimpleQueryLerpFunctor_int.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_int.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SimpleQueryLerpFunctor_int.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SimpleQueryLerpFunctor_int.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SimpleQueryLerpFunctor_int)");
             printf(" Error In PyType_ReadySimpleQueryLerpFunctor_int");
             return;
        }
        Py_INCREF(&Dtool_SimpleQueryLerpFunctor_int.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_int.As_PyTypeObject().tp_dict,"IntQueryLerpFunctor",&Dtool_SimpleQueryLerpFunctor_int.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_int.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_SimpleQueryLerpFunctor_int[1],&Dtool_SimpleQueryLerpFunctor_int.As_PyObject()));
        RegisterRuntimeClass(&Dtool_SimpleQueryLerpFunctor_int,SimpleQueryLerpFunctor< int >::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SimpleQueryLerpFunctor_int.As_PyTypeObject());
        PyModule_AddObject(module, "IntQueryLerpFunctor",(PyObject *)&Dtool_SimpleQueryLerpFunctor_int.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SimpleQueryLerpFunctor_float | FloatQueryLerpFunctor
//********************************************************************
PyMethodDef Dtool_Methods_SimpleQueryLerpFunctor_float[]= {
  { "getValue",(PyCFunction ) &Dtool_SimpleQueryLerpFunctor_float_get_value_63, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleQueryLerpFunctor_float_get_value_63_comment},
  { "getClassType",(PyCFunction ) &Dtool_SimpleQueryLerpFunctor_float_get_class_type_64, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleQueryLerpFunctor_float_get_class_type_64_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SimpleQueryLerpFunctor_float(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_SimpleLerpFunctor_float._Dtool_ClassInit(NULL);
        Dtool_SimpleQueryLerpFunctor_float.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_SimpleLerpFunctor_float.As_PyTypeObject());
        Dtool_SimpleQueryLerpFunctor_float.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_float.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SimpleQueryLerpFunctor_float.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SimpleQueryLerpFunctor_float.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SimpleQueryLerpFunctor_float)");
             printf(" Error In PyType_ReadySimpleQueryLerpFunctor_float");
             return;
        }
        Py_INCREF(&Dtool_SimpleQueryLerpFunctor_float.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_float.As_PyTypeObject().tp_dict,"FloatQueryLerpFunctor",&Dtool_SimpleQueryLerpFunctor_float.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_float.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_SimpleQueryLerpFunctor_float[1],&Dtool_SimpleQueryLerpFunctor_float.As_PyObject()));
        RegisterRuntimeClass(&Dtool_SimpleQueryLerpFunctor_float,SimpleQueryLerpFunctor< float >::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SimpleQueryLerpFunctor_float.As_PyTypeObject());
        PyModule_AddObject(module, "FloatQueryLerpFunctor",(PyObject *)&Dtool_SimpleQueryLerpFunctor_float.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SimpleQueryLerpFunctor_LPoint2f | SimpleQueryLerpFunctorLPoint2f
//********************************************************************
PyMethodDef Dtool_Methods_SimpleQueryLerpFunctor_LPoint2f[]= {
  { "getValue",(PyCFunction ) &Dtool_SimpleQueryLerpFunctor_LPoint2f_get_value_66, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleQueryLerpFunctor_LPoint2f_get_value_66_comment},
  { "getClassType",(PyCFunction ) &Dtool_SimpleQueryLerpFunctor_LPoint2f_get_class_type_67, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleQueryLerpFunctor_LPoint2f_get_class_type_67_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SimpleQueryLerpFunctor_LPoint2f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_SimpleLerpFunctor_LPoint2f._Dtool_ClassInit(NULL);
        Dtool_SimpleQueryLerpFunctor_LPoint2f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_SimpleLerpFunctor_LPoint2f.As_PyTypeObject());
        Dtool_SimpleQueryLerpFunctor_LPoint2f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_LPoint2f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SimpleQueryLerpFunctor_LPoint2f.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SimpleQueryLerpFunctor_LPoint2f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SimpleQueryLerpFunctor_LPoint2f)");
             printf(" Error In PyType_ReadySimpleQueryLerpFunctor_LPoint2f");
             return;
        }
        Py_INCREF(&Dtool_SimpleQueryLerpFunctor_LPoint2f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_LPoint2f.As_PyTypeObject().tp_dict,"SimpleQueryLerpFunctorLPoint2f",&Dtool_SimpleQueryLerpFunctor_LPoint2f.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_LPoint2f.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_SimpleQueryLerpFunctor_LPoint2f[1],&Dtool_SimpleQueryLerpFunctor_LPoint2f.As_PyObject()));
        RegisterRuntimeClass(&Dtool_SimpleQueryLerpFunctor_LPoint2f,SimpleQueryLerpFunctor< LPoint2f >::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SimpleQueryLerpFunctor_LPoint2f.As_PyTypeObject());
        PyModule_AddObject(module, "SimpleQueryLerpFunctorLPoint2f",(PyObject *)&Dtool_SimpleQueryLerpFunctor_LPoint2f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SimpleQueryLerpFunctor_LPoint3f | SimpleQueryLerpFunctorLPoint3f
//********************************************************************
PyMethodDef Dtool_Methods_SimpleQueryLerpFunctor_LPoint3f[]= {
  { "getValue",(PyCFunction ) &Dtool_SimpleQueryLerpFunctor_LPoint3f_get_value_69, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleQueryLerpFunctor_LPoint3f_get_value_69_comment},
  { "getClassType",(PyCFunction ) &Dtool_SimpleQueryLerpFunctor_LPoint3f_get_class_type_70, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleQueryLerpFunctor_LPoint3f_get_class_type_70_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SimpleQueryLerpFunctor_LPoint3f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_SimpleLerpFunctor_LPoint3f._Dtool_ClassInit(NULL);
        Dtool_SimpleQueryLerpFunctor_LPoint3f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_SimpleLerpFunctor_LPoint3f.As_PyTypeObject());
        Dtool_SimpleQueryLerpFunctor_LPoint3f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_LPoint3f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SimpleQueryLerpFunctor_LPoint3f.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SimpleQueryLerpFunctor_LPoint3f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SimpleQueryLerpFunctor_LPoint3f)");
             printf(" Error In PyType_ReadySimpleQueryLerpFunctor_LPoint3f");
             return;
        }
        Py_INCREF(&Dtool_SimpleQueryLerpFunctor_LPoint3f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_LPoint3f.As_PyTypeObject().tp_dict,"SimpleQueryLerpFunctorLPoint3f",&Dtool_SimpleQueryLerpFunctor_LPoint3f.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_LPoint3f.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_SimpleQueryLerpFunctor_LPoint3f[1],&Dtool_SimpleQueryLerpFunctor_LPoint3f.As_PyObject()));
        RegisterRuntimeClass(&Dtool_SimpleQueryLerpFunctor_LPoint3f,SimpleQueryLerpFunctor< LPoint3f >::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SimpleQueryLerpFunctor_LPoint3f.As_PyTypeObject());
        PyModule_AddObject(module, "SimpleQueryLerpFunctorLPoint3f",(PyObject *)&Dtool_SimpleQueryLerpFunctor_LPoint3f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SimpleQueryLerpFunctor_LPoint4f | SimpleQueryLerpFunctorLPoint4f
//********************************************************************
PyMethodDef Dtool_Methods_SimpleQueryLerpFunctor_LPoint4f[]= {
  { "getValue",(PyCFunction ) &Dtool_SimpleQueryLerpFunctor_LPoint4f_get_value_72, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleQueryLerpFunctor_LPoint4f_get_value_72_comment},
  { "getClassType",(PyCFunction ) &Dtool_SimpleQueryLerpFunctor_LPoint4f_get_class_type_73, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleQueryLerpFunctor_LPoint4f_get_class_type_73_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SimpleQueryLerpFunctor_LPoint4f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_SimpleLerpFunctor_LPoint4f._Dtool_ClassInit(NULL);
        Dtool_SimpleQueryLerpFunctor_LPoint4f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_SimpleLerpFunctor_LPoint4f.As_PyTypeObject());
        Dtool_SimpleQueryLerpFunctor_LPoint4f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_LPoint4f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SimpleQueryLerpFunctor_LPoint4f.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SimpleQueryLerpFunctor_LPoint4f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SimpleQueryLerpFunctor_LPoint4f)");
             printf(" Error In PyType_ReadySimpleQueryLerpFunctor_LPoint4f");
             return;
        }
        Py_INCREF(&Dtool_SimpleQueryLerpFunctor_LPoint4f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_LPoint4f.As_PyTypeObject().tp_dict,"SimpleQueryLerpFunctorLPoint4f",&Dtool_SimpleQueryLerpFunctor_LPoint4f.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_LPoint4f.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_SimpleQueryLerpFunctor_LPoint4f[1],&Dtool_SimpleQueryLerpFunctor_LPoint4f.As_PyObject()));
        RegisterRuntimeClass(&Dtool_SimpleQueryLerpFunctor_LPoint4f,SimpleQueryLerpFunctor< LPoint4f >::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SimpleQueryLerpFunctor_LPoint4f.As_PyTypeObject());
        PyModule_AddObject(module, "SimpleQueryLerpFunctorLPoint4f",(PyObject *)&Dtool_SimpleQueryLerpFunctor_LPoint4f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SimpleQueryLerpFunctor_LVecBase2f | SimpleQueryLerpFunctorLVecBase2f
//********************************************************************
PyMethodDef Dtool_Methods_SimpleQueryLerpFunctor_LVecBase2f[]= {
  { "getValue",(PyCFunction ) &Dtool_SimpleQueryLerpFunctor_LVecBase2f_get_value_75, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleQueryLerpFunctor_LVecBase2f_get_value_75_comment},
  { "getClassType",(PyCFunction ) &Dtool_SimpleQueryLerpFunctor_LVecBase2f_get_class_type_76, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleQueryLerpFunctor_LVecBase2f_get_class_type_76_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SimpleQueryLerpFunctor_LVecBase2f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_SimpleLerpFunctor_LVecBase2f._Dtool_ClassInit(NULL);
        Dtool_SimpleQueryLerpFunctor_LVecBase2f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_SimpleLerpFunctor_LVecBase2f.As_PyTypeObject());
        Dtool_SimpleQueryLerpFunctor_LVecBase2f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_LVecBase2f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SimpleQueryLerpFunctor_LVecBase2f.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SimpleQueryLerpFunctor_LVecBase2f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SimpleQueryLerpFunctor_LVecBase2f)");
             printf(" Error In PyType_ReadySimpleQueryLerpFunctor_LVecBase2f");
             return;
        }
        Py_INCREF(&Dtool_SimpleQueryLerpFunctor_LVecBase2f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_LVecBase2f.As_PyTypeObject().tp_dict,"SimpleQueryLerpFunctorLVecBase2f",&Dtool_SimpleQueryLerpFunctor_LVecBase2f.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_LVecBase2f.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_SimpleQueryLerpFunctor_LVecBase2f[1],&Dtool_SimpleQueryLerpFunctor_LVecBase2f.As_PyObject()));
        RegisterRuntimeClass(&Dtool_SimpleQueryLerpFunctor_LVecBase2f,SimpleQueryLerpFunctor< LVecBase2f >::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SimpleQueryLerpFunctor_LVecBase2f.As_PyTypeObject());
        PyModule_AddObject(module, "SimpleQueryLerpFunctorLVecBase2f",(PyObject *)&Dtool_SimpleQueryLerpFunctor_LVecBase2f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SimpleQueryLerpFunctor_LVecBase3f | SimpleQueryLerpFunctorLVecBase3f
//********************************************************************
PyMethodDef Dtool_Methods_SimpleQueryLerpFunctor_LVecBase3f[]= {
  { "getValue",(PyCFunction ) &Dtool_SimpleQueryLerpFunctor_LVecBase3f_get_value_78, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleQueryLerpFunctor_LVecBase3f_get_value_78_comment},
  { "getClassType",(PyCFunction ) &Dtool_SimpleQueryLerpFunctor_LVecBase3f_get_class_type_79, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleQueryLerpFunctor_LVecBase3f_get_class_type_79_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SimpleQueryLerpFunctor_LVecBase3f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_SimpleLerpFunctor_LVecBase3f._Dtool_ClassInit(NULL);
        Dtool_SimpleQueryLerpFunctor_LVecBase3f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_SimpleLerpFunctor_LVecBase3f.As_PyTypeObject());
        Dtool_SimpleQueryLerpFunctor_LVecBase3f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_LVecBase3f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SimpleQueryLerpFunctor_LVecBase3f.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SimpleQueryLerpFunctor_LVecBase3f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SimpleQueryLerpFunctor_LVecBase3f)");
             printf(" Error In PyType_ReadySimpleQueryLerpFunctor_LVecBase3f");
             return;
        }
        Py_INCREF(&Dtool_SimpleQueryLerpFunctor_LVecBase3f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_LVecBase3f.As_PyTypeObject().tp_dict,"SimpleQueryLerpFunctorLVecBase3f",&Dtool_SimpleQueryLerpFunctor_LVecBase3f.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_LVecBase3f.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_SimpleQueryLerpFunctor_LVecBase3f[1],&Dtool_SimpleQueryLerpFunctor_LVecBase3f.As_PyObject()));
        RegisterRuntimeClass(&Dtool_SimpleQueryLerpFunctor_LVecBase3f,SimpleQueryLerpFunctor< LVecBase3f >::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SimpleQueryLerpFunctor_LVecBase3f.As_PyTypeObject());
        PyModule_AddObject(module, "SimpleQueryLerpFunctorLVecBase3f",(PyObject *)&Dtool_SimpleQueryLerpFunctor_LVecBase3f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SimpleQueryLerpFunctor_LVecBase4f | SimpleQueryLerpFunctorLVecBase4f
//********************************************************************
PyMethodDef Dtool_Methods_SimpleQueryLerpFunctor_LVecBase4f[]= {
  { "getValue",(PyCFunction ) &Dtool_SimpleQueryLerpFunctor_LVecBase4f_get_value_81, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleQueryLerpFunctor_LVecBase4f_get_value_81_comment},
  { "getClassType",(PyCFunction ) &Dtool_SimpleQueryLerpFunctor_LVecBase4f_get_class_type_82, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleQueryLerpFunctor_LVecBase4f_get_class_type_82_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SimpleQueryLerpFunctor_LVecBase4f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_SimpleLerpFunctor_LVecBase4f._Dtool_ClassInit(NULL);
        Dtool_SimpleQueryLerpFunctor_LVecBase4f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_SimpleLerpFunctor_LVecBase4f.As_PyTypeObject());
        Dtool_SimpleQueryLerpFunctor_LVecBase4f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_LVecBase4f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SimpleQueryLerpFunctor_LVecBase4f.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SimpleQueryLerpFunctor_LVecBase4f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SimpleQueryLerpFunctor_LVecBase4f)");
             printf(" Error In PyType_ReadySimpleQueryLerpFunctor_LVecBase4f");
             return;
        }
        Py_INCREF(&Dtool_SimpleQueryLerpFunctor_LVecBase4f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_LVecBase4f.As_PyTypeObject().tp_dict,"SimpleQueryLerpFunctorLVecBase4f",&Dtool_SimpleQueryLerpFunctor_LVecBase4f.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_LVecBase4f.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_SimpleQueryLerpFunctor_LVecBase4f[1],&Dtool_SimpleQueryLerpFunctor_LVecBase4f.As_PyObject()));
        RegisterRuntimeClass(&Dtool_SimpleQueryLerpFunctor_LVecBase4f,SimpleQueryLerpFunctor< LVecBase4f >::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SimpleQueryLerpFunctor_LVecBase4f.As_PyTypeObject());
        PyModule_AddObject(module, "SimpleQueryLerpFunctorLVecBase4f",(PyObject *)&Dtool_SimpleQueryLerpFunctor_LVecBase4f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SimpleQueryLerpFunctor_LVector2f | SimpleQueryLerpFunctorLVector2f
//********************************************************************
PyMethodDef Dtool_Methods_SimpleQueryLerpFunctor_LVector2f[]= {
  { "getValue",(PyCFunction ) &Dtool_SimpleQueryLerpFunctor_LVector2f_get_value_84, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleQueryLerpFunctor_LVector2f_get_value_84_comment},
  { "getClassType",(PyCFunction ) &Dtool_SimpleQueryLerpFunctor_LVector2f_get_class_type_85, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleQueryLerpFunctor_LVector2f_get_class_type_85_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SimpleQueryLerpFunctor_LVector2f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_SimpleLerpFunctor_LVector2f._Dtool_ClassInit(NULL);
        Dtool_SimpleQueryLerpFunctor_LVector2f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_SimpleLerpFunctor_LVector2f.As_PyTypeObject());
        Dtool_SimpleQueryLerpFunctor_LVector2f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_LVector2f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SimpleQueryLerpFunctor_LVector2f.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SimpleQueryLerpFunctor_LVector2f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SimpleQueryLerpFunctor_LVector2f)");
             printf(" Error In PyType_ReadySimpleQueryLerpFunctor_LVector2f");
             return;
        }
        Py_INCREF(&Dtool_SimpleQueryLerpFunctor_LVector2f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_LVector2f.As_PyTypeObject().tp_dict,"SimpleQueryLerpFunctorLVector2f",&Dtool_SimpleQueryLerpFunctor_LVector2f.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_LVector2f.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_SimpleQueryLerpFunctor_LVector2f[1],&Dtool_SimpleQueryLerpFunctor_LVector2f.As_PyObject()));
        RegisterRuntimeClass(&Dtool_SimpleQueryLerpFunctor_LVector2f,SimpleQueryLerpFunctor< LVector2f >::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SimpleQueryLerpFunctor_LVector2f.As_PyTypeObject());
        PyModule_AddObject(module, "SimpleQueryLerpFunctorLVector2f",(PyObject *)&Dtool_SimpleQueryLerpFunctor_LVector2f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SimpleQueryLerpFunctor_LVector3f | SimpleQueryLerpFunctorLVector3f
//********************************************************************
PyMethodDef Dtool_Methods_SimpleQueryLerpFunctor_LVector3f[]= {
  { "getValue",(PyCFunction ) &Dtool_SimpleQueryLerpFunctor_LVector3f_get_value_87, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleQueryLerpFunctor_LVector3f_get_value_87_comment},
  { "getClassType",(PyCFunction ) &Dtool_SimpleQueryLerpFunctor_LVector3f_get_class_type_88, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleQueryLerpFunctor_LVector3f_get_class_type_88_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SimpleQueryLerpFunctor_LVector3f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_SimpleLerpFunctor_LVector3f._Dtool_ClassInit(NULL);
        Dtool_SimpleQueryLerpFunctor_LVector3f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_SimpleLerpFunctor_LVector3f.As_PyTypeObject());
        Dtool_SimpleQueryLerpFunctor_LVector3f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_LVector3f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SimpleQueryLerpFunctor_LVector3f.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SimpleQueryLerpFunctor_LVector3f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SimpleQueryLerpFunctor_LVector3f)");
             printf(" Error In PyType_ReadySimpleQueryLerpFunctor_LVector3f");
             return;
        }
        Py_INCREF(&Dtool_SimpleQueryLerpFunctor_LVector3f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_LVector3f.As_PyTypeObject().tp_dict,"SimpleQueryLerpFunctorLVector3f",&Dtool_SimpleQueryLerpFunctor_LVector3f.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_LVector3f.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_SimpleQueryLerpFunctor_LVector3f[1],&Dtool_SimpleQueryLerpFunctor_LVector3f.As_PyObject()));
        RegisterRuntimeClass(&Dtool_SimpleQueryLerpFunctor_LVector3f,SimpleQueryLerpFunctor< LVector3f >::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SimpleQueryLerpFunctor_LVector3f.As_PyTypeObject());
        PyModule_AddObject(module, "SimpleQueryLerpFunctorLVector3f",(PyObject *)&Dtool_SimpleQueryLerpFunctor_LVector3f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. SimpleQueryLerpFunctor_LVector4f | SimpleQueryLerpFunctorLVector4f
//********************************************************************
PyMethodDef Dtool_Methods_SimpleQueryLerpFunctor_LVector4f[]= {
  { "getValue",(PyCFunction ) &Dtool_SimpleQueryLerpFunctor_LVector4f_get_value_90, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleQueryLerpFunctor_LVector4f_get_value_90_comment},
  { "getClassType",(PyCFunction ) &Dtool_SimpleQueryLerpFunctor_LVector4f_get_class_type_91, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_SimpleQueryLerpFunctor_LVector4f_get_class_type_91_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_SimpleQueryLerpFunctor_LVector4f(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_SimpleLerpFunctor_LVector4f._Dtool_ClassInit(NULL);
        Dtool_SimpleQueryLerpFunctor_LVector4f.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_SimpleLerpFunctor_LVector4f.As_PyTypeObject());
        Dtool_SimpleQueryLerpFunctor_LVector4f.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_LVector4f.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_SimpleQueryLerpFunctor_LVector4f.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_SimpleQueryLerpFunctor_LVector4f.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(SimpleQueryLerpFunctor_LVector4f)");
             printf(" Error In PyType_ReadySimpleQueryLerpFunctor_LVector4f");
             return;
        }
        Py_INCREF(&Dtool_SimpleQueryLerpFunctor_LVector4f.As_PyTypeObject());
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_LVector4f.As_PyTypeObject().tp_dict,"SimpleQueryLerpFunctorLVector4f",&Dtool_SimpleQueryLerpFunctor_LVector4f.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_SimpleQueryLerpFunctor_LVector4f.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_SimpleQueryLerpFunctor_LVector4f[1],&Dtool_SimpleQueryLerpFunctor_LVector4f.As_PyObject()));
        RegisterRuntimeClass(&Dtool_SimpleQueryLerpFunctor_LVector4f,SimpleQueryLerpFunctor< LVector4f >::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_SimpleQueryLerpFunctor_LVector4f.As_PyTypeObject());
        PyModule_AddObject(module, "SimpleQueryLerpFunctorLVector4f",(PyObject *)&Dtool_SimpleQueryLerpFunctor_LVector4f.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. MultiLerpFunctor | MultiLerpFunctor
//********************************************************************
PyMethodDef Dtool_Methods_MultiLerpFunctor[]= {
  { "getClassType",(PyCFunction ) &Dtool_MultiLerpFunctor_get_class_type_93, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_MultiLerpFunctor_get_class_type_93_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_MultiLerpFunctor(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_LerpFunctor._Dtool_ClassInit(NULL);
        Dtool_MultiLerpFunctor.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LerpFunctor.As_PyTypeObject());
        Dtool_MultiLerpFunctor.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_MultiLerpFunctor.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_MultiLerpFunctor.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_MultiLerpFunctor.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(MultiLerpFunctor)");
             printf(" Error In PyType_ReadyMultiLerpFunctor");
             return;
        }
        Py_INCREF(&Dtool_MultiLerpFunctor.As_PyTypeObject());
        PyDict_SetItemString(Dtool_MultiLerpFunctor.As_PyTypeObject().tp_dict,"MultiLerpFunctor",&Dtool_MultiLerpFunctor.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_MultiLerpFunctor.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_MultiLerpFunctor[0],&Dtool_MultiLerpFunctor.As_PyObject()));
        RegisterRuntimeClass(&Dtool_MultiLerpFunctor,MultiLerpFunctor::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_MultiLerpFunctor.As_PyTypeObject());
        PyModule_AddObject(module, "MultiLerpFunctor",(PyObject *)&Dtool_MultiLerpFunctor.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. LerpBlendType | LerpBlendType
//********************************************************************
PyMethodDef Dtool_Methods_LerpBlendType[]= {
  { "__call__",(PyCFunction ) &Dtool_LerpBlendType_operator_95, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LerpBlendType_operator_95_comment},
  { "getClassType",(PyCFunction ) &Dtool_LerpBlendType_get_class_type_96, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LerpBlendType_get_class_type_96_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_LerpBlendType(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_LerpBlendType.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_LerpBlendType.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_LerpBlendType.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_LerpBlendType.As_PyTypeObject().tp_dict);
        // tp_call = __call__
        Dtool_LerpBlendType.As_PyTypeObject().tp_call = &Dtool_LerpBlendType_operator_95;
        if(PyType_Ready(&Dtool_LerpBlendType.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(LerpBlendType)");
             printf(" Error In PyType_ReadyLerpBlendType");
             return;
        }
        Py_INCREF(&Dtool_LerpBlendType.As_PyTypeObject());
        PyDict_SetItemString(Dtool_LerpBlendType.As_PyTypeObject().tp_dict,"LerpBlendType",&Dtool_LerpBlendType.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_LerpBlendType.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_LerpBlendType[1],&Dtool_LerpBlendType.As_PyObject()));
        RegisterRuntimeClass(&Dtool_LerpBlendType,LerpBlendType::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_LerpBlendType.As_PyTypeObject());
        PyModule_AddObject(module, "LerpBlendType",(PyObject *)&Dtool_LerpBlendType.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. EaseInBlendType | EaseInBlendType
//********************************************************************
PyMethodDef Dtool_Methods_EaseInBlendType[]= {
  { "getClassType",(PyCFunction ) &Dtool_EaseInBlendType_get_class_type_99, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EaseInBlendType_get_class_type_99_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_EaseInBlendType(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_LerpBlendType._Dtool_ClassInit(NULL);
        Dtool_EaseInBlendType.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LerpBlendType.As_PyTypeObject());
        Dtool_EaseInBlendType.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_EaseInBlendType.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_EaseInBlendType.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_EaseInBlendType.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(EaseInBlendType)");
             printf(" Error In PyType_ReadyEaseInBlendType");
             return;
        }
        Py_INCREF(&Dtool_EaseInBlendType.As_PyTypeObject());
        PyDict_SetItemString(Dtool_EaseInBlendType.As_PyTypeObject().tp_dict,"EaseInBlendType",&Dtool_EaseInBlendType.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_EaseInBlendType.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_EaseInBlendType[0],&Dtool_EaseInBlendType.As_PyObject()));
        RegisterRuntimeClass(&Dtool_EaseInBlendType,EaseInBlendType::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_EaseInBlendType.As_PyTypeObject());
        PyModule_AddObject(module, "EaseInBlendType",(PyObject *)&Dtool_EaseInBlendType.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. EaseOutBlendType | EaseOutBlendType
//********************************************************************
PyMethodDef Dtool_Methods_EaseOutBlendType[]= {
  { "getClassType",(PyCFunction ) &Dtool_EaseOutBlendType_get_class_type_102, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EaseOutBlendType_get_class_type_102_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_EaseOutBlendType(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_LerpBlendType._Dtool_ClassInit(NULL);
        Dtool_EaseOutBlendType.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LerpBlendType.As_PyTypeObject());
        Dtool_EaseOutBlendType.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_EaseOutBlendType.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_EaseOutBlendType.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_EaseOutBlendType.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(EaseOutBlendType)");
             printf(" Error In PyType_ReadyEaseOutBlendType");
             return;
        }
        Py_INCREF(&Dtool_EaseOutBlendType.As_PyTypeObject());
        PyDict_SetItemString(Dtool_EaseOutBlendType.As_PyTypeObject().tp_dict,"EaseOutBlendType",&Dtool_EaseOutBlendType.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_EaseOutBlendType.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_EaseOutBlendType[0],&Dtool_EaseOutBlendType.As_PyObject()));
        RegisterRuntimeClass(&Dtool_EaseOutBlendType,EaseOutBlendType::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_EaseOutBlendType.As_PyTypeObject());
        PyModule_AddObject(module, "EaseOutBlendType",(PyObject *)&Dtool_EaseOutBlendType.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. EaseInOutBlendType | EaseInOutBlendType
//********************************************************************
PyMethodDef Dtool_Methods_EaseInOutBlendType[]= {
  { "getClassType",(PyCFunction ) &Dtool_EaseInOutBlendType_get_class_type_105, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_EaseInOutBlendType_get_class_type_105_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_EaseInOutBlendType(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_LerpBlendType._Dtool_ClassInit(NULL);
        Dtool_EaseInOutBlendType.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LerpBlendType.As_PyTypeObject());
        Dtool_EaseInOutBlendType.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_EaseInOutBlendType.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_EaseInOutBlendType.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_EaseInOutBlendType.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(EaseInOutBlendType)");
             printf(" Error In PyType_ReadyEaseInOutBlendType");
             return;
        }
        Py_INCREF(&Dtool_EaseInOutBlendType.As_PyTypeObject());
        PyDict_SetItemString(Dtool_EaseInOutBlendType.As_PyTypeObject().tp_dict,"EaseInOutBlendType",&Dtool_EaseInOutBlendType.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_EaseInOutBlendType.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_EaseInOutBlendType[0],&Dtool_EaseInOutBlendType.As_PyObject()));
        RegisterRuntimeClass(&Dtool_EaseInOutBlendType,EaseInOutBlendType::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_EaseInOutBlendType.As_PyTypeObject());
        PyModule_AddObject(module, "EaseInOutBlendType",(PyObject *)&Dtool_EaseInOutBlendType.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. NoBlendType | NoBlendType
//********************************************************************
PyMethodDef Dtool_Methods_NoBlendType[]= {
  { "getClassType",(PyCFunction ) &Dtool_NoBlendType_get_class_type_108, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_NoBlendType_get_class_type_108_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_NoBlendType(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_LerpBlendType._Dtool_ClassInit(NULL);
        Dtool_NoBlendType.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LerpBlendType.As_PyTypeObject());
        Dtool_NoBlendType.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_NoBlendType.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_NoBlendType.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_NoBlendType.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(NoBlendType)");
             printf(" Error In PyType_ReadyNoBlendType");
             return;
        }
        Py_INCREF(&Dtool_NoBlendType.As_PyTypeObject());
        PyDict_SetItemString(Dtool_NoBlendType.As_PyTypeObject().tp_dict,"NoBlendType",&Dtool_NoBlendType.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_NoBlendType.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_NoBlendType[0],&Dtool_NoBlendType.As_PyObject()));
        RegisterRuntimeClass(&Dtool_NoBlendType,NoBlendType::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_NoBlendType.As_PyTypeObject());
        PyModule_AddObject(module, "NoBlendType",(PyObject *)&Dtool_NoBlendType.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Lerp | Lerp
//********************************************************************
PyMethodDef Dtool_Methods_Lerp[]= {
  { "assign",(PyCFunction ) &Dtool_Lerp_operator_111, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Lerp_operator_111_comment},
  { "step",(PyCFunction ) &Dtool_Lerp_step_112, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Lerp_step_112_comment},
  { "setStepSize",(PyCFunction ) &Dtool_Lerp_set_step_size_113, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Lerp_set_step_size_113_comment},
  { "getStepSize",(PyCFunction ) &Dtool_Lerp_get_step_size_114, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Lerp_get_step_size_114_comment},
  { "setT",(PyCFunction ) &Dtool_Lerp_set_t_115, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Lerp_set_t_115_comment},
  { "getT",(PyCFunction ) &Dtool_Lerp_get_t_116, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Lerp_get_t_116_comment},
  { "isDone",(PyCFunction ) &Dtool_Lerp_is_done_117, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Lerp_is_done_117_comment},
  { "getFunctor",(PyCFunction ) &Dtool_Lerp_get_functor_118, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Lerp_get_functor_118_comment},
  { "setEndEvent",(PyCFunction ) &Dtool_Lerp_set_end_event_119, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Lerp_set_end_event_119_comment},
  { "getEndEvent",(PyCFunction ) &Dtool_Lerp_get_end_event_120, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Lerp_get_end_event_120_comment},
  { "getClassType",(PyCFunction ) &Dtool_Lerp_get_class_type_121, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Lerp_get_class_type_121_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_Lerp(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_Lerp.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_Lerp.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Lerp.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Lerp.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_Lerp.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Lerp)");
             printf(" Error In PyType_ReadyLerp");
             return;
        }
        Py_INCREF(&Dtool_Lerp.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Lerp.As_PyTypeObject().tp_dict,"Lerp",&Dtool_Lerp.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_Lerp.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_Lerp[10],&Dtool_Lerp.As_PyObject()));
        RegisterRuntimeClass(&Dtool_Lerp,Lerp::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Lerp.As_PyTypeObject());
        PyModule_AddObject(module, "Lerp",(PyObject *)&Dtool_Lerp.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. AutonomousLerp | AutonomousLerp
//********************************************************************
PyMethodDef Dtool_Methods_AutonomousLerp[]= {
  { "assign",(PyCFunction ) &Dtool_AutonomousLerp_operator_124, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AutonomousLerp_operator_124_comment},
  { "start",(PyCFunction ) &Dtool_AutonomousLerp_start_125, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AutonomousLerp_start_125_comment},
  { "stop",(PyCFunction ) &Dtool_AutonomousLerp_stop_126, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AutonomousLerp_stop_126_comment},
  { "resume",(PyCFunction ) &Dtool_AutonomousLerp_resume_127, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AutonomousLerp_resume_127_comment},
  { "isDone",(PyCFunction ) &Dtool_AutonomousLerp_is_done_128, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AutonomousLerp_is_done_128_comment},
  { "getFunctor",(PyCFunction ) &Dtool_AutonomousLerp_get_functor_129, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AutonomousLerp_get_functor_129_comment},
  { "setT",(PyCFunction ) &Dtool_AutonomousLerp_set_t_130, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AutonomousLerp_set_t_130_comment},
  { "getT",(PyCFunction ) &Dtool_AutonomousLerp_get_t_131, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AutonomousLerp_get_t_131_comment},
  { "setEndEvent",(PyCFunction ) &Dtool_AutonomousLerp_set_end_event_132, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AutonomousLerp_set_end_event_132_comment},
  { "getEndEvent",(PyCFunction ) &Dtool_AutonomousLerp_get_end_event_133, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AutonomousLerp_get_end_event_133_comment},
  { "getClassType",(PyCFunction ) &Dtool_AutonomousLerp_get_class_type_134, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AutonomousLerp_get_class_type_134_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_AutonomousLerp(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_AutonomousLerp.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_AutonomousLerp.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_AutonomousLerp.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_AutonomousLerp.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_AutonomousLerp.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(AutonomousLerp)");
             printf(" Error In PyType_ReadyAutonomousLerp");
             return;
        }
        Py_INCREF(&Dtool_AutonomousLerp.As_PyTypeObject());
        PyDict_SetItemString(Dtool_AutonomousLerp.As_PyTypeObject().tp_dict,"AutonomousLerp",&Dtool_AutonomousLerp.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_AutonomousLerp.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_AutonomousLerp[10],&Dtool_AutonomousLerp.As_PyObject()));
        RegisterRuntimeClass(&Dtool_AutonomousLerp,AutonomousLerp::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_AutonomousLerp.As_PyTypeObject());
        PyModule_AddObject(module, "AutonomousLerp",(PyObject *)&Dtool_AutonomousLerp.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..LerpFunctor
//********************************************************************
   Dtool_PyModuleClassInit_LerpFunctor(module);
//********************************************************************
//*** Module Init Updcall ..SimpleLerpFunctor< int >
//********************************************************************
   Dtool_PyModuleClassInit_SimpleLerpFunctor_int(module);
//********************************************************************
//*** Module Init Updcall ..SimpleLerpFunctor< float >
//********************************************************************
   Dtool_PyModuleClassInit_SimpleLerpFunctor_float(module);
//********************************************************************
//*** Module Init Updcall ..SimpleLerpFunctor< LPoint2f >
//********************************************************************
   Dtool_PyModuleClassInit_SimpleLerpFunctor_LPoint2f(module);
//********************************************************************
//*** Module Init Updcall ..SimpleLerpFunctor< LPoint3f >
//********************************************************************
   Dtool_PyModuleClassInit_SimpleLerpFunctor_LPoint3f(module);
//********************************************************************
//*** Module Init Updcall ..SimpleLerpFunctor< LPoint4f >
//********************************************************************
   Dtool_PyModuleClassInit_SimpleLerpFunctor_LPoint4f(module);
//********************************************************************
//*** Module Init Updcall ..SimpleLerpFunctor< LVecBase2f >
//********************************************************************
   Dtool_PyModuleClassInit_SimpleLerpFunctor_LVecBase2f(module);
//********************************************************************
//*** Module Init Updcall ..SimpleLerpFunctor< LVecBase3f >
//********************************************************************
   Dtool_PyModuleClassInit_SimpleLerpFunctor_LVecBase3f(module);
//********************************************************************
//*** Module Init Updcall ..SimpleLerpFunctor< LVecBase4f >
//********************************************************************
   Dtool_PyModuleClassInit_SimpleLerpFunctor_LVecBase4f(module);
//********************************************************************
//*** Module Init Updcall ..SimpleLerpFunctor< LVector2f >
//********************************************************************
   Dtool_PyModuleClassInit_SimpleLerpFunctor_LVector2f(module);
//********************************************************************
//*** Module Init Updcall ..SimpleLerpFunctor< LVector3f >
//********************************************************************
   Dtool_PyModuleClassInit_SimpleLerpFunctor_LVector3f(module);
//********************************************************************
//*** Module Init Updcall ..SimpleLerpFunctor< LVector4f >
//********************************************************************
   Dtool_PyModuleClassInit_SimpleLerpFunctor_LVector4f(module);
//********************************************************************
//*** Module Init Updcall ..SimpleQueryLerpFunctor< int >
//********************************************************************
   Dtool_PyModuleClassInit_SimpleQueryLerpFunctor_int(module);
//********************************************************************
//*** Module Init Updcall ..SimpleQueryLerpFunctor< float >
//********************************************************************
   Dtool_PyModuleClassInit_SimpleQueryLerpFunctor_float(module);
//********************************************************************
//*** Module Init Updcall ..SimpleQueryLerpFunctor< LPoint2f >
//********************************************************************
   Dtool_PyModuleClassInit_SimpleQueryLerpFunctor_LPoint2f(module);
//********************************************************************
//*** Module Init Updcall ..SimpleQueryLerpFunctor< LPoint3f >
//********************************************************************
   Dtool_PyModuleClassInit_SimpleQueryLerpFunctor_LPoint3f(module);
//********************************************************************
//*** Module Init Updcall ..SimpleQueryLerpFunctor< LPoint4f >
//********************************************************************
   Dtool_PyModuleClassInit_SimpleQueryLerpFunctor_LPoint4f(module);
//********************************************************************
//*** Module Init Updcall ..SimpleQueryLerpFunctor< LVecBase2f >
//********************************************************************
   Dtool_PyModuleClassInit_SimpleQueryLerpFunctor_LVecBase2f(module);
//********************************************************************
//*** Module Init Updcall ..SimpleQueryLerpFunctor< LVecBase3f >
//********************************************************************
   Dtool_PyModuleClassInit_SimpleQueryLerpFunctor_LVecBase3f(module);
//********************************************************************
//*** Module Init Updcall ..SimpleQueryLerpFunctor< LVecBase4f >
//********************************************************************
   Dtool_PyModuleClassInit_SimpleQueryLerpFunctor_LVecBase4f(module);
//********************************************************************
//*** Module Init Updcall ..SimpleQueryLerpFunctor< LVector2f >
//********************************************************************
   Dtool_PyModuleClassInit_SimpleQueryLerpFunctor_LVector2f(module);
//********************************************************************
//*** Module Init Updcall ..SimpleQueryLerpFunctor< LVector3f >
//********************************************************************
   Dtool_PyModuleClassInit_SimpleQueryLerpFunctor_LVector3f(module);
//********************************************************************
//*** Module Init Updcall ..SimpleQueryLerpFunctor< LVector4f >
//********************************************************************
   Dtool_PyModuleClassInit_SimpleQueryLerpFunctor_LVector4f(module);
//********************************************************************
//*** Module Init Updcall ..MultiLerpFunctor
//********************************************************************
   Dtool_PyModuleClassInit_MultiLerpFunctor(module);
//********************************************************************
//*** Module Init Updcall ..LerpBlendType
//********************************************************************
   Dtool_PyModuleClassInit_LerpBlendType(module);
//********************************************************************
//*** Module Init Updcall ..EaseInBlendType
//********************************************************************
   Dtool_PyModuleClassInit_EaseInBlendType(module);
//********************************************************************
//*** Module Init Updcall ..EaseOutBlendType
//********************************************************************
   Dtool_PyModuleClassInit_EaseOutBlendType(module);
//********************************************************************
//*** Module Init Updcall ..EaseInOutBlendType
//********************************************************************
   Dtool_PyModuleClassInit_EaseInOutBlendType(module);
//********************************************************************
//*** Module Init Updcall ..NoBlendType
//********************************************************************
   Dtool_PyModuleClassInit_NoBlendType(module);
//********************************************************************
//*** Module Init Updcall ..Lerp
//********************************************************************
   Dtool_PyModuleClassInit_Lerp(module);
//********************************************************************
//*** Module Init Updcall ..AutonomousLerp
//********************************************************************
   Dtool_PyModuleClassInit_AutonomousLerp(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef liblerp_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212835,  /* file_identifier */
  "liblerp",  /* library_name */
  "jRdz",  /* library_hash_name */
  "panda",  /* module_name */
  "liblerp.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  342  /* next_index */
};

Configure(_in_configure_liblerp);
ConfigureFn(_in_configure_liblerp) {
  interrogate_request_module(&_in_module_def);
}

