/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/physics -Ipanda/src/physics -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libphysics_igate.cxx -od built_Rocket/pandac/input/libphysics.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/physics -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDAPHYSICS -module pandaphysics -library libphysics actorNode.h angularEulerIntegrator.h angularForce.h angularIntegrator.h angularVectorForce.h baseForce.h baseIntegrator.h config_physics.h forceNode.h linearControlForce.h linearCylinderVortexForce.h linearDistanceForce.h linearEulerIntegrator.h linearForce.h linearFrictionForce.h linearIntegrator.h linearJitterForce.h linearNoiseForce.h linearRandomForce.h linearSinkForce.h linearSourceForce.h linearUserDefinedForce.h linearVectorForce.h physical.h physicalNode.h physicsCollisionHandler.h physicsManager.h physicsObject.h physicsObjectCollection.h physics_composite.cxx 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libphysics
#include "py_panda.h"  

#include "actorNode.h"
#include "angularEulerIntegrator.h"
#include "angularForce.h"
#include "angularIntegrator.h"
#include "angularVectorForce.h"
#include "baseForce.h"
#include "baseIntegrator.h"
#include "collisionHandlerPusher.h"
#include "configVariableInt.h"
#include "config_physics.h"
#include "forceNode.h"
#include "linearControlForce.h"
#include "linearCylinderVortexForce.h"
#include "linearDistanceForce.h"
#include "linearEulerIntegrator.h"
#include "linearForce.h"
#include "linearFrictionForce.h"
#include "linearIntegrator.h"
#include "linearJitterForce.h"
#include "linearNoiseForce.h"
#include "linearRandomForce.h"
#include "linearSinkForce.h"
#include "linearSourceForce.h"
#include "linearUserDefinedForce.h"
#include "linearVectorForce.h"
#include "pandaNode.h"
#include "pandabase.h"
#include "physical.h"
#include "physicalNode.h"
#include "physicsCollisionHandler.h"
#include "physicsManager.h"
#include "physicsObject.h"
#include "physicsObjectCollection.h"
#include "plist.h"
#include "pointerTo.h"
#include "pvector.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. PhysicsObject
//********************************************************************
typedef  PhysicsObject  PhysicsObject_localtype;
Define_Module_ClassRef(pandaphysics,PhysicsObject,PhysicsObject_localtype,PhysicsObject);
//********************************************************************
//*** prototypes for .. PhysicsObjectCollection
//********************************************************************
typedef  PhysicsObjectCollection  PhysicsObjectCollection_localtype;
Define_Module_Class(pandaphysics,PhysicsObjectCollection,PhysicsObjectCollection_localtype,PhysicsObjectCollection);
//********************************************************************
//*** prototypes for .. BaseForce
//********************************************************************
typedef  BaseForce  BaseForce_localtype;
Define_Module_ClassRef(pandaphysics,BaseForce,BaseForce_localtype,BaseForce);
//********************************************************************
//*** prototypes for .. LinearForce
//********************************************************************
typedef  LinearForce  LinearForce_localtype;
Define_Module_ClassRef(pandaphysics,LinearForce,LinearForce_localtype,LinearForce);
//********************************************************************
//*** prototypes for .. AngularForce
//********************************************************************
typedef  AngularForce  AngularForce_localtype;
Define_Module_ClassRef(pandaphysics,AngularForce,AngularForce_localtype,AngularForce);
//********************************************************************
//*** prototypes for .. Physical
//********************************************************************
typedef  Physical  Physical_localtype;
Define_Module_ClassRef(pandaphysics,Physical,Physical_localtype,Physical);
//********************************************************************
//*** prototypes for .. PhysicalNode
//********************************************************************
typedef  PhysicalNode  PhysicalNode_localtype;
Define_Module_ClassRef(pandaphysics,PhysicalNode,PhysicalNode_localtype,PhysicalNode);
//********************************************************************
//*** prototypes for .. ActorNode
//********************************************************************
typedef  ActorNode  ActorNode_localtype;
Define_Module_ClassRef(pandaphysics,ActorNode,ActorNode_localtype,ActorNode);
//********************************************************************
//*** prototypes for .. BaseIntegrator
//********************************************************************
typedef  BaseIntegrator  BaseIntegrator_localtype;
Define_Module_ClassRef(pandaphysics,BaseIntegrator,BaseIntegrator_localtype,BaseIntegrator);
//********************************************************************
//*** prototypes for .. AngularIntegrator
//********************************************************************
typedef  AngularIntegrator  AngularIntegrator_localtype;
Define_Module_ClassRef(pandaphysics,AngularIntegrator,AngularIntegrator_localtype,AngularIntegrator);
//********************************************************************
//*** prototypes for .. AngularEulerIntegrator
//********************************************************************
typedef  AngularEulerIntegrator  AngularEulerIntegrator_localtype;
Define_Module_ClassRef(pandaphysics,AngularEulerIntegrator,AngularEulerIntegrator_localtype,AngularEulerIntegrator);
//********************************************************************
//*** prototypes for .. AngularVectorForce
//********************************************************************
typedef  AngularVectorForce  AngularVectorForce_localtype;
Define_Module_ClassRef(pandaphysics,AngularVectorForce,AngularVectorForce_localtype,AngularVectorForce);
//********************************************************************
//*** prototypes for .. ForceNode
//********************************************************************
typedef  ForceNode  ForceNode_localtype;
Define_Module_ClassRef(pandaphysics,ForceNode,ForceNode_localtype,ForceNode);
//********************************************************************
//*** prototypes for .. LinearControlForce
//********************************************************************
typedef  LinearControlForce  LinearControlForce_localtype;
Define_Module_ClassRef(pandaphysics,LinearControlForce,LinearControlForce_localtype,LinearControlForce);
//********************************************************************
//*** prototypes for .. LinearCylinderVortexForce
//********************************************************************
typedef  LinearCylinderVortexForce  LinearCylinderVortexForce_localtype;
Define_Module_ClassRef(pandaphysics,LinearCylinderVortexForce,LinearCylinderVortexForce_localtype,LinearCylinderVortexForce);
//********************************************************************
//*** prototypes for .. LinearDistanceForce
//********************************************************************
typedef  LinearDistanceForce  LinearDistanceForce_localtype;
Define_Module_ClassRef_Private(pandaphysics,LinearDistanceForce,LinearDistanceForce_localtype,LinearDistanceForce);
//********************************************************************
//*** prototypes for .. LinearIntegrator
//********************************************************************
typedef  LinearIntegrator  LinearIntegrator_localtype;
Define_Module_ClassRef(pandaphysics,LinearIntegrator,LinearIntegrator_localtype,LinearIntegrator);
//********************************************************************
//*** prototypes for .. LinearEulerIntegrator
//********************************************************************
typedef  LinearEulerIntegrator  LinearEulerIntegrator_localtype;
Define_Module_ClassRef(pandaphysics,LinearEulerIntegrator,LinearEulerIntegrator_localtype,LinearEulerIntegrator);
//********************************************************************
//*** prototypes for .. LinearFrictionForce
//********************************************************************
typedef  LinearFrictionForce  LinearFrictionForce_localtype;
Define_Module_ClassRef(pandaphysics,LinearFrictionForce,LinearFrictionForce_localtype,LinearFrictionForce);
//********************************************************************
//*** prototypes for .. LinearRandomForce
//********************************************************************
typedef  LinearRandomForce  LinearRandomForce_localtype;
Define_Module_ClassRef(pandaphysics,LinearRandomForce,LinearRandomForce_localtype,LinearRandomForce);
//********************************************************************
//*** prototypes for .. LinearJitterForce
//********************************************************************
typedef  LinearJitterForce  LinearJitterForce_localtype;
Define_Module_ClassRef(pandaphysics,LinearJitterForce,LinearJitterForce_localtype,LinearJitterForce);
//********************************************************************
//*** prototypes for .. LinearNoiseForce
//********************************************************************
typedef  LinearNoiseForce  LinearNoiseForce_localtype;
Define_Module_ClassRef(pandaphysics,LinearNoiseForce,LinearNoiseForce_localtype,LinearNoiseForce);
//********************************************************************
//*** prototypes for .. LinearSinkForce
//********************************************************************
typedef  LinearSinkForce  LinearSinkForce_localtype;
Define_Module_ClassRef(pandaphysics,LinearSinkForce,LinearSinkForce_localtype,LinearSinkForce);
//********************************************************************
//*** prototypes for .. LinearSourceForce
//********************************************************************
typedef  LinearSourceForce  LinearSourceForce_localtype;
Define_Module_ClassRef(pandaphysics,LinearSourceForce,LinearSourceForce_localtype,LinearSourceForce);
//********************************************************************
//*** prototypes for .. LinearUserDefinedForce
//********************************************************************
typedef  LinearUserDefinedForce  LinearUserDefinedForce_localtype;
Define_Module_ClassRef(pandaphysics,LinearUserDefinedForce,LinearUserDefinedForce_localtype,LinearUserDefinedForce);
//********************************************************************
//*** prototypes for .. LinearVectorForce
//********************************************************************
typedef  LinearVectorForce  LinearVectorForce_localtype;
Define_Module_ClassRef(pandaphysics,LinearVectorForce,LinearVectorForce_localtype,LinearVectorForce);
//********************************************************************
//*** prototypes for .. PhysicsCollisionHandler
//********************************************************************
typedef  PhysicsCollisionHandler  PhysicsCollisionHandler_localtype;
Define_Module_ClassRef(pandaphysics,PhysicsCollisionHandler,PhysicsCollisionHandler_localtype,PhysicsCollisionHandler);
//********************************************************************
//*** prototypes for .. PhysicsManager
//********************************************************************
typedef  PhysicsManager  PhysicsManager_localtype;
Define_Module_Class(pandaphysics,PhysicsManager,PhysicsManager_localtype,PhysicsManager);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_CollisionHandler;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_CollisionHandlerEvent;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_CollisionHandlerPhysical;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_CollisionHandlerPusher;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LMatrix4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LOrientationf;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LPoint3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LRotationf;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVector3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Namable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_NodePath;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PandaNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedWritable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. PhysicsObject 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * PhysicsObject const &PhysicsObject::operator =(PhysicsObject const &other)
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_operator_4(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-PhysicsObject const &PhysicsObject::operator =(PhysicsObject const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                PhysicsObject *param1_this = (PhysicsObject *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PhysicsObject, 1, "PhysicsObject.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    PhysicsObject *return_value = local_this;
                    if (return_value != (PhysicsObject *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PhysicsObject,true, false, (return_value)->as_typed_object()->get_type_index());
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsObject.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const PhysicsObject this, const PhysicsObject other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_operator_4_comment =
    "C++ Interface:\n"
    "assign(non-const PhysicsObject this, const PhysicsObject other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : Assignment operator\n"
    "//       Access : Public\n"
    "//  Description :\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_operator_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PhysicsObject::set_active(bool flag)
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_set_active_5(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PhysicsObject::set_active(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setActive", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setActive", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_active((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PhysicsObject.setActive() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setActive(non-const PhysicsObject this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_set_active_5_comment =
    "C++ Interface:\n"
    "setActive(non-const PhysicsObject this, bool flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_active\n"
    "//      Access : Public\n"
    "// Description : Process Flag assignment\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_set_active_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PhysicsObject::get_active(void) const
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_get_active_6(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool PhysicsObject::get_active(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getActive", key_word_list));
        else
            (PyArg_Parse(args, ":getActive"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PhysicsObject*)local_this)->get_active();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getActive(const PhysicsObject this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_get_active_6_comment =
    "C++ Interface:\n"
    "getActive(const PhysicsObject this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_active\n"
    "//      Access : Public\n"
    "// Description : Process Flag Query\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_get_active_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PhysicsObject::set_mass(float )
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_set_mass_7(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PhysicsObject::set_mass(float )
        double param1;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setMass", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setMass", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_mass((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PhysicsObject.setMass() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMass(non-const PhysicsObject this, float)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_set_mass_7_comment =
    "C++ Interface:\n"
    "setMass(non-const PhysicsObject this, float)\n"
    "\n"
    "// Filename: physicsObject.I\n"
    "// Created by:  charles (13Jun00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_mass\n"
    "//      Access : Public\n"
    "// Description : Set the mass in slugs (or kilograms).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_set_mass_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float PhysicsObject::get_mass(void) const
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_get_mass_8(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float PhysicsObject::get_mass(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMass", key_word_list));
        else
            (PyArg_Parse(args, ":getMass"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const PhysicsObject*)local_this)->get_mass();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMass(const PhysicsObject this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_get_mass_8_comment =
    "C++ Interface:\n"
    "getMass(const PhysicsObject this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_mass\n"
    "//      Access : Public\n"
    "// Description : Get the mass in slugs (or kilograms).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_get_mass_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PhysicsObject::set_position(LPoint3f const &pos)
 * inline void PhysicsObject::set_position(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_set_position_9(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void PhysicsObject::set_position(LPoint3f const &pos)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"pos", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setPosition", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setPosition", &param1));
                if(!PyErr_Occurred())
                {
                    LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "PhysicsObject.setPosition", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_position(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PhysicsObject.setPosition() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PhysicsObject::set_position(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setPosition", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_position((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsObject.setPosition() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setPosition() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setPosition(non-const PhysicsObject this, const Point3 pos)\n"
          "setPosition(non-const PhysicsObject this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_set_position_9_comment =
    "C++ Interface:\n"
    "setPosition(non-const PhysicsObject this, const Point3 pos)\n"
    "setPosition(non-const PhysicsObject this, float x, float y, float z)\n"
    "\n"
    "//INLINE void set_center_of_mass(const LPoint3f &pos); use set_position.\n"
    "\n"
    "//INLINE void set_center_of_mass(const LPoint3f &pos); use set_position.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_position\n"
    "//      Access : Public\n"
    "// Description : Vector position assignment.  This is also used as\n"
    "//               the center of mass.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_position\n"
    "//      Access : Public\n"
    "// Description : Piecewise position assignment\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_set_position_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f PhysicsObject::get_position(void) const
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_get_position_10(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f PhysicsObject::get_position(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPosition", key_word_list));
        else
            (PyArg_Parse(args, ":getPosition"));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const PhysicsObject*)local_this)->get_position();
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPosition(const PhysicsObject this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_get_position_10_comment =
    "C++ Interface:\n"
    "getPosition(const PhysicsObject this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_position\n"
    "//      Access : Public\n"
    "// Description : Position Query\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_get_position_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PhysicsObject::reset_position(LPoint3f const &pos)
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_reset_position_11(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PhysicsObject::reset_position(LPoint3f const &pos)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"pos", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:resetPosition", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:resetPosition", &param1));
            if(!PyErr_Occurred())
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "PhysicsObject.resetPosition", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->reset_position(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsObject.resetPosition() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetPosition(non-const PhysicsObject this, const Point3 pos)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_reset_position_11_comment =
    "C++ Interface:\n"
    "resetPosition(non-const PhysicsObject this, const Point3 pos)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : reset_position\n"
    "//      Access : Public\n"
    "// Description : use this to place an object in a completely new\n"
    "//               position, that has nothing to do with its last\n"
    "//               position.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_reset_position_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PhysicsObject::set_last_position(LPoint3f const &pos)
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_set_last_position_12(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PhysicsObject::set_last_position(LPoint3f const &pos)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"pos", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setLastPosition", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setLastPosition", &param1));
            if(!PyErr_Occurred())
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "PhysicsObject.setLastPosition", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_last_position(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsObject.setLastPosition() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setLastPosition(non-const PhysicsObject this, const Point3 pos)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_set_last_position_12_comment =
    "C++ Interface:\n"
    "setLastPosition(non-const PhysicsObject this, const Point3 pos)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_last_position\n"
    "//      Access : Public\n"
    "// Description : Last position assignment\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_set_last_position_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f PhysicsObject::get_last_position(void) const
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_get_last_position_13(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f PhysicsObject::get_last_position(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLastPosition", key_word_list));
        else
            (PyArg_Parse(args, ":getLastPosition"));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const PhysicsObject*)local_this)->get_last_position();
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLastPosition(const PhysicsObject this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_get_last_position_13_comment =
    "C++ Interface:\n"
    "getLastPosition(const PhysicsObject this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_last_position\n"
    "//      Access : Public\n"
    "// Description : Get the position of the physics object at the start\n"
    "//               of the most recent do_physics.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_get_last_position_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PhysicsObject::set_velocity(LVector3f const &vel)
 * inline void PhysicsObject::set_velocity(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_set_velocity_14(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void PhysicsObject::set_velocity(LVector3f const &vel)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"vel", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setVelocity", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setVelocity", &param1));
                if(!PyErr_Occurred())
                {
                    LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "PhysicsObject.setVelocity", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_velocity(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PhysicsObject.setVelocity() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PhysicsObject::set_velocity(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setVelocity", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_velocity((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsObject.setVelocity() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setVelocity() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setVelocity(non-const PhysicsObject this, const Vec3 vel)\n"
          "setVelocity(non-const PhysicsObject this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_set_velocity_14_comment =
    "C++ Interface:\n"
    "setVelocity(non-const PhysicsObject this, const Vec3 vel)\n"
    "setVelocity(non-const PhysicsObject this, float x, float y, float z)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_velocity\n"
    "//      Access : Public\n"
    "// Description : Vector velocity assignment\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_velocity\n"
    "//      Access : Public\n"
    "// Description : Piecewise velocity assignment\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_set_velocity_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector3f PhysicsObject::get_velocity(void) const
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_get_velocity_15(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVector3f PhysicsObject::get_velocity(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getVelocity", key_word_list));
        else
            (PyArg_Parse(args, ":getVelocity"));
        if(!PyErr_Occurred())
        {
            LVector3f result = ((const PhysicsObject*)local_this)->get_velocity();
            LVector3f *return_value = new LVector3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVelocity(const PhysicsObject this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_get_velocity_15_comment =
    "C++ Interface:\n"
    "getVelocity(const PhysicsObject this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_velocity\n"
    "//      Access : Public\n"
    "// Description : Velocity Query per second\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_get_velocity_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector3f PhysicsObject::get_implicit_velocity(void) const
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_get_implicit_velocity_16(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVector3f PhysicsObject::get_implicit_velocity(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getImplicitVelocity", key_word_list));
        else
            (PyArg_Parse(args, ":getImplicitVelocity"));
        if(!PyErr_Occurred())
        {
            LVector3f result = ((const PhysicsObject*)local_this)->get_implicit_velocity();
            LVector3f *return_value = new LVector3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getImplicitVelocity(const PhysicsObject this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_get_implicit_velocity_16_comment =
    "C++ Interface:\n"
    "getImplicitVelocity(const PhysicsObject this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_implicit_velocity\n"
    "//      Access : Public\n"
    "// Description : Velocity Query over the last dt\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_get_implicit_velocity_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PhysicsObject::add_torque(LRotationf const &torque)
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_add_torque_17(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PhysicsObject::add_torque(LRotationf const &torque)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"torque", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addTorque", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addTorque", &param1));
            if(!PyErr_Occurred())
            {
                LRotationf *param1_this = (LRotationf *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LRotationf, 1, "PhysicsObject.addTorque", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_torque(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsObject.addTorque() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addTorque(non-const PhysicsObject this, const LRotationf torque)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_add_torque_17_comment =
    "C++ Interface:\n"
    "addTorque(non-const PhysicsObject this, const LRotationf torque)\n"
    "\n"
    "// Global instantanious forces\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : add_torque\n"
    "//      Access : Public\n"
    "// Description : Adds an torque force (i.e. an instantanious change\n"
    "//               in velocity).  This is a quicker way to get the \n"
    "//               angular velocity, add a vector to it and set that\n"
    "//               value to be the new angular velocity.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_add_torque_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PhysicsObject::add_impulse(LVector3f const &impulse)
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_add_impulse_18(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PhysicsObject::add_impulse(LVector3f const &impulse)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"impulse", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addImpulse", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addImpulse", &param1));
            if(!PyErr_Occurred())
            {
                LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "PhysicsObject.addImpulse", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_impulse(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsObject.addImpulse() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addImpulse(non-const PhysicsObject this, const Vec3 impulse)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_add_impulse_18_comment =
    "C++ Interface:\n"
    "addImpulse(non-const PhysicsObject this, const Vec3 impulse)\n"
    "\n"
    "// Global instantanious forces\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : add_impulse\n"
    "//      Access : Public\n"
    "// Description : Adds an impulse force (i.e. an instantanious change\n"
    "//               in velocity).  This is a quicker way to get the \n"
    "//               velocity, add a vector to it and set that value to\n"
    "//               be the new velocity.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_add_impulse_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void PhysicsObject::add_impact(LPoint3f const &offset_from_center_of_mass, LVector3f const &impulse)
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_add_impact_19(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void PhysicsObject::add_impact(LPoint3f const &offset_from_center_of_mass, LVector3f const &impulse)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"offset_from_center_of_mass", (char *)"impulse", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:addImpact", key_word_list, &param1, &param2))
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "PhysicsObject.addImpact", 1, coerced_ptr, report_errors);
LVector3f *param2_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3f, 2, "PhysicsObject.addImpact", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    (local_this)->add_impact(*param1_this, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsObject.addImpact() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addImpact(non-const PhysicsObject this, const Point3 offset_from_center_of_mass, const Vec3 impulse)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_add_impact_19_comment =
    "C++ Interface:\n"
    "addImpact(non-const PhysicsObject this, const Point3 offset_from_center_of_mass, const Vec3 impulse)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : add_impact\n"
    "//      Access : Public\n"
    "// Description : Adds an impulse and/or torque (i.e. an instantanious\n"
    "//               change in velocity) based on how well the offset and\n"
    "//               impulse align with the center of mass (aka position).\n"
    "//               If you wanted to immitate this function you could\n"
    "//               work out the impulse and torque and call add_impulse\n"
    "//               and add_torque respectively.\n"
    "//               offset and force are in global (or parent) coordinates.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_add_impact_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PhysicsObject::add_local_torque(LRotationf const &torque)
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_add_local_torque_20(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PhysicsObject::add_local_torque(LRotationf const &torque)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"torque", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addLocalTorque", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addLocalTorque", &param1));
            if(!PyErr_Occurred())
            {
                LRotationf *param1_this = (LRotationf *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LRotationf, 1, "PhysicsObject.addLocalTorque", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_local_torque(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsObject.addLocalTorque() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addLocalTorque(non-const PhysicsObject this, const LRotationf torque)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_add_local_torque_20_comment =
    "C++ Interface:\n"
    "addLocalTorque(non-const PhysicsObject this, const LRotationf torque)\n"
    "\n"
    "// Local instantanious forces\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : add_local_torque\n"
    "//      Access : Public\n"
    "// Description : Adds an torque force (i.e. an instantanious change\n"
    "//               in velocity).  This is a quicker way to get the \n"
    "//               angular velocity, add a vector to it and set that\n"
    "//               value to be the new angular velocity.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_add_local_torque_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PhysicsObject::add_local_impulse(LVector3f const &impulse)
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_add_local_impulse_21(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PhysicsObject::add_local_impulse(LVector3f const &impulse)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"impulse", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addLocalImpulse", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addLocalImpulse", &param1));
            if(!PyErr_Occurred())
            {
                LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "PhysicsObject.addLocalImpulse", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_local_impulse(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsObject.addLocalImpulse() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addLocalImpulse(non-const PhysicsObject this, const Vec3 impulse)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_add_local_impulse_21_comment =
    "C++ Interface:\n"
    "addLocalImpulse(non-const PhysicsObject this, const Vec3 impulse)\n"
    "\n"
    "// Local instantanious forces\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : add_local_impulse\n"
    "//      Access : Public\n"
    "// Description : Adds an impulse force (i.e. an instantanious change\n"
    "//               in velocity).  This is a quicker way to get the \n"
    "//               velocity, add a vector to it and set that value to\n"
    "//               be the new velocity.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_add_local_impulse_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void PhysicsObject::add_local_impact(LPoint3f const &offset_from_center_of_mass, LVector3f const &impulse)
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_add_local_impact_22(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void PhysicsObject::add_local_impact(LPoint3f const &offset_from_center_of_mass, LVector3f const &impulse)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"offset_from_center_of_mass", (char *)"impulse", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:addLocalImpact", key_word_list, &param1, &param2))
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "PhysicsObject.addLocalImpact", 1, coerced_ptr, report_errors);
LVector3f *param2_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3f, 2, "PhysicsObject.addLocalImpact", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    (local_this)->add_local_impact(*param1_this, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsObject.addLocalImpact() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addLocalImpact(non-const PhysicsObject this, const Point3 offset_from_center_of_mass, const Vec3 impulse)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_add_local_impact_22_comment =
    "C++ Interface:\n"
    "addLocalImpact(non-const PhysicsObject this, const Point3 offset_from_center_of_mass, const Vec3 impulse)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : add_local_impact\n"
    "//      Access : Public\n"
    "// Description : Adds an impulse and/or torque (i.e. an instantanious\n"
    "//               change in velocity) based on how well the offset and\n"
    "//               impulse align with the center of mass (aka position).\n"
    "//               If you wanted to immitate this function you could\n"
    "//               work out the impulse and torque and call add_impulse\n"
    "//               and add_torque respectively.\n"
    "//               offset and force are in local coordinates.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_add_local_impact_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PhysicsObject::set_terminal_velocity(float tv)
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_set_terminal_velocity_23(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PhysicsObject::set_terminal_velocity(float tv)
        double param1;
        static char * key_word_list[] = {(char *)"tv", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setTerminalVelocity", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setTerminalVelocity", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_terminal_velocity((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PhysicsObject.setTerminalVelocity() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTerminalVelocity(non-const PhysicsObject this, float tv)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_set_terminal_velocity_23_comment =
    "C++ Interface:\n"
    "setTerminalVelocity(non-const PhysicsObject this, float tv)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_terminal_velocity\n"
    "//      Access : Public\n"
    "// Description : tv assignment\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_set_terminal_velocity_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float PhysicsObject::get_terminal_velocity(void) const
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_get_terminal_velocity_24(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float PhysicsObject::get_terminal_velocity(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTerminalVelocity", key_word_list));
        else
            (PyArg_Parse(args, ":getTerminalVelocity"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const PhysicsObject*)local_this)->get_terminal_velocity();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTerminalVelocity(const PhysicsObject this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_get_terminal_velocity_24_comment =
    "C++ Interface:\n"
    "getTerminalVelocity(const PhysicsObject this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_terminal_velocity\n"
    "//      Access : Public\n"
    "// Description : tv query\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_get_terminal_velocity_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PhysicsObject::set_oriented(bool flag)
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_set_oriented_25(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PhysicsObject::set_oriented(bool flag)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"flag", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setOriented", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setOriented", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_oriented((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PhysicsObject.setOriented() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setOriented(non-const PhysicsObject this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_set_oriented_25_comment =
    "C++ Interface:\n"
    "setOriented(non-const PhysicsObject this, bool flag)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_oriented\n"
    "//      Access : Public\n"
    "// Description : Set flag to determine whether this object should do\n"
    "//               any rotation or orientation calculations.  Optimization.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_set_oriented_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PhysicsObject::get_oriented(void) const
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_get_oriented_26(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool PhysicsObject::get_oriented(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOriented", key_word_list));
        else
            (PyArg_Parse(args, ":getOriented"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PhysicsObject*)local_this)->get_oriented();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOriented(const PhysicsObject this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_get_oriented_26_comment =
    "C++ Interface:\n"
    "getOriented(const PhysicsObject this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_oriented\n"
    "//      Access : Public\n"
    "// Description : See set_oriented().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_get_oriented_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PhysicsObject::set_orientation(LOrientationf const &orientation)
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_set_orientation_27(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PhysicsObject::set_orientation(LOrientationf const &orientation)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"orientation", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setOrientation", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setOrientation", &param1));
            if(!PyErr_Occurred())
            {
                LOrientationf *param1_this = (LOrientationf *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LOrientationf, 1, "PhysicsObject.setOrientation", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_orientation(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsObject.setOrientation() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setOrientation(non-const PhysicsObject this, const LOrientationf orientation)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_set_orientation_27_comment =
    "C++ Interface:\n"
    "setOrientation(non-const PhysicsObject this, const LOrientationf orientation)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_orientation\n"
    "//      Access : Public\n"
    "// Description :\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_set_orientation_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LOrientationf PhysicsObject::get_orientation(void) const
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_get_orientation_28(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LOrientationf PhysicsObject::get_orientation(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOrientation", key_word_list));
        else
            (PyArg_Parse(args, ":getOrientation"));
        if(!PyErr_Occurred())
        {
            LOrientationf result = ((const PhysicsObject*)local_this)->get_orientation();
            LOrientationf *return_value = new LOrientationf(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LOrientationf,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOrientation(const PhysicsObject this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_get_orientation_28_comment =
    "C++ Interface:\n"
    "getOrientation(const PhysicsObject this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_orientation\n"
    "//      Access : Public\n"
    "// Description : get current orientation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_get_orientation_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PhysicsObject::reset_orientation(LOrientationf const &orientation)
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_reset_orientation_29(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PhysicsObject::reset_orientation(LOrientationf const &orientation)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"orientation", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:resetOrientation", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:resetOrientation", &param1));
            if(!PyErr_Occurred())
            {
                LOrientationf *param1_this = (LOrientationf *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LOrientationf, 1, "PhysicsObject.resetOrientation", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->reset_orientation(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsObject.resetOrientation() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetOrientation(non-const PhysicsObject this, const LOrientationf orientation)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_reset_orientation_29_comment =
    "C++ Interface:\n"
    "resetOrientation(non-const PhysicsObject this, const LOrientationf orientation)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : reset_orientation\n"
    "//      Access : Public\n"
    "// Description : set the orientation while clearing the rotation\n"
    "//               velocity.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_reset_orientation_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PhysicsObject::set_rotation(LRotationf const &rotation)
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_set_rotation_30(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PhysicsObject::set_rotation(LRotationf const &rotation)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"rotation", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setRotation", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setRotation", &param1));
            if(!PyErr_Occurred())
            {
                LRotationf *param1_this = (LRotationf *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LRotationf, 1, "PhysicsObject.setRotation", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_rotation(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsObject.setRotation() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRotation(non-const PhysicsObject this, const LRotationf rotation)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_set_rotation_30_comment =
    "C++ Interface:\n"
    "setRotation(non-const PhysicsObject this, const LRotationf rotation)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_rotation\n"
    "//      Access : Public\n"
    "// Description : set rotation as a quaternion delta per second.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_set_rotation_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LRotationf PhysicsObject::get_rotation(void) const
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_get_rotation_31(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LRotationf PhysicsObject::get_rotation(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRotation", key_word_list));
        else
            (PyArg_Parse(args, ":getRotation"));
        if(!PyErr_Occurred())
        {
            LRotationf result = ((const PhysicsObject*)local_this)->get_rotation();
            LRotationf *return_value = new LRotationf(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LRotationf,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRotation(const PhysicsObject this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_get_rotation_31_comment =
    "C++ Interface:\n"
    "getRotation(const PhysicsObject this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_rotation\n"
    "//      Access : Public\n"
    "// Description : get rotation per second.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_get_rotation_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual LMatrix4f PhysicsObject::get_inertial_tensor(void) const
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_get_inertial_tensor_32(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual LMatrix4f PhysicsObject::get_inertial_tensor(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInertialTensor", key_word_list));
        else
            (PyArg_Parse(args, ":getInertialTensor"));
        if(!PyErr_Occurred())
        {
            LMatrix4f result = ((const PhysicsObject*)local_this)->get_inertial_tensor();
            LMatrix4f *return_value = new LMatrix4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LMatrix4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInertialTensor(const PhysicsObject this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_get_inertial_tensor_32_comment =
    "C++ Interface:\n"
    "getInertialTensor(const PhysicsObject this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : get_inertial_tensor\n"
    "//       Access : Public\n"
    "//  Description : returns a transform matrix that represents the\n"
    "//                object's willingness to be forced.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_get_inertial_tensor_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual LMatrix4f PhysicsObject::get_lcs(void) const
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_get_lcs_33(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual LMatrix4f PhysicsObject::get_lcs(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLcs", key_word_list));
        else
            (PyArg_Parse(args, ":getLcs"));
        if(!PyErr_Occurred())
        {
            LMatrix4f result = ((const PhysicsObject*)local_this)->get_lcs();
            LMatrix4f *return_value = new LMatrix4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LMatrix4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLcs(const PhysicsObject this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_get_lcs_33_comment =
    "C++ Interface:\n"
    "getLcs(const PhysicsObject this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : get_lcs\n"
    "//       Access : Public\n"
    "//  Description : returns a transform matrix to this object's\n"
    "//                local coordinate system.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_get_lcs_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual PhysicsObject *PhysicsObject::make_copy(void) const
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_make_copy_34(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual PhysicsObject *PhysicsObject::make_copy(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":makeCopy", key_word_list));
        else
            (PyArg_Parse(args, ":makeCopy"));
        if(!PyErr_Occurred())
        {
            PhysicsObject *return_value = ((const PhysicsObject*)local_this)->make_copy();
            if (return_value != (PhysicsObject *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PhysicsObject,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeCopy(const PhysicsObject this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_make_copy_34_comment =
    "C++ Interface:\n"
    "makeCopy(const PhysicsObject this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : make_copy\n"
    "//       Access : Public, virtual\n"
    "//  Description : dynamic copy.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_make_copy_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void PhysicsObject::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_output_35(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void PhysicsObject::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PhysicsObject.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const PhysicsObject*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const PhysicsObject this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_output_35_comment =
    "C++ Interface:\n"
    "output(const PhysicsObject this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : output\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_output_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void PhysicsObject::write(ostream &out, unsigned int indent) const
 * virtual void PhysicsObject::write(ostream &out, unsigned int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_write_36(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void PhysicsObject::write(ostream &out, unsigned int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PhysicsObject.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const PhysicsObject*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void PhysicsObject::write(ostream &out, unsigned int indent) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PhysicsObject.write", 0, coerced_ptr, report_errors);
 PyObject *param2_uint = PyNumber_Long(param2);
                    if (!((param1_this == NULL)|| (param2_uint == NULL)))
                    {
                        ((const PhysicsObject*)local_this)->write(*param1_this, PyLong_AsUnsignedLong(param2_uint));
                         Py_XDECREF(param2_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const PhysicsObject this, non-const Ostream out)\n"
          "write(const PhysicsObject this, non-const Ostream out, unsigned int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_write_36_comment =
    "C++ Interface:\n"
    "write(const PhysicsObject this, non-const Ostream out)\n"
    "write(const PhysicsObject this, non-const Ostream out, unsigned int indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : write\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObject_write_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle PhysicsObject::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_PhysicsObject_get_class_type_37(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle PhysicsObject::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = PhysicsObject::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObject_get_class_type_37_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_PhysicsObject_get_class_type_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PhysicsObject::PhysicsObject(void)
 * PhysicsObject::PhysicsObject(PhysicsObject const &copy)
 *******************************************************************/
int  Dtool_Init_PhysicsObject(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-PhysicsObject::PhysicsObject(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PhysicsObject", key_word_list))
            {
                PhysicsObject *return_value = new PhysicsObject();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PhysicsObject,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-PhysicsObject::PhysicsObject(PhysicsObject const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PhysicsObject", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PhysicsObject", &param0));
                if(!PyErr_Occurred())
                {
                    PhysicsObject *param0_this = (PhysicsObject *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PhysicsObject, 0, "PhysicsObject.PhysicsObject", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        PhysicsObject *return_value = new PhysicsObject(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PhysicsObject,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PhysicsObject() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PhysicsObject()\n"
          "PhysicsObject(const PhysicsObject copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PhysicsObject(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PhysicsObject)
    {
        printf("PhysicsObject ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PhysicsObject * local_this = (PhysicsObject *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PhysicsObject)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PhysicsObject(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PhysicsObject)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (PhysicsObject*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (PhysicsObject*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (PhysicsObject*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PhysicsObjectCollection 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void PhysicsObjectCollection::operator =(PhysicsObjectCollection const &copy)
 *******************************************************************/
static PyObject *Dtool_PhysicsObjectCollection_operator_40(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObjectCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObjectCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PhysicsObjectCollection::operator =(PhysicsObjectCollection const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                PhysicsObjectCollection *param1_this = (PhysicsObjectCollection *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PhysicsObjectCollection, 1, "PhysicsObjectCollection.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    PhysicsObjectCollection *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_PhysicsObjectCollection,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsObjectCollection.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const PhysicsObjectCollection this, const PhysicsObjectCollection copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObjectCollection_operator_40_comment =
    "C++ Interface:\n"
    "assign(non-const PhysicsObjectCollection this, const PhysicsObjectCollection copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PhysicsObjectCollection::Copy Assignment Operator\n"
    "//       Access: Published\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObjectCollection_operator_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PhysicsObjectCollection::add_physics_object(PointerTo< PhysicsObject > physics_object)
 *******************************************************************/
static PyObject *Dtool_PhysicsObjectCollection_add_physics_object_42(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObjectCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObjectCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PhysicsObjectCollection::add_physics_object(PointerTo< PhysicsObject > physics_object)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"physics_object", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addPhysicsObject", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addPhysicsObject", &param1));
            if(!PyErr_Occurred())
            {
                PhysicsObject *param1_this = (PhysicsObject *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PhysicsObject, 1, "PhysicsObjectCollection.addPhysicsObject", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_physics_object(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsObjectCollection.addPhysicsObject() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addPhysicsObject(non-const PhysicsObjectCollection this, const PhysicsObject physics_object)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObjectCollection_add_physics_object_42_comment =
    "C++ Interface:\n"
    "addPhysicsObject(non-const PhysicsObjectCollection this, const PhysicsObject physics_object)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PhysicsObjectCollection::add_physics_object\n"
    "//       Access: Published\n"
    "//  Description: Adds a new PhysicsObject to the collection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObjectCollection_add_physics_object_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool PhysicsObjectCollection::remove_physics_object(PointerTo< PhysicsObject > physics_object)
 *******************************************************************/
static PyObject *Dtool_PhysicsObjectCollection_remove_physics_object_43(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObjectCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObjectCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool PhysicsObjectCollection::remove_physics_object(PointerTo< PhysicsObject > physics_object)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"physics_object", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removePhysicsObject", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removePhysicsObject", &param1));
            if(!PyErr_Occurred())
            {
                PhysicsObject *param1_this = (PhysicsObject *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PhysicsObject, 1, "PhysicsObjectCollection.removePhysicsObject", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->remove_physics_object(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsObjectCollection.removePhysicsObject() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removePhysicsObject(non-const PhysicsObjectCollection this, const PhysicsObject physics_object)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObjectCollection_remove_physics_object_43_comment =
    "C++ Interface:\n"
    "removePhysicsObject(non-const PhysicsObjectCollection this, const PhysicsObject physics_object)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PhysicsObjectCollection::remove_physics_object\n"
    "//       Access: Published\n"
    "//  Description: Removes the indicated PhysicsObject from the collection.\n"
    "//               Returns true if the physics_object was removed, false if it was\n"
    "//               not a member of the collection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObjectCollection_remove_physics_object_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PhysicsObjectCollection::add_physics_objects_from(PhysicsObjectCollection const &other)
 *******************************************************************/
static PyObject *Dtool_PhysicsObjectCollection_add_physics_objects_from_44(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObjectCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObjectCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PhysicsObjectCollection::add_physics_objects_from(PhysicsObjectCollection const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addPhysicsObjectsFrom", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addPhysicsObjectsFrom", &param1));
            if(!PyErr_Occurred())
            {
                PhysicsObjectCollection *param1_this = (PhysicsObjectCollection *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PhysicsObjectCollection, 1, "PhysicsObjectCollection.addPhysicsObjectsFrom", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_physics_objects_from(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsObjectCollection.addPhysicsObjectsFrom() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addPhysicsObjectsFrom(non-const PhysicsObjectCollection this, const PhysicsObjectCollection other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObjectCollection_add_physics_objects_from_44_comment =
    "C++ Interface:\n"
    "addPhysicsObjectsFrom(non-const PhysicsObjectCollection this, const PhysicsObjectCollection other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PhysicsObjectCollection::add_physics_objects_from\n"
    "//       Access: Published\n"
    "//  Description: Adds all the PhysicsObjects indicated in the other\n"
    "//               collection to this collection.  The other \n"
    "//               physics_objects are simply appended to the end of \n"
    "//               the physics_objects in this list;\n"
    "//               duplicates are not automatically removed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObjectCollection_add_physics_objects_from_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PhysicsObjectCollection::remove_physics_objects_from(PhysicsObjectCollection const &other)
 *******************************************************************/
static PyObject *Dtool_PhysicsObjectCollection_remove_physics_objects_from_45(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObjectCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObjectCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PhysicsObjectCollection::remove_physics_objects_from(PhysicsObjectCollection const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removePhysicsObjectsFrom", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removePhysicsObjectsFrom", &param1));
            if(!PyErr_Occurred())
            {
                PhysicsObjectCollection *param1_this = (PhysicsObjectCollection *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PhysicsObjectCollection, 1, "PhysicsObjectCollection.removePhysicsObjectsFrom", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->remove_physics_objects_from(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsObjectCollection.removePhysicsObjectsFrom() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removePhysicsObjectsFrom(non-const PhysicsObjectCollection this, const PhysicsObjectCollection other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObjectCollection_remove_physics_objects_from_45_comment =
    "C++ Interface:\n"
    "removePhysicsObjectsFrom(non-const PhysicsObjectCollection this, const PhysicsObjectCollection other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PhysicsObjectCollection::remove_physics_objects_from\n"
    "//       Access: Published\n"
    "//  Description: Removes from this collection all of the PhysicsObjects\n"
    "//               listed in the other collection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObjectCollection_remove_physics_objects_from_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PhysicsObjectCollection::remove_duplicate_physics_objects(void)
 *******************************************************************/
static PyObject *Dtool_PhysicsObjectCollection_remove_duplicate_physics_objects_46(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObjectCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObjectCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PhysicsObjectCollection::remove_duplicate_physics_objects(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":removeDuplicatePhysicsObjects", key_word_list));
        else
            (PyArg_Parse(args, ":removeDuplicatePhysicsObjects"));
        if(!PyErr_Occurred())
        {
            (local_this)->remove_duplicate_physics_objects();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PhysicsObjectCollection.removeDuplicatePhysicsObjects() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeDuplicatePhysicsObjects(non-const PhysicsObjectCollection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObjectCollection_remove_duplicate_physics_objects_46_comment =
    "C++ Interface:\n"
    "removeDuplicatePhysicsObjects(non-const PhysicsObjectCollection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PhysicsObjectCollection::remove_duplicate_physics_objects\n"
    "//       Access: Published\n"
    "//  Description: Removes any duplicate entries of the same PhysicsObjects\n"
    "//               on this collection.  If a PhysicsObject appears multiple\n"
    "//               times, the first appearance is retained; subsequent\n"
    "//               appearances are removed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObjectCollection_remove_duplicate_physics_objects_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool PhysicsObjectCollection::has_physics_object(PointerTo< PhysicsObject > physics_object) const
 *******************************************************************/
static PyObject *Dtool_PhysicsObjectCollection_has_physics_object_47(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObjectCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObjectCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool PhysicsObjectCollection::has_physics_object(PointerTo< PhysicsObject > physics_object) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"physics_object", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:hasPhysicsObject", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:hasPhysicsObject", &param1));
            if(!PyErr_Occurred())
            {
                PhysicsObject *param1_this = (PhysicsObject *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PhysicsObject, 1, "PhysicsObjectCollection.hasPhysicsObject", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const PhysicsObjectCollection*)local_this)->has_physics_object(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasPhysicsObject(const PhysicsObjectCollection this, const PhysicsObject physics_object)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObjectCollection_has_physics_object_47_comment =
    "C++ Interface:\n"
    "hasPhysicsObject(const PhysicsObjectCollection this, const PhysicsObject physics_object)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PhysicsObjectCollection::has_physics_object\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the indicated PhysicsObject appears in\n"
    "//               this collection, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObjectCollection_has_physics_object_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PhysicsObjectCollection::clear(void)
 *******************************************************************/
static PyObject *Dtool_PhysicsObjectCollection_clear_48(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObjectCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObjectCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PhysicsObjectCollection::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PhysicsObjectCollection.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const PhysicsObjectCollection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObjectCollection_clear_48_comment =
    "C++ Interface:\n"
    "clear(non-const PhysicsObjectCollection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PhysicsObjectCollection::clear\n"
    "//       Access: Published\n"
    "//  Description: Removes all PhysicsObjects from the collection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObjectCollection_clear_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool PhysicsObjectCollection::is_empty(void) const
 *******************************************************************/
static PyObject *Dtool_PhysicsObjectCollection_is_empty_49(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObjectCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObjectCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool PhysicsObjectCollection::is_empty(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isEmpty", key_word_list));
        else
            (PyArg_Parse(args, ":isEmpty"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const PhysicsObjectCollection*)local_this)->is_empty();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isEmpty(const PhysicsObjectCollection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObjectCollection_is_empty_49_comment =
    "C++ Interface:\n"
    "isEmpty(const PhysicsObjectCollection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PhysicsObjectCollection::is_empty\n"
    "//       Access: Published\n"
    "//  Description: Returns true if there are no PhysicsObjects in the\n"
    "//               collection, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObjectCollection_is_empty_49_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int PhysicsObjectCollection::get_num_physics_objects(void) const
 *******************************************************************/
static PyObject *Dtool_PhysicsObjectCollection_get_num_physics_objects_50(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObjectCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObjectCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int PhysicsObjectCollection::get_num_physics_objects(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumPhysicsObjects", key_word_list));
        else
            (PyArg_Parse(args, ":getNumPhysicsObjects"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PhysicsObjectCollection*)local_this)->get_num_physics_objects();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumPhysicsObjects(const PhysicsObjectCollection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObjectCollection_get_num_physics_objects_50_comment =
    "C++ Interface:\n"
    "getNumPhysicsObjects(const PhysicsObjectCollection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PhysicsObjectCollection::get_num_physics_objects\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of PhysicsObjects in the collection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObjectCollection_get_num_physics_objects_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< PhysicsObject > PhysicsObjectCollection::get_physics_object(int index) const
 *******************************************************************/
static PyObject *Dtool_PhysicsObjectCollection_get_physics_object_51(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObjectCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObjectCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PointerTo< PhysicsObject > PhysicsObjectCollection::get_physics_object(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getPhysicsObject", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getPhysicsObject", &param1));
        if(!PyErr_Occurred())
        {
            PointerTo< PhysicsObject > return_value = ((const PhysicsObjectCollection*)local_this)->get_physics_object((int)param1);
            if (return_value != (PhysicsObject *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_PhysicsObject,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPhysicsObject(const PhysicsObjectCollection this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObjectCollection_get_physics_object_51_comment =
    "C++ Interface:\n"
    "getPhysicsObject(const PhysicsObjectCollection this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PhysicsObjectCollection::get_physics_object\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth PhysicsObject in the collection.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObjectCollection_get_physics_object_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< PhysicsObject > PhysicsObjectCollection::operator [](int index) const
 *******************************************************************/
static PyObject *Dtool_PhysicsObjectCollection_operator_52(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObjectCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObjectCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PointerTo< PhysicsObject > PhysicsObjectCollection::operator [](int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__getitem__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__getitem__", &param1));
        if(!PyErr_Occurred())
        {
            if (((int)param1) < 0 || ((int)param1) >= ((const PhysicsObjectCollection*)local_this)->size()) {
              PyErr_SetString(PyExc_IndexError, "Out of bounds.");
              return NULL;
            }
            PointerTo< PhysicsObject > return_value = ((const PhysicsObjectCollection*)local_this)->operator []((int)param1);
            if (return_value != (PhysicsObject *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_PhysicsObject,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__getitem__(const PhysicsObjectCollection this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObjectCollection_operator_52_comment =
    "C++ Interface:\n"
    "__getitem__(const PhysicsObjectCollection this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PhysicsObjectCollection::operator []\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth PhysicsObject in the collection.  This is\n"
    "//               the same as get_physics_object(), but it may be a more\n"
    "//               convenient way to access it.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObjectCollection_operator_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int PhysicsObjectCollection::size(void) const
 *******************************************************************/
static PyObject *Dtool_PhysicsObjectCollection_size_53(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObjectCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObjectCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int PhysicsObjectCollection::size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list));
        else
            (PyArg_Parse(args, ":size"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PhysicsObjectCollection*)local_this)->size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(const PhysicsObjectCollection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObjectCollection_size_53_comment =
    "C++ Interface:\n"
    "size(const PhysicsObjectCollection this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PhysicsObjectCollection::size\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of physics objects in the\n"
    "//               collection.  This is the same thing as\n"
    "//               get_num_physics_objects().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObjectCollection_size_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PhysicsObjectCollection::operator +=(PhysicsObjectCollection const &other)
 *******************************************************************/
static PyObject *Dtool_PhysicsObjectCollection_operator_54(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObjectCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObjectCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PhysicsObjectCollection::operator +=(PhysicsObjectCollection const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__iadd__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__iadd__", &param1));
            if(!PyErr_Occurred())
            {
                PhysicsObjectCollection *param1_this = (PhysicsObjectCollection *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PhysicsObjectCollection, 1, "PhysicsObjectCollection.__iadd__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator +=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsObjectCollection.__iadd__() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__iadd__(non-const PhysicsObjectCollection this, const PhysicsObjectCollection other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObjectCollection_operator_54_comment =
    "C++ Interface:\n"
    "__iadd__(non-const PhysicsObjectCollection this, const PhysicsObjectCollection other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PhysicsObjectCollection::operator +=\n"
    "//       Access: Published\n"
    "//  Description: Appends the other list onto the end of this one.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObjectCollection_operator_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PhysicsObjectCollection PhysicsObjectCollection::operator +(PhysicsObjectCollection const &other) const
 *******************************************************************/
static PyObject *Dtool_PhysicsObjectCollection_operator_55(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObjectCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObjectCollection,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline PhysicsObjectCollection PhysicsObjectCollection::operator +(PhysicsObjectCollection const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__add__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__add__", &param1));
            if(!PyErr_Occurred())
            {
                PhysicsObjectCollection *param1_this = (PhysicsObjectCollection *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PhysicsObjectCollection, 1, "PhysicsObjectCollection.__add__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    PhysicsObjectCollection result = ((const PhysicsObjectCollection*)local_this)->operator +(*param1_this);
                    PhysicsObjectCollection *return_value = new PhysicsObjectCollection(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_PhysicsObjectCollection,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__add__(const PhysicsObjectCollection this, const PhysicsObjectCollection other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObjectCollection_operator_55_comment =
    "C++ Interface:\n"
    "__add__(const PhysicsObjectCollection this, const PhysicsObjectCollection other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PhysicsObjectCollection::operator +\n"
    "//       Access: Published\n"
    "//  Description: Returns a PhysicsObjectCollection representing the\n"
    "//               concatenation of the two lists.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObjectCollection_operator_55_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PhysicsObjectCollection::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_PhysicsObjectCollection_output_56(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObjectCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObjectCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void PhysicsObjectCollection::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PhysicsObjectCollection.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const PhysicsObjectCollection*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const PhysicsObjectCollection this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObjectCollection_output_56_comment =
    "C++ Interface:\n"
    "output(const PhysicsObjectCollection this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PhysicsObjectCollection::output\n"
    "//       Access: Published\n"
    "//  Description: Writes a brief one-line description of the\n"
    "//               PhysicsObjectCollection to the indicated output stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObjectCollection_output_56_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PhysicsObjectCollection::write(ostream &out, int indent_level) const
 * void PhysicsObjectCollection::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_PhysicsObjectCollection_write_57(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsObjectCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObjectCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void PhysicsObjectCollection::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PhysicsObjectCollection.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const PhysicsObjectCollection*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void PhysicsObjectCollection::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PhysicsObjectCollection.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const PhysicsObjectCollection*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const PhysicsObjectCollection this, non-const Ostream out)\n"
          "write(const PhysicsObjectCollection this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsObjectCollection_write_57_comment =
    "C++ Interface:\n"
    "write(const PhysicsObjectCollection this, non-const Ostream out)\n"
    "write(const PhysicsObjectCollection this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PhysicsObjectCollection::write\n"
    "//       Access: Published\n"
    "//  Description: Writes a complete multi-line description of the\n"
    "//               PhysicsObjectCollection to the indicated output stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsObjectCollection_write_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PhysicsObjectCollection::PhysicsObjectCollection(void)
 * PhysicsObjectCollection::PhysicsObjectCollection(PhysicsObjectCollection const &copy)
 *******************************************************************/
int  Dtool_Init_PhysicsObjectCollection(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-PhysicsObjectCollection::PhysicsObjectCollection(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PhysicsObjectCollection", key_word_list))
            {
                PhysicsObjectCollection *return_value = new PhysicsObjectCollection();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PhysicsObjectCollection,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-PhysicsObjectCollection::PhysicsObjectCollection(PhysicsObjectCollection const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PhysicsObjectCollection", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PhysicsObjectCollection", &param0));
                if(!PyErr_Occurred())
                {
                    PhysicsObjectCollection *param0_this = (PhysicsObjectCollection *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PhysicsObjectCollection, 0, "PhysicsObjectCollection.PhysicsObjectCollection", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        PhysicsObjectCollection *return_value = new PhysicsObjectCollection(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PhysicsObjectCollection,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PhysicsObjectCollection() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PhysicsObjectCollection()\n"
          "PhysicsObjectCollection(const PhysicsObjectCollection copy)\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_PhysicsObjectCollection_get_physics_objects(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumPhysicsObjects", "getPhysicsObject");
}
inline void  * Dtool_UpcastInterface_PhysicsObjectCollection(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PhysicsObjectCollection)
    {
        printf("PhysicsObjectCollection ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PhysicsObjectCollection * local_this = (PhysicsObjectCollection *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PhysicsObjectCollection)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PhysicsObjectCollection(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PhysicsObjectCollection)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. BaseForce 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline bool BaseForce::get_active(void) const
 *******************************************************************/
static PyObject *Dtool_BaseForce_get_active_59(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool BaseForce::get_active(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getActive", key_word_list));
        else
            (PyArg_Parse(args, ":getActive"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const BaseForce*)local_this)->get_active();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getActive(const BaseForce this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseForce_get_active_59_comment =
    "C++ Interface:\n"
    "getActive(const BaseForce this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_active\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseForce_get_active_59_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void BaseForce::set_active(bool active)
 *******************************************************************/
static PyObject *Dtool_BaseForce_set_active_60(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void BaseForce::set_active(bool active)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"active", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setActive", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setActive", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_active((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call BaseForce.setActive() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setActive(non-const BaseForce this, bool active)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseForce_set_active_60_comment =
    "C++ Interface:\n"
    "setActive(non-const BaseForce this, bool active)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_active\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseForce_set_active_60_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool BaseForce::is_linear(void) const = 0
 *******************************************************************/
static PyObject *Dtool_BaseForce_is_linear_61(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual bool BaseForce::is_linear(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isLinear", key_word_list));
        else
            (PyArg_Parse(args, ":isLinear"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const BaseForce*)local_this)->is_linear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isLinear(const BaseForce this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseForce_is_linear_61_comment =
    "C++ Interface:\n"
    "isLinear(const BaseForce this)\n"
    "\n"
    "";
#else
static const char * Dtool_BaseForce_is_linear_61_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ForceNode *BaseForce::get_force_node(void) const
 *******************************************************************/
static PyObject *Dtool_BaseForce_get_force_node_62(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline ForceNode *BaseForce::get_force_node(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getForceNode", key_word_list));
        else
            (PyArg_Parse(args, ":getForceNode"));
        if(!PyErr_Occurred())
        {
            ForceNode *return_value = ((const BaseForce*)local_this)->get_force_node();
            if (return_value != (ForceNode *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_ForceNode,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getForceNode(const BaseForce this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseForce_get_force_node_62_comment =
    "C++ Interface:\n"
    "getForceNode(const BaseForce this)\n"
    "\n"
    "// Filename: baseForce.I\n"
    "// Created by:  charles (08Aug00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_force_node\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseForce_get_force_node_62_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NodePath BaseForce::get_force_node_path(void) const
 *******************************************************************/
static PyObject *Dtool_BaseForce_get_force_node_path_63(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NodePath BaseForce::get_force_node_path(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getForceNodePath", key_word_list));
        else
            (PyArg_Parse(args, ":getForceNodePath"));
        if(!PyErr_Occurred())
        {
            NodePath result = ((const BaseForce*)local_this)->get_force_node_path();
            NodePath *return_value = new NodePath(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getForceNodePath(const BaseForce this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseForce_get_force_node_path_63_comment =
    "C++ Interface:\n"
    "getForceNodePath(const BaseForce this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_force_node_path\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseForce_get_force_node_path_63_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void BaseForce::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_BaseForce_output_64(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void BaseForce::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BaseForce.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const BaseForce*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const BaseForce this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseForce_output_64_comment =
    "C++ Interface:\n"
    "output(const BaseForce this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : output\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseForce_output_64_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void BaseForce::write(ostream &out, int indent_level) const
 * virtual void BaseForce::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_BaseForce_write_65(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void BaseForce::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BaseForce.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BaseForce*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void BaseForce::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BaseForce.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BaseForce*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const BaseForce this, non-const Ostream out)\n"
          "write(const BaseForce this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseForce_write_65_comment =
    "C++ Interface:\n"
    "write(const BaseForce this, non-const Ostream out)\n"
    "write(const BaseForce this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : write\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseForce_write_65_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle BaseForce::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_BaseForce_get_class_type_66(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle BaseForce::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = BaseForce::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseForce_get_class_type_66_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_BaseForce_get_class_type_66_comment = NULL;
#endif

int  Dtool_Init_BaseForce(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (BaseForce)");
       return -1;
}
inline void  * Dtool_UpcastInterface_BaseForce(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_BaseForce)
    {
        printf("BaseForce ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    BaseForce * local_this = (BaseForce *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_BaseForce)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_BaseForce(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_BaseForce)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (BaseForce*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (BaseForce*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (BaseForce*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. LinearForce 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void LinearForce::set_amplitude(float const a)
 *******************************************************************/
static PyObject *Dtool_LinearForce_set_amplitude_68(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LinearForce::set_amplitude(float const a)
        double param1;
        static char * key_word_list[] = {(char *)"a", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setAmplitude", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setAmplitude", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_amplitude((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LinearForce.setAmplitude() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAmplitude(non-const LinearForce this, float a)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearForce_set_amplitude_68_comment =
    "C++ Interface:\n"
    "setAmplitude(non-const LinearForce this, float a)\n"
    "\n"
    "// Filename: linearForce.I\n"
    "// Created by:  charles (13Jun00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_amplitude\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LinearForce_set_amplitude_68_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LinearForce::set_mass_dependent(bool m)
 *******************************************************************/
static PyObject *Dtool_LinearForce_set_mass_dependent_69(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LinearForce::set_mass_dependent(bool m)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"m", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setMassDependent", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setMassDependent", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_mass_dependent((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LinearForce.setMassDependent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMassDependent(non-const LinearForce this, bool m)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearForce_set_mass_dependent_69_comment =
    "C++ Interface:\n"
    "setMassDependent(non-const LinearForce this, bool m)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_mass_Dependent\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LinearForce_set_mass_dependent_69_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float LinearForce::get_amplitude(void) const
 *******************************************************************/
static PyObject *Dtool_LinearForce_get_amplitude_70(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float LinearForce::get_amplitude(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAmplitude", key_word_list));
        else
            (PyArg_Parse(args, ":getAmplitude"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const LinearForce*)local_this)->get_amplitude();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAmplitude(const LinearForce this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearForce_get_amplitude_70_comment =
    "C++ Interface:\n"
    "getAmplitude(const LinearForce this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_amplitude\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LinearForce_get_amplitude_70_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool LinearForce::get_mass_dependent(void) const
 *******************************************************************/
static PyObject *Dtool_LinearForce_get_mass_dependent_71(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool LinearForce::get_mass_dependent(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMassDependent", key_word_list));
        else
            (PyArg_Parse(args, ":getMassDependent"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const LinearForce*)local_this)->get_mass_dependent();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMassDependent(const LinearForce this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearForce_get_mass_dependent_71_comment =
    "C++ Interface:\n"
    "getMassDependent(const LinearForce this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_mass_dependent\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LinearForce_get_mass_dependent_71_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LinearForce::set_vector_masks(bool x, bool y, bool z)
 *******************************************************************/
static PyObject *Dtool_LinearForce_set_vector_masks_72(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LinearForce::set_vector_masks(bool x, bool y, bool z)
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:setVectorMasks", key_word_list, &param1, &param2, &param3))
        {
            (local_this)->set_vector_masks((PyObject_IsTrue(param1)!=0), (PyObject_IsTrue(param2)!=0), (PyObject_IsTrue(param3)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LinearForce.setVectorMasks() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setVectorMasks(non-const LinearForce this, bool x, bool y, bool z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearForce_set_vector_masks_72_comment =
    "C++ Interface:\n"
    "setVectorMasks(non-const LinearForce this, bool x, bool y, bool z)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_vector_masks\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LinearForce_set_vector_masks_72_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector3f LinearForce::get_vector_masks(void)
 *******************************************************************/
static PyObject *Dtool_LinearForce_get_vector_masks_73(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline LVector3f LinearForce::get_vector_masks(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getVectorMasks", key_word_list));
        else
            (PyArg_Parse(args, ":getVectorMasks"));
        if(!PyErr_Occurred())
        {
            LVector3f result = (local_this)->get_vector_masks();
            LVector3f *return_value = new LVector3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LinearForce.getVectorMasks() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVectorMasks(non-const LinearForce this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearForce_get_vector_masks_73_comment =
    "C++ Interface:\n"
    "getVectorMasks(non-const LinearForce this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_vector_masks\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LinearForce_get_vector_masks_73_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LVector3f LinearForce::get_vector(PhysicsObject const *po)
 *******************************************************************/
static PyObject *Dtool_LinearForce_get_vector_74(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-LVector3f LinearForce::get_vector(PhysicsObject const *po)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"po", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getVector", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getVector", &param1));
            if(!PyErr_Occurred())
            {
                PhysicsObject *param1_this = (PhysicsObject *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PhysicsObject, 1, "LinearForce.getVector", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    LVector3f result = (local_this)->get_vector(param1_this);
                    LVector3f *return_value = new LVector3f(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,true, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LinearForce.getVector() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVector(non-const LinearForce this, const PhysicsObject po)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearForce_get_vector_74_comment =
    "C++ Interface:\n"
    "getVector(non-const LinearForce this, const PhysicsObject po)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_vector\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LinearForce_get_vector_74_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual LinearForce *LinearForce::make_copy(void) = 0
 *******************************************************************/
static PyObject *Dtool_LinearForce_make_copy_75(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual LinearForce *LinearForce::make_copy(void) = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":makeCopy", key_word_list));
        else
            (PyArg_Parse(args, ":makeCopy"));
        if(!PyErr_Occurred())
        {
            LinearForce *return_value = (local_this)->make_copy();
            if (return_value != (LinearForce *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_LinearForce,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LinearForce.makeCopy() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeCopy(non-const LinearForce this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearForce_make_copy_75_comment =
    "C++ Interface:\n"
    "makeCopy(non-const LinearForce this)\n"
    "\n"
    "";
#else
static const char * Dtool_LinearForce_make_copy_75_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void LinearForce::write(ostream &out, unsigned int indent) const
 * virtual void LinearForce::write(ostream &out, unsigned int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_LinearForce_write_76(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void LinearForce::write(ostream &out, unsigned int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "LinearForce.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const LinearForce*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void LinearForce::write(ostream &out, unsigned int indent) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "LinearForce.write", 0, coerced_ptr, report_errors);
 PyObject *param2_uint = PyNumber_Long(param2);
                    if (!((param1_this == NULL)|| (param2_uint == NULL)))
                    {
                        ((const LinearForce*)local_this)->write(*param1_this, PyLong_AsUnsignedLong(param2_uint));
                         Py_XDECREF(param2_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const LinearForce this, non-const Ostream out)\n"
          "write(const LinearForce this, non-const Ostream out, unsigned int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearForce_write_76_comment =
    "C++ Interface:\n"
    "write(const LinearForce this, non-const Ostream out)\n"
    "write(const LinearForce this, non-const Ostream out, unsigned int indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : write\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LinearForce_write_76_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle LinearForce::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_LinearForce_get_class_type_77(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle LinearForce::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = LinearForce::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearForce_get_class_type_77_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_LinearForce_get_class_type_77_comment = NULL;
#endif

int  Dtool_Init_LinearForce(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (LinearForce)");
       return -1;
}
inline void  * Dtool_UpcastInterface_LinearForce(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_LinearForce)
    {
        printf("LinearForce ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    LinearForce * local_this = (LinearForce *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_LinearForce)
        return local_this;
    if(requested_type == &Dtool_BaseForce)
        return ( BaseForce *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( BaseForce *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( BaseForce *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( BaseForce *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_LinearForce(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_LinearForce)
        return from_this;
    if(from_type == &Dtool_BaseForce)
    {
          BaseForce* other_this = (BaseForce*)from_this;
          return (LinearForce*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (LinearForce*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (LinearForce*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (LinearForce*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. AngularForce 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual AngularForce *AngularForce::make_copy(void) const = 0
 *******************************************************************/
static PyObject *Dtool_AngularForce_make_copy_79(PyObject *self, PyObject *args,PyObject *kwds) {
    AngularForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AngularForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual AngularForce *AngularForce::make_copy(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":makeCopy", key_word_list));
        else
            (PyArg_Parse(args, ":makeCopy"));
        if(!PyErr_Occurred())
        {
            AngularForce *return_value = ((const AngularForce*)local_this)->make_copy();
            if (return_value != (AngularForce *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_AngularForce,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeCopy(const AngularForce this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AngularForce_make_copy_79_comment =
    "C++ Interface:\n"
    "makeCopy(const AngularForce this)\n"
    "\n"
    "";
#else
static const char * Dtool_AngularForce_make_copy_79_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LRotationf AngularForce::get_quat(PhysicsObject const *po)
 *******************************************************************/
static PyObject *Dtool_AngularForce_get_quat_80(PyObject *self, PyObject *args,PyObject *kwds) {
    AngularForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AngularForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-LRotationf AngularForce::get_quat(PhysicsObject const *po)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"po", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getQuat", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getQuat", &param1));
            if(!PyErr_Occurred())
            {
                PhysicsObject *param1_this = (PhysicsObject *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PhysicsObject, 1, "AngularForce.getQuat", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    LRotationf result = (local_this)->get_quat(param1_this);
                    LRotationf *return_value = new LRotationf(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_LRotationf,true, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AngularForce.getQuat() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getQuat(non-const AngularForce this, const PhysicsObject po)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AngularForce_get_quat_80_comment =
    "C++ Interface:\n"
    "getQuat(non-const AngularForce this, const PhysicsObject po)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_quat\n"
    "//      Access : public\n"
    "// Description : access query\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AngularForce_get_quat_80_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void AngularForce::write(ostream &out, unsigned int indent) const
 * virtual void AngularForce::write(ostream &out, unsigned int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_AngularForce_write_81(PyObject *self, PyObject *args,PyObject *kwds) {
    AngularForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AngularForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void AngularForce::write(ostream &out, unsigned int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "AngularForce.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const AngularForce*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void AngularForce::write(ostream &out, unsigned int indent) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "AngularForce.write", 0, coerced_ptr, report_errors);
 PyObject *param2_uint = PyNumber_Long(param2);
                    if (!((param1_this == NULL)|| (param2_uint == NULL)))
                    {
                        ((const AngularForce*)local_this)->write(*param1_this, PyLong_AsUnsignedLong(param2_uint));
                         Py_XDECREF(param2_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const AngularForce this, non-const Ostream out)\n"
          "write(const AngularForce this, non-const Ostream out, unsigned int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AngularForce_write_81_comment =
    "C++ Interface:\n"
    "write(const AngularForce this, non-const Ostream out)\n"
    "write(const AngularForce this, non-const Ostream out, unsigned int indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : write\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AngularForce_write_81_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle AngularForce::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_AngularForce_get_class_type_82(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle AngularForce::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = AngularForce::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AngularForce_get_class_type_82_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_AngularForce_get_class_type_82_comment = NULL;
#endif

int  Dtool_Init_AngularForce(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (AngularForce)");
       return -1;
}
inline void  * Dtool_UpcastInterface_AngularForce(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_AngularForce)
    {
        printf("AngularForce ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    AngularForce * local_this = (AngularForce *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_AngularForce)
        return local_this;
    if(requested_type == &Dtool_BaseForce)
        return ( BaseForce *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( BaseForce *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( BaseForce *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( BaseForce *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_AngularForce(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_AngularForce)
        return from_this;
    if(from_type == &Dtool_BaseForce)
    {
          BaseForce* other_this = (BaseForce*)from_this;
          return (AngularForce*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (AngularForce*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (AngularForce*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (AngularForce*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. Physical 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline PhysicsManager *Physical::get_physics_manager(void) const
 *******************************************************************/
static PyObject *Dtool_Physical_get_physics_manager_85(PyObject *self, PyObject *args,PyObject *kwds) {
    Physical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Physical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PhysicsManager *Physical::get_physics_manager(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPhysicsManager", key_word_list));
        else
            (PyArg_Parse(args, ":getPhysicsManager"));
        if(!PyErr_Occurred())
        {
            PhysicsManager *return_value = ((const Physical*)local_this)->get_physics_manager();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_PhysicsManager,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPhysicsManager(const Physical this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Physical_get_physics_manager_85_comment =
    "C++ Interface:\n"
    "getPhysicsManager(const Physical this)\n"
    "\n"
    "// helpers\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_physics_manager\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Physical_get_physics_manager_85_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PhysicalNode *Physical::get_physical_node(void) const
 *******************************************************************/
static PyObject *Dtool_Physical_get_physical_node_86(PyObject *self, PyObject *args,PyObject *kwds) {
    Physical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Physical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PhysicalNode *Physical::get_physical_node(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPhysicalNode", key_word_list));
        else
            (PyArg_Parse(args, ":getPhysicalNode"));
        if(!PyErr_Occurred())
        {
            PhysicalNode *return_value = ((const Physical*)local_this)->get_physical_node();
            if (return_value != (PhysicalNode *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PhysicalNode,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPhysicalNode(const Physical this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Physical_get_physical_node_86_comment =
    "C++ Interface:\n"
    "getPhysicalNode(const Physical this)\n"
    "\n"
    "// helpers\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_physical_node\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Physical_get_physical_node_86_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NodePath Physical::get_physical_node_path(void) const
 *******************************************************************/
static PyObject *Dtool_Physical_get_physical_node_path_87(PyObject *self, PyObject *args,PyObject *kwds) {
    Physical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Physical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NodePath Physical::get_physical_node_path(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPhysicalNodePath", key_word_list));
        else
            (PyArg_Parse(args, ":getPhysicalNodePath"));
        if(!PyErr_Occurred())
        {
            NodePath result = ((const Physical*)local_this)->get_physical_node_path();
            NodePath *return_value = new NodePath(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPhysicalNodePath(const Physical this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Physical_get_physical_node_path_87_comment =
    "C++ Interface:\n"
    "getPhysicalNodePath(const Physical this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_physical_node_path\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Physical_get_physical_node_path_87_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PhysicsObject *Physical::get_phys_body(void) const
 *******************************************************************/
static PyObject *Dtool_Physical_get_phys_body_88(PyObject *self, PyObject *args,PyObject *kwds) {
    Physical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Physical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PhysicsObject *Physical::get_phys_body(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPhysBody", key_word_list));
        else
            (PyArg_Parse(args, ":getPhysBody"));
        if(!PyErr_Occurred())
        {
            PhysicsObject *return_value = ((const Physical*)local_this)->get_phys_body();
            if (return_value != (PhysicsObject *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PhysicsObject,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPhysBody(const Physical this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Physical_get_phys_body_88_comment =
    "C++ Interface:\n"
    "getPhysBody(const Physical this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_phys_body\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Physical_get_phys_body_88_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Physical::clear_linear_forces(void)
 *******************************************************************/
static PyObject *Dtool_Physical_clear_linear_forces_89(PyObject *self, PyObject *args,PyObject *kwds) {
    Physical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Physical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Physical::clear_linear_forces(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearLinearForces", key_word_list));
        else
            (PyArg_Parse(args, ":clearLinearForces"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_linear_forces();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Physical.clearLinearForces() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearLinearForces(non-const Physical this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Physical_clear_linear_forces_89_comment =
    "C++ Interface:\n"
    "clearLinearForces(non-const Physical this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : clear_linear_forces\n"
    "//      Access : Public\n"
    "// Description : Erases the linear force list\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Physical_clear_linear_forces_89_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Physical::clear_angular_forces(void)
 *******************************************************************/
static PyObject *Dtool_Physical_clear_angular_forces_90(PyObject *self, PyObject *args,PyObject *kwds) {
    Physical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Physical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Physical::clear_angular_forces(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearAngularForces", key_word_list));
        else
            (PyArg_Parse(args, ":clearAngularForces"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_angular_forces();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Physical.clearAngularForces() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearAngularForces(non-const Physical this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Physical_clear_angular_forces_90_comment =
    "C++ Interface:\n"
    "clearAngularForces(non-const Physical this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : clear_angular_forces\n"
    "//      Access : Public\n"
    "// Description : Erases the angular force list\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Physical_clear_angular_forces_90_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Physical::clear_physics_objects(void)
 *******************************************************************/
static PyObject *Dtool_Physical_clear_physics_objects_91(PyObject *self, PyObject *args,PyObject *kwds) {
    Physical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Physical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Physical::clear_physics_objects(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearPhysicsObjects", key_word_list));
        else
            (PyArg_Parse(args, ":clearPhysicsObjects"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_physics_objects();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Physical.clearPhysicsObjects() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearPhysicsObjects(non-const Physical this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Physical_clear_physics_objects_91_comment =
    "C++ Interface:\n"
    "clearPhysicsObjects(non-const Physical this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : clear_physics_objects\n"
    "//      Access : Public\n"
    "// Description : Erases the object list\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Physical_clear_physics_objects_91_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Physical::add_linear_force(LinearForce *f)
 *******************************************************************/
static PyObject *Dtool_Physical_add_linear_force_92(PyObject *self, PyObject *args,PyObject *kwds) {
    Physical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Physical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void Physical::add_linear_force(LinearForce *f)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"f", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addLinearForce", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addLinearForce", &param1));
            if(!PyErr_Occurred())
            {
                LinearForce *param1_this = (LinearForce *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LinearForce, 1, "Physical.addLinearForce", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_linear_force(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Physical.addLinearForce() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addLinearForce(non-const Physical this, non-const LinearForce f)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Physical_add_linear_force_92_comment =
    "C++ Interface:\n"
    "addLinearForce(non-const Physical this, non-const LinearForce f)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : add_linear_force\n"
    "//      Access : Public\n"
    "// Description : Adds a linear force to the force list\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Physical_add_linear_force_92_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Physical::add_angular_force(AngularForce *f)
 *******************************************************************/
static PyObject *Dtool_Physical_add_angular_force_93(PyObject *self, PyObject *args,PyObject *kwds) {
    Physical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Physical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void Physical::add_angular_force(AngularForce *f)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"f", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addAngularForce", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addAngularForce", &param1));
            if(!PyErr_Occurred())
            {
                AngularForce *param1_this = (AngularForce *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AngularForce, 1, "Physical.addAngularForce", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_angular_force(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Physical.addAngularForce() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addAngularForce(non-const Physical this, non-const AngularForce f)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Physical_add_angular_force_93_comment =
    "C++ Interface:\n"
    "addAngularForce(non-const Physical this, non-const AngularForce f)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : add_angular_force\n"
    "//      Access : Public\n"
    "// Description : Adds an angular force to the force list\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Physical_add_angular_force_93_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Physical::add_physics_object(PhysicsObject *po)
 *******************************************************************/
static PyObject *Dtool_Physical_add_physics_object_94(PyObject *self, PyObject *args,PyObject *kwds) {
    Physical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Physical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void Physical::add_physics_object(PhysicsObject *po)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"po", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addPhysicsObject", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addPhysicsObject", &param1));
            if(!PyErr_Occurred())
            {
                PhysicsObject *param1_this = (PhysicsObject *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PhysicsObject, 1, "Physical.addPhysicsObject", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_physics_object(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Physical.addPhysicsObject() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addPhysicsObject(non-const Physical this, non-const PhysicsObject po)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Physical_add_physics_object_94_comment =
    "C++ Interface:\n"
    "addPhysicsObject(non-const Physical this, non-const PhysicsObject po)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : add_physics_object\n"
    "//      Access : Public\n"
    "// Description : Adds an object to the physics object vector\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Physical_add_physics_object_94_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Physical::remove_linear_force(LinearForce *f)
 *******************************************************************/
static PyObject *Dtool_Physical_remove_linear_force_95(PyObject *self, PyObject *args,PyObject *kwds) {
    Physical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Physical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void Physical::remove_linear_force(LinearForce *f)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"f", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeLinearForce", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeLinearForce", &param1));
            if(!PyErr_Occurred())
            {
                LinearForce *param1_this = (LinearForce *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LinearForce, 1, "Physical.removeLinearForce", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->remove_linear_force(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Physical.removeLinearForce() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeLinearForce(non-const Physical this, non-const LinearForce f)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Physical_remove_linear_force_95_comment =
    "C++ Interface:\n"
    "removeLinearForce(non-const Physical this, non-const LinearForce f)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : remove_linear_force\n"
    "//      Access : Public\n"
    "// Description : removes a linear force from the force list\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Physical_remove_linear_force_95_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Physical::remove_angular_force(AngularForce *f)
 *******************************************************************/
static PyObject *Dtool_Physical_remove_angular_force_96(PyObject *self, PyObject *args,PyObject *kwds) {
    Physical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Physical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void Physical::remove_angular_force(AngularForce *f)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"f", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeAngularForce", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeAngularForce", &param1));
            if(!PyErr_Occurred())
            {
                AngularForce *param1_this = (AngularForce *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AngularForce, 1, "Physical.removeAngularForce", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->remove_angular_force(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call Physical.removeAngularForce() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeAngularForce(non-const Physical this, non-const AngularForce f)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Physical_remove_angular_force_96_comment =
    "C++ Interface:\n"
    "removeAngularForce(non-const Physical this, non-const AngularForce f)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : remove_angular_force\n"
    "//      Access : Public\n"
    "// Description : removes an angular force from the force list\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Physical_remove_angular_force_96_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int Physical::get_num_linear_forces(void) const
 *******************************************************************/
static PyObject *Dtool_Physical_get_num_linear_forces_97(PyObject *self, PyObject *args,PyObject *kwds) {
    Physical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Physical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int Physical::get_num_linear_forces(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumLinearForces", key_word_list));
        else
            (PyArg_Parse(args, ":getNumLinearForces"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const Physical*)local_this)->get_num_linear_forces();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumLinearForces(const Physical this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Physical_get_num_linear_forces_97_comment =
    "C++ Interface:\n"
    "getNumLinearForces(const Physical this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_num_linear_forces\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Physical_get_num_linear_forces_97_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PointerTo< LinearForce > Physical::get_linear_force(int index) const
 *******************************************************************/
static PyObject *Dtool_Physical_get_linear_force_98(PyObject *self, PyObject *args,PyObject *kwds) {
    Physical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Physical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PointerTo< LinearForce > Physical::get_linear_force(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getLinearForce", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getLinearForce", &param1));
        if(!PyErr_Occurred())
        {
            PointerTo< LinearForce > return_value = ((const Physical*)local_this)->get_linear_force((int)param1);
            if (return_value != (LinearForce *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_LinearForce,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLinearForce(const Physical this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Physical_get_linear_force_98_comment =
    "C++ Interface:\n"
    "getLinearForce(const Physical this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_linear_force\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Physical_get_linear_force_98_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int Physical::get_num_angular_forces(void) const
 *******************************************************************/
static PyObject *Dtool_Physical_get_num_angular_forces_99(PyObject *self, PyObject *args,PyObject *kwds) {
    Physical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Physical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int Physical::get_num_angular_forces(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumAngularForces", key_word_list));
        else
            (PyArg_Parse(args, ":getNumAngularForces"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const Physical*)local_this)->get_num_angular_forces();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumAngularForces(const Physical this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Physical_get_num_angular_forces_99_comment =
    "C++ Interface:\n"
    "getNumAngularForces(const Physical this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_num_angular_forces\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Physical_get_num_angular_forces_99_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PointerTo< AngularForce > Physical::get_angular_force(int index) const
 *******************************************************************/
static PyObject *Dtool_Physical_get_angular_force_100(PyObject *self, PyObject *args,PyObject *kwds) {
    Physical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Physical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PointerTo< AngularForce > Physical::get_angular_force(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getAngularForce", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getAngularForce", &param1));
        if(!PyErr_Occurred())
        {
            PointerTo< AngularForce > return_value = ((const Physical*)local_this)->get_angular_force((int)param1);
            if (return_value != (AngularForce *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_AngularForce,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAngularForce(const Physical this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Physical_get_angular_force_100_comment =
    "C++ Interface:\n"
    "getAngularForce(const Physical this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_angular_force\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Physical_get_angular_force_100_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void Physical::set_viscosity(float viscosity)
 *******************************************************************/
static PyObject *Dtool_Physical_set_viscosity_101(PyObject *self, PyObject *args,PyObject *kwds) {
    Physical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Physical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void Physical::set_viscosity(float viscosity)
        double param1;
        static char * key_word_list[] = {(char *)"viscosity", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setViscosity", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setViscosity", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_viscosity((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call Physical.setViscosity() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setViscosity(non-const Physical this, float viscosity)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Physical_set_viscosity_101_comment =
    "C++ Interface:\n"
    "setViscosity(non-const Physical this, float viscosity)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_viscosity\n"
    "//      Access : Public\n"
    "// Description : Set the local viscosity.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Physical_set_viscosity_101_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float Physical::get_viscosity(void) const
 *******************************************************************/
static PyObject *Dtool_Physical_get_viscosity_102(PyObject *self, PyObject *args,PyObject *kwds) {
    Physical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Physical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float Physical::get_viscosity(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getViscosity", key_word_list));
        else
            (PyArg_Parse(args, ":getViscosity"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const Physical*)local_this)->get_viscosity();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getViscosity(const Physical this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Physical_get_viscosity_102_comment =
    "C++ Interface:\n"
    "getViscosity(const Physical this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_viscosity\n"
    "//      Access : Public\n"
    "// Description : Get the local viscosity.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Physical_get_viscosity_102_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PhysicsObjectCollection const Physical::get_objects(void) const
 *******************************************************************/
static PyObject *Dtool_Physical_get_objects_103(PyObject *self, PyObject *args,PyObject *kwds) {
    Physical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Physical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PhysicsObjectCollection const Physical::get_objects(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getObjects", key_word_list));
        else
            (PyArg_Parse(args, ":getObjects"));
        if(!PyErr_Occurred())
        {
            PhysicsObjectCollection const result = ((const Physical*)local_this)->get_objects();
            PhysicsObjectCollection const *return_value = new PhysicsObjectCollection const(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_PhysicsObjectCollection,true, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getObjects(const Physical this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Physical_get_objects_103_comment =
    "C++ Interface:\n"
    "getObjects(const Physical this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_objects\n"
    "//      Access : Public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Physical_get_objects_103_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void Physical::output(ostream &out) const
 * virtual void Physical::output(ostream &out = (cout)) const
 *******************************************************************/
static PyObject *Dtool_Physical_output_104(PyObject *self, PyObject *args,PyObject *kwds) {
    Physical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Physical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-virtual void Physical::output(ostream &out = (cout)) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":output", key_word_list));
            else
                (PyArg_Parse(args, ":output"));
            if(!PyErr_Occurred())
            {
                ((const Physical*)local_this)->output();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void Physical::output(ostream &out) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:output", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Physical.output", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const Physical*)local_this)->output(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "output() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "output(const Physical this)\n"
          "output(const Physical this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Physical_output_104_comment =
    "C++ Interface:\n"
    "output(const Physical this)\n"
    "output(const Physical this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : output\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Physical_output_104_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void Physical::write_physics_objects(ostream &out, unsigned int indent) const
 * virtual void Physical::write_physics_objects(ostream &out, unsigned int indent = (0)) const
 * virtual void Physical::write_physics_objects(ostream &out = (cout), unsigned int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_Physical_write_physics_objects_105(PyObject *self, PyObject *args,PyObject *kwds) {
    Physical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Physical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-virtual void Physical::write_physics_objects(ostream &out = (cout), unsigned int indent = (0)) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":writePhysicsObjects", key_word_list));
            else
                (PyArg_Parse(args, ":writePhysicsObjects"));
            if(!PyErr_Occurred())
            {
                ((const Physical*)local_this)->write_physics_objects();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void Physical::write_physics_objects(ostream &out, unsigned int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:writePhysicsObjects", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:writePhysicsObjects", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Physical.writePhysicsObjects", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const Physical*)local_this)->write_physics_objects(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void Physical::write_physics_objects(ostream &out, unsigned int indent) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:writePhysicsObjects", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Physical.writePhysicsObjects", 0, coerced_ptr, report_errors);
 PyObject *param2_uint = PyNumber_Long(param2);
                    if (!((param1_this == NULL)|| (param2_uint == NULL)))
                    {
                        ((const Physical*)local_this)->write_physics_objects(*param1_this, PyLong_AsUnsignedLong(param2_uint));
                         Py_XDECREF(param2_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "writePhysicsObjects() takes 1, 2, or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "writePhysicsObjects(const Physical this)\n"
          "writePhysicsObjects(const Physical this, non-const Ostream out)\n"
          "writePhysicsObjects(const Physical this, non-const Ostream out, unsigned int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Physical_write_physics_objects_105_comment =
    "C++ Interface:\n"
    "writePhysicsObjects(const Physical this)\n"
    "writePhysicsObjects(const Physical this, non-const Ostream out)\n"
    "writePhysicsObjects(const Physical this, non-const Ostream out, unsigned int indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : write_physics_objects\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Physical_write_physics_objects_105_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void Physical::write_linear_forces(ostream &out, unsigned int indent) const
 * virtual void Physical::write_linear_forces(ostream &out, unsigned int indent = (0)) const
 * virtual void Physical::write_linear_forces(ostream &out = (cout), unsigned int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_Physical_write_linear_forces_106(PyObject *self, PyObject *args,PyObject *kwds) {
    Physical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Physical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-virtual void Physical::write_linear_forces(ostream &out = (cout), unsigned int indent = (0)) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":writeLinearForces", key_word_list));
            else
                (PyArg_Parse(args, ":writeLinearForces"));
            if(!PyErr_Occurred())
            {
                ((const Physical*)local_this)->write_linear_forces();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void Physical::write_linear_forces(ostream &out, unsigned int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:writeLinearForces", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:writeLinearForces", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Physical.writeLinearForces", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const Physical*)local_this)->write_linear_forces(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void Physical::write_linear_forces(ostream &out, unsigned int indent) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:writeLinearForces", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Physical.writeLinearForces", 0, coerced_ptr, report_errors);
 PyObject *param2_uint = PyNumber_Long(param2);
                    if (!((param1_this == NULL)|| (param2_uint == NULL)))
                    {
                        ((const Physical*)local_this)->write_linear_forces(*param1_this, PyLong_AsUnsignedLong(param2_uint));
                         Py_XDECREF(param2_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "writeLinearForces() takes 1, 2, or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "writeLinearForces(const Physical this)\n"
          "writeLinearForces(const Physical this, non-const Ostream out)\n"
          "writeLinearForces(const Physical this, non-const Ostream out, unsigned int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Physical_write_linear_forces_106_comment =
    "C++ Interface:\n"
    "writeLinearForces(const Physical this)\n"
    "writeLinearForces(const Physical this, non-const Ostream out)\n"
    "writeLinearForces(const Physical this, non-const Ostream out, unsigned int indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : write_linear_forces\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Physical_write_linear_forces_106_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void Physical::write_angular_forces(ostream &out, unsigned int indent) const
 * virtual void Physical::write_angular_forces(ostream &out, unsigned int indent = (0)) const
 * virtual void Physical::write_angular_forces(ostream &out = (cout), unsigned int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_Physical_write_angular_forces_107(PyObject *self, PyObject *args,PyObject *kwds) {
    Physical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Physical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-virtual void Physical::write_angular_forces(ostream &out = (cout), unsigned int indent = (0)) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":writeAngularForces", key_word_list));
            else
                (PyArg_Parse(args, ":writeAngularForces"));
            if(!PyErr_Occurred())
            {
                ((const Physical*)local_this)->write_angular_forces();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void Physical::write_angular_forces(ostream &out, unsigned int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:writeAngularForces", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:writeAngularForces", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Physical.writeAngularForces", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const Physical*)local_this)->write_angular_forces(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void Physical::write_angular_forces(ostream &out, unsigned int indent) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:writeAngularForces", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Physical.writeAngularForces", 0, coerced_ptr, report_errors);
 PyObject *param2_uint = PyNumber_Long(param2);
                    if (!((param1_this == NULL)|| (param2_uint == NULL)))
                    {
                        ((const Physical*)local_this)->write_angular_forces(*param1_this, PyLong_AsUnsignedLong(param2_uint));
                         Py_XDECREF(param2_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "writeAngularForces() takes 1, 2, or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "writeAngularForces(const Physical this)\n"
          "writeAngularForces(const Physical this, non-const Ostream out)\n"
          "writeAngularForces(const Physical this, non-const Ostream out, unsigned int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Physical_write_angular_forces_107_comment =
    "C++ Interface:\n"
    "writeAngularForces(const Physical this)\n"
    "writeAngularForces(const Physical this, non-const Ostream out)\n"
    "writeAngularForces(const Physical this, non-const Ostream out, unsigned int indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : write_angular_forces\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Physical_write_angular_forces_107_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void Physical::write(ostream &out, unsigned int indent) const
 * virtual void Physical::write(ostream &out, unsigned int indent = (0)) const
 * virtual void Physical::write(ostream &out = (cout), unsigned int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_Physical_write_108(PyObject *self, PyObject *args,PyObject *kwds) {
    Physical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Physical,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-virtual void Physical::write(ostream &out = (cout), unsigned int indent = (0)) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":write", key_word_list));
            else
                (PyArg_Parse(args, ":write"));
            if(!PyErr_Occurred())
            {
                ((const Physical*)local_this)->write();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void Physical::write(ostream &out, unsigned int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Physical.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const Physical*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void Physical::write(ostream &out, unsigned int indent) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "Physical.write", 0, coerced_ptr, report_errors);
 PyObject *param2_uint = PyNumber_Long(param2);
                    if (!((param1_this == NULL)|| (param2_uint == NULL)))
                    {
                        ((const Physical*)local_this)->write(*param1_this, PyLong_AsUnsignedLong(param2_uint));
                         Py_XDECREF(param2_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 1, 2, or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const Physical this)\n"
          "write(const Physical this, non-const Ostream out)\n"
          "write(const Physical this, non-const Ostream out, unsigned int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Physical_write_108_comment =
    "C++ Interface:\n"
    "write(const Physical this)\n"
    "write(const Physical this, non-const Ostream out)\n"
    "write(const Physical this, non-const Ostream out, unsigned int indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : write\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_Physical_write_108_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle Physical::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_Physical_get_class_type_109(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle Physical::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = Physical::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_Physical_get_class_type_109_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_Physical_get_class_type_109_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Physical::Physical(Physical const &copy)
 * Physical::Physical(int total_objects, bool pre_alloc)
 * Physical::Physical(int total_objects, bool pre_alloc = (0))
 * Physical::Physical(int total_objects = (1), bool pre_alloc = (0))
 *******************************************************************/
int  Dtool_Init_Physical(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-Physical::Physical(int total_objects = (1), bool pre_alloc = (0))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":Physical", key_word_list))
            {
                Physical *return_value = new Physical();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_Physical,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 Physical::Physical(Physical const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:Physical", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:Physical", &param0));
                if(!PyErr_Occurred())
                {
                    Physical *param0_this = (Physical *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Physical, 0, "Physical.Physical", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        Physical *return_value = new Physical(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_Physical,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 Physical::Physical(int total_objects, bool pre_alloc = (0))
                int param0;
                static char * key_word_list[] = {(char *)"total_objects", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "i:Physical", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "i:Physical", &param0));
                if(!PyErr_Occurred())
                {
                    Physical *return_value = new Physical((int)param0);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_Physical,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          // 1-Physical::Physical(int total_objects, bool pre_alloc)
            int param0;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"total_objects", (char *)"pre_alloc", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:Physical", key_word_list, &param0, &param1))
            {
                Physical *return_value = new Physical((int)param0, (PyObject_IsTrue(param1)!=0));
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_Physical,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "Physical() takes 0, 1, or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "Physical()\n"
          "Physical(const Physical copy)\n"
          "Physical(int total_objects)\n"
          "Physical(int total_objects, bool pre_alloc)\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_Physical_get_linear_forces(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumLinearForces", "getLinearForce");
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_Physical_get_angular_forces(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumAngularForces", "getAngularForce");
}
inline void  * Dtool_UpcastInterface_Physical(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_Physical)
    {
        printf("Physical ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    Physical * local_this = (Physical *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_Physical)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_Physical(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_Physical)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (Physical*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (Physical*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (Physical*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PhysicalNode 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void PhysicalNode::clear(void)
 *******************************************************************/
static PyObject *Dtool_PhysicalNode_clear_113(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicalNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicalNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PhysicalNode::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PhysicalNode.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const PhysicalNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicalNode_clear_113_comment =
    "C++ Interface:\n"
    "clear(non-const PhysicalNode this)\n"
    "\n"
    "// Filename: physicalNode.I\n"
    "// Created by:  charles (01Aug00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//  Function : clear\n"
    "//    Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicalNode_clear_113_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Physical *PhysicalNode::get_physical(int index) const
 *******************************************************************/
static PyObject *Dtool_PhysicalNode_get_physical_114(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicalNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicalNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Physical *PhysicalNode::get_physical(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getPhysical", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getPhysical", &param1));
        if(!PyErr_Occurred())
        {
            Physical *return_value = ((const PhysicalNode*)local_this)->get_physical((int)param1);
            if (return_value != (Physical *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Physical,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPhysical(const PhysicalNode this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicalNode_get_physical_114_comment =
    "C++ Interface:\n"
    "getPhysical(const PhysicalNode this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//  Function : get_physical\n"
    "//    Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicalNode_get_physical_114_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PhysicalNode::get_num_physicals(void) const
 *******************************************************************/
static PyObject *Dtool_PhysicalNode_get_num_physicals_115(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicalNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicalNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PhysicalNode::get_num_physicals(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumPhysicals", key_word_list));
        else
            (PyArg_Parse(args, ":getNumPhysicals"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PhysicalNode*)local_this)->get_num_physicals();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumPhysicals(const PhysicalNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicalNode_get_num_physicals_115_comment =
    "C++ Interface:\n"
    "getNumPhysicals(const PhysicalNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//  Function : get_num_physicals\n"
    "//    Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicalNode_get_num_physicals_115_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PhysicalNode::add_physical(Physical *physical)
 *******************************************************************/
static PyObject *Dtool_PhysicalNode_add_physical_116(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicalNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicalNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PhysicalNode::add_physical(Physical *physical)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"physical", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addPhysical", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addPhysical", &param1));
            if(!PyErr_Occurred())
            {
                Physical *param1_this = (Physical *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Physical, 1, "PhysicalNode.addPhysical", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_physical(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicalNode.addPhysical() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addPhysical(non-const PhysicalNode this, non-const Physical physical)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicalNode_add_physical_116_comment =
    "C++ Interface:\n"
    "addPhysical(non-const PhysicalNode this, non-const Physical physical)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//  Function : add_physical\n"
    "//    Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicalNode_add_physical_116_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PhysicalNode::add_physicals_from(PhysicalNode const &other)
 *******************************************************************/
static PyObject *Dtool_PhysicalNode_add_physicals_from_117(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicalNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicalNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PhysicalNode::add_physicals_from(PhysicalNode const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addPhysicalsFrom", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addPhysicalsFrom", &param1));
            if(!PyErr_Occurred())
            {
                PhysicalNode *param1_this = (PhysicalNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PhysicalNode, 1, "PhysicalNode.addPhysicalsFrom", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_physicals_from(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicalNode.addPhysicalsFrom() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addPhysicalsFrom(non-const PhysicalNode this, const PhysicalNode other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicalNode_add_physicals_from_117_comment =
    "C++ Interface:\n"
    "addPhysicalsFrom(non-const PhysicalNode this, const PhysicalNode other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : add_physicals_from\n"
    "//       Access : public\n"
    "//  Description : append operation\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicalNode_add_physicals_from_117_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PhysicalNode::remove_physical(Physical *physical)
 * void PhysicalNode::remove_physical(int index)
 *******************************************************************/
static PyObject *Dtool_PhysicalNode_remove_physical_118(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicalNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicalNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 void PhysicalNode::remove_physical(Physical *physical)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"physical", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removePhysical", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removePhysical", &param1));
            if(!PyErr_Occurred())
            {
                Physical *param1_this = (Physical *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Physical, 1, "PhysicalNode.removePhysical", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->remove_physical(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 void PhysicalNode::remove_physical(int index)
            int param1;
            static char * key_word_list[] = {(char *)"index", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:removePhysical", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:removePhysical", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->remove_physical((int)param1);
                Py_XDECREF(coerced);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removePhysical(non-const PhysicalNode this, non-const Physical physical)\n"
          "removePhysical(non-const PhysicalNode this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicalNode_remove_physical_118_comment =
    "C++ Interface:\n"
    "removePhysical(non-const PhysicalNode this, non-const Physical physical)\n"
    "removePhysical(non-const PhysicalNode this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : remove_physical\n"
    "//       Access : public\n"
    "//  Description : remove operation\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : remove_physical\n"
    "//       Access : public\n"
    "//  Description : remove operation\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicalNode_remove_physical_118_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void PhysicalNode::write(ostream &out, unsigned int indent) const
 * virtual void PhysicalNode::write(ostream &out, unsigned int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_PhysicalNode_write_119(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicalNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicalNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void PhysicalNode::write(ostream &out, unsigned int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PhysicalNode.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const PhysicalNode*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void PhysicalNode::write(ostream &out, unsigned int indent) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PhysicalNode.write", 0, coerced_ptr, report_errors);
 PyObject *param2_uint = PyNumber_Long(param2);
                    if (!((param1_this == NULL)|| (param2_uint == NULL)))
                    {
                        ((const PhysicalNode*)local_this)->write(*param1_this, PyLong_AsUnsignedLong(param2_uint));
                         Py_XDECREF(param2_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const PhysicalNode this, non-const Ostream out)\n"
          "write(const PhysicalNode this, non-const Ostream out, unsigned int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicalNode_write_119_comment =
    "C++ Interface:\n"
    "write(const PhysicalNode this, non-const Ostream out)\n"
    "write(const PhysicalNode this, non-const Ostream out, unsigned int indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : write\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicalNode_write_119_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle PhysicalNode::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_PhysicalNode_get_class_type_120(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle PhysicalNode::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = PhysicalNode::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicalNode_get_class_type_120_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_PhysicalNode_get_class_type_120_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PhysicalNode::PhysicalNode(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_PhysicalNode(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-PhysicalNode::PhysicalNode(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:PhysicalNode", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:PhysicalNode", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            PhysicalNode *return_value = new PhysicalNode(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_PhysicalNode,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "PhysicalNode(string name)\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_PhysicalNode_get_physicals(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumPhysicals", "getPhysical");
}
inline void  * Dtool_UpcastInterface_PhysicalNode(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PhysicalNode)
    {
        printf("PhysicalNode ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PhysicalNode * local_this = (PhysicalNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PhysicalNode)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PhysicalNode(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PhysicalNode)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (PhysicalNode*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (PhysicalNode*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (PhysicalNode*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (PhysicalNode*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ActorNode 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * PhysicsObject *ActorNode::get_physics_object(void)
 *******************************************************************/
static PyObject *Dtool_ActorNode_get_physics_object_123(PyObject *self, PyObject *args,PyObject *kwds) {
    ActorNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ActorNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-PhysicsObject *ActorNode::get_physics_object(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPhysicsObject", key_word_list));
        else
            (PyArg_Parse(args, ":getPhysicsObject"));
        if(!PyErr_Occurred())
        {
            PhysicsObject *return_value = (local_this)->get_physics_object();
            if (return_value != (PhysicsObject *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_PhysicsObject,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ActorNode.getPhysicsObject() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPhysicsObject(non-const ActorNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ActorNode_get_physics_object_123_comment =
    "C++ Interface:\n"
    "getPhysicsObject(non-const ActorNode this)\n"
    "\n"
    "";
#else
static const char * Dtool_ActorNode_get_physics_object_123_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ActorNode::set_contact_vector(LVector3f const &contact_vector)
 *******************************************************************/
static PyObject *Dtool_ActorNode_set_contact_vector_124(PyObject *self, PyObject *args,PyObject *kwds) {
    ActorNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ActorNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void ActorNode::set_contact_vector(LVector3f const &contact_vector)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"contact_vector", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setContactVector", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setContactVector", &param1));
            if(!PyErr_Occurred())
            {
                LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "ActorNode.setContactVector", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_contact_vector(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ActorNode.setContactVector() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setContactVector(non-const ActorNode this, const Vec3 contact_vector)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ActorNode_set_contact_vector_124_comment =
    "C++ Interface:\n"
    "setContactVector(non-const ActorNode this, const Vec3 contact_vector)\n"
    "\n"
    "// Filename: actorNode.I\n"
    "// Created by:  charles (07Aug00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_contact_vector\n"
    "//      Access : Public\n"
    "// Description : \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ActorNode_set_contact_vector_124_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LVector3f const &ActorNode::get_contact_vector(void) const
 *******************************************************************/
static PyObject *Dtool_ActorNode_get_contact_vector_125(PyObject *self, PyObject *args,PyObject *kwds) {
    ActorNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ActorNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-LVector3f const &ActorNode::get_contact_vector(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getContactVector", key_word_list));
        else
            (PyArg_Parse(args, ":getContactVector"));
        if(!PyErr_Occurred())
        {
            LVector3f const *return_value = &(((const ActorNode*)local_this)->get_contact_vector());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getContactVector(const ActorNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ActorNode_get_contact_vector_125_comment =
    "C++ Interface:\n"
    "getContactVector(const ActorNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_contact_vector\n"
    "//      Access : Public\n"
    "// Description : \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ActorNode_get_contact_vector_125_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ActorNode::update_transform(void)
 *******************************************************************/
static PyObject *Dtool_ActorNode_update_transform_126(PyObject *self, PyObject *args,PyObject *kwds) {
    ActorNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ActorNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ActorNode::update_transform(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":updateTransform", key_word_list));
        else
            (PyArg_Parse(args, ":updateTransform"));
        if(!PyErr_Occurred())
        {
            (local_this)->update_transform();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ActorNode.updateTransform() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "updateTransform(non-const ActorNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ActorNode_update_transform_126_comment =
    "C++ Interface:\n"
    "updateTransform(non-const ActorNode this)\n"
    "\n"
    "// update the parent scene graph node with PhysicsObject information\n"
    "// i.e. copy from PhysicsObject to PandaNode\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : update_transform\n"
    "//       Access : public\n"
    "//  Description : this sets the transform generated by the contained\n"
    "//                Physical, moving the node and subsequent geometry.\n"
    "//                i.e. copy from PhysicsObject to PandaNode\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ActorNode_update_transform_126_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ActorNode::set_transform_limit(float limit)
 *******************************************************************/
static PyObject *Dtool_ActorNode_set_transform_limit_127(PyObject *self, PyObject *args,PyObject *kwds) {
    ActorNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ActorNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void ActorNode::set_transform_limit(float limit)
        double param1;
        static char * key_word_list[] = {(char *)"limit", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setTransformLimit", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setTransformLimit", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_transform_limit((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ActorNode.setTransformLimit() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTransformLimit(non-const ActorNode this, float limit)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ActorNode_set_transform_limit_127_comment =
    "C++ Interface:\n"
    "setTransformLimit(non-const ActorNode this, float limit)\n"
    "\n"
    "";
#else
static const char * Dtool_ActorNode_set_transform_limit_127_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ActorNode::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_ActorNode_get_class_type_128(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ActorNode::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ActorNode::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ActorNode_get_class_type_128_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_ActorNode_get_class_type_128_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ActorNode::ActorNode(ActorNode const &copy)
 * ActorNode::ActorNode(basic_string< char > const &name)
 * ActorNode::ActorNode(basic_string< char > const &name = (""))
 *******************************************************************/
int  Dtool_Init_ActorNode(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-ActorNode::ActorNode(basic_string< char > const &name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":ActorNode", key_word_list))
            {
                ActorNode *return_value = new ActorNode();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_ActorNode,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 ActorNode::ActorNode(ActorNode const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:ActorNode", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:ActorNode", &param0));
                if(!PyErr_Occurred())
                {
                    ActorNode *param0_this = (ActorNode *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_ActorNode, 0, "ActorNode.ActorNode", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        ActorNode *return_value = new ActorNode(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_ActorNode,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 ActorNode::ActorNode(basic_string< char > const &name)
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"name", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:ActorNode", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:ActorNode", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    ActorNode *return_value = new ActorNode(basic_string<char>(param0_str, param0_len));
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_ActorNode,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "ActorNode() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "ActorNode()\n"
          "ActorNode(const ActorNode copy)\n"
          "ActorNode(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ActorNode(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ActorNode)
    {
        printf("ActorNode ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ActorNode * local_this = (ActorNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ActorNode)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *)( PhysicalNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *)( PhysicalNode *) local_this;
    if(requested_type == &Dtool_PhysicalNode)
        return ( PhysicalNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *)( PhysicalNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *)( PhysicalNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *)( PhysicalNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ActorNode(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ActorNode)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (ActorNode*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (ActorNode*)other_this;
    }
    if(from_type == &Dtool_PhysicalNode)
    {
          PhysicalNode* other_this = (PhysicalNode*)from_this;
          return (ActorNode*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (ActorNode*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (ActorNode*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. BaseIntegrator 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual void BaseIntegrator::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_BaseIntegrator_output_131(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseIntegrator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseIntegrator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void BaseIntegrator::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BaseIntegrator.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const BaseIntegrator*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const BaseIntegrator this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseIntegrator_output_131_comment =
    "C++ Interface:\n"
    "output(const BaseIntegrator this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : output\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseIntegrator_output_131_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void BaseIntegrator::write_precomputed_linear_matrices(ostream &out, unsigned int indent) const
 * virtual void BaseIntegrator::write_precomputed_linear_matrices(ostream &out, unsigned int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_BaseIntegrator_write_precomputed_linear_matrices_132(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseIntegrator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseIntegrator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void BaseIntegrator::write_precomputed_linear_matrices(ostream &out, unsigned int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:writePrecomputedLinearMatrices", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:writePrecomputedLinearMatrices", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BaseIntegrator.writePrecomputedLinearMatrices", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BaseIntegrator*)local_this)->write_precomputed_linear_matrices(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void BaseIntegrator::write_precomputed_linear_matrices(ostream &out, unsigned int indent) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:writePrecomputedLinearMatrices", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BaseIntegrator.writePrecomputedLinearMatrices", 0, coerced_ptr, report_errors);
 PyObject *param2_uint = PyNumber_Long(param2);
                    if (!((param1_this == NULL)|| (param2_uint == NULL)))
                    {
                        ((const BaseIntegrator*)local_this)->write_precomputed_linear_matrices(*param1_this, PyLong_AsUnsignedLong(param2_uint));
                         Py_XDECREF(param2_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "writePrecomputedLinearMatrices() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "writePrecomputedLinearMatrices(const BaseIntegrator this, non-const Ostream out)\n"
          "writePrecomputedLinearMatrices(const BaseIntegrator this, non-const Ostream out, unsigned int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseIntegrator_write_precomputed_linear_matrices_132_comment =
    "C++ Interface:\n"
    "writePrecomputedLinearMatrices(const BaseIntegrator this, non-const Ostream out)\n"
    "writePrecomputedLinearMatrices(const BaseIntegrator this, non-const Ostream out, unsigned int indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : write_precomputed_linear_matrices\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseIntegrator_write_precomputed_linear_matrices_132_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void BaseIntegrator::write_precomputed_angular_matrices(ostream &out, unsigned int indent) const
 * virtual void BaseIntegrator::write_precomputed_angular_matrices(ostream &out, unsigned int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_BaseIntegrator_write_precomputed_angular_matrices_133(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseIntegrator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseIntegrator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void BaseIntegrator::write_precomputed_angular_matrices(ostream &out, unsigned int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:writePrecomputedAngularMatrices", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:writePrecomputedAngularMatrices", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BaseIntegrator.writePrecomputedAngularMatrices", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BaseIntegrator*)local_this)->write_precomputed_angular_matrices(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void BaseIntegrator::write_precomputed_angular_matrices(ostream &out, unsigned int indent) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:writePrecomputedAngularMatrices", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BaseIntegrator.writePrecomputedAngularMatrices", 0, coerced_ptr, report_errors);
 PyObject *param2_uint = PyNumber_Long(param2);
                    if (!((param1_this == NULL)|| (param2_uint == NULL)))
                    {
                        ((const BaseIntegrator*)local_this)->write_precomputed_angular_matrices(*param1_this, PyLong_AsUnsignedLong(param2_uint));
                         Py_XDECREF(param2_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "writePrecomputedAngularMatrices() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "writePrecomputedAngularMatrices(const BaseIntegrator this, non-const Ostream out)\n"
          "writePrecomputedAngularMatrices(const BaseIntegrator this, non-const Ostream out, unsigned int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseIntegrator_write_precomputed_angular_matrices_133_comment =
    "C++ Interface:\n"
    "writePrecomputedAngularMatrices(const BaseIntegrator this, non-const Ostream out)\n"
    "writePrecomputedAngularMatrices(const BaseIntegrator this, non-const Ostream out, unsigned int indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : write_precomputed_angular_matrices\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseIntegrator_write_precomputed_angular_matrices_133_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void BaseIntegrator::write(ostream &out, unsigned int indent) const
 * virtual void BaseIntegrator::write(ostream &out, unsigned int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_BaseIntegrator_write_134(PyObject *self, PyObject *args,PyObject *kwds) {
    BaseIntegrator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseIntegrator,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void BaseIntegrator::write(ostream &out, unsigned int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BaseIntegrator.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const BaseIntegrator*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void BaseIntegrator::write(ostream &out, unsigned int indent) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "BaseIntegrator.write", 0, coerced_ptr, report_errors);
 PyObject *param2_uint = PyNumber_Long(param2);
                    if (!((param1_this == NULL)|| (param2_uint == NULL)))
                    {
                        ((const BaseIntegrator*)local_this)->write(*param1_this, PyLong_AsUnsignedLong(param2_uint));
                         Py_XDECREF(param2_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const BaseIntegrator this, non-const Ostream out)\n"
          "write(const BaseIntegrator this, non-const Ostream out, unsigned int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_BaseIntegrator_write_134_comment =
    "C++ Interface:\n"
    "write(const BaseIntegrator this, non-const Ostream out)\n"
    "write(const BaseIntegrator this, non-const Ostream out, unsigned int indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : write\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_BaseIntegrator_write_134_comment = NULL;
#endif

int  Dtool_Init_BaseIntegrator(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (BaseIntegrator)");
       return -1;
}
inline void  * Dtool_UpcastInterface_BaseIntegrator(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_BaseIntegrator)
    {
        printf("BaseIntegrator ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    BaseIntegrator * local_this = (BaseIntegrator *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_BaseIntegrator)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_BaseIntegrator(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_BaseIntegrator)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (BaseIntegrator*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. AngularIntegrator 
//********************************************************************
int  Dtool_Init_AngularIntegrator(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (AngularIntegrator)");
       return -1;
}
inline void  * Dtool_UpcastInterface_AngularIntegrator(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_AngularIntegrator)
    {
        printf("AngularIntegrator ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    AngularIntegrator * local_this = (AngularIntegrator *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_AngularIntegrator)
        return local_this;
    if(requested_type == &Dtool_BaseIntegrator)
        return ( BaseIntegrator *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( BaseIntegrator *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_AngularIntegrator(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_AngularIntegrator)
        return from_this;
    if(from_type == &Dtool_BaseIntegrator)
    {
          BaseIntegrator* other_this = (BaseIntegrator*)from_this;
          return (AngularIntegrator*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (AngularIntegrator*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. AngularEulerIntegrator 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * AngularEulerIntegrator::AngularEulerIntegrator(void)
 *******************************************************************/
int  Dtool_Init_AngularEulerIntegrator(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-AngularEulerIntegrator::AngularEulerIntegrator(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":AngularEulerIntegrator", key_word_list))
        {
            AngularEulerIntegrator *return_value = new AngularEulerIntegrator();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_AngularEulerIntegrator,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "AngularEulerIntegrator()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_AngularEulerIntegrator(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_AngularEulerIntegrator)
    {
        printf("AngularEulerIntegrator ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    AngularEulerIntegrator * local_this = (AngularEulerIntegrator *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_AngularEulerIntegrator)
        return local_this;
    if(requested_type == &Dtool_AngularIntegrator)
        return ( AngularIntegrator *) local_this;
    if(requested_type == &Dtool_BaseIntegrator)
        return ( BaseIntegrator *)( AngularIntegrator *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( BaseIntegrator *)( AngularIntegrator *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_AngularEulerIntegrator(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_AngularEulerIntegrator)
        return from_this;
    if(from_type == &Dtool_AngularIntegrator)
    {
          AngularIntegrator* other_this = (AngularIntegrator*)from_this;
          return (AngularEulerIntegrator*)other_this;
    }
    if(from_type == &Dtool_BaseIntegrator)
    {
          BaseIntegrator* other_this = (BaseIntegrator*)from_this;
          return (AngularEulerIntegrator*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (AngularEulerIntegrator*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. AngularVectorForce 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void AngularVectorForce::set_quat(LRotationf const &quat)
 *******************************************************************/
static PyObject *Dtool_AngularVectorForce_set_quat_140(PyObject *self, PyObject *args,PyObject *kwds) {
    AngularVectorForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AngularVectorForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void AngularVectorForce::set_quat(LRotationf const &quat)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"quat", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setQuat", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setQuat", &param1));
            if(!PyErr_Occurred())
            {
                LRotationf *param1_this = (LRotationf *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LRotationf, 1, "AngularVectorForce.setQuat", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_quat(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call AngularVectorForce.setQuat() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setQuat(non-const AngularVectorForce this, const LRotationf quat)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AngularVectorForce_set_quat_140_comment =
    "C++ Interface:\n"
    "setQuat(non-const AngularVectorForce this, const LRotationf quat)\n"
    "\n"
    "// Filename: angularVectorForce.I\n"
    "// Created by:  charles (09Aug00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : set_quat\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AngularVectorForce_set_quat_140_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void AngularVectorForce::set_hpr(float h, float p, float r)
 *******************************************************************/
static PyObject *Dtool_AngularVectorForce_set_hpr_141(PyObject *self, PyObject *args,PyObject *kwds) {
    AngularVectorForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AngularVectorForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void AngularVectorForce::set_hpr(float h, float p, float r)
        double param1;
        double param2;
        double param3;
        static char * key_word_list[] = {(char *)"h", (char *)"p", (char *)"r", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setHpr", key_word_list, &param1, &param2, &param3))
        {
            (local_this)->set_hpr((float)param1, (float)param2, (float)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call AngularVectorForce.setHpr() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setHpr(non-const AngularVectorForce this, float h, float p, float r)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AngularVectorForce_set_hpr_141_comment =
    "C++ Interface:\n"
    "setHpr(non-const AngularVectorForce this, float h, float p, float r)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : set_hpr\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AngularVectorForce_set_hpr_141_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LRotationf AngularVectorForce::get_local_quat(void) const
 *******************************************************************/
static PyObject *Dtool_AngularVectorForce_get_local_quat_142(PyObject *self, PyObject *args,PyObject *kwds) {
    AngularVectorForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AngularVectorForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LRotationf AngularVectorForce::get_local_quat(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLocalQuat", key_word_list));
        else
            (PyArg_Parse(args, ":getLocalQuat"));
        if(!PyErr_Occurred())
        {
            LRotationf result = ((const AngularVectorForce*)local_this)->get_local_quat();
            LRotationf *return_value = new LRotationf(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LRotationf,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLocalQuat(const AngularVectorForce this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AngularVectorForce_get_local_quat_142_comment =
    "C++ Interface:\n"
    "getLocalQuat(const AngularVectorForce this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : get_local_quat\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_AngularVectorForce_get_local_quat_142_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle AngularVectorForce::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_AngularVectorForce_get_class_type_143(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle AngularVectorForce::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = AngularVectorForce::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_AngularVectorForce_get_class_type_143_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_AngularVectorForce_get_class_type_143_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * AngularVectorForce::AngularVectorForce(AngularVectorForce const &copy)
 * AngularVectorForce::AngularVectorForce(LRotationf const &quat)
 * AngularVectorForce::AngularVectorForce(float h, float p, float r)
 *******************************************************************/
int  Dtool_Init_AngularVectorForce(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 AngularVectorForce::AngularVectorForce(AngularVectorForce const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:AngularVectorForce", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:AngularVectorForce", &param0));
                if(!PyErr_Occurred())
                {
                    AngularVectorForce *param0_this = (AngularVectorForce *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_AngularVectorForce, 0, "AngularVectorForce.AngularVectorForce", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        AngularVectorForce *return_value = new AngularVectorForce(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_AngularVectorForce,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 AngularVectorForce::AngularVectorForce(LRotationf const &quat)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"quat", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:AngularVectorForce", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:AngularVectorForce", &param0));
                if(!PyErr_Occurred())
                {
                    LRotationf *param0_this = (LRotationf *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LRotationf, 0, "AngularVectorForce.AngularVectorForce", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        AngularVectorForce *return_value = new AngularVectorForce(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_AngularVectorForce,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          // 1-AngularVectorForce::AngularVectorForce(float h, float p, float r)
            double param0;
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"h", (char *)"p", (char *)"r", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:AngularVectorForce", key_word_list, &param0, &param1, &param2))
            {
                AngularVectorForce *return_value = new AngularVectorForce((float)param0, (float)param1, (float)param2);
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_AngularVectorForce,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "AngularVectorForce() takes 1 or 3 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "AngularVectorForce(const AngularVectorForce copy)\n"
          "AngularVectorForce(const LRotationf quat)\n"
          "AngularVectorForce(float h, float p, float r)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_AngularVectorForce(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_AngularVectorForce)
    {
        printf("AngularVectorForce ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    AngularVectorForce * local_this = (AngularVectorForce *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_AngularVectorForce)
        return local_this;
    if(requested_type == &Dtool_AngularForce)
        return ( AngularForce *) local_this;
    if(requested_type == &Dtool_BaseForce)
        return ( BaseForce *)( AngularForce *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( BaseForce *)( AngularForce *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( BaseForce *)( AngularForce *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( BaseForce *)( AngularForce *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_AngularVectorForce(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_AngularVectorForce)
        return from_this;
    if(from_type == &Dtool_AngularForce)
    {
          AngularForce* other_this = (AngularForce*)from_this;
          return (AngularVectorForce*)other_this;
    }
    if(from_type == &Dtool_BaseForce)
    {
          BaseForce* other_this = (BaseForce*)from_this;
          return (AngularVectorForce*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (AngularVectorForce*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (AngularVectorForce*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (AngularVectorForce*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ForceNode 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void ForceNode::clear(void)
 *******************************************************************/
static PyObject *Dtool_ForceNode_clear_146(PyObject *self, PyObject *args,PyObject *kwds) {
    ForceNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ForceNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void ForceNode::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call ForceNode.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const ForceNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ForceNode_clear_146_comment =
    "C++ Interface:\n"
    "clear(non-const ForceNode this)\n"
    "\n"
    "// Filename: forceNode.I\n"
    "// Created by:  charles (02Aug00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//  Function : clear\n"
    "//    Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ForceNode_clear_146_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BaseForce *ForceNode::get_force(int index) const
 *******************************************************************/
static PyObject *Dtool_ForceNode_get_force_147(PyObject *self, PyObject *args,PyObject *kwds) {
    ForceNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ForceNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline BaseForce *ForceNode::get_force(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getForce", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getForce", &param1));
        if(!PyErr_Occurred())
        {
            BaseForce *return_value = ((const ForceNode*)local_this)->get_force((int)param1);
            if (return_value != (BaseForce *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_BaseForce,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getForce(const ForceNode this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ForceNode_get_force_147_comment =
    "C++ Interface:\n"
    "getForce(const ForceNode this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//  Function : get_force\n"
    "//    Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ForceNode_get_force_147_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int ForceNode::get_num_forces(void) const
 *******************************************************************/
static PyObject *Dtool_ForceNode_get_num_forces_148(PyObject *self, PyObject *args,PyObject *kwds) {
    ForceNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ForceNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int ForceNode::get_num_forces(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumForces", key_word_list));
        else
            (PyArg_Parse(args, ":getNumForces"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const ForceNode*)local_this)->get_num_forces();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumForces(const ForceNode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ForceNode_get_num_forces_148_comment =
    "C++ Interface:\n"
    "getNumForces(const ForceNode this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//  Function : get_num_forces\n"
    "//    Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ForceNode_get_num_forces_148_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void ForceNode::add_force(BaseForce *force)
 *******************************************************************/
static PyObject *Dtool_ForceNode_add_force_149(PyObject *self, PyObject *args,PyObject *kwds) {
    ForceNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ForceNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void ForceNode::add_force(BaseForce *force)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"force", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addForce", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addForce", &param1));
            if(!PyErr_Occurred())
            {
                BaseForce *param1_this = (BaseForce *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BaseForce, 1, "ForceNode.addForce", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_force(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ForceNode.addForce() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addForce(non-const ForceNode this, non-const BaseForce force)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ForceNode_add_force_149_comment =
    "C++ Interface:\n"
    "addForce(non-const ForceNode this, non-const BaseForce force)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//  Function : add_force\n"
    "//    Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ForceNode_add_force_149_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ForceNode::add_forces_from(ForceNode const &other)
 *******************************************************************/
static PyObject *Dtool_ForceNode_add_forces_from_150(PyObject *self, PyObject *args,PyObject *kwds) {
    ForceNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ForceNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void ForceNode::add_forces_from(ForceNode const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addForcesFrom", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addForcesFrom", &param1));
            if(!PyErr_Occurred())
            {
                ForceNode *param1_this = (ForceNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ForceNode, 1, "ForceNode.addForcesFrom", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_forces_from(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call ForceNode.addForcesFrom() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addForcesFrom(non-const ForceNode this, const ForceNode other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ForceNode_add_forces_from_150_comment =
    "C++ Interface:\n"
    "addForcesFrom(non-const ForceNode this, const ForceNode other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : add_forces_from\n"
    "//       Access : public\n"
    "//  Description : append operation\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ForceNode_add_forces_from_150_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void ForceNode::remove_force(BaseForce *f)
 * void ForceNode::remove_force(int index)
 *******************************************************************/
static PyObject *Dtool_ForceNode_remove_force_151(PyObject *self, PyObject *args,PyObject *kwds) {
    ForceNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ForceNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 void ForceNode::remove_force(BaseForce *f)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"f", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeForce", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeForce", &param1));
            if(!PyErr_Occurred())
            {
                BaseForce *param1_this = (BaseForce *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BaseForce, 1, "ForceNode.removeForce", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->remove_force(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 void ForceNode::remove_force(int index)
            int param1;
            static char * key_word_list[] = {(char *)"index", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:removeForce", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:removeForce", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->remove_force((int)param1);
                Py_XDECREF(coerced);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeForce(non-const ForceNode this, non-const BaseForce f)\n"
          "removeForce(non-const ForceNode this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ForceNode_remove_force_151_comment =
    "C++ Interface:\n"
    "removeForce(non-const ForceNode this, non-const BaseForce f)\n"
    "removeForce(non-const ForceNode this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : remove_force\n"
    "//       Access : public\n"
    "//  Description : remove operation\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : remove_force\n"
    "//       Access : public\n"
    "//  Description : remove operation\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ForceNode_remove_force_151_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void ForceNode::write_forces(ostream &out, unsigned int indent) const
 * virtual void ForceNode::write_forces(ostream &out, unsigned int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_ForceNode_write_forces_152(PyObject *self, PyObject *args,PyObject *kwds) {
    ForceNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ForceNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void ForceNode::write_forces(ostream &out, unsigned int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:writeForces", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:writeForces", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ForceNode.writeForces", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const ForceNode*)local_this)->write_forces(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void ForceNode::write_forces(ostream &out, unsigned int indent) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:writeForces", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ForceNode.writeForces", 0, coerced_ptr, report_errors);
 PyObject *param2_uint = PyNumber_Long(param2);
                    if (!((param1_this == NULL)|| (param2_uint == NULL)))
                    {
                        ((const ForceNode*)local_this)->write_forces(*param1_this, PyLong_AsUnsignedLong(param2_uint));
                         Py_XDECREF(param2_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "writeForces() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "writeForces(const ForceNode this, non-const Ostream out)\n"
          "writeForces(const ForceNode this, non-const Ostream out, unsigned int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ForceNode_write_forces_152_comment =
    "C++ Interface:\n"
    "writeForces(const ForceNode this, non-const Ostream out)\n"
    "writeForces(const ForceNode this, non-const Ostream out, unsigned int indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : write_linear_forces\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ForceNode_write_forces_152_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void ForceNode::write(ostream &out, unsigned int indent) const
 * virtual void ForceNode::write(ostream &out, unsigned int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_ForceNode_write_153(PyObject *self, PyObject *args,PyObject *kwds) {
    ForceNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ForceNode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void ForceNode::write(ostream &out, unsigned int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ForceNode.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const ForceNode*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void ForceNode::write(ostream &out, unsigned int indent) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "ForceNode.write", 0, coerced_ptr, report_errors);
 PyObject *param2_uint = PyNumber_Long(param2);
                    if (!((param1_this == NULL)|| (param2_uint == NULL)))
                    {
                        ((const ForceNode*)local_this)->write(*param1_this, PyLong_AsUnsignedLong(param2_uint));
                         Py_XDECREF(param2_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const ForceNode this, non-const Ostream out)\n"
          "write(const ForceNode this, non-const Ostream out, unsigned int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ForceNode_write_153_comment =
    "C++ Interface:\n"
    "write(const ForceNode this, non-const Ostream out)\n"
    "write(const ForceNode this, non-const Ostream out, unsigned int indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : write\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_ForceNode_write_153_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ForceNode::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_ForceNode_get_class_type_154(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ForceNode::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ForceNode::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ForceNode_get_class_type_154_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_ForceNode_get_class_type_154_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ForceNode::ForceNode(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_ForceNode(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-ForceNode::ForceNode(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:ForceNode", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:ForceNode", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            ForceNode *return_value = new ForceNode(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_ForceNode,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ForceNode(string name)\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_ForceNode_get_forces(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumForces", "getForce");
}
inline void  * Dtool_UpcastInterface_ForceNode(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ForceNode)
    {
        printf("ForceNode ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ForceNode * local_this = (ForceNode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ForceNode)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_PandaNode)
        return ( PandaNode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedWritable *)( PandaNode *) local_this;
    if(requested_type == &Dtool_TypedWritable)
        return ( TypedWritable *)( PandaNode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ForceNode(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ForceNode)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (ForceNode*)other_this;
    }
    if(from_type == &Dtool_PandaNode)
    {
          PandaNode* other_this = (PandaNode*)from_this;
          return (ForceNode*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (ForceNode*)other_this;
    }
    if(from_type == &Dtool_TypedWritable)
    {
          TypedWritable* other_this = (TypedWritable*)from_this;
          return (ForceNode*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. LinearControlForce 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void LinearControlForce::clear_physics_object(void)
 *******************************************************************/
static PyObject *Dtool_LinearControlForce_clear_physics_object_157(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearControlForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearControlForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LinearControlForce::clear_physics_object(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearPhysicsObject", key_word_list));
        else
            (PyArg_Parse(args, ":clearPhysicsObject"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_physics_object();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LinearControlForce.clearPhysicsObject() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearPhysicsObject(non-const LinearControlForce this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearControlForce_clear_physics_object_157_comment =
    "C++ Interface:\n"
    "clearPhysicsObject(non-const LinearControlForce this)\n"
    "\n"
    "// Filename: linearControlForce.I\n"
    "// Created by: Dave Schuyler (2006)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : clear_physics_object\n"
    "//      Access : Public\n"
    "// Description : encapsulating wrapper\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LinearControlForce_clear_physics_object_157_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LinearControlForce::set_physics_object(PhysicsObject const *po)
 *******************************************************************/
static PyObject *Dtool_LinearControlForce_set_physics_object_158(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearControlForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearControlForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LinearControlForce::set_physics_object(PhysicsObject const *po)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"po", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setPhysicsObject", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setPhysicsObject", &param1));
            if(!PyErr_Occurred())
            {
                PhysicsObject *param1_this = (PhysicsObject *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PhysicsObject, 1, "LinearControlForce.setPhysicsObject", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_physics_object(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LinearControlForce.setPhysicsObject() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPhysicsObject(non-const LinearControlForce this, const PhysicsObject po)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearControlForce_set_physics_object_158_comment =
    "C++ Interface:\n"
    "setPhysicsObject(non-const LinearControlForce this, const PhysicsObject po)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_physics_object\n"
    "//      Access : Public\n"
    "// Description : encapsulating wrapper\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LinearControlForce_set_physics_object_158_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline ConstPointerTo< PhysicsObject > LinearControlForce::get_physics_object(void) const
 *******************************************************************/
static PyObject *Dtool_LinearControlForce_get_physics_object_159(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearControlForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearControlForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline ConstPointerTo< PhysicsObject > LinearControlForce::get_physics_object(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPhysicsObject", key_word_list));
        else
            (PyArg_Parse(args, ":getPhysicsObject"));
        if(!PyErr_Occurred())
        {
            ConstPointerTo< PhysicsObject > return_value = ((const LinearControlForce*)local_this)->get_physics_object();
            if (return_value != (PhysicsObject const *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_PhysicsObject,true, true, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPhysicsObject(const LinearControlForce this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearControlForce_get_physics_object_159_comment =
    "C++ Interface:\n"
    "getPhysicsObject(const LinearControlForce this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_physics_object\n"
    "//      Access : Public\n"
    "// Description : piecewise encapsulating wrapper\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LinearControlForce_get_physics_object_159_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LinearControlForce::set_vector(LVector3f const &v)
 * inline void LinearControlForce::set_vector(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_LinearControlForce_set_vector_160(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearControlForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearControlForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void LinearControlForce::set_vector(LVector3f const &v)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"v", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setVector", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setVector", &param1));
                if(!PyErr_Occurred())
                {
                    LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "LinearControlForce.setVector", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_vector(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call LinearControlForce.setVector() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LinearControlForce::set_vector(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setVector", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_vector((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LinearControlForce.setVector() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setVector() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setVector(non-const LinearControlForce this, const Vec3 v)\n"
          "setVector(non-const LinearControlForce this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearControlForce_set_vector_160_comment =
    "C++ Interface:\n"
    "setVector(non-const LinearControlForce this, const Vec3 v)\n"
    "setVector(non-const LinearControlForce this, float x, float y, float z)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_vector\n"
    "//      Access : Public\n"
    "// Description : encapsulating wrapper\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_vector\n"
    "//      Access : Public\n"
    "// Description : piecewise encapsulating wrapper\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LinearControlForce_set_vector_160_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector3f LinearControlForce::get_local_vector(void) const
 *******************************************************************/
static PyObject *Dtool_LinearControlForce_get_local_vector_161(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearControlForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearControlForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVector3f LinearControlForce::get_local_vector(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLocalVector", key_word_list));
        else
            (PyArg_Parse(args, ":getLocalVector"));
        if(!PyErr_Occurred())
        {
            LVector3f result = ((const LinearControlForce*)local_this)->get_local_vector();
            LVector3f *return_value = new LVector3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLocalVector(const LinearControlForce this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearControlForce_get_local_vector_161_comment =
    "C++ Interface:\n"
    "getLocalVector(const LinearControlForce this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_local_vector\n"
    "//      Access : Public\n"
    "// Description :\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LinearControlForce_get_local_vector_161_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle LinearControlForce::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_LinearControlForce_get_class_type_162(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle LinearControlForce::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = LinearControlForce::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearControlForce_get_class_type_162_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_LinearControlForce_get_class_type_162_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LinearControlForce::LinearControlForce(LinearControlForce const &copy)
 * LinearControlForce::LinearControlForce(PhysicsObject const *po, float a, bool mass)
 * LinearControlForce::LinearControlForce(PhysicsObject const *po, float a, bool mass = (0))
 * LinearControlForce::LinearControlForce(PhysicsObject const *po, float a = (1), bool mass = (0))
 * LinearControlForce::LinearControlForce(PhysicsObject const *po = (0), float a = (1), bool mass = (0))
 *******************************************************************/
int  Dtool_Init_LinearControlForce(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-LinearControlForce::LinearControlForce(PhysicsObject const *po = (0), float a = (1), bool mass = (0))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":LinearControlForce", key_word_list))
            {
                LinearControlForce *return_value = new LinearControlForce();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearControlForce,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 LinearControlForce::LinearControlForce(LinearControlForce const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:LinearControlForce", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:LinearControlForce", &param0));
                if(!PyErr_Occurred())
                {
                    LinearControlForce *param0_this = (LinearControlForce *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LinearControlForce, 0, "LinearControlForce.LinearControlForce", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        LinearControlForce *return_value = new LinearControlForce(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearControlForce,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 LinearControlForce::LinearControlForce(PhysicsObject const *po, float a = (1), bool mass = (0))
                PyObject *param0;
                static char * key_word_list[] = {(char *)"po", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:LinearControlForce", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:LinearControlForce", &param0));
                if(!PyErr_Occurred())
                {
                    PhysicsObject *param0_this = (PhysicsObject *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PhysicsObject, 0, "LinearControlForce.LinearControlForce", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        LinearControlForce *return_value = new LinearControlForce(param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearControlForce,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-LinearControlForce::LinearControlForce(PhysicsObject const *po, float a, bool mass = (0))
                PyObject *param0;
                double param1;
                static char * key_word_list[] = {(char *)"po", (char *)"a", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Od:LinearControlForce", key_word_list, &param0, &param1))
                {
                    PhysicsObject *param0_this = (PhysicsObject *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PhysicsObject, 0, "LinearControlForce.LinearControlForce", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        LinearControlForce *return_value = new LinearControlForce(param0_this, (float)param1);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearControlForce,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-LinearControlForce::LinearControlForce(PhysicsObject const *po, float a, bool mass)
                PyObject *param0;
                double param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"po", (char *)"a", (char *)"mass", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OdO:LinearControlForce", key_word_list, &param0, &param1, &param2))
                {
                    PhysicsObject *param0_this = (PhysicsObject *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PhysicsObject, 0, "LinearControlForce.LinearControlForce", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        LinearControlForce *return_value = new LinearControlForce(param0_this, (float)param1, (PyObject_IsTrue(param2)!=0));
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearControlForce,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "LinearControlForce() takes 0, 1, 2, or 3 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "LinearControlForce()\n"
          "LinearControlForce(const LinearControlForce copy)\n"
          "LinearControlForce(const PhysicsObject po)\n"
          "LinearControlForce(const PhysicsObject po, float a)\n"
          "LinearControlForce(const PhysicsObject po, float a, bool mass)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_LinearControlForce(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_LinearControlForce)
    {
        printf("LinearControlForce ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    LinearControlForce * local_this = (LinearControlForce *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_LinearControlForce)
        return local_this;
    if(requested_type == &Dtool_BaseForce)
        return ( BaseForce *)( LinearForce *) local_this;
    if(requested_type == &Dtool_LinearForce)
        return ( LinearForce *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( BaseForce *)( LinearForce *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( BaseForce *)( LinearForce *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( BaseForce *)( LinearForce *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_LinearControlForce(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_LinearControlForce)
        return from_this;
    if(from_type == &Dtool_BaseForce)
    {
          BaseForce* other_this = (BaseForce*)from_this;
          return (LinearControlForce*)other_this;
    }
    if(from_type == &Dtool_LinearForce)
    {
          LinearForce* other_this = (LinearForce*)from_this;
          return (LinearControlForce*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (LinearControlForce*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (LinearControlForce*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (LinearControlForce*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. LinearCylinderVortexForce 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void LinearCylinderVortexForce::set_coef(float coef)
 *******************************************************************/
static PyObject *Dtool_LinearCylinderVortexForce_set_coef_165(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearCylinderVortexForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearCylinderVortexForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LinearCylinderVortexForce::set_coef(float coef)
        double param1;
        static char * key_word_list[] = {(char *)"coef", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setCoef", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setCoef", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_coef((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LinearCylinderVortexForce.setCoef() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCoef(non-const LinearCylinderVortexForce this, float coef)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearCylinderVortexForce_set_coef_165_comment =
    "C++ Interface:\n"
    "setCoef(non-const LinearCylinderVortexForce this, float coef)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : set_coef\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LinearCylinderVortexForce_set_coef_165_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float LinearCylinderVortexForce::get_coef(void) const
 *******************************************************************/
static PyObject *Dtool_LinearCylinderVortexForce_get_coef_166(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearCylinderVortexForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearCylinderVortexForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float LinearCylinderVortexForce::get_coef(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCoef", key_word_list));
        else
            (PyArg_Parse(args, ":getCoef"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const LinearCylinderVortexForce*)local_this)->get_coef();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCoef(const LinearCylinderVortexForce this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearCylinderVortexForce_get_coef_166_comment =
    "C++ Interface:\n"
    "getCoef(const LinearCylinderVortexForce this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : get_coef\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LinearCylinderVortexForce_get_coef_166_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LinearCylinderVortexForce::set_radius(float radius)
 *******************************************************************/
static PyObject *Dtool_LinearCylinderVortexForce_set_radius_167(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearCylinderVortexForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearCylinderVortexForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LinearCylinderVortexForce::set_radius(float radius)
        double param1;
        static char * key_word_list[] = {(char *)"radius", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setRadius", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setRadius", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_radius((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LinearCylinderVortexForce.setRadius() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRadius(non-const LinearCylinderVortexForce this, float radius)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearCylinderVortexForce_set_radius_167_comment =
    "C++ Interface:\n"
    "setRadius(non-const LinearCylinderVortexForce this, float radius)\n"
    "\n"
    "// Filename: linearCylinderVortexForce.I\n"
    "// Created by:  charles (24Jul00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : set_radius\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LinearCylinderVortexForce_set_radius_167_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float LinearCylinderVortexForce::get_radius(void) const
 *******************************************************************/
static PyObject *Dtool_LinearCylinderVortexForce_get_radius_168(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearCylinderVortexForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearCylinderVortexForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float LinearCylinderVortexForce::get_radius(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRadius", key_word_list));
        else
            (PyArg_Parse(args, ":getRadius"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const LinearCylinderVortexForce*)local_this)->get_radius();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRadius(const LinearCylinderVortexForce this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearCylinderVortexForce_get_radius_168_comment =
    "C++ Interface:\n"
    "getRadius(const LinearCylinderVortexForce this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : get_radius\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LinearCylinderVortexForce_get_radius_168_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LinearCylinderVortexForce::set_length(float length)
 *******************************************************************/
static PyObject *Dtool_LinearCylinderVortexForce_set_length_169(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearCylinderVortexForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearCylinderVortexForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LinearCylinderVortexForce::set_length(float length)
        double param1;
        static char * key_word_list[] = {(char *)"length", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setLength", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setLength", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_length((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LinearCylinderVortexForce.setLength() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setLength(non-const LinearCylinderVortexForce this, float length)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearCylinderVortexForce_set_length_169_comment =
    "C++ Interface:\n"
    "setLength(non-const LinearCylinderVortexForce this, float length)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : set_length\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LinearCylinderVortexForce_set_length_169_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float LinearCylinderVortexForce::get_length(void) const
 *******************************************************************/
static PyObject *Dtool_LinearCylinderVortexForce_get_length_170(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearCylinderVortexForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearCylinderVortexForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float LinearCylinderVortexForce::get_length(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLength", key_word_list));
        else
            (PyArg_Parse(args, ":getLength"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const LinearCylinderVortexForce*)local_this)->get_length();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLength(const LinearCylinderVortexForce this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearCylinderVortexForce_get_length_170_comment =
    "C++ Interface:\n"
    "getLength(const LinearCylinderVortexForce this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : get_length\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LinearCylinderVortexForce_get_length_170_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle LinearCylinderVortexForce::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_LinearCylinderVortexForce_get_class_type_171(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle LinearCylinderVortexForce::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = LinearCylinderVortexForce::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearCylinderVortexForce_get_class_type_171_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_LinearCylinderVortexForce_get_class_type_171_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LinearCylinderVortexForce::LinearCylinderVortexForce(LinearCylinderVortexForce const &copy)
 * LinearCylinderVortexForce::LinearCylinderVortexForce(float radius, float length, float coef, float a, bool md)
 * LinearCylinderVortexForce::LinearCylinderVortexForce(float radius, float length, float coef, float a, bool md = (0))
 * LinearCylinderVortexForce::LinearCylinderVortexForce(float radius, float length, float coef, float a = (1), bool md = (0))
 * LinearCylinderVortexForce::LinearCylinderVortexForce(float radius, float length, float coef = (1), float a = (1), bool md = (0))
 * LinearCylinderVortexForce::LinearCylinderVortexForce(float radius, float length = (0), float coef = (1), float a = (1), bool md = (0))
 * LinearCylinderVortexForce::LinearCylinderVortexForce(float radius = (1), float length = (0), float coef = (1), float a = (1), bool md = (0))
 *******************************************************************/
int  Dtool_Init_LinearCylinderVortexForce(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-LinearCylinderVortexForce::LinearCylinderVortexForce(float radius = (1), float length = (0), float coef = (1), float a = (1), bool md = (0))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":LinearCylinderVortexForce", key_word_list))
            {
                LinearCylinderVortexForce *return_value = new LinearCylinderVortexForce();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearCylinderVortexForce,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 LinearCylinderVortexForce::LinearCylinderVortexForce(LinearCylinderVortexForce const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:LinearCylinderVortexForce", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:LinearCylinderVortexForce", &param0));
                if(!PyErr_Occurred())
                {
                    LinearCylinderVortexForce *param0_this = (LinearCylinderVortexForce *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LinearCylinderVortexForce, 0, "LinearCylinderVortexForce.LinearCylinderVortexForce", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        LinearCylinderVortexForce *return_value = new LinearCylinderVortexForce(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearCylinderVortexForce,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 LinearCylinderVortexForce::LinearCylinderVortexForce(float radius, float length = (0), float coef = (1), float a = (1), bool md = (0))
                double param0;
                static char * key_word_list[] = {(char *)"radius", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "d:LinearCylinderVortexForce", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "d:LinearCylinderVortexForce", &param0));
                if(!PyErr_Occurred())
                {
                    LinearCylinderVortexForce *return_value = new LinearCylinderVortexForce((float)param0);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearCylinderVortexForce,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          // 1-LinearCylinderVortexForce::LinearCylinderVortexForce(float radius, float length, float coef = (1), float a = (1), bool md = (0))
            double param0;
            double param1;
            static char * key_word_list[] = {(char *)"radius", (char *)"length", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:LinearCylinderVortexForce", key_word_list, &param0, &param1))
            {
                LinearCylinderVortexForce *return_value = new LinearCylinderVortexForce((float)param0, (float)param1);
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearCylinderVortexForce,true,false);
                }
            }
        }

        }
        break;
    case(3):
        {
        {
          // 1-LinearCylinderVortexForce::LinearCylinderVortexForce(float radius, float length, float coef, float a = (1), bool md = (0))
            double param0;
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"radius", (char *)"length", (char *)"coef", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:LinearCylinderVortexForce", key_word_list, &param0, &param1, &param2))
            {
                LinearCylinderVortexForce *return_value = new LinearCylinderVortexForce((float)param0, (float)param1, (float)param2);
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearCylinderVortexForce,true,false);
                }
            }
        }

        }
        break;
    case(4):
        {
        {
          // 1-LinearCylinderVortexForce::LinearCylinderVortexForce(float radius, float length, float coef, float a, bool md = (0))
            double param0;
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"radius", (char *)"length", (char *)"coef", (char *)"a", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:LinearCylinderVortexForce", key_word_list, &param0, &param1, &param2, &param3))
            {
                LinearCylinderVortexForce *return_value = new LinearCylinderVortexForce((float)param0, (float)param1, (float)param2, (float)param3);
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearCylinderVortexForce,true,false);
                }
            }
        }

        }
        break;
    case(5):
        {
        {
          // 1-LinearCylinderVortexForce::LinearCylinderVortexForce(float radius, float length, float coef, float a, bool md)
            double param0;
            double param1;
            double param2;
            double param3;
            PyObject *param4;
            static char * key_word_list[] = {(char *)"radius", (char *)"length", (char *)"coef", (char *)"a", (char *)"md", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddddO:LinearCylinderVortexForce", key_word_list, &param0, &param1, &param2, &param3, &param4))
            {
                LinearCylinderVortexForce *return_value = new LinearCylinderVortexForce((float)param0, (float)param1, (float)param2, (float)param3, (PyObject_IsTrue(param4)!=0));
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearCylinderVortexForce,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "LinearCylinderVortexForce() takes 0, 1, 2, 3, 4, or 5 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "LinearCylinderVortexForce()\n"
          "LinearCylinderVortexForce(const LinearCylinderVortexForce copy)\n"
          "LinearCylinderVortexForce(float radius)\n"
          "LinearCylinderVortexForce(float radius, float length)\n"
          "LinearCylinderVortexForce(float radius, float length, float coef)\n"
          "LinearCylinderVortexForce(float radius, float length, float coef, float a)\n"
          "LinearCylinderVortexForce(float radius, float length, float coef, float a, bool md)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_LinearCylinderVortexForce(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_LinearCylinderVortexForce)
    {
        printf("LinearCylinderVortexForce ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    LinearCylinderVortexForce * local_this = (LinearCylinderVortexForce *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_LinearCylinderVortexForce)
        return local_this;
    if(requested_type == &Dtool_BaseForce)
        return ( BaseForce *)( LinearForce *) local_this;
    if(requested_type == &Dtool_LinearForce)
        return ( LinearForce *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( BaseForce *)( LinearForce *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( BaseForce *)( LinearForce *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( BaseForce *)( LinearForce *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_LinearCylinderVortexForce(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_LinearCylinderVortexForce)
        return from_this;
    if(from_type == &Dtool_BaseForce)
    {
          BaseForce* other_this = (BaseForce*)from_this;
          return (LinearCylinderVortexForce*)other_this;
    }
    if(from_type == &Dtool_LinearForce)
    {
          LinearForce* other_this = (LinearForce*)from_this;
          return (LinearCylinderVortexForce*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (LinearCylinderVortexForce*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (LinearCylinderVortexForce*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (LinearCylinderVortexForce*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. LinearDistanceForce 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void LinearDistanceForce::set_radius(float r)
 *******************************************************************/
static PyObject *Dtool_LinearDistanceForce_set_radius_174(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearDistanceForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearDistanceForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LinearDistanceForce::set_radius(float r)
        double param1;
        static char * key_word_list[] = {(char *)"r", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setRadius", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setRadius", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_radius((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LinearDistanceForce.setRadius() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRadius(non-const LinearDistanceForce this, float r)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearDistanceForce_set_radius_174_comment =
    "C++ Interface:\n"
    "setRadius(non-const LinearDistanceForce this, float r)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_radius\n"
    "//      Access : Public\n"
    "// Description : set the radius\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LinearDistanceForce_set_radius_174_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LinearDistanceForce::set_falloff_type(LinearDistanceForce::FalloffType ft)
 *******************************************************************/
static PyObject *Dtool_LinearDistanceForce_set_falloff_type_175(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearDistanceForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearDistanceForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LinearDistanceForce::set_falloff_type(LinearDistanceForce::FalloffType ft)
        int param1;
        static char * key_word_list[] = {(char *)"ft", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setFalloffType", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setFalloffType", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_falloff_type((LinearDistanceForce::FalloffType)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LinearDistanceForce.setFalloffType() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFalloffType(non-const LinearDistanceForce this, int ft)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearDistanceForce_set_falloff_type_175_comment =
    "C++ Interface:\n"
    "setFalloffType(non-const LinearDistanceForce this, int ft)\n"
    "\n"
    "// Filename: linearDistanceForce.I\n"
    "// Created by:  charles (21Jun00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_falloff_type\n"
    "//      Access : Public\n"
    "// Description : falloff_type encapsulating wrap\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LinearDistanceForce_set_falloff_type_175_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void LinearDistanceForce::set_force_center(LPoint3f const &p)
 *******************************************************************/
static PyObject *Dtool_LinearDistanceForce_set_force_center_176(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearDistanceForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearDistanceForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LinearDistanceForce::set_force_center(LPoint3f const &p)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"p", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setForceCenter", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setForceCenter", &param1));
            if(!PyErr_Occurred())
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "LinearDistanceForce.setForceCenter", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_force_center(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LinearDistanceForce.setForceCenter() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setForceCenter(non-const LinearDistanceForce this, const Point3 p)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearDistanceForce_set_force_center_176_comment =
    "C++ Interface:\n"
    "setForceCenter(non-const LinearDistanceForce this, const Point3 p)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_force_center\n"
    "//      Access : Public\n"
    "// Description : set the force center\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LinearDistanceForce_set_force_center_176_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float LinearDistanceForce::get_radius(void) const
 *******************************************************************/
static PyObject *Dtool_LinearDistanceForce_get_radius_177(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearDistanceForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearDistanceForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float LinearDistanceForce::get_radius(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRadius", key_word_list));
        else
            (PyArg_Parse(args, ":getRadius"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const LinearDistanceForce*)local_this)->get_radius();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRadius(const LinearDistanceForce this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearDistanceForce_get_radius_177_comment =
    "C++ Interface:\n"
    "getRadius(const LinearDistanceForce this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_radius\n"
    "//      Access : public\n"
    "// Description : radius query\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LinearDistanceForce_get_radius_177_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LinearDistanceForce::FalloffType LinearDistanceForce::get_falloff_type(void) const
 *******************************************************************/
static PyObject *Dtool_LinearDistanceForce_get_falloff_type_178(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearDistanceForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearDistanceForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LinearDistanceForce::FalloffType LinearDistanceForce::get_falloff_type(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFalloffType", key_word_list));
        else
            (PyArg_Parse(args, ":getFalloffType"));
        if(!PyErr_Occurred())
        {
            LinearDistanceForce::FalloffType return_value = ((const LinearDistanceForce*)local_this)->get_falloff_type();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFalloffType(const LinearDistanceForce this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearDistanceForce_get_falloff_type_178_comment =
    "C++ Interface:\n"
    "getFalloffType(const LinearDistanceForce this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_falloff_type\n"
    "//      Access : public\n"
    "// Description : falloff_type query\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LinearDistanceForce_get_falloff_type_178_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f LinearDistanceForce::get_force_center(void) const
 *******************************************************************/
static PyObject *Dtool_LinearDistanceForce_get_force_center_179(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearDistanceForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearDistanceForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f LinearDistanceForce::get_force_center(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getForceCenter", key_word_list));
        else
            (PyArg_Parse(args, ":getForceCenter"));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const LinearDistanceForce*)local_this)->get_force_center();
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getForceCenter(const LinearDistanceForce this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearDistanceForce_get_force_center_179_comment =
    "C++ Interface:\n"
    "getForceCenter(const LinearDistanceForce this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_force_center\n"
    "//      Access : public\n"
    "// Description : force_center query\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LinearDistanceForce_get_force_center_179_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float LinearDistanceForce::get_scalar_term(void) const
 *******************************************************************/
static PyObject *Dtool_LinearDistanceForce_get_scalar_term_180(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearDistanceForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearDistanceForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float LinearDistanceForce::get_scalar_term(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getScalarTerm", key_word_list));
        else
            (PyArg_Parse(args, ":getScalarTerm"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const LinearDistanceForce*)local_this)->get_scalar_term();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getScalarTerm(const LinearDistanceForce this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearDistanceForce_get_scalar_term_180_comment =
    "C++ Interface:\n"
    "getScalarTerm(const LinearDistanceForce this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_scalar_term\n"
    "//      Access : private\n"
    "// Description : calculate the term based on falloff\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LinearDistanceForce_get_scalar_term_180_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle LinearDistanceForce::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_LinearDistanceForce_get_class_type_181(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle LinearDistanceForce::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = LinearDistanceForce::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearDistanceForce_get_class_type_181_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_LinearDistanceForce_get_class_type_181_comment = NULL;
#endif

int  Dtool_Init_LinearDistanceForce(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (LinearDistanceForce)");
       return -1;
}
inline void  * Dtool_UpcastInterface_LinearDistanceForce(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_LinearDistanceForce)
    {
        printf("LinearDistanceForce ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    LinearDistanceForce * local_this = (LinearDistanceForce *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_LinearDistanceForce)
        return local_this;
    if(requested_type == &Dtool_BaseForce)
        return ( BaseForce *)( LinearForce *) local_this;
    if(requested_type == &Dtool_LinearForce)
        return ( LinearForce *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( BaseForce *)( LinearForce *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( BaseForce *)( LinearForce *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( BaseForce *)( LinearForce *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_LinearDistanceForce(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_LinearDistanceForce)
        return from_this;
    if(from_type == &Dtool_BaseForce)
    {
          BaseForce* other_this = (BaseForce*)from_this;
          return (LinearDistanceForce*)other_this;
    }
    if(from_type == &Dtool_LinearForce)
    {
          LinearForce* other_this = (LinearForce*)from_this;
          return (LinearDistanceForce*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (LinearDistanceForce*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (LinearDistanceForce*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (LinearDistanceForce*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. LinearIntegrator 
//********************************************************************
int  Dtool_Init_LinearIntegrator(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (LinearIntegrator)");
       return -1;
}
inline void  * Dtool_UpcastInterface_LinearIntegrator(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_LinearIntegrator)
    {
        printf("LinearIntegrator ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    LinearIntegrator * local_this = (LinearIntegrator *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_LinearIntegrator)
        return local_this;
    if(requested_type == &Dtool_BaseIntegrator)
        return ( BaseIntegrator *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( BaseIntegrator *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_LinearIntegrator(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_LinearIntegrator)
        return from_this;
    if(from_type == &Dtool_BaseIntegrator)
    {
          BaseIntegrator* other_this = (BaseIntegrator*)from_this;
          return (LinearIntegrator*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (LinearIntegrator*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. LinearEulerIntegrator 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * LinearEulerIntegrator::LinearEulerIntegrator(void)
 *******************************************************************/
int  Dtool_Init_LinearEulerIntegrator(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-LinearEulerIntegrator::LinearEulerIntegrator(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":LinearEulerIntegrator", key_word_list))
        {
            LinearEulerIntegrator *return_value = new LinearEulerIntegrator();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearEulerIntegrator,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "LinearEulerIntegrator()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_LinearEulerIntegrator(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_LinearEulerIntegrator)
    {
        printf("LinearEulerIntegrator ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    LinearEulerIntegrator * local_this = (LinearEulerIntegrator *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_LinearEulerIntegrator)
        return local_this;
    if(requested_type == &Dtool_BaseIntegrator)
        return ( BaseIntegrator *)( LinearIntegrator *) local_this;
    if(requested_type == &Dtool_LinearIntegrator)
        return ( LinearIntegrator *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( BaseIntegrator *)( LinearIntegrator *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_LinearEulerIntegrator(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_LinearEulerIntegrator)
        return from_this;
    if(from_type == &Dtool_BaseIntegrator)
    {
          BaseIntegrator* other_this = (BaseIntegrator*)from_this;
          return (LinearEulerIntegrator*)other_this;
    }
    if(from_type == &Dtool_LinearIntegrator)
    {
          LinearIntegrator* other_this = (LinearIntegrator*)from_this;
          return (LinearEulerIntegrator*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (LinearEulerIntegrator*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. LinearFrictionForce 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void LinearFrictionForce::set_coef(float coef)
 *******************************************************************/
static PyObject *Dtool_LinearFrictionForce_set_coef_187(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearFrictionForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearFrictionForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void LinearFrictionForce::set_coef(float coef)
        double param1;
        static char * key_word_list[] = {(char *)"coef", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setCoef", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setCoef", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_coef((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call LinearFrictionForce.setCoef() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCoef(non-const LinearFrictionForce this, float coef)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearFrictionForce_set_coef_187_comment =
    "C++ Interface:\n"
    "setCoef(non-const LinearFrictionForce this, float coef)\n"
    "\n"
    "// Filename: linearFrictionForce.I\n"
    "// Created by:  charles (31Jul00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : set_coef\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LinearFrictionForce_set_coef_187_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float LinearFrictionForce::get_coef(void) const
 *******************************************************************/
static PyObject *Dtool_LinearFrictionForce_get_coef_188(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearFrictionForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearFrictionForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float LinearFrictionForce::get_coef(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCoef", key_word_list));
        else
            (PyArg_Parse(args, ":getCoef"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const LinearFrictionForce*)local_this)->get_coef();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCoef(const LinearFrictionForce this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearFrictionForce_get_coef_188_comment =
    "C++ Interface:\n"
    "getCoef(const LinearFrictionForce this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "// Function : get_coef\n"
    "//   Access : public\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LinearFrictionForce_get_coef_188_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle LinearFrictionForce::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_LinearFrictionForce_get_class_type_189(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle LinearFrictionForce::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = LinearFrictionForce::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearFrictionForce_get_class_type_189_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_LinearFrictionForce_get_class_type_189_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LinearFrictionForce::LinearFrictionForce(LinearFrictionForce const &copy)
 * LinearFrictionForce::LinearFrictionForce(float coef, float a, bool m)
 * LinearFrictionForce::LinearFrictionForce(float coef, float a, bool m = (0))
 * LinearFrictionForce::LinearFrictionForce(float coef, float a = (1), bool m = (0))
 * LinearFrictionForce::LinearFrictionForce(float coef = (1), float a = (1), bool m = (0))
 *******************************************************************/
int  Dtool_Init_LinearFrictionForce(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-LinearFrictionForce::LinearFrictionForce(float coef = (1), float a = (1), bool m = (0))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":LinearFrictionForce", key_word_list))
            {
                LinearFrictionForce *return_value = new LinearFrictionForce();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearFrictionForce,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 LinearFrictionForce::LinearFrictionForce(LinearFrictionForce const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:LinearFrictionForce", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:LinearFrictionForce", &param0));
                if(!PyErr_Occurred())
                {
                    LinearFrictionForce *param0_this = (LinearFrictionForce *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LinearFrictionForce, 0, "LinearFrictionForce.LinearFrictionForce", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        LinearFrictionForce *return_value = new LinearFrictionForce(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearFrictionForce,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 LinearFrictionForce::LinearFrictionForce(float coef, float a = (1), bool m = (0))
                double param0;
                static char * key_word_list[] = {(char *)"coef", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "d:LinearFrictionForce", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "d:LinearFrictionForce", &param0));
                if(!PyErr_Occurred())
                {
                    LinearFrictionForce *return_value = new LinearFrictionForce((float)param0);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearFrictionForce,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          // 1-LinearFrictionForce::LinearFrictionForce(float coef, float a, bool m = (0))
            double param0;
            double param1;
            static char * key_word_list[] = {(char *)"coef", (char *)"a", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:LinearFrictionForce", key_word_list, &param0, &param1))
            {
                LinearFrictionForce *return_value = new LinearFrictionForce((float)param0, (float)param1);
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearFrictionForce,true,false);
                }
            }
        }

        }
        break;
    case(3):
        {
        {
          // 1-LinearFrictionForce::LinearFrictionForce(float coef, float a, bool m)
            double param0;
            double param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"coef", (char *)"a", (char *)"m", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddO:LinearFrictionForce", key_word_list, &param0, &param1, &param2))
            {
                LinearFrictionForce *return_value = new LinearFrictionForce((float)param0, (float)param1, (PyObject_IsTrue(param2)!=0));
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearFrictionForce,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "LinearFrictionForce() takes 0, 1, 2, or 3 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "LinearFrictionForce()\n"
          "LinearFrictionForce(const LinearFrictionForce copy)\n"
          "LinearFrictionForce(float coef)\n"
          "LinearFrictionForce(float coef, float a)\n"
          "LinearFrictionForce(float coef, float a, bool m)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_LinearFrictionForce(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_LinearFrictionForce)
    {
        printf("LinearFrictionForce ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    LinearFrictionForce * local_this = (LinearFrictionForce *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_LinearFrictionForce)
        return local_this;
    if(requested_type == &Dtool_BaseForce)
        return ( BaseForce *)( LinearForce *) local_this;
    if(requested_type == &Dtool_LinearForce)
        return ( LinearForce *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( BaseForce *)( LinearForce *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( BaseForce *)( LinearForce *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( BaseForce *)( LinearForce *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_LinearFrictionForce(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_LinearFrictionForce)
        return from_this;
    if(from_type == &Dtool_BaseForce)
    {
          BaseForce* other_this = (BaseForce*)from_this;
          return (LinearFrictionForce*)other_this;
    }
    if(from_type == &Dtool_LinearForce)
    {
          LinearForce* other_this = (LinearForce*)from_this;
          return (LinearFrictionForce*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (LinearFrictionForce*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (LinearFrictionForce*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (LinearFrictionForce*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. LinearRandomForce 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle LinearRandomForce::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_LinearRandomForce_get_class_type_191(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle LinearRandomForce::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = LinearRandomForce::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearRandomForce_get_class_type_191_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_LinearRandomForce_get_class_type_191_comment = NULL;
#endif

int  Dtool_Init_LinearRandomForce(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (LinearRandomForce)");
       return -1;
}
inline void  * Dtool_UpcastInterface_LinearRandomForce(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_LinearRandomForce)
    {
        printf("LinearRandomForce ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    LinearRandomForce * local_this = (LinearRandomForce *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_LinearRandomForce)
        return local_this;
    if(requested_type == &Dtool_BaseForce)
        return ( BaseForce *)( LinearForce *) local_this;
    if(requested_type == &Dtool_LinearForce)
        return ( LinearForce *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( BaseForce *)( LinearForce *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( BaseForce *)( LinearForce *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( BaseForce *)( LinearForce *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_LinearRandomForce(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_LinearRandomForce)
        return from_this;
    if(from_type == &Dtool_BaseForce)
    {
          BaseForce* other_this = (BaseForce*)from_this;
          return (LinearRandomForce*)other_this;
    }
    if(from_type == &Dtool_LinearForce)
    {
          LinearForce* other_this = (LinearForce*)from_this;
          return (LinearRandomForce*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (LinearRandomForce*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (LinearRandomForce*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (LinearRandomForce*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. LinearJitterForce 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle LinearJitterForce::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_LinearJitterForce_get_class_type_194(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle LinearJitterForce::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = LinearJitterForce::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearJitterForce_get_class_type_194_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_LinearJitterForce_get_class_type_194_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LinearJitterForce::LinearJitterForce(LinearJitterForce const &copy)
 * LinearJitterForce::LinearJitterForce(float a, bool m)
 * LinearJitterForce::LinearJitterForce(float a, bool m = (0))
 * LinearJitterForce::LinearJitterForce(float a = (1), bool m = (0))
 *******************************************************************/
int  Dtool_Init_LinearJitterForce(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-LinearJitterForce::LinearJitterForce(float a = (1), bool m = (0))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":LinearJitterForce", key_word_list))
            {
                LinearJitterForce *return_value = new LinearJitterForce();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearJitterForce,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 LinearJitterForce::LinearJitterForce(LinearJitterForce const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:LinearJitterForce", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:LinearJitterForce", &param0));
                if(!PyErr_Occurred())
                {
                    LinearJitterForce *param0_this = (LinearJitterForce *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LinearJitterForce, 0, "LinearJitterForce.LinearJitterForce", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        LinearJitterForce *return_value = new LinearJitterForce(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearJitterForce,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 LinearJitterForce::LinearJitterForce(float a, bool m = (0))
                double param0;
                static char * key_word_list[] = {(char *)"a", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "d:LinearJitterForce", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "d:LinearJitterForce", &param0));
                if(!PyErr_Occurred())
                {
                    LinearJitterForce *return_value = new LinearJitterForce((float)param0);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearJitterForce,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          // 1-LinearJitterForce::LinearJitterForce(float a, bool m)
            double param0;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"a", (char *)"m", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dO:LinearJitterForce", key_word_list, &param0, &param1))
            {
                LinearJitterForce *return_value = new LinearJitterForce((float)param0, (PyObject_IsTrue(param1)!=0));
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearJitterForce,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "LinearJitterForce() takes 0, 1, or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "LinearJitterForce()\n"
          "LinearJitterForce(const LinearJitterForce copy)\n"
          "LinearJitterForce(float a)\n"
          "LinearJitterForce(float a, bool m)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_LinearJitterForce(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_LinearJitterForce)
    {
        printf("LinearJitterForce ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    LinearJitterForce * local_this = (LinearJitterForce *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_LinearJitterForce)
        return local_this;
    if(requested_type == &Dtool_BaseForce)
        return ( BaseForce *)( LinearForce *)( LinearRandomForce *) local_this;
    if(requested_type == &Dtool_LinearForce)
        return ( LinearForce *)( LinearRandomForce *) local_this;
    if(requested_type == &Dtool_LinearRandomForce)
        return ( LinearRandomForce *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( BaseForce *)( LinearForce *)( LinearRandomForce *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( BaseForce *)( LinearForce *)( LinearRandomForce *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( BaseForce *)( LinearForce *)( LinearRandomForce *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_LinearJitterForce(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_LinearJitterForce)
        return from_this;
    if(from_type == &Dtool_BaseForce)
    {
          BaseForce* other_this = (BaseForce*)from_this;
          return (LinearJitterForce*)other_this;
    }
    if(from_type == &Dtool_LinearForce)
    {
          LinearForce* other_this = (LinearForce*)from_this;
          return (LinearJitterForce*)other_this;
    }
    if(from_type == &Dtool_LinearRandomForce)
    {
          LinearRandomForce* other_this = (LinearRandomForce*)from_this;
          return (LinearJitterForce*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (LinearJitterForce*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (LinearJitterForce*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (LinearJitterForce*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. LinearNoiseForce 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle LinearNoiseForce::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_LinearNoiseForce_get_class_type_197(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle LinearNoiseForce::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = LinearNoiseForce::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearNoiseForce_get_class_type_197_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_LinearNoiseForce_get_class_type_197_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LinearNoiseForce::LinearNoiseForce(LinearNoiseForce const &copy)
 * LinearNoiseForce::LinearNoiseForce(float a, bool m)
 * LinearNoiseForce::LinearNoiseForce(float a, bool m = (0))
 * LinearNoiseForce::LinearNoiseForce(float a = (1), bool m = (0))
 *******************************************************************/
int  Dtool_Init_LinearNoiseForce(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-LinearNoiseForce::LinearNoiseForce(float a = (1), bool m = (0))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":LinearNoiseForce", key_word_list))
            {
                LinearNoiseForce *return_value = new LinearNoiseForce();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearNoiseForce,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 LinearNoiseForce::LinearNoiseForce(LinearNoiseForce const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:LinearNoiseForce", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:LinearNoiseForce", &param0));
                if(!PyErr_Occurred())
                {
                    LinearNoiseForce *param0_this = (LinearNoiseForce *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LinearNoiseForce, 0, "LinearNoiseForce.LinearNoiseForce", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        LinearNoiseForce *return_value = new LinearNoiseForce(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearNoiseForce,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 LinearNoiseForce::LinearNoiseForce(float a, bool m = (0))
                double param0;
                static char * key_word_list[] = {(char *)"a", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "d:LinearNoiseForce", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "d:LinearNoiseForce", &param0));
                if(!PyErr_Occurred())
                {
                    LinearNoiseForce *return_value = new LinearNoiseForce((float)param0);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearNoiseForce,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          // 1-LinearNoiseForce::LinearNoiseForce(float a, bool m)
            double param0;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"a", (char *)"m", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dO:LinearNoiseForce", key_word_list, &param0, &param1))
            {
                LinearNoiseForce *return_value = new LinearNoiseForce((float)param0, (PyObject_IsTrue(param1)!=0));
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearNoiseForce,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "LinearNoiseForce() takes 0, 1, or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "LinearNoiseForce()\n"
          "LinearNoiseForce(const LinearNoiseForce copy)\n"
          "LinearNoiseForce(float a)\n"
          "LinearNoiseForce(float a, bool m)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_LinearNoiseForce(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_LinearNoiseForce)
    {
        printf("LinearNoiseForce ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    LinearNoiseForce * local_this = (LinearNoiseForce *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_LinearNoiseForce)
        return local_this;
    if(requested_type == &Dtool_BaseForce)
        return ( BaseForce *)( LinearForce *)( LinearRandomForce *) local_this;
    if(requested_type == &Dtool_LinearForce)
        return ( LinearForce *)( LinearRandomForce *) local_this;
    if(requested_type == &Dtool_LinearRandomForce)
        return ( LinearRandomForce *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( BaseForce *)( LinearForce *)( LinearRandomForce *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( BaseForce *)( LinearForce *)( LinearRandomForce *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( BaseForce *)( LinearForce *)( LinearRandomForce *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_LinearNoiseForce(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_LinearNoiseForce)
        return from_this;
    if(from_type == &Dtool_BaseForce)
    {
          BaseForce* other_this = (BaseForce*)from_this;
          return (LinearNoiseForce*)other_this;
    }
    if(from_type == &Dtool_LinearForce)
    {
          LinearForce* other_this = (LinearForce*)from_this;
          return (LinearNoiseForce*)other_this;
    }
    if(from_type == &Dtool_LinearRandomForce)
    {
          LinearRandomForce* other_this = (LinearRandomForce*)from_this;
          return (LinearNoiseForce*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (LinearNoiseForce*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (LinearNoiseForce*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (LinearNoiseForce*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. LinearSinkForce 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle LinearSinkForce::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_LinearSinkForce_get_class_type_200(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle LinearSinkForce::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = LinearSinkForce::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearSinkForce_get_class_type_200_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_LinearSinkForce_get_class_type_200_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LinearSinkForce::LinearSinkForce(void)
 * LinearSinkForce::LinearSinkForce(LPoint3f const &p, LinearDistanceForce::FalloffType f, float r, float a, bool m)
 * LinearSinkForce::LinearSinkForce(LPoint3f const &p, LinearDistanceForce::FalloffType f, float r, float a, bool m = (1))
 * LinearSinkForce::LinearSinkForce(LPoint3f const &p, LinearDistanceForce::FalloffType f, float r, float a = (1), bool m = (1))
 * LinearSinkForce::LinearSinkForce(LinearSinkForce const &copy)
 *******************************************************************/
int  Dtool_Init_LinearSinkForce(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-LinearSinkForce::LinearSinkForce(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":LinearSinkForce", key_word_list))
            {
                LinearSinkForce *return_value = new LinearSinkForce();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearSinkForce,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-LinearSinkForce::LinearSinkForce(LinearSinkForce const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:LinearSinkForce", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:LinearSinkForce", &param0));
                if(!PyErr_Occurred())
                {
                    LinearSinkForce *param0_this = (LinearSinkForce *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LinearSinkForce, 0, "LinearSinkForce.LinearSinkForce", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        LinearSinkForce *return_value = new LinearSinkForce(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearSinkForce,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-LinearSinkForce::LinearSinkForce(LPoint3f const &p, LinearDistanceForce::FalloffType f, float r, float a = (1), bool m = (1))
                PyObject *param0;
                int param1;
                double param2;
                static char * key_word_list[] = {(char *)"p", (char *)"f", (char *)"r", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oid:LinearSinkForce", key_word_list, &param0, &param1, &param2))
                {
                    LPoint3f *param0_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LPoint3f, 0, "LinearSinkForce.LinearSinkForce", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        LinearSinkForce *return_value = new LinearSinkForce(*param0_this, (LinearDistanceForce::FalloffType)param1, (float)param2);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearSinkForce,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-LinearSinkForce::LinearSinkForce(LPoint3f const &p, LinearDistanceForce::FalloffType f, float r, float a, bool m = (1))
                PyObject *param0;
                int param1;
                double param2;
                double param3;
                static char * key_word_list[] = {(char *)"p", (char *)"f", (char *)"r", (char *)"a", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oidd:LinearSinkForce", key_word_list, &param0, &param1, &param2, &param3))
                {
                    LPoint3f *param0_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LPoint3f, 0, "LinearSinkForce.LinearSinkForce", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        LinearSinkForce *return_value = new LinearSinkForce(*param0_this, (LinearDistanceForce::FalloffType)param1, (float)param2, (float)param3);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearSinkForce,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(5):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-LinearSinkForce::LinearSinkForce(LPoint3f const &p, LinearDistanceForce::FalloffType f, float r, float a, bool m)
                PyObject *param0;
                int param1;
                double param2;
                double param3;
                PyObject *param4;
                static char * key_word_list[] = {(char *)"p", (char *)"f", (char *)"r", (char *)"a", (char *)"m", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OiddO:LinearSinkForce", key_word_list, &param0, &param1, &param2, &param3, &param4))
                {
                    LPoint3f *param0_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LPoint3f, 0, "LinearSinkForce.LinearSinkForce", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        LinearSinkForce *return_value = new LinearSinkForce(*param0_this, (LinearDistanceForce::FalloffType)param1, (float)param2, (float)param3, (PyObject_IsTrue(param4)!=0));
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearSinkForce,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "LinearSinkForce() takes 0, 1, 3, 4, or 5 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "LinearSinkForce()\n"
          "LinearSinkForce(const LinearSinkForce copy)\n"
          "LinearSinkForce(const Point3 p, int f, float r)\n"
          "LinearSinkForce(const Point3 p, int f, float r, float a)\n"
          "LinearSinkForce(const Point3 p, int f, float r, float a, bool m)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_LinearSinkForce(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_LinearSinkForce)
    {
        printf("LinearSinkForce ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    LinearSinkForce * local_this = (LinearSinkForce *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_LinearSinkForce)
        return local_this;
    if(requested_type == &Dtool_BaseForce)
        return ( BaseForce *)( LinearForce *)( LinearDistanceForce *) local_this;
    if(requested_type == &Dtool_LinearDistanceForce)
        return ( LinearDistanceForce *) local_this;
    if(requested_type == &Dtool_LinearForce)
        return ( LinearForce *)( LinearDistanceForce *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( BaseForce *)( LinearForce *)( LinearDistanceForce *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( BaseForce *)( LinearForce *)( LinearDistanceForce *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( BaseForce *)( LinearForce *)( LinearDistanceForce *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_LinearSinkForce(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_LinearSinkForce)
        return from_this;
    if(from_type == &Dtool_BaseForce)
    {
          BaseForce* other_this = (BaseForce*)from_this;
          return (LinearSinkForce*)other_this;
    }
    if(from_type == &Dtool_LinearDistanceForce)
    {
          LinearDistanceForce* other_this = (LinearDistanceForce*)from_this;
          return (LinearSinkForce*)other_this;
    }
    if(from_type == &Dtool_LinearForce)
    {
          LinearForce* other_this = (LinearForce*)from_this;
          return (LinearSinkForce*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (LinearSinkForce*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (LinearSinkForce*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (LinearSinkForce*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. LinearSourceForce 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle LinearSourceForce::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_LinearSourceForce_get_class_type_203(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle LinearSourceForce::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = LinearSourceForce::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearSourceForce_get_class_type_203_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_LinearSourceForce_get_class_type_203_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LinearSourceForce::LinearSourceForce(void)
 * LinearSourceForce::LinearSourceForce(LPoint3f const &p, LinearDistanceForce::FalloffType f, float r, float a, bool mass)
 * LinearSourceForce::LinearSourceForce(LPoint3f const &p, LinearDistanceForce::FalloffType f, float r, float a, bool mass = (1))
 * LinearSourceForce::LinearSourceForce(LPoint3f const &p, LinearDistanceForce::FalloffType f, float r, float a = (1), bool mass = (1))
 * LinearSourceForce::LinearSourceForce(LinearSourceForce const &copy)
 *******************************************************************/
int  Dtool_Init_LinearSourceForce(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-LinearSourceForce::LinearSourceForce(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":LinearSourceForce", key_word_list))
            {
                LinearSourceForce *return_value = new LinearSourceForce();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearSourceForce,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-LinearSourceForce::LinearSourceForce(LinearSourceForce const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:LinearSourceForce", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:LinearSourceForce", &param0));
                if(!PyErr_Occurred())
                {
                    LinearSourceForce *param0_this = (LinearSourceForce *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LinearSourceForce, 0, "LinearSourceForce.LinearSourceForce", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        LinearSourceForce *return_value = new LinearSourceForce(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearSourceForce,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-LinearSourceForce::LinearSourceForce(LPoint3f const &p, LinearDistanceForce::FalloffType f, float r, float a = (1), bool mass = (1))
                PyObject *param0;
                int param1;
                double param2;
                static char * key_word_list[] = {(char *)"p", (char *)"f", (char *)"r", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oid:LinearSourceForce", key_word_list, &param0, &param1, &param2))
                {
                    LPoint3f *param0_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LPoint3f, 0, "LinearSourceForce.LinearSourceForce", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        LinearSourceForce *return_value = new LinearSourceForce(*param0_this, (LinearDistanceForce::FalloffType)param1, (float)param2);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearSourceForce,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-LinearSourceForce::LinearSourceForce(LPoint3f const &p, LinearDistanceForce::FalloffType f, float r, float a, bool mass = (1))
                PyObject *param0;
                int param1;
                double param2;
                double param3;
                static char * key_word_list[] = {(char *)"p", (char *)"f", (char *)"r", (char *)"a", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oidd:LinearSourceForce", key_word_list, &param0, &param1, &param2, &param3))
                {
                    LPoint3f *param0_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LPoint3f, 0, "LinearSourceForce.LinearSourceForce", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        LinearSourceForce *return_value = new LinearSourceForce(*param0_this, (LinearDistanceForce::FalloffType)param1, (float)param2, (float)param3);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearSourceForce,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(5):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-LinearSourceForce::LinearSourceForce(LPoint3f const &p, LinearDistanceForce::FalloffType f, float r, float a, bool mass)
                PyObject *param0;
                int param1;
                double param2;
                double param3;
                PyObject *param4;
                static char * key_word_list[] = {(char *)"p", (char *)"f", (char *)"r", (char *)"a", (char *)"mass", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OiddO:LinearSourceForce", key_word_list, &param0, &param1, &param2, &param3, &param4))
                {
                    LPoint3f *param0_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LPoint3f, 0, "LinearSourceForce.LinearSourceForce", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        LinearSourceForce *return_value = new LinearSourceForce(*param0_this, (LinearDistanceForce::FalloffType)param1, (float)param2, (float)param3, (PyObject_IsTrue(param4)!=0));
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearSourceForce,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "LinearSourceForce() takes 0, 1, 3, 4, or 5 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "LinearSourceForce()\n"
          "LinearSourceForce(const LinearSourceForce copy)\n"
          "LinearSourceForce(const Point3 p, int f, float r)\n"
          "LinearSourceForce(const Point3 p, int f, float r, float a)\n"
          "LinearSourceForce(const Point3 p, int f, float r, float a, bool mass)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_LinearSourceForce(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_LinearSourceForce)
    {
        printf("LinearSourceForce ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    LinearSourceForce * local_this = (LinearSourceForce *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_LinearSourceForce)
        return local_this;
    if(requested_type == &Dtool_BaseForce)
        return ( BaseForce *)( LinearForce *)( LinearDistanceForce *) local_this;
    if(requested_type == &Dtool_LinearDistanceForce)
        return ( LinearDistanceForce *) local_this;
    if(requested_type == &Dtool_LinearForce)
        return ( LinearForce *)( LinearDistanceForce *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( BaseForce *)( LinearForce *)( LinearDistanceForce *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( BaseForce *)( LinearForce *)( LinearDistanceForce *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( BaseForce *)( LinearForce *)( LinearDistanceForce *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_LinearSourceForce(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_LinearSourceForce)
        return from_this;
    if(from_type == &Dtool_BaseForce)
    {
          BaseForce* other_this = (BaseForce*)from_this;
          return (LinearSourceForce*)other_this;
    }
    if(from_type == &Dtool_LinearDistanceForce)
    {
          LinearDistanceForce* other_this = (LinearDistanceForce*)from_this;
          return (LinearSourceForce*)other_this;
    }
    if(from_type == &Dtool_LinearForce)
    {
          LinearForce* other_this = (LinearForce*)from_this;
          return (LinearSourceForce*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (LinearSourceForce*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (LinearSourceForce*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (LinearSourceForce*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. LinearUserDefinedForce 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle LinearUserDefinedForce::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_LinearUserDefinedForce_get_class_type_207(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle LinearUserDefinedForce::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = LinearUserDefinedForce::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearUserDefinedForce_get_class_type_207_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_LinearUserDefinedForce_get_class_type_207_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LinearUserDefinedForce::LinearUserDefinedForce(LVector3f (*proc)(PhysicsObject const *) = ((void *)(0)), float a = (1), bool md = (0))
 * LinearUserDefinedForce::LinearUserDefinedForce(LinearUserDefinedForce const &copy)
 *******************************************************************/
int  Dtool_Init_LinearUserDefinedForce(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-LinearUserDefinedForce::LinearUserDefinedForce(LVector3f (*proc)(PhysicsObject const *) = ((void *)(0)), float a = (1), bool md = (0))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":LinearUserDefinedForce", key_word_list))
            {
                LinearUserDefinedForce *return_value = new LinearUserDefinedForce();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearUserDefinedForce,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-LinearUserDefinedForce::LinearUserDefinedForce(LinearUserDefinedForce const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:LinearUserDefinedForce", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:LinearUserDefinedForce", &param0));
                if(!PyErr_Occurred())
                {
                    LinearUserDefinedForce *param0_this = (LinearUserDefinedForce *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LinearUserDefinedForce, 0, "LinearUserDefinedForce.LinearUserDefinedForce", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        LinearUserDefinedForce *return_value = new LinearUserDefinedForce(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearUserDefinedForce,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "LinearUserDefinedForce() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "LinearUserDefinedForce()\n"
          "LinearUserDefinedForce(const LinearUserDefinedForce copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_LinearUserDefinedForce(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_LinearUserDefinedForce)
    {
        printf("LinearUserDefinedForce ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    LinearUserDefinedForce * local_this = (LinearUserDefinedForce *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_LinearUserDefinedForce)
        return local_this;
    if(requested_type == &Dtool_BaseForce)
        return ( BaseForce *)( LinearForce *) local_this;
    if(requested_type == &Dtool_LinearForce)
        return ( LinearForce *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( BaseForce *)( LinearForce *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( BaseForce *)( LinearForce *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( BaseForce *)( LinearForce *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_LinearUserDefinedForce(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_LinearUserDefinedForce)
        return from_this;
    if(from_type == &Dtool_BaseForce)
    {
          BaseForce* other_this = (BaseForce*)from_this;
          return (LinearUserDefinedForce*)other_this;
    }
    if(from_type == &Dtool_LinearForce)
    {
          LinearForce* other_this = (LinearForce*)from_this;
          return (LinearUserDefinedForce*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (LinearUserDefinedForce*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (LinearUserDefinedForce*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (LinearUserDefinedForce*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. LinearVectorForce 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void LinearVectorForce::set_vector(LVector3f const &v)
 * inline void LinearVectorForce::set_vector(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_LinearVectorForce_set_vector_210(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearVectorForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearVectorForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void LinearVectorForce::set_vector(LVector3f const &v)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"v", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setVector", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setVector", &param1));
                if(!PyErr_Occurred())
                {
                    LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "LinearVectorForce.setVector", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_vector(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call LinearVectorForce.setVector() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void LinearVectorForce::set_vector(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setVector", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_vector((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call LinearVectorForce.setVector() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setVector() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setVector(non-const LinearVectorForce this, const Vec3 v)\n"
          "setVector(non-const LinearVectorForce this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearVectorForce_set_vector_210_comment =
    "C++ Interface:\n"
    "setVector(non-const LinearVectorForce this, const Vec3 v)\n"
    "setVector(non-const LinearVectorForce this, float x, float y, float z)\n"
    "\n"
    "// Filename: linearVectorForce.I\n"
    "// Created by:  charles (21Jun00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_vector\n"
    "//      Access : Public\n"
    "// Description : encapsulating wrapper\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_vector\n"
    "//      Access : Public\n"
    "// Description : piecewise encapsulating wrapper\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LinearVectorForce_set_vector_210_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector3f LinearVectorForce::get_local_vector(void) const
 *******************************************************************/
static PyObject *Dtool_LinearVectorForce_get_local_vector_211(PyObject *self, PyObject *args,PyObject *kwds) {
    LinearVectorForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearVectorForce,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVector3f LinearVectorForce::get_local_vector(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLocalVector", key_word_list));
        else
            (PyArg_Parse(args, ":getLocalVector"));
        if(!PyErr_Occurred())
        {
            LVector3f result = ((const LinearVectorForce*)local_this)->get_local_vector();
            LVector3f *return_value = new LVector3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLocalVector(const LinearVectorForce this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearVectorForce_get_local_vector_211_comment =
    "C++ Interface:\n"
    "getLocalVector(const LinearVectorForce this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_local_vector\n"
    "//      Access : Public\n"
    "// Description :\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_LinearVectorForce_get_local_vector_211_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle LinearVectorForce::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_LinearVectorForce_get_class_type_212(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle LinearVectorForce::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = LinearVectorForce::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_LinearVectorForce_get_class_type_212_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_LinearVectorForce_get_class_type_212_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LinearVectorForce::LinearVectorForce(LVector3f const &vec, float a, bool mass)
 * LinearVectorForce::LinearVectorForce(LVector3f const &vec, float a, bool mass = (0))
 * LinearVectorForce::LinearVectorForce(LVector3f const &vec, float a = (1), bool mass = (0))
 * LinearVectorForce::LinearVectorForce(LinearVectorForce const &copy)
 * LinearVectorForce::LinearVectorForce(float x, float y, float z, float a, bool mass)
 * LinearVectorForce::LinearVectorForce(float x, float y, float z, float a, bool mass = (0))
 * LinearVectorForce::LinearVectorForce(float x, float y, float z, float a = (1), bool mass = (0))
 * LinearVectorForce::LinearVectorForce(float x, float y, float z = (0), float a = (1), bool mass = (0))
 * LinearVectorForce::LinearVectorForce(float x, float y = (0), float z = (0), float a = (1), bool mass = (0))
 * LinearVectorForce::LinearVectorForce(float x = (0), float y = (0), float z = (0), float a = (1), bool mass = (0))
 *******************************************************************/
int  Dtool_Init_LinearVectorForce(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-LinearVectorForce::LinearVectorForce(float x = (0), float y = (0), float z = (0), float a = (1), bool mass = (0))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":LinearVectorForce", key_word_list))
            {
                LinearVectorForce *return_value = new LinearVectorForce();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearVectorForce,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 LinearVectorForce::LinearVectorForce(LinearVectorForce const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:LinearVectorForce", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:LinearVectorForce", &param0));
                if(!PyErr_Occurred())
                {
                    LinearVectorForce *param0_this = (LinearVectorForce *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LinearVectorForce, 0, "LinearVectorForce.LinearVectorForce", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        LinearVectorForce *return_value = new LinearVectorForce(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearVectorForce,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 LinearVectorForce::LinearVectorForce(LVector3f const &vec, float a = (1), bool mass = (0))
                PyObject *param0;
                static char * key_word_list[] = {(char *)"vec", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:LinearVectorForce", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:LinearVectorForce", &param0));
                if(!PyErr_Occurred())
                {
                    LVector3f *param0_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LVector3f, 0, "LinearVectorForce.LinearVectorForce", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        LinearVectorForce *return_value = new LinearVectorForce(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearVectorForce,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 LinearVectorForce::LinearVectorForce(float x, float y = (0), float z = (0), float a = (1), bool mass = (0))
                double param0;
                static char * key_word_list[] = {(char *)"x", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "d:LinearVectorForce", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "d:LinearVectorForce", &param0));
                if(!PyErr_Occurred())
                {
                    LinearVectorForce *return_value = new LinearVectorForce((float)param0);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearVectorForce,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 LinearVectorForce::LinearVectorForce(LVector3f const &vec, float a, bool mass = (0))
                PyObject *param0;
                double param1;
                static char * key_word_list[] = {(char *)"vec", (char *)"a", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Od:LinearVectorForce", key_word_list, &param0, &param1))
                {
                    LVector3f *param0_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LVector3f, 0, "LinearVectorForce.LinearVectorForce", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        LinearVectorForce *return_value = new LinearVectorForce(*param0_this, (float)param1);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearVectorForce,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 LinearVectorForce::LinearVectorForce(float x, float y, float z = (0), float a = (1), bool mass = (0))
                double param0;
                double param1;
                static char * key_word_list[] = {(char *)"x", (char *)"y", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:LinearVectorForce", key_word_list, &param0, &param1))
                {
                    LinearVectorForce *return_value = new LinearVectorForce((float)param0, (float)param1);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearVectorForce,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 LinearVectorForce::LinearVectorForce(LVector3f const &vec, float a, bool mass)
                PyObject *param0;
                double param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"vec", (char *)"a", (char *)"mass", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OdO:LinearVectorForce", key_word_list, &param0, &param1, &param2))
                {
                    LVector3f *param0_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LVector3f, 0, "LinearVectorForce.LinearVectorForce", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        LinearVectorForce *return_value = new LinearVectorForce(*param0_this, (float)param1, (PyObject_IsTrue(param2)!=0));
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearVectorForce,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 LinearVectorForce::LinearVectorForce(float x, float y, float z, float a = (1), bool mass = (0))
                double param0;
                double param1;
                double param2;
                static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:LinearVectorForce", key_word_list, &param0, &param1, &param2))
                {
                    LinearVectorForce *return_value = new LinearVectorForce((float)param0, (float)param1, (float)param2);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearVectorForce,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          // 1-LinearVectorForce::LinearVectorForce(float x, float y, float z, float a, bool mass = (0))
            double param0;
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", (char *)"a", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:LinearVectorForce", key_word_list, &param0, &param1, &param2, &param3))
            {
                LinearVectorForce *return_value = new LinearVectorForce((float)param0, (float)param1, (float)param2, (float)param3);
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearVectorForce,true,false);
                }
            }
        }

        }
        break;
    case(5):
        {
        {
          // 1-LinearVectorForce::LinearVectorForce(float x, float y, float z, float a, bool mass)
            double param0;
            double param1;
            double param2;
            double param3;
            PyObject *param4;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", (char *)"a", (char *)"mass", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddddO:LinearVectorForce", key_word_list, &param0, &param1, &param2, &param3, &param4))
            {
                LinearVectorForce *return_value = new LinearVectorForce((float)param0, (float)param1, (float)param2, (float)param3, (PyObject_IsTrue(param4)!=0));
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_LinearVectorForce,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "LinearVectorForce() takes 0, 1, 2, 3, 4, or 5 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "LinearVectorForce()\n"
          "LinearVectorForce(const LinearVectorForce copy)\n"
          "LinearVectorForce(const Vec3 vec)\n"
          "LinearVectorForce(float x)\n"
          "LinearVectorForce(const Vec3 vec, float a)\n"
          "LinearVectorForce(float x, float y)\n"
          "LinearVectorForce(const Vec3 vec, float a, bool mass)\n"
          "LinearVectorForce(float x, float y, float z)\n"
          "LinearVectorForce(float x, float y, float z, float a)\n"
          "LinearVectorForce(float x, float y, float z, float a, bool mass)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_LinearVectorForce(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_LinearVectorForce)
    {
        printf("LinearVectorForce ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    LinearVectorForce * local_this = (LinearVectorForce *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_LinearVectorForce)
        return local_this;
    if(requested_type == &Dtool_BaseForce)
        return ( BaseForce *)( LinearForce *) local_this;
    if(requested_type == &Dtool_LinearForce)
        return ( LinearForce *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( BaseForce *)( LinearForce *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( BaseForce *)( LinearForce *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( BaseForce *)( LinearForce *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_LinearVectorForce(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_LinearVectorForce)
        return from_this;
    if(from_type == &Dtool_BaseForce)
    {
          BaseForce* other_this = (BaseForce*)from_this;
          return (LinearVectorForce*)other_this;
    }
    if(from_type == &Dtool_LinearForce)
    {
          LinearForce* other_this = (LinearForce*)from_this;
          return (LinearVectorForce*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (LinearVectorForce*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (LinearVectorForce*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (LinearVectorForce*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PhysicsCollisionHandler 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void PhysicsCollisionHandler::set_almost_stationary_speed(float speed)
 *******************************************************************/
static PyObject *Dtool_PhysicsCollisionHandler_set_almost_stationary_speed_216(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsCollisionHandler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsCollisionHandler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PhysicsCollisionHandler::set_almost_stationary_speed(float speed)
        double param1;
        static char * key_word_list[] = {(char *)"speed", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setAlmostStationarySpeed", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setAlmostStationarySpeed", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_almost_stationary_speed((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PhysicsCollisionHandler.setAlmostStationarySpeed() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAlmostStationarySpeed(non-const PhysicsCollisionHandler this, float speed)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsCollisionHandler_set_almost_stationary_speed_216_comment =
    "C++ Interface:\n"
    "setAlmostStationarySpeed(non-const PhysicsCollisionHandler this, float speed)\n"
    "\n"
    "// These setters and getter are a bit of a hack:\n"
    "";
#else
static const char * Dtool_PhysicsCollisionHandler_set_almost_stationary_speed_216_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float PhysicsCollisionHandler::get_almost_stationary_speed(void)
 *******************************************************************/
static PyObject *Dtool_PhysicsCollisionHandler_get_almost_stationary_speed_217(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsCollisionHandler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsCollisionHandler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline float PhysicsCollisionHandler::get_almost_stationary_speed(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAlmostStationarySpeed", key_word_list));
        else
            (PyArg_Parse(args, ":getAlmostStationarySpeed"));
        if(!PyErr_Occurred())
        {
            float return_value = (local_this)->get_almost_stationary_speed();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PhysicsCollisionHandler.getAlmostStationarySpeed() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAlmostStationarySpeed(non-const PhysicsCollisionHandler this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsCollisionHandler_get_almost_stationary_speed_217_comment =
    "C++ Interface:\n"
    "getAlmostStationarySpeed(non-const PhysicsCollisionHandler this)\n"
    "\n"
    "// These setters and getter are a bit of a hack:\n"
    "";
#else
static const char * Dtool_PhysicsCollisionHandler_get_almost_stationary_speed_217_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PhysicsCollisionHandler::set_static_friction_coef(float coef)
 *******************************************************************/
static PyObject *Dtool_PhysicsCollisionHandler_set_static_friction_coef_218(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsCollisionHandler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsCollisionHandler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PhysicsCollisionHandler::set_static_friction_coef(float coef)
        double param1;
        static char * key_word_list[] = {(char *)"coef", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setStaticFrictionCoef", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setStaticFrictionCoef", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_static_friction_coef((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PhysicsCollisionHandler.setStaticFrictionCoef() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setStaticFrictionCoef(non-const PhysicsCollisionHandler this, float coef)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsCollisionHandler_set_static_friction_coef_218_comment =
    "C++ Interface:\n"
    "setStaticFrictionCoef(non-const PhysicsCollisionHandler this, float coef)\n"
    "\n"
    "";
#else
static const char * Dtool_PhysicsCollisionHandler_set_static_friction_coef_218_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float PhysicsCollisionHandler::get_static_friction_coef(void)
 *******************************************************************/
static PyObject *Dtool_PhysicsCollisionHandler_get_static_friction_coef_219(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsCollisionHandler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsCollisionHandler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline float PhysicsCollisionHandler::get_static_friction_coef(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStaticFrictionCoef", key_word_list));
        else
            (PyArg_Parse(args, ":getStaticFrictionCoef"));
        if(!PyErr_Occurred())
        {
            float return_value = (local_this)->get_static_friction_coef();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PhysicsCollisionHandler.getStaticFrictionCoef() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStaticFrictionCoef(non-const PhysicsCollisionHandler this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsCollisionHandler_get_static_friction_coef_219_comment =
    "C++ Interface:\n"
    "getStaticFrictionCoef(non-const PhysicsCollisionHandler this)\n"
    "\n"
    "";
#else
static const char * Dtool_PhysicsCollisionHandler_get_static_friction_coef_219_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PhysicsCollisionHandler::set_dynamic_friction_coef(float coef)
 *******************************************************************/
static PyObject *Dtool_PhysicsCollisionHandler_set_dynamic_friction_coef_220(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsCollisionHandler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsCollisionHandler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PhysicsCollisionHandler::set_dynamic_friction_coef(float coef)
        double param1;
        static char * key_word_list[] = {(char *)"coef", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setDynamicFrictionCoef", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setDynamicFrictionCoef", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_dynamic_friction_coef((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PhysicsCollisionHandler.setDynamicFrictionCoef() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDynamicFrictionCoef(non-const PhysicsCollisionHandler this, float coef)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsCollisionHandler_set_dynamic_friction_coef_220_comment =
    "C++ Interface:\n"
    "setDynamicFrictionCoef(non-const PhysicsCollisionHandler this, float coef)\n"
    "\n"
    "";
#else
static const char * Dtool_PhysicsCollisionHandler_set_dynamic_friction_coef_220_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float PhysicsCollisionHandler::get_dynamic_friction_coef(void)
 *******************************************************************/
static PyObject *Dtool_PhysicsCollisionHandler_get_dynamic_friction_coef_221(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsCollisionHandler * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsCollisionHandler,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline float PhysicsCollisionHandler::get_dynamic_friction_coef(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDynamicFrictionCoef", key_word_list));
        else
            (PyArg_Parse(args, ":getDynamicFrictionCoef"));
        if(!PyErr_Occurred())
        {
            float return_value = (local_this)->get_dynamic_friction_coef();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PhysicsCollisionHandler.getDynamicFrictionCoef() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDynamicFrictionCoef(non-const PhysicsCollisionHandler this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsCollisionHandler_get_dynamic_friction_coef_221_comment =
    "C++ Interface:\n"
    "getDynamicFrictionCoef(non-const PhysicsCollisionHandler this)\n"
    "\n"
    "";
#else
static const char * Dtool_PhysicsCollisionHandler_get_dynamic_friction_coef_221_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle PhysicsCollisionHandler::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_PhysicsCollisionHandler_get_class_type_222(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle PhysicsCollisionHandler::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = PhysicsCollisionHandler::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsCollisionHandler_get_class_type_222_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_PhysicsCollisionHandler_get_class_type_222_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PhysicsCollisionHandler::PhysicsCollisionHandler(void)
 *******************************************************************/
int  Dtool_Init_PhysicsCollisionHandler(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-PhysicsCollisionHandler::PhysicsCollisionHandler(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":PhysicsCollisionHandler", key_word_list))
        {
            PhysicsCollisionHandler *return_value = new PhysicsCollisionHandler();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_PhysicsCollisionHandler,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "PhysicsCollisionHandler()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PhysicsCollisionHandler(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PhysicsCollisionHandler)
    {
        printf("PhysicsCollisionHandler ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PhysicsCollisionHandler * local_this = (PhysicsCollisionHandler *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PhysicsCollisionHandler)
        return local_this;
    if(requested_type == &Dtool_CollisionHandler)
        return ( CollisionHandler *)( CollisionHandlerEvent *)( CollisionHandlerPhysical *)( CollisionHandlerPusher *) local_this;
    if(requested_type == &Dtool_CollisionHandlerEvent)
        return ( CollisionHandlerEvent *)( CollisionHandlerPhysical *)( CollisionHandlerPusher *) local_this;
    if(requested_type == &Dtool_CollisionHandlerPhysical)
        return ( CollisionHandlerPhysical *)( CollisionHandlerPusher *) local_this;
    if(requested_type == &Dtool_CollisionHandlerPusher)
        return ( CollisionHandlerPusher *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( CollisionHandler *)( CollisionHandlerEvent *)( CollisionHandlerPhysical *)( CollisionHandlerPusher *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( CollisionHandler *)( CollisionHandlerEvent *)( CollisionHandlerPhysical *)( CollisionHandlerPusher *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( CollisionHandler *)( CollisionHandlerEvent *)( CollisionHandlerPhysical *)( CollisionHandlerPusher *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PhysicsCollisionHandler(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PhysicsCollisionHandler)
        return from_this;
    if(from_type == &Dtool_CollisionHandler)
    {
          CollisionHandler* other_this = (CollisionHandler*)from_this;
          return (PhysicsCollisionHandler*)other_this;
    }
    if(from_type == &Dtool_CollisionHandlerEvent)
    {
          CollisionHandlerEvent* other_this = (CollisionHandlerEvent*)from_this;
          return (PhysicsCollisionHandler*)other_this;
    }
    if(from_type == &Dtool_CollisionHandlerPhysical)
    {
          CollisionHandlerPhysical* other_this = (CollisionHandlerPhysical*)from_this;
          return (PhysicsCollisionHandler*)other_this;
    }
    if(from_type == &Dtool_CollisionHandlerPusher)
    {
          CollisionHandlerPusher* other_this = (CollisionHandlerPusher*)from_this;
          return (PhysicsCollisionHandler*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (PhysicsCollisionHandler*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (PhysicsCollisionHandler*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (PhysicsCollisionHandler*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PhysicsManager 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void PhysicsManager::attach_linear_integrator(LinearIntegrator *i)
 *******************************************************************/
static PyObject *Dtool_PhysicsManager_attach_linear_integrator_226(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PhysicsManager::attach_linear_integrator(LinearIntegrator *i)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"i", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:attachLinearIntegrator", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:attachLinearIntegrator", &param1));
            if(!PyErr_Occurred())
            {
                LinearIntegrator *param1_this = (LinearIntegrator *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LinearIntegrator, 1, "PhysicsManager.attachLinearIntegrator", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->attach_linear_integrator(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsManager.attachLinearIntegrator() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "attachLinearIntegrator(non-const PhysicsManager this, non-const LinearIntegrator i)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsManager_attach_linear_integrator_226_comment =
    "C++ Interface:\n"
    "attachLinearIntegrator(non-const PhysicsManager this, non-const LinearIntegrator i)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : attach_linear_integrator\n"
    "//      Access : Public\n"
    "// Description : Hooks a linear integrator into the manager\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsManager_attach_linear_integrator_226_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PhysicsManager::attach_angular_integrator(AngularIntegrator *i)
 *******************************************************************/
static PyObject *Dtool_PhysicsManager_attach_angular_integrator_227(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PhysicsManager::attach_angular_integrator(AngularIntegrator *i)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"i", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:attachAngularIntegrator", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:attachAngularIntegrator", &param1));
            if(!PyErr_Occurred())
            {
                AngularIntegrator *param1_this = (AngularIntegrator *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AngularIntegrator, 1, "PhysicsManager.attachAngularIntegrator", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->attach_angular_integrator(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsManager.attachAngularIntegrator() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "attachAngularIntegrator(non-const PhysicsManager this, non-const AngularIntegrator i)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsManager_attach_angular_integrator_227_comment =
    "C++ Interface:\n"
    "attachAngularIntegrator(non-const PhysicsManager this, non-const AngularIntegrator i)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : attach_angular_integrator\n"
    "//      Access : Public\n"
    "// Description : Hooks an angular integrator into the manager\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsManager_attach_angular_integrator_227_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PhysicsManager::attach_physical(Physical *p)
 *******************************************************************/
static PyObject *Dtool_PhysicsManager_attach_physical_228(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PhysicsManager::attach_physical(Physical *p)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"p", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:attachPhysical", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:attachPhysical", &param1));
            if(!PyErr_Occurred())
            {
                Physical *param1_this = (Physical *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Physical, 1, "PhysicsManager.attachPhysical", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->attach_physical(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsManager.attachPhysical() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "attachPhysical(non-const PhysicsManager this, non-const Physical p)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsManager_attach_physical_228_comment =
    "C++ Interface:\n"
    "attachPhysical(non-const PhysicsManager this, non-const Physical p)\n"
    "\n"
    "// Filename: physicsManager.I\n"
    "// Created by:  charles (14Jun00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : attach_physical\n"
    "//      Access : Public\n"
    "// Description : Registers a Physical class with the manager\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsManager_attach_physical_228_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PhysicsManager::attach_physicalnode(PhysicalNode *p)
 *******************************************************************/
static PyObject *Dtool_PhysicsManager_attach_physicalnode_229(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PhysicsManager::attach_physicalnode(PhysicalNode *p)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"p", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:attachPhysicalnode", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:attachPhysicalnode", &param1));
            if(!PyErr_Occurred())
            {
                PhysicalNode *param1_this = (PhysicalNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PhysicalNode, 1, "PhysicsManager.attachPhysicalnode", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->attach_physicalnode(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsManager.attachPhysicalnode() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "attachPhysicalnode(non-const PhysicsManager this, non-const PhysicalNode p)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsManager_attach_physicalnode_229_comment =
    "C++ Interface:\n"
    "attachPhysicalnode(non-const PhysicsManager this, non-const PhysicalNode p)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : attach_physicalnode\n"
    "//      Access : Public\n"
    "// Description : Please call attach_physical_node instead.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsManager_attach_physicalnode_229_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PhysicsManager::attach_physical_node(PhysicalNode *p)
 *******************************************************************/
static PyObject *Dtool_PhysicsManager_attach_physical_node_230(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PhysicsManager::attach_physical_node(PhysicalNode *p)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"p", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:attachPhysicalNode", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:attachPhysicalNode", &param1));
            if(!PyErr_Occurred())
            {
                PhysicalNode *param1_this = (PhysicalNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PhysicalNode, 1, "PhysicsManager.attachPhysicalNode", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->attach_physical_node(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsManager.attachPhysicalNode() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "attachPhysicalNode(non-const PhysicsManager this, non-const PhysicalNode p)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsManager_attach_physical_node_230_comment =
    "C++ Interface:\n"
    "attachPhysicalNode(non-const PhysicsManager this, non-const PhysicalNode p)\n"
    "\n"
    "// use attach_physical_node instead.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : attach_physical_node\n"
    "//      Access : Public\n"
    "// Description : Registers a physicalnode with the manager\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsManager_attach_physical_node_230_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PhysicsManager::add_linear_force(LinearForce *f)
 *******************************************************************/
static PyObject *Dtool_PhysicsManager_add_linear_force_231(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PhysicsManager::add_linear_force(LinearForce *f)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"f", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addLinearForce", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addLinearForce", &param1));
            if(!PyErr_Occurred())
            {
                LinearForce *param1_this = (LinearForce *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LinearForce, 1, "PhysicsManager.addLinearForce", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_linear_force(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsManager.addLinearForce() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addLinearForce(non-const PhysicsManager this, non-const LinearForce f)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsManager_add_linear_force_231_comment =
    "C++ Interface:\n"
    "addLinearForce(non-const PhysicsManager this, non-const LinearForce f)\n"
    "\n"
    "// use attach_physical_node instead.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : attach_linear_force\n"
    "//      Access : Public\n"
    "// Description : Adds a global linear force to the physics manager\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsManager_add_linear_force_231_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PhysicsManager::add_angular_force(AngularForce *f)
 *******************************************************************/
static PyObject *Dtool_PhysicsManager_add_angular_force_232(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PhysicsManager::add_angular_force(AngularForce *f)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"f", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addAngularForce", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addAngularForce", &param1));
            if(!PyErr_Occurred())
            {
                AngularForce *param1_this = (AngularForce *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AngularForce, 1, "PhysicsManager.addAngularForce", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_angular_force(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsManager.addAngularForce() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addAngularForce(non-const PhysicsManager this, non-const AngularForce f)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsManager_add_angular_force_232_comment =
    "C++ Interface:\n"
    "addAngularForce(non-const PhysicsManager this, non-const AngularForce f)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : attach_angular_force\n"
    "//      Access : Public\n"
    "// Description : Adds a global angular force to the physics manager\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsManager_add_angular_force_232_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PhysicsManager::clear_linear_forces(void)
 *******************************************************************/
static PyObject *Dtool_PhysicsManager_clear_linear_forces_233(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PhysicsManager::clear_linear_forces(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearLinearForces", key_word_list));
        else
            (PyArg_Parse(args, ":clearLinearForces"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_linear_forces();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PhysicsManager.clearLinearForces() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearLinearForces(non-const PhysicsManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsManager_clear_linear_forces_233_comment =
    "C++ Interface:\n"
    "clearLinearForces(non-const PhysicsManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : clear_linear_forces\n"
    "//      Access : Public\n"
    "// Description : Resets the physics manager force vector\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsManager_clear_linear_forces_233_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PhysicsManager::clear_angular_forces(void)
 *******************************************************************/
static PyObject *Dtool_PhysicsManager_clear_angular_forces_234(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PhysicsManager::clear_angular_forces(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearAngularForces", key_word_list));
        else
            (PyArg_Parse(args, ":clearAngularForces"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_angular_forces();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PhysicsManager.clearAngularForces() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearAngularForces(non-const PhysicsManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsManager_clear_angular_forces_234_comment =
    "C++ Interface:\n"
    "clearAngularForces(non-const PhysicsManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : clear_angular_forces\n"
    "//      Access : Public\n"
    "// Description : Resets the physics manager force vector\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsManager_clear_angular_forces_234_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PhysicsManager::clear_physicals(void)
 *******************************************************************/
static PyObject *Dtool_PhysicsManager_clear_physicals_235(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PhysicsManager::clear_physicals(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearPhysicals", key_word_list));
        else
            (PyArg_Parse(args, ":clearPhysicals"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_physicals();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PhysicsManager.clearPhysicals() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearPhysicals(non-const PhysicsManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsManager_clear_physicals_235_comment =
    "C++ Interface:\n"
    "clearPhysicals(non-const PhysicsManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : clear_physicals\n"
    "//      Access : Public\n"
    "// Description : Resets the physics manager objects vector\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsManager_clear_physicals_235_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PhysicsManager::set_viscosity(float viscosity)
 *******************************************************************/
static PyObject *Dtool_PhysicsManager_set_viscosity_236(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PhysicsManager::set_viscosity(float viscosity)
        double param1;
        static char * key_word_list[] = {(char *)"viscosity", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setViscosity", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setViscosity", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_viscosity((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PhysicsManager.setViscosity() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setViscosity(non-const PhysicsManager this, float viscosity)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsManager_set_viscosity_236_comment =
    "C++ Interface:\n"
    "setViscosity(non-const PhysicsManager this, float viscosity)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : set_viscosity\n"
    "//      Access : Public\n"
    "// Description : Set the global viscosity.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsManager_set_viscosity_236_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float PhysicsManager::get_viscosity(void) const
 *******************************************************************/
static PyObject *Dtool_PhysicsManager_get_viscosity_237(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float PhysicsManager::get_viscosity(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getViscosity", key_word_list));
        else
            (PyArg_Parse(args, ":getViscosity"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const PhysicsManager*)local_this)->get_viscosity();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getViscosity(const PhysicsManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsManager_get_viscosity_237_comment =
    "C++ Interface:\n"
    "getViscosity(const PhysicsManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : get_viscosity\n"
    "//      Access : Public\n"
    "// Description : Get the global viscosity.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsManager_get_viscosity_237_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PhysicsManager::remove_physical(Physical *p)
 *******************************************************************/
static PyObject *Dtool_PhysicsManager_remove_physical_238(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PhysicsManager::remove_physical(Physical *p)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"p", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removePhysical", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removePhysical", &param1));
            if(!PyErr_Occurred())
            {
                Physical *param1_this = (Physical *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Physical, 1, "PhysicsManager.removePhysical", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->remove_physical(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsManager.removePhysical() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removePhysical(non-const PhysicsManager this, non-const Physical p)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsManager_remove_physical_238_comment =
    "C++ Interface:\n"
    "removePhysical(non-const PhysicsManager this, non-const Physical p)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : remove_physical\n"
    "//       Access : Public\n"
    "//  Description : takes a physical out of the object list\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsManager_remove_physical_238_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PhysicsManager::remove_physical_node(PhysicalNode *p)
 *******************************************************************/
static PyObject *Dtool_PhysicsManager_remove_physical_node_239(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PhysicsManager::remove_physical_node(PhysicalNode *p)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"p", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removePhysicalNode", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removePhysicalNode", &param1));
            if(!PyErr_Occurred())
            {
                PhysicalNode *param1_this = (PhysicalNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PhysicalNode, 1, "PhysicsManager.removePhysicalNode", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->remove_physical_node(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsManager.removePhysicalNode() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removePhysicalNode(non-const PhysicsManager this, non-const PhysicalNode p)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsManager_remove_physical_node_239_comment =
    "C++ Interface:\n"
    "removePhysicalNode(non-const PhysicsManager this, non-const PhysicalNode p)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//    Function : remove_physical_node\n"
    "//      Access : Public\n"
    "// Description : Removes a physicalnode from the manager\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsManager_remove_physical_node_239_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PhysicsManager::remove_linear_force(LinearForce *f)
 *******************************************************************/
static PyObject *Dtool_PhysicsManager_remove_linear_force_240(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PhysicsManager::remove_linear_force(LinearForce *f)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"f", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeLinearForce", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeLinearForce", &param1));
            if(!PyErr_Occurred())
            {
                LinearForce *param1_this = (LinearForce *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LinearForce, 1, "PhysicsManager.removeLinearForce", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->remove_linear_force(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsManager.removeLinearForce() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeLinearForce(non-const PhysicsManager this, non-const LinearForce f)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsManager_remove_linear_force_240_comment =
    "C++ Interface:\n"
    "removeLinearForce(non-const PhysicsManager this, non-const LinearForce f)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : remove_linear_force\n"
    "//       Access : Public\n"
    "//  Description : takes a linear force out of the physics list\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsManager_remove_linear_force_240_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PhysicsManager::remove_angular_force(AngularForce *f)
 *******************************************************************/
static PyObject *Dtool_PhysicsManager_remove_angular_force_241(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PhysicsManager::remove_angular_force(AngularForce *f)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"f", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeAngularForce", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeAngularForce", &param1));
            if(!PyErr_Occurred())
            {
                AngularForce *param1_this = (AngularForce *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AngularForce, 1, "PhysicsManager.removeAngularForce", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->remove_angular_force(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsManager.removeAngularForce() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeAngularForce(non-const PhysicsManager this, non-const AngularForce f)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsManager_remove_angular_force_241_comment =
    "C++ Interface:\n"
    "removeAngularForce(non-const PhysicsManager this, non-const AngularForce f)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : remove_angular_force\n"
    "//       Access : Public\n"
    "//  Description : takes an angular force out of the physics list\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsManager_remove_angular_force_241_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PhysicsManager::do_physics(float dt)
 * void PhysicsManager::do_physics(float dt, Physical *p)
 *******************************************************************/
static PyObject *Dtool_PhysicsManager_do_physics_242(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void PhysicsManager::do_physics(float dt)
            double param1;
            static char * key_word_list[] = {(char *)"dt", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:doPhysics", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:doPhysics", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->do_physics((float)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PhysicsManager.doPhysics() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void PhysicsManager::do_physics(float dt, Physical *p)
                double param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"dt", (char *)"p", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "dO:doPhysics", key_word_list, &param1, &param2))
                {
                    Physical *param2_this = (Physical *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Physical, 2, "PhysicsManager.doPhysics", 0, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        (local_this)->do_physics((float)param1, param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PhysicsManager.doPhysics() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "doPhysics() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "doPhysics(non-const PhysicsManager this, float dt)\n"
          "doPhysics(non-const PhysicsManager this, float dt, non-const Physical p)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsManager_do_physics_242_comment =
    "C++ Interface:\n"
    "doPhysics(non-const PhysicsManager this, float dt)\n"
    "doPhysics(non-const PhysicsManager this, float dt, non-const Physical p)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : DoPhysics\n"
    "//       Access : Public\n"
    "//  Description : This is the main high-level API call.  Performs\n"
    "//                integration on every attached Physical.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : DoPhysics\n"
    "//       Access : Public\n"
    "//  Description : This is the main high-level API call.  Performs\n"
    "//                integration on a single physical.  Make sure its \n"
    "//                associated forces are active.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsManager_do_physics_242_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void PhysicsManager::init_random_seed(void)
 *******************************************************************/
static PyObject *Dtool_PhysicsManager_init_random_seed_243(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void PhysicsManager::init_random_seed(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":initRandomSeed", key_word_list));
        else
            (PyArg_Parse(args, ":initRandomSeed"));
        if(!PyErr_Occurred())
        {
            (local_this)->init_random_seed();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PhysicsManager.initRandomSeed() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "initRandomSeed(non-const PhysicsManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsManager_init_random_seed_243_comment =
    "C++ Interface:\n"
    "initRandomSeed(non-const PhysicsManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : InitRandomSeed\n"
    "//       Access : Public\n"
    "//  Description : One-time config function, sets up the random seed\n"
    "//                used by the physics and particle systems.\n"
    "//                For synchronizing across distributed computers\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsManager_init_random_seed_243_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void PhysicsManager::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_PhysicsManager_output_244(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void PhysicsManager::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PhysicsManager.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const PhysicsManager*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const PhysicsManager this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsManager_output_244_comment =
    "C++ Interface:\n"
    "output(const PhysicsManager this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : output\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsManager_output_244_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void PhysicsManager::write_physicals(ostream &out, unsigned int indent) const
 * virtual void PhysicsManager::write_physicals(ostream &out, unsigned int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_PhysicsManager_write_physicals_245(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void PhysicsManager::write_physicals(ostream &out, unsigned int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:writePhysicals", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:writePhysicals", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PhysicsManager.writePhysicals", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const PhysicsManager*)local_this)->write_physicals(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void PhysicsManager::write_physicals(ostream &out, unsigned int indent) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:writePhysicals", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PhysicsManager.writePhysicals", 0, coerced_ptr, report_errors);
 PyObject *param2_uint = PyNumber_Long(param2);
                    if (!((param1_this == NULL)|| (param2_uint == NULL)))
                    {
                        ((const PhysicsManager*)local_this)->write_physicals(*param1_this, PyLong_AsUnsignedLong(param2_uint));
                         Py_XDECREF(param2_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "writePhysicals() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "writePhysicals(const PhysicsManager this, non-const Ostream out)\n"
          "writePhysicals(const PhysicsManager this, non-const Ostream out, unsigned int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsManager_write_physicals_245_comment =
    "C++ Interface:\n"
    "writePhysicals(const PhysicsManager this, non-const Ostream out)\n"
    "writePhysicals(const PhysicsManager this, non-const Ostream out, unsigned int indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : write_physicals\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsManager_write_physicals_245_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void PhysicsManager::write_linear_forces(ostream &out, unsigned int indent) const
 * virtual void PhysicsManager::write_linear_forces(ostream &out, unsigned int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_PhysicsManager_write_linear_forces_246(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void PhysicsManager::write_linear_forces(ostream &out, unsigned int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:writeLinearForces", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:writeLinearForces", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PhysicsManager.writeLinearForces", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const PhysicsManager*)local_this)->write_linear_forces(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void PhysicsManager::write_linear_forces(ostream &out, unsigned int indent) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:writeLinearForces", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PhysicsManager.writeLinearForces", 0, coerced_ptr, report_errors);
 PyObject *param2_uint = PyNumber_Long(param2);
                    if (!((param1_this == NULL)|| (param2_uint == NULL)))
                    {
                        ((const PhysicsManager*)local_this)->write_linear_forces(*param1_this, PyLong_AsUnsignedLong(param2_uint));
                         Py_XDECREF(param2_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "writeLinearForces() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "writeLinearForces(const PhysicsManager this, non-const Ostream out)\n"
          "writeLinearForces(const PhysicsManager this, non-const Ostream out, unsigned int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsManager_write_linear_forces_246_comment =
    "C++ Interface:\n"
    "writeLinearForces(const PhysicsManager this, non-const Ostream out)\n"
    "writeLinearForces(const PhysicsManager this, non-const Ostream out, unsigned int indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : write_forces\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsManager_write_linear_forces_246_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void PhysicsManager::write_angular_forces(ostream &out, unsigned int indent) const
 * virtual void PhysicsManager::write_angular_forces(ostream &out, unsigned int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_PhysicsManager_write_angular_forces_247(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void PhysicsManager::write_angular_forces(ostream &out, unsigned int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:writeAngularForces", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:writeAngularForces", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PhysicsManager.writeAngularForces", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const PhysicsManager*)local_this)->write_angular_forces(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void PhysicsManager::write_angular_forces(ostream &out, unsigned int indent) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:writeAngularForces", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PhysicsManager.writeAngularForces", 0, coerced_ptr, report_errors);
 PyObject *param2_uint = PyNumber_Long(param2);
                    if (!((param1_this == NULL)|| (param2_uint == NULL)))
                    {
                        ((const PhysicsManager*)local_this)->write_angular_forces(*param1_this, PyLong_AsUnsignedLong(param2_uint));
                         Py_XDECREF(param2_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "writeAngularForces() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "writeAngularForces(const PhysicsManager this, non-const Ostream out)\n"
          "writeAngularForces(const PhysicsManager this, non-const Ostream out, unsigned int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsManager_write_angular_forces_247_comment =
    "C++ Interface:\n"
    "writeAngularForces(const PhysicsManager this, non-const Ostream out)\n"
    "writeAngularForces(const PhysicsManager this, non-const Ostream out, unsigned int indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : write_angular_forces\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsManager_write_angular_forces_247_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void PhysicsManager::write(ostream &out, unsigned int indent) const
 * virtual void PhysicsManager::write(ostream &out, unsigned int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_PhysicsManager_write_248(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void PhysicsManager::write(ostream &out, unsigned int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PhysicsManager.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const PhysicsManager*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void PhysicsManager::write(ostream &out, unsigned int indent) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PhysicsManager.write", 0, coerced_ptr, report_errors);
 PyObject *param2_uint = PyNumber_Long(param2);
                    if (!((param1_this == NULL)|| (param2_uint == NULL)))
                    {
                        ((const PhysicsManager*)local_this)->write(*param1_this, PyLong_AsUnsignedLong(param2_uint));
                         Py_XDECREF(param2_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const PhysicsManager this, non-const Ostream out)\n"
          "write(const PhysicsManager this, non-const Ostream out, unsigned int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsManager_write_248_comment =
    "C++ Interface:\n"
    "write(const PhysicsManager this, non-const Ostream out)\n"
    "write(const PhysicsManager this, non-const Ostream out, unsigned int indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : write\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsManager_write_248_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void PhysicsManager::debug_output(ostream &out, unsigned int indent) const
 * virtual void PhysicsManager::debug_output(ostream &out, unsigned int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_PhysicsManager_debug_output_249(PyObject *self, PyObject *args,PyObject *kwds) {
    PhysicsManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void PhysicsManager::debug_output(ostream &out, unsigned int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:debugOutput", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:debugOutput", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PhysicsManager.debugOutput", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const PhysicsManager*)local_this)->debug_output(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void PhysicsManager::debug_output(ostream &out, unsigned int indent) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:debugOutput", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "PhysicsManager.debugOutput", 0, coerced_ptr, report_errors);
 PyObject *param2_uint = PyNumber_Long(param2);
                    if (!((param1_this == NULL)|| (param2_uint == NULL)))
                    {
                        ((const PhysicsManager*)local_this)->debug_output(*param1_this, PyLong_AsUnsignedLong(param2_uint));
                         Py_XDECREF(param2_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "debugOutput() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "debugOutput(const PhysicsManager this, non-const Ostream out)\n"
          "debugOutput(const PhysicsManager this, non-const Ostream out, unsigned int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PhysicsManager_debug_output_249_comment =
    "C++ Interface:\n"
    "debugOutput(const PhysicsManager this, non-const Ostream out)\n"
    "debugOutput(const PhysicsManager this, non-const Ostream out, unsigned int indent)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : write\n"
    "//       Access : Public\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PhysicsManager_debug_output_249_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PhysicsManager::PhysicsManager(void)
 *******************************************************************/
int  Dtool_Init_PhysicsManager(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-PhysicsManager::PhysicsManager(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":PhysicsManager", key_word_list))
        {
            PhysicsManager *return_value = new PhysicsManager();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_PhysicsManager,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "PhysicsManager()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PhysicsManager(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PhysicsManager)
    {
        printf("PhysicsManager ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PhysicsManager * local_this = (PhysicsManager *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PhysicsManager)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PhysicsManager(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PhysicsManager)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. PhysicsObject | PhysicsObject
//********************************************************************
PyMethodDef Dtool_Methods_PhysicsObject[]= {
  { "assign",(PyCFunction ) &Dtool_PhysicsObject_operator_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_operator_4_comment},
  { "setActive",(PyCFunction ) &Dtool_PhysicsObject_set_active_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_set_active_5_comment},
  { "getActive",(PyCFunction ) &Dtool_PhysicsObject_get_active_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_get_active_6_comment},
  { "setMass",(PyCFunction ) &Dtool_PhysicsObject_set_mass_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_set_mass_7_comment},
  { "getMass",(PyCFunction ) &Dtool_PhysicsObject_get_mass_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_get_mass_8_comment},
  { "setPosition",(PyCFunction ) &Dtool_PhysicsObject_set_position_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_set_position_9_comment},
  { "getPosition",(PyCFunction ) &Dtool_PhysicsObject_get_position_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_get_position_10_comment},
  { "resetPosition",(PyCFunction ) &Dtool_PhysicsObject_reset_position_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_reset_position_11_comment},
  { "setLastPosition",(PyCFunction ) &Dtool_PhysicsObject_set_last_position_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_set_last_position_12_comment},
  { "getLastPosition",(PyCFunction ) &Dtool_PhysicsObject_get_last_position_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_get_last_position_13_comment},
  { "setVelocity",(PyCFunction ) &Dtool_PhysicsObject_set_velocity_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_set_velocity_14_comment},
  { "getVelocity",(PyCFunction ) &Dtool_PhysicsObject_get_velocity_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_get_velocity_15_comment},
  { "getImplicitVelocity",(PyCFunction ) &Dtool_PhysicsObject_get_implicit_velocity_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_get_implicit_velocity_16_comment},
  { "addTorque",(PyCFunction ) &Dtool_PhysicsObject_add_torque_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_add_torque_17_comment},
  { "addImpulse",(PyCFunction ) &Dtool_PhysicsObject_add_impulse_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_add_impulse_18_comment},
  { "addImpact",(PyCFunction ) &Dtool_PhysicsObject_add_impact_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_add_impact_19_comment},
  { "addLocalTorque",(PyCFunction ) &Dtool_PhysicsObject_add_local_torque_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_add_local_torque_20_comment},
  { "addLocalImpulse",(PyCFunction ) &Dtool_PhysicsObject_add_local_impulse_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_add_local_impulse_21_comment},
  { "addLocalImpact",(PyCFunction ) &Dtool_PhysicsObject_add_local_impact_22, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_add_local_impact_22_comment},
  { "setTerminalVelocity",(PyCFunction ) &Dtool_PhysicsObject_set_terminal_velocity_23, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_set_terminal_velocity_23_comment},
  { "getTerminalVelocity",(PyCFunction ) &Dtool_PhysicsObject_get_terminal_velocity_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_get_terminal_velocity_24_comment},
  { "setOriented",(PyCFunction ) &Dtool_PhysicsObject_set_oriented_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_set_oriented_25_comment},
  { "getOriented",(PyCFunction ) &Dtool_PhysicsObject_get_oriented_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_get_oriented_26_comment},
  { "setOrientation",(PyCFunction ) &Dtool_PhysicsObject_set_orientation_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_set_orientation_27_comment},
  { "getOrientation",(PyCFunction ) &Dtool_PhysicsObject_get_orientation_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_get_orientation_28_comment},
  { "resetOrientation",(PyCFunction ) &Dtool_PhysicsObject_reset_orientation_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_reset_orientation_29_comment},
  { "setRotation",(PyCFunction ) &Dtool_PhysicsObject_set_rotation_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_set_rotation_30_comment},
  { "getRotation",(PyCFunction ) &Dtool_PhysicsObject_get_rotation_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_get_rotation_31_comment},
  { "getInertialTensor",(PyCFunction ) &Dtool_PhysicsObject_get_inertial_tensor_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_get_inertial_tensor_32_comment},
  { "getLcs",(PyCFunction ) &Dtool_PhysicsObject_get_lcs_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_get_lcs_33_comment},
  { "makeCopy",(PyCFunction ) &Dtool_PhysicsObject_make_copy_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_make_copy_34_comment},
  { "output",(PyCFunction ) &Dtool_PhysicsObject_output_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_output_35_comment},
  { "write",(PyCFunction ) &Dtool_PhysicsObject_write_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_write_36_comment},
  { "getClassType",(PyCFunction ) &Dtool_PhysicsObject_get_class_type_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObject_get_class_type_37_comment},
  { "__copy__", (PyCFunction)&copy_from_make_copy, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     PhysicsObject
//////////////////
static PyObject *  Dtool_Repr_PhysicsObject(PyObject * self)
{
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     PhysicsObject
//////////////////
static PyObject *  Dtool_Str_PhysicsObject(PyObject * self)
{
    PhysicsObject * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObject,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_PhysicsObject(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PhysicsObject.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PhysicsObject\n"
          "// Description : A body on which physics will be applied.  If you're\n"
          "//               looking to add physical motion to your class, do\n"
          "//               NOT derive from this.  Derive from Physical instead.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_PhysicsObject.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_PhysicsObject.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PhysicsObject.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PhysicsObject.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_PhysicsObject.As_PyTypeObject().tp_repr = & Dtool_Repr_PhysicsObject;
        // __str__
        Dtool_PhysicsObject.As_PyTypeObject().tp_str = & Dtool_Str_PhysicsObject;
        if(PyType_Ready(&Dtool_PhysicsObject.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PhysicsObject)");
             printf(" Error In PyType_ReadyPhysicsObject");
             return;
        }
        Py_INCREF(&Dtool_PhysicsObject.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PhysicsObject.As_PyTypeObject().tp_dict,"PhysicsObject",&Dtool_PhysicsObject.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_PhysicsObject.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_PhysicsObject[33],&Dtool_PhysicsObject.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PhysicsObject,PhysicsObject::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PhysicsObject.As_PyTypeObject());
        PyModule_AddObject(module, "PhysicsObject",(PyObject *)&Dtool_PhysicsObject.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PhysicsObjectCollection | PhysicsObjectCollection
//********************************************************************
PyMethodDef Dtool_Methods_PhysicsObjectCollection[]= {
  { "assign",(PyCFunction ) &Dtool_PhysicsObjectCollection_operator_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObjectCollection_operator_40_comment},
  { "addPhysicsObject",(PyCFunction ) &Dtool_PhysicsObjectCollection_add_physics_object_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObjectCollection_add_physics_object_42_comment},
  { "removePhysicsObject",(PyCFunction ) &Dtool_PhysicsObjectCollection_remove_physics_object_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObjectCollection_remove_physics_object_43_comment},
  { "addPhysicsObjectsFrom",(PyCFunction ) &Dtool_PhysicsObjectCollection_add_physics_objects_from_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObjectCollection_add_physics_objects_from_44_comment},
  { "removePhysicsObjectsFrom",(PyCFunction ) &Dtool_PhysicsObjectCollection_remove_physics_objects_from_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObjectCollection_remove_physics_objects_from_45_comment},
  { "removeDuplicatePhysicsObjects",(PyCFunction ) &Dtool_PhysicsObjectCollection_remove_duplicate_physics_objects_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObjectCollection_remove_duplicate_physics_objects_46_comment},
  { "hasPhysicsObject",(PyCFunction ) &Dtool_PhysicsObjectCollection_has_physics_object_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObjectCollection_has_physics_object_47_comment},
  { "clear",(PyCFunction ) &Dtool_PhysicsObjectCollection_clear_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObjectCollection_clear_48_comment},
  { "isEmpty",(PyCFunction ) &Dtool_PhysicsObjectCollection_is_empty_49, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObjectCollection_is_empty_49_comment},
  { "getNumPhysicsObjects",(PyCFunction ) &Dtool_PhysicsObjectCollection_get_num_physics_objects_50, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObjectCollection_get_num_physics_objects_50_comment},
  { "getPhysicsObject",(PyCFunction ) &Dtool_PhysicsObjectCollection_get_physics_object_51, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObjectCollection_get_physics_object_51_comment},
  { "__getitem__",(PyCFunction ) &Dtool_PhysicsObjectCollection_operator_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObjectCollection_operator_52_comment},
  { "size",(PyCFunction ) &Dtool_PhysicsObjectCollection_size_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObjectCollection_size_53_comment},
  { "__iadd__",(PyCFunction ) &Dtool_PhysicsObjectCollection_operator_54, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObjectCollection_operator_54_comment},
  { "__add__",(PyCFunction ) &Dtool_PhysicsObjectCollection_operator_55, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObjectCollection_operator_55_comment},
  { "output",(PyCFunction ) &Dtool_PhysicsObjectCollection_output_56, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObjectCollection_output_56_comment},
  { "write",(PyCFunction ) &Dtool_PhysicsObjectCollection_write_57, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsObjectCollection_write_57_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { "getPhysicsObjects",(PyCFunction) &MakeSeq_PhysicsObjectCollection_get_physics_objects, METH_NOARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PhysicsObjectCollection ...tp_as_number->nb_add = __add__
//////////////////
static PyObject *Dtool_PhysicsObjectCollection_operator_55__add__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_PhysicsObjectCollection_operator_55(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PhysicsObjectCollection ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_PhysicsObjectCollection_size_53size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_PhysicsObjectCollection_size_53(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PhysicsObjectCollection ...tp_as_number->nb_inplace_add = __iadd__
//////////////////
static PyObject *Dtool_PhysicsObjectCollection_operator_54__iadd__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_PhysicsObjectCollection_operator_54(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     PhysicsObjectCollection ...tp_as_sequence->sq_item = __getitem__
//////////////////
static PyObject * Dtool_PhysicsObjectCollection_operator_52__getitem__( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_PhysicsObjectCollection_operator_52(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A __repr__ Function
//     PhysicsObjectCollection
//////////////////
static PyObject *  Dtool_Repr_PhysicsObjectCollection(PyObject * self)
{
    PhysicsObjectCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObjectCollection,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     PhysicsObjectCollection
//////////////////
static PyObject *  Dtool_Str_PhysicsObjectCollection(PyObject * self)
{
    PhysicsObjectCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsObjectCollection,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_PhysicsObjectCollection(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PhysicsObjectCollection.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PhysicsObjectCollection\n"
          "// Description : This is a set of zero or more PhysicsObjects.  It's handy\n"
          "//               for returning from functions that need to return\n"
          "//               multiple PhysicsObjects.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_PhysicsObjectCollection.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_PhysicsObjectCollection.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PhysicsObjectCollection.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PhysicsObjectCollection.As_PyTypeObject().tp_dict);
        // tp_as_number->nb_add = __add__
        Dtool_PhysicsObjectCollection.As_PyTypeObject().tp_as_number->nb_add = &Dtool_PhysicsObjectCollection_operator_55__add__;
        // tp_as_sequence->sq_length = size
        Dtool_PhysicsObjectCollection.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_PhysicsObjectCollection_size_53size;
        // tp_as_number->nb_inplace_add = __iadd__
        Dtool_PhysicsObjectCollection.As_PyTypeObject().tp_as_number->nb_inplace_add = &Dtool_PhysicsObjectCollection_operator_54__iadd__;
        // tp_as_sequence->sq_item = __getitem__
        Dtool_PhysicsObjectCollection.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_PhysicsObjectCollection_operator_52__getitem__;
        // __repr__
        Dtool_PhysicsObjectCollection.As_PyTypeObject().tp_repr = & Dtool_Repr_PhysicsObjectCollection;
        // __str__
        Dtool_PhysicsObjectCollection.As_PyTypeObject().tp_str = & Dtool_Str_PhysicsObjectCollection;
        if(PyType_Ready(&Dtool_PhysicsObjectCollection.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PhysicsObjectCollection)");
             printf(" Error In PyType_ReadyPhysicsObjectCollection");
             return;
        }
        Py_INCREF(&Dtool_PhysicsObjectCollection.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PhysicsObjectCollection.As_PyTypeObject().tp_dict,"PhysicsObjectCollection",&Dtool_PhysicsObjectCollection.As_PyObject());
        RegisterRuntimeClass(&Dtool_PhysicsObjectCollection,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PhysicsObjectCollection.As_PyTypeObject());
        PyModule_AddObject(module, "PhysicsObjectCollection",(PyObject *)&Dtool_PhysicsObjectCollection.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. BaseForce | BaseForce
//********************************************************************
PyMethodDef Dtool_Methods_BaseForce[]= {
  { "getActive",(PyCFunction ) &Dtool_BaseForce_get_active_59, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseForce_get_active_59_comment},
  { "setActive",(PyCFunction ) &Dtool_BaseForce_set_active_60, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseForce_set_active_60_comment},
  { "isLinear",(PyCFunction ) &Dtool_BaseForce_is_linear_61, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseForce_is_linear_61_comment},
  { "getForceNode",(PyCFunction ) &Dtool_BaseForce_get_force_node_62, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseForce_get_force_node_62_comment},
  { "getForceNodePath",(PyCFunction ) &Dtool_BaseForce_get_force_node_path_63, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseForce_get_force_node_path_63_comment},
  { "output",(PyCFunction ) &Dtool_BaseForce_output_64, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseForce_output_64_comment},
  { "write",(PyCFunction ) &Dtool_BaseForce_write_65, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseForce_write_65_comment},
  { "getClassType",(PyCFunction ) &Dtool_BaseForce_get_class_type_66, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseForce_get_class_type_66_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     BaseForce
//////////////////
static PyObject *  Dtool_Repr_BaseForce(PyObject * self)
{
    BaseForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseForce,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     BaseForce
//////////////////
static PyObject *  Dtool_Str_BaseForce(PyObject * self)
{
    BaseForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseForce,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_BaseForce(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_BaseForce.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//        Class : BaseForce\n"
          "//  Description : pure virtual base class for all forces that could\n"
          "//                POSSIBLY exist.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_BaseForce.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_BaseForce.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_BaseForce.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_BaseForce.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_BaseForce.As_PyTypeObject().tp_repr = & Dtool_Repr_BaseForce;
        // __str__
        Dtool_BaseForce.As_PyTypeObject().tp_str = & Dtool_Str_BaseForce;
        if(PyType_Ready(&Dtool_BaseForce.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(BaseForce)");
             printf(" Error In PyType_ReadyBaseForce");
             return;
        }
        Py_INCREF(&Dtool_BaseForce.As_PyTypeObject());
        PyDict_SetItemString(Dtool_BaseForce.As_PyTypeObject().tp_dict,"BaseForce",&Dtool_BaseForce.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_BaseForce.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_BaseForce[7],&Dtool_BaseForce.As_PyObject()));
        RegisterRuntimeClass(&Dtool_BaseForce,BaseForce::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_BaseForce.As_PyTypeObject());
        PyModule_AddObject(module, "BaseForce",(PyObject *)&Dtool_BaseForce.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. LinearForce | LinearForce
//********************************************************************
PyMethodDef Dtool_Methods_LinearForce[]= {
  { "setAmplitude",(PyCFunction ) &Dtool_LinearForce_set_amplitude_68, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearForce_set_amplitude_68_comment},
  { "setMassDependent",(PyCFunction ) &Dtool_LinearForce_set_mass_dependent_69, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearForce_set_mass_dependent_69_comment},
  { "getAmplitude",(PyCFunction ) &Dtool_LinearForce_get_amplitude_70, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearForce_get_amplitude_70_comment},
  { "getMassDependent",(PyCFunction ) &Dtool_LinearForce_get_mass_dependent_71, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearForce_get_mass_dependent_71_comment},
  { "setVectorMasks",(PyCFunction ) &Dtool_LinearForce_set_vector_masks_72, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearForce_set_vector_masks_72_comment},
  { "getVectorMasks",(PyCFunction ) &Dtool_LinearForce_get_vector_masks_73, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearForce_get_vector_masks_73_comment},
  { "getVector",(PyCFunction ) &Dtool_LinearForce_get_vector_74, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearForce_get_vector_74_comment},
  { "makeCopy",(PyCFunction ) &Dtool_LinearForce_make_copy_75, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearForce_make_copy_75_comment},
  { "write",(PyCFunction ) &Dtool_LinearForce_write_76, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearForce_write_76_comment},
  { "getClassType",(PyCFunction ) &Dtool_LinearForce_get_class_type_77, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearForce_get_class_type_77_comment},
  { "__copy__", (PyCFunction)&copy_from_make_copy, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __str__ Function
//     LinearForce
//////////////////
static PyObject *  Dtool_Str_LinearForce(PyObject * self)
{
    LinearForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_LinearForce,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_LinearForce(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_BaseForce._Dtool_ClassInit(NULL);
        Dtool_LinearForce.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_BaseForce.As_PyTypeObject());
        Dtool_LinearForce.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_LinearForce.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_LinearForce.As_PyTypeObject().tp_dict);
        // __str__
        Dtool_LinearForce.As_PyTypeObject().tp_str = & Dtool_Str_LinearForce;
        if(PyType_Ready(&Dtool_LinearForce.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(LinearForce)");
             printf(" Error In PyType_ReadyLinearForce");
             return;
        }
        Py_INCREF(&Dtool_LinearForce.As_PyTypeObject());
        PyDict_SetItemString(Dtool_LinearForce.As_PyTypeObject().tp_dict,"LinearForce",&Dtool_LinearForce.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_LinearForce.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_LinearForce[9],&Dtool_LinearForce.As_PyObject()));
        RegisterRuntimeClass(&Dtool_LinearForce,LinearForce::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_LinearForce.As_PyTypeObject());
        PyModule_AddObject(module, "LinearForce",(PyObject *)&Dtool_LinearForce.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. AngularForce | AngularForce
//********************************************************************
PyMethodDef Dtool_Methods_AngularForce[]= {
  { "makeCopy",(PyCFunction ) &Dtool_AngularForce_make_copy_79, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AngularForce_make_copy_79_comment},
  { "getQuat",(PyCFunction ) &Dtool_AngularForce_get_quat_80, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AngularForce_get_quat_80_comment},
  { "write",(PyCFunction ) &Dtool_AngularForce_write_81, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AngularForce_write_81_comment},
  { "getClassType",(PyCFunction ) &Dtool_AngularForce_get_class_type_82, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AngularForce_get_class_type_82_comment},
  { "__copy__", (PyCFunction)&copy_from_make_copy, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __str__ Function
//     AngularForce
//////////////////
static PyObject *  Dtool_Str_AngularForce(PyObject * self)
{
    AngularForce * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_AngularForce,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_AngularForce(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_AngularForce.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : AngularForce\n"
          "// Description : pure virtual parent of all quat-based forces.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_BaseForce._Dtool_ClassInit(NULL);
        Dtool_AngularForce.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_BaseForce.As_PyTypeObject());
        Dtool_AngularForce.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_AngularForce.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_AngularForce.As_PyTypeObject().tp_dict);
        // __str__
        Dtool_AngularForce.As_PyTypeObject().tp_str = & Dtool_Str_AngularForce;
        if(PyType_Ready(&Dtool_AngularForce.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(AngularForce)");
             printf(" Error In PyType_ReadyAngularForce");
             return;
        }
        Py_INCREF(&Dtool_AngularForce.As_PyTypeObject());
        PyDict_SetItemString(Dtool_AngularForce.As_PyTypeObject().tp_dict,"AngularForce",&Dtool_AngularForce.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_AngularForce.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_AngularForce[3],&Dtool_AngularForce.As_PyObject()));
        RegisterRuntimeClass(&Dtool_AngularForce,AngularForce::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_AngularForce.As_PyTypeObject());
        PyModule_AddObject(module, "AngularForce",(PyObject *)&Dtool_AngularForce.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. Physical | Physical
//********************************************************************
PyMethodDef Dtool_Methods_Physical[]= {
  { "getPhysicsManager",(PyCFunction ) &Dtool_Physical_get_physics_manager_85, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Physical_get_physics_manager_85_comment},
  { "getPhysicalNode",(PyCFunction ) &Dtool_Physical_get_physical_node_86, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Physical_get_physical_node_86_comment},
  { "getPhysicalNodePath",(PyCFunction ) &Dtool_Physical_get_physical_node_path_87, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Physical_get_physical_node_path_87_comment},
  { "getPhysBody",(PyCFunction ) &Dtool_Physical_get_phys_body_88, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Physical_get_phys_body_88_comment},
  { "clearLinearForces",(PyCFunction ) &Dtool_Physical_clear_linear_forces_89, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Physical_clear_linear_forces_89_comment},
  { "clearAngularForces",(PyCFunction ) &Dtool_Physical_clear_angular_forces_90, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Physical_clear_angular_forces_90_comment},
  { "clearPhysicsObjects",(PyCFunction ) &Dtool_Physical_clear_physics_objects_91, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Physical_clear_physics_objects_91_comment},
  { "addLinearForce",(PyCFunction ) &Dtool_Physical_add_linear_force_92, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Physical_add_linear_force_92_comment},
  { "addAngularForce",(PyCFunction ) &Dtool_Physical_add_angular_force_93, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Physical_add_angular_force_93_comment},
  { "addPhysicsObject",(PyCFunction ) &Dtool_Physical_add_physics_object_94, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Physical_add_physics_object_94_comment},
  { "removeLinearForce",(PyCFunction ) &Dtool_Physical_remove_linear_force_95, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Physical_remove_linear_force_95_comment},
  { "removeAngularForce",(PyCFunction ) &Dtool_Physical_remove_angular_force_96, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Physical_remove_angular_force_96_comment},
  { "getNumLinearForces",(PyCFunction ) &Dtool_Physical_get_num_linear_forces_97, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Physical_get_num_linear_forces_97_comment},
  { "getLinearForce",(PyCFunction ) &Dtool_Physical_get_linear_force_98, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Physical_get_linear_force_98_comment},
  { "getNumAngularForces",(PyCFunction ) &Dtool_Physical_get_num_angular_forces_99, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Physical_get_num_angular_forces_99_comment},
  { "getAngularForce",(PyCFunction ) &Dtool_Physical_get_angular_force_100, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Physical_get_angular_force_100_comment},
  { "setViscosity",(PyCFunction ) &Dtool_Physical_set_viscosity_101, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Physical_set_viscosity_101_comment},
  { "getViscosity",(PyCFunction ) &Dtool_Physical_get_viscosity_102, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Physical_get_viscosity_102_comment},
  { "getObjects",(PyCFunction ) &Dtool_Physical_get_objects_103, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Physical_get_objects_103_comment},
  { "output",(PyCFunction ) &Dtool_Physical_output_104, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Physical_output_104_comment},
  { "writePhysicsObjects",(PyCFunction ) &Dtool_Physical_write_physics_objects_105, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Physical_write_physics_objects_105_comment},
  { "writeLinearForces",(PyCFunction ) &Dtool_Physical_write_linear_forces_106, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Physical_write_linear_forces_106_comment},
  { "writeAngularForces",(PyCFunction ) &Dtool_Physical_write_angular_forces_107, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Physical_write_angular_forces_107_comment},
  { "write",(PyCFunction ) &Dtool_Physical_write_108, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Physical_write_108_comment},
  { "getClassType",(PyCFunction ) &Dtool_Physical_get_class_type_109, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_Physical_get_class_type_109_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { "getLinearForces",(PyCFunction) &MakeSeq_Physical_get_linear_forces, METH_NOARGS, NULL},
  { "getAngularForces",(PyCFunction) &MakeSeq_Physical_get_angular_forces, METH_NOARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     Physical
//////////////////
static PyObject *  Dtool_Repr_Physical(PyObject * self)
{
    Physical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Physical,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     Physical
//////////////////
static PyObject *  Dtool_Str_Physical(PyObject * self)
{
    Physical * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_Physical,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_Physical(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_Physical.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : Physical\n"
          "// Description : Defines a set of physically modeled attributes.\n"
          "//               If you want physics applied to your class, derive\n"
          "//               it from this.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_Physical.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_Physical.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_Physical.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_Physical.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_Physical.As_PyTypeObject().tp_repr = & Dtool_Repr_Physical;
        // __str__
        Dtool_Physical.As_PyTypeObject().tp_str = & Dtool_Str_Physical;
        if(PyType_Ready(&Dtool_Physical.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(Physical)");
             printf(" Error In PyType_ReadyPhysical");
             return;
        }
        Py_INCREF(&Dtool_Physical.As_PyTypeObject());
        PyDict_SetItemString(Dtool_Physical.As_PyTypeObject().tp_dict,"Physical",&Dtool_Physical.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_Physical.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_Physical[24],&Dtool_Physical.As_PyObject()));
        RegisterRuntimeClass(&Dtool_Physical,Physical::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_Physical.As_PyTypeObject());
        PyModule_AddObject(module, "Physical",(PyObject *)&Dtool_Physical.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PhysicalNode | PhysicalNode
//********************************************************************
PyMethodDef Dtool_Methods_PhysicalNode[]= {
  { "clear",(PyCFunction ) &Dtool_PhysicalNode_clear_113, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicalNode_clear_113_comment},
  { "getPhysical",(PyCFunction ) &Dtool_PhysicalNode_get_physical_114, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicalNode_get_physical_114_comment},
  { "getNumPhysicals",(PyCFunction ) &Dtool_PhysicalNode_get_num_physicals_115, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicalNode_get_num_physicals_115_comment},
  { "addPhysical",(PyCFunction ) &Dtool_PhysicalNode_add_physical_116, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicalNode_add_physical_116_comment},
  { "addPhysicalsFrom",(PyCFunction ) &Dtool_PhysicalNode_add_physicals_from_117, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicalNode_add_physicals_from_117_comment},
  { "removePhysical",(PyCFunction ) &Dtool_PhysicalNode_remove_physical_118, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicalNode_remove_physical_118_comment},
  { "write",(PyCFunction ) &Dtool_PhysicalNode_write_119, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicalNode_write_119_comment},
  { "getClassType",(PyCFunction ) &Dtool_PhysicalNode_get_class_type_120, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicalNode_get_class_type_120_comment},
  { "getPhysicals",(PyCFunction) &MakeSeq_PhysicalNode_get_physicals, METH_NOARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __str__ Function
//     PhysicalNode
//////////////////
static PyObject *  Dtool_Str_PhysicalNode(PyObject * self)
{
    PhysicalNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicalNode,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_PhysicalNode(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PandaNode._Dtool_ClassInit(NULL);
        Dtool_PhysicalNode.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PandaNode.As_PyTypeObject());
        Dtool_PhysicalNode.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PhysicalNode.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PhysicalNode.As_PyTypeObject().tp_dict);
        // __str__
        Dtool_PhysicalNode.As_PyTypeObject().tp_str = & Dtool_Str_PhysicalNode;
        if(PyType_Ready(&Dtool_PhysicalNode.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PhysicalNode)");
             printf(" Error In PyType_ReadyPhysicalNode");
             return;
        }
        Py_INCREF(&Dtool_PhysicalNode.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PhysicalNode.As_PyTypeObject().tp_dict,"PhysicalNode",&Dtool_PhysicalNode.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_PhysicalNode.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_PhysicalNode[7],&Dtool_PhysicalNode.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PhysicalNode,PhysicalNode::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PhysicalNode.As_PyTypeObject());
        PyModule_AddObject(module, "PhysicalNode",(PyObject *)&Dtool_PhysicalNode.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ActorNode | ActorNode
//********************************************************************
PyMethodDef Dtool_Methods_ActorNode[]= {
  { "getPhysicsObject",(PyCFunction ) &Dtool_ActorNode_get_physics_object_123, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ActorNode_get_physics_object_123_comment},
  { "setContactVector",(PyCFunction ) &Dtool_ActorNode_set_contact_vector_124, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ActorNode_set_contact_vector_124_comment},
  { "getContactVector",(PyCFunction ) &Dtool_ActorNode_get_contact_vector_125, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ActorNode_get_contact_vector_125_comment},
  { "updateTransform",(PyCFunction ) &Dtool_ActorNode_update_transform_126, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ActorNode_update_transform_126_comment},
  { "setTransformLimit",(PyCFunction ) &Dtool_ActorNode_set_transform_limit_127, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ActorNode_set_transform_limit_127_comment},
  { "getClassType",(PyCFunction ) &Dtool_ActorNode_get_class_type_128, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ActorNode_get_class_type_128_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ActorNode(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_PhysicalNode._Dtool_ClassInit(NULL);
        Dtool_ActorNode.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PhysicalNode.As_PyTypeObject());
        Dtool_ActorNode.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ActorNode.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ActorNode.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ActorNode.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ActorNode)");
             printf(" Error In PyType_ReadyActorNode");
             return;
        }
        Py_INCREF(&Dtool_ActorNode.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ActorNode.As_PyTypeObject().tp_dict,"ActorNode",&Dtool_ActorNode.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_ActorNode.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_ActorNode[5],&Dtool_ActorNode.As_PyObject()));
        RegisterRuntimeClass(&Dtool_ActorNode,ActorNode::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ActorNode.As_PyTypeObject());
        PyModule_AddObject(module, "ActorNode",(PyObject *)&Dtool_ActorNode.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. BaseIntegrator | BaseIntegrator
//********************************************************************
PyMethodDef Dtool_Methods_BaseIntegrator[]= {
  { "output",(PyCFunction ) &Dtool_BaseIntegrator_output_131, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseIntegrator_output_131_comment},
  { "writePrecomputedLinearMatrices",(PyCFunction ) &Dtool_BaseIntegrator_write_precomputed_linear_matrices_132, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseIntegrator_write_precomputed_linear_matrices_132_comment},
  { "writePrecomputedAngularMatrices",(PyCFunction ) &Dtool_BaseIntegrator_write_precomputed_angular_matrices_133, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseIntegrator_write_precomputed_angular_matrices_133_comment},
  { "write",(PyCFunction ) &Dtool_BaseIntegrator_write_134, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_BaseIntegrator_write_134_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     BaseIntegrator
//////////////////
static PyObject *  Dtool_Repr_BaseIntegrator(PyObject * self)
{
    BaseIntegrator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseIntegrator,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     BaseIntegrator
//////////////////
static PyObject *  Dtool_Str_BaseIntegrator(PyObject * self)
{
    BaseIntegrator * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_BaseIntegrator,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_BaseIntegrator(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_BaseIntegrator.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : BaseIntegrator\n"
          "// Description : pure virtual integrator class that holds cached\n"
          "//               matrix information that really should be common to\n"
          "//               any possible child implementation.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ReferenceCount._Dtool_ClassInit(NULL);
        Dtool_BaseIntegrator.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ReferenceCount.As_PyTypeObject());
        Dtool_BaseIntegrator.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_BaseIntegrator.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_BaseIntegrator.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_BaseIntegrator.As_PyTypeObject().tp_repr = & Dtool_Repr_BaseIntegrator;
        // __str__
        Dtool_BaseIntegrator.As_PyTypeObject().tp_str = & Dtool_Str_BaseIntegrator;
        if(PyType_Ready(&Dtool_BaseIntegrator.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(BaseIntegrator)");
             printf(" Error In PyType_ReadyBaseIntegrator");
             return;
        }
        Py_INCREF(&Dtool_BaseIntegrator.As_PyTypeObject());
        PyDict_SetItemString(Dtool_BaseIntegrator.As_PyTypeObject().tp_dict,"BaseIntegrator",&Dtool_BaseIntegrator.As_PyObject());
        RegisterRuntimeClass(&Dtool_BaseIntegrator,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_BaseIntegrator.As_PyTypeObject());
        PyModule_AddObject(module, "BaseIntegrator",(PyObject *)&Dtool_BaseIntegrator.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. AngularIntegrator | AngularIntegrator
//********************************************************************
PyMethodDef Dtool_Methods_AngularIntegrator[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_AngularIntegrator(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_AngularIntegrator.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : BaseAngularIntegrator\n"
          "// Description : Pure virtual base class for physical modeling.\n"
          "//               Takes physically modelable objects and applies\n"
          "//               forces to them.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_BaseIntegrator._Dtool_ClassInit(NULL);
        Dtool_AngularIntegrator.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_BaseIntegrator.As_PyTypeObject());
        Dtool_AngularIntegrator.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_AngularIntegrator.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_AngularIntegrator.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_AngularIntegrator.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(AngularIntegrator)");
             printf(" Error In PyType_ReadyAngularIntegrator");
             return;
        }
        Py_INCREF(&Dtool_AngularIntegrator.As_PyTypeObject());
        PyDict_SetItemString(Dtool_AngularIntegrator.As_PyTypeObject().tp_dict,"AngularIntegrator",&Dtool_AngularIntegrator.As_PyObject());
        RegisterRuntimeClass(&Dtool_AngularIntegrator,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_AngularIntegrator.As_PyTypeObject());
        PyModule_AddObject(module, "AngularIntegrator",(PyObject *)&Dtool_AngularIntegrator.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. AngularEulerIntegrator | AngularEulerIntegrator
//********************************************************************
PyMethodDef Dtool_Methods_AngularEulerIntegrator[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_AngularEulerIntegrator(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_AngularIntegrator._Dtool_ClassInit(NULL);
        Dtool_AngularEulerIntegrator.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_AngularIntegrator.As_PyTypeObject());
        Dtool_AngularEulerIntegrator.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_AngularEulerIntegrator.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_AngularEulerIntegrator.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_AngularEulerIntegrator.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(AngularEulerIntegrator)");
             printf(" Error In PyType_ReadyAngularEulerIntegrator");
             return;
        }
        Py_INCREF(&Dtool_AngularEulerIntegrator.As_PyTypeObject());
        PyDict_SetItemString(Dtool_AngularEulerIntegrator.As_PyTypeObject().tp_dict,"AngularEulerIntegrator",&Dtool_AngularEulerIntegrator.As_PyObject());
        RegisterRuntimeClass(&Dtool_AngularEulerIntegrator,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_AngularEulerIntegrator.As_PyTypeObject());
        PyModule_AddObject(module, "AngularEulerIntegrator",(PyObject *)&Dtool_AngularEulerIntegrator.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. AngularVectorForce | AngularVectorForce
//********************************************************************
PyMethodDef Dtool_Methods_AngularVectorForce[]= {
  { "setQuat",(PyCFunction ) &Dtool_AngularVectorForce_set_quat_140, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AngularVectorForce_set_quat_140_comment},
  { "setHpr",(PyCFunction ) &Dtool_AngularVectorForce_set_hpr_141, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AngularVectorForce_set_hpr_141_comment},
  { "getLocalQuat",(PyCFunction ) &Dtool_AngularVectorForce_get_local_quat_142, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AngularVectorForce_get_local_quat_142_comment},
  { "getClassType",(PyCFunction ) &Dtool_AngularVectorForce_get_class_type_143, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_AngularVectorForce_get_class_type_143_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_AngularVectorForce(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_AngularVectorForce.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : AngularVectorForce\n"
          "// Description : a simple directed torque force, the angular\n"
          "//               equivalent of simple vector force.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_AngularForce._Dtool_ClassInit(NULL);
        Dtool_AngularVectorForce.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_AngularForce.As_PyTypeObject());
        Dtool_AngularVectorForce.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_AngularVectorForce.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_AngularVectorForce.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_AngularVectorForce.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(AngularVectorForce)");
             printf(" Error In PyType_ReadyAngularVectorForce");
             return;
        }
        Py_INCREF(&Dtool_AngularVectorForce.As_PyTypeObject());
        PyDict_SetItemString(Dtool_AngularVectorForce.As_PyTypeObject().tp_dict,"AngularVectorForce",&Dtool_AngularVectorForce.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_AngularVectorForce.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_AngularVectorForce[3],&Dtool_AngularVectorForce.As_PyObject()));
        RegisterRuntimeClass(&Dtool_AngularVectorForce,AngularVectorForce::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_AngularVectorForce.As_PyTypeObject());
        PyModule_AddObject(module, "AngularVectorForce",(PyObject *)&Dtool_AngularVectorForce.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ForceNode | ForceNode
//********************************************************************
PyMethodDef Dtool_Methods_ForceNode[]= {
  { "clear",(PyCFunction ) &Dtool_ForceNode_clear_146, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ForceNode_clear_146_comment},
  { "getForce",(PyCFunction ) &Dtool_ForceNode_get_force_147, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ForceNode_get_force_147_comment},
  { "getNumForces",(PyCFunction ) &Dtool_ForceNode_get_num_forces_148, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ForceNode_get_num_forces_148_comment},
  { "addForce",(PyCFunction ) &Dtool_ForceNode_add_force_149, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ForceNode_add_force_149_comment},
  { "addForcesFrom",(PyCFunction ) &Dtool_ForceNode_add_forces_from_150, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ForceNode_add_forces_from_150_comment},
  { "removeForce",(PyCFunction ) &Dtool_ForceNode_remove_force_151, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ForceNode_remove_force_151_comment},
  { "writeForces",(PyCFunction ) &Dtool_ForceNode_write_forces_152, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ForceNode_write_forces_152_comment},
  { "write",(PyCFunction ) &Dtool_ForceNode_write_153, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ForceNode_write_153_comment},
  { "getClassType",(PyCFunction ) &Dtool_ForceNode_get_class_type_154, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ForceNode_get_class_type_154_comment},
  { "getForces",(PyCFunction) &MakeSeq_ForceNode_get_forces, METH_NOARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __str__ Function
//     ForceNode
//////////////////
static PyObject *  Dtool_Str_ForceNode(PyObject * self)
{
    ForceNode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_ForceNode,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_ForceNode(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ForceNode.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//        Class : ForceNode\n"
          "//  Description : A force that lives in the scene graph and is\n"
          "//                therefore subject to local coordinate systems.\n"
          "//                An example of this would be simulating gravity\n"
          "//                in a rotating space station.  or something.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PandaNode._Dtool_ClassInit(NULL);
        Dtool_ForceNode.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PandaNode.As_PyTypeObject());
        Dtool_ForceNode.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ForceNode.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ForceNode.As_PyTypeObject().tp_dict);
        // __str__
        Dtool_ForceNode.As_PyTypeObject().tp_str = & Dtool_Str_ForceNode;
        if(PyType_Ready(&Dtool_ForceNode.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ForceNode)");
             printf(" Error In PyType_ReadyForceNode");
             return;
        }
        Py_INCREF(&Dtool_ForceNode.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ForceNode.As_PyTypeObject().tp_dict,"ForceNode",&Dtool_ForceNode.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_ForceNode.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_ForceNode[8],&Dtool_ForceNode.As_PyObject()));
        RegisterRuntimeClass(&Dtool_ForceNode,ForceNode::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ForceNode.As_PyTypeObject());
        PyModule_AddObject(module, "ForceNode",(PyObject *)&Dtool_ForceNode.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. LinearControlForce | LinearControlForce
//********************************************************************
PyMethodDef Dtool_Methods_LinearControlForce[]= {
  { "clearPhysicsObject",(PyCFunction ) &Dtool_LinearControlForce_clear_physics_object_157, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearControlForce_clear_physics_object_157_comment},
  { "setPhysicsObject",(PyCFunction ) &Dtool_LinearControlForce_set_physics_object_158, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearControlForce_set_physics_object_158_comment},
  { "getPhysicsObject",(PyCFunction ) &Dtool_LinearControlForce_get_physics_object_159, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearControlForce_get_physics_object_159_comment},
  { "setVector",(PyCFunction ) &Dtool_LinearControlForce_set_vector_160, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearControlForce_set_vector_160_comment},
  { "getLocalVector",(PyCFunction ) &Dtool_LinearControlForce_get_local_vector_161, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearControlForce_get_local_vector_161_comment},
  { "getClassType",(PyCFunction ) &Dtool_LinearControlForce_get_class_type_162, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearControlForce_get_class_type_162_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_LinearControlForce(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_LinearControlForce.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////\n"
          "//       Class : LinearControlForce\n"
          "// Description : Simple directed vector force.  This force is \n"
          "//               different from the others in that it can be\n"
          "//               global and still only affect a single object.\n"
          "//               That might not make sense for a physics simulation,\n"
          "//               but it's very handy for a game.  I.e. this is\n"
          "//               the force applied by user on the selected object.\n"
          "////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_LinearForce._Dtool_ClassInit(NULL);
        Dtool_LinearControlForce.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LinearForce.As_PyTypeObject());
        Dtool_LinearControlForce.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_LinearControlForce.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_LinearControlForce.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_LinearControlForce.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(LinearControlForce)");
             printf(" Error In PyType_ReadyLinearControlForce");
             return;
        }
        Py_INCREF(&Dtool_LinearControlForce.As_PyTypeObject());
        PyDict_SetItemString(Dtool_LinearControlForce.As_PyTypeObject().tp_dict,"LinearControlForce",&Dtool_LinearControlForce.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_LinearControlForce.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_LinearControlForce[5],&Dtool_LinearControlForce.As_PyObject()));
        RegisterRuntimeClass(&Dtool_LinearControlForce,LinearControlForce::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_LinearControlForce.As_PyTypeObject());
        PyModule_AddObject(module, "LinearControlForce",(PyObject *)&Dtool_LinearControlForce.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. LinearCylinderVortexForce | LinearCylinderVortexForce
//********************************************************************
PyMethodDef Dtool_Methods_LinearCylinderVortexForce[]= {
  { "setCoef",(PyCFunction ) &Dtool_LinearCylinderVortexForce_set_coef_165, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearCylinderVortexForce_set_coef_165_comment},
  { "getCoef",(PyCFunction ) &Dtool_LinearCylinderVortexForce_get_coef_166, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearCylinderVortexForce_get_coef_166_comment},
  { "setRadius",(PyCFunction ) &Dtool_LinearCylinderVortexForce_set_radius_167, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearCylinderVortexForce_set_radius_167_comment},
  { "getRadius",(PyCFunction ) &Dtool_LinearCylinderVortexForce_get_radius_168, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearCylinderVortexForce_get_radius_168_comment},
  { "setLength",(PyCFunction ) &Dtool_LinearCylinderVortexForce_set_length_169, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearCylinderVortexForce_set_length_169_comment},
  { "getLength",(PyCFunction ) &Dtool_LinearCylinderVortexForce_get_length_170, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearCylinderVortexForce_get_length_170_comment},
  { "getClassType",(PyCFunction ) &Dtool_LinearCylinderVortexForce_get_class_type_171, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearCylinderVortexForce_get_class_type_171_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_LinearCylinderVortexForce(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_LinearCylinderVortexForce.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : LinearCylinderVortexForce\n"
          "// Description : Defines a cylinder inside of which all forces are\n"
          "//               tangential to the theta of the particle wrt the\n"
          "//               z-axis in local coord. space.  This happens by\n"
          "//               assigning the force a node by which the cylinder is\n"
          "//               transformed.  Be warned- this will suck anything\n"
          "//               that it can reach directly into orbit and will NOT\n"
          "//               let go.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_LinearForce._Dtool_ClassInit(NULL);
        Dtool_LinearCylinderVortexForce.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LinearForce.As_PyTypeObject());
        Dtool_LinearCylinderVortexForce.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_LinearCylinderVortexForce.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_LinearCylinderVortexForce.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_LinearCylinderVortexForce.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(LinearCylinderVortexForce)");
             printf(" Error In PyType_ReadyLinearCylinderVortexForce");
             return;
        }
        Py_INCREF(&Dtool_LinearCylinderVortexForce.As_PyTypeObject());
        PyDict_SetItemString(Dtool_LinearCylinderVortexForce.As_PyTypeObject().tp_dict,"LinearCylinderVortexForce",&Dtool_LinearCylinderVortexForce.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_LinearCylinderVortexForce.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_LinearCylinderVortexForce[6],&Dtool_LinearCylinderVortexForce.As_PyObject()));
        RegisterRuntimeClass(&Dtool_LinearCylinderVortexForce,LinearCylinderVortexForce::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_LinearCylinderVortexForce.As_PyTypeObject());
        PyModule_AddObject(module, "LinearCylinderVortexForce",(PyObject *)&Dtool_LinearCylinderVortexForce.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. LinearDistanceForce | LinearDistanceForce
//********************************************************************
PyMethodDef Dtool_Methods_LinearDistanceForce[]= {
  { "setRadius",(PyCFunction ) &Dtool_LinearDistanceForce_set_radius_174, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearDistanceForce_set_radius_174_comment},
  { "setFalloffType",(PyCFunction ) &Dtool_LinearDistanceForce_set_falloff_type_175, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearDistanceForce_set_falloff_type_175_comment},
  { "setForceCenter",(PyCFunction ) &Dtool_LinearDistanceForce_set_force_center_176, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearDistanceForce_set_force_center_176_comment},
  { "getRadius",(PyCFunction ) &Dtool_LinearDistanceForce_get_radius_177, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearDistanceForce_get_radius_177_comment},
  { "getFalloffType",(PyCFunction ) &Dtool_LinearDistanceForce_get_falloff_type_178, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearDistanceForce_get_falloff_type_178_comment},
  { "getForceCenter",(PyCFunction ) &Dtool_LinearDistanceForce_get_force_center_179, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearDistanceForce_get_force_center_179_comment},
  { "getScalarTerm",(PyCFunction ) &Dtool_LinearDistanceForce_get_scalar_term_180, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearDistanceForce_get_scalar_term_180_comment},
  { "getClassType",(PyCFunction ) &Dtool_LinearDistanceForce_get_class_type_181, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearDistanceForce_get_class_type_181_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_LinearDistanceForce(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_LinearDistanceForce.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : LinearDistanceForce\n"
          "// Description : Pure virtual class for sinks and sources\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_LinearForce._Dtool_ClassInit(NULL);
        Dtool_LinearDistanceForce.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LinearForce.As_PyTypeObject());
        Dtool_LinearDistanceForce.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_LinearDistanceForce.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_LinearDistanceForce.As_PyTypeObject().tp_dict);
        // Enum  LinearDistanceForce::FalloffType;
        PyDict_SetItemString(Dtool_LinearDistanceForce.As_PyTypeObject().tp_dict,"FTONEOVERR",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_LinearDistanceForce.As_PyTypeObject().tp_dict,"FTONEOVERRSQUARED",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_LinearDistanceForce.As_PyTypeObject().tp_dict,"FTONEOVERRCUBED",PyInt_FromLong(2));
        if(PyType_Ready(&Dtool_LinearDistanceForce.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(LinearDistanceForce)");
             printf(" Error In PyType_ReadyLinearDistanceForce");
             return;
        }
        Py_INCREF(&Dtool_LinearDistanceForce.As_PyTypeObject());
        PyDict_SetItemString(Dtool_LinearDistanceForce.As_PyTypeObject().tp_dict,"LinearDistanceForce",&Dtool_LinearDistanceForce.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_LinearDistanceForce.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_LinearDistanceForce[7],&Dtool_LinearDistanceForce.As_PyObject()));
        RegisterRuntimeClass(&Dtool_LinearDistanceForce,LinearDistanceForce::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_LinearDistanceForce.As_PyTypeObject());
        PyModule_AddObject(module, "LinearDistanceForce",(PyObject *)&Dtool_LinearDistanceForce.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. LinearIntegrator | LinearIntegrator
//********************************************************************
PyMethodDef Dtool_Methods_LinearIntegrator[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_LinearIntegrator(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_LinearIntegrator.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : LinearIntegrator\n"
          "// Description : Pure virtual base class for physical modeling.\n"
          "//               Takes physically modelable objects and applies\n"
          "//               forces to them.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_BaseIntegrator._Dtool_ClassInit(NULL);
        Dtool_LinearIntegrator.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_BaseIntegrator.As_PyTypeObject());
        Dtool_LinearIntegrator.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_LinearIntegrator.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_LinearIntegrator.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_LinearIntegrator.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(LinearIntegrator)");
             printf(" Error In PyType_ReadyLinearIntegrator");
             return;
        }
        Py_INCREF(&Dtool_LinearIntegrator.As_PyTypeObject());
        PyDict_SetItemString(Dtool_LinearIntegrator.As_PyTypeObject().tp_dict,"LinearIntegrator",&Dtool_LinearIntegrator.As_PyObject());
        RegisterRuntimeClass(&Dtool_LinearIntegrator,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_LinearIntegrator.As_PyTypeObject());
        PyModule_AddObject(module, "LinearIntegrator",(PyObject *)&Dtool_LinearIntegrator.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. LinearEulerIntegrator | LinearEulerIntegrator
//********************************************************************
PyMethodDef Dtool_Methods_LinearEulerIntegrator[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_LinearEulerIntegrator(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_LinearIntegrator._Dtool_ClassInit(NULL);
        Dtool_LinearEulerIntegrator.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LinearIntegrator.As_PyTypeObject());
        Dtool_LinearEulerIntegrator.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_LinearEulerIntegrator.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_LinearEulerIntegrator.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_LinearEulerIntegrator.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(LinearEulerIntegrator)");
             printf(" Error In PyType_ReadyLinearEulerIntegrator");
             return;
        }
        Py_INCREF(&Dtool_LinearEulerIntegrator.As_PyTypeObject());
        PyDict_SetItemString(Dtool_LinearEulerIntegrator.As_PyTypeObject().tp_dict,"LinearEulerIntegrator",&Dtool_LinearEulerIntegrator.As_PyObject());
        RegisterRuntimeClass(&Dtool_LinearEulerIntegrator,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_LinearEulerIntegrator.As_PyTypeObject());
        PyModule_AddObject(module, "LinearEulerIntegrator",(PyObject *)&Dtool_LinearEulerIntegrator.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. LinearFrictionForce | LinearFrictionForce
//********************************************************************
PyMethodDef Dtool_Methods_LinearFrictionForce[]= {
  { "setCoef",(PyCFunction ) &Dtool_LinearFrictionForce_set_coef_187, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearFrictionForce_set_coef_187_comment},
  { "getCoef",(PyCFunction ) &Dtool_LinearFrictionForce_get_coef_188, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearFrictionForce_get_coef_188_comment},
  { "getClassType",(PyCFunction ) &Dtool_LinearFrictionForce_get_class_type_189, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearFrictionForce_get_class_type_189_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_LinearFrictionForce(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_LinearFrictionForce.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : LinearFrictionForce\n"
          "// Description : Friction-based drag force\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_LinearForce._Dtool_ClassInit(NULL);
        Dtool_LinearFrictionForce.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LinearForce.As_PyTypeObject());
        Dtool_LinearFrictionForce.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_LinearFrictionForce.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_LinearFrictionForce.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_LinearFrictionForce.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(LinearFrictionForce)");
             printf(" Error In PyType_ReadyLinearFrictionForce");
             return;
        }
        Py_INCREF(&Dtool_LinearFrictionForce.As_PyTypeObject());
        PyDict_SetItemString(Dtool_LinearFrictionForce.As_PyTypeObject().tp_dict,"LinearFrictionForce",&Dtool_LinearFrictionForce.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_LinearFrictionForce.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_LinearFrictionForce[2],&Dtool_LinearFrictionForce.As_PyObject()));
        RegisterRuntimeClass(&Dtool_LinearFrictionForce,LinearFrictionForce::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_LinearFrictionForce.As_PyTypeObject());
        PyModule_AddObject(module, "LinearFrictionForce",(PyObject *)&Dtool_LinearFrictionForce.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. LinearRandomForce | LinearRandomForce
//********************************************************************
PyMethodDef Dtool_Methods_LinearRandomForce[]= {
  { "getClassType",(PyCFunction ) &Dtool_LinearRandomForce_get_class_type_191, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearRandomForce_get_class_type_191_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_LinearRandomForce(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_LinearRandomForce.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : LinearRandomForce\n"
          "// Description : Pure virtual, parent to noiseForce and jitterForce\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_LinearForce._Dtool_ClassInit(NULL);
        Dtool_LinearRandomForce.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LinearForce.As_PyTypeObject());
        Dtool_LinearRandomForce.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_LinearRandomForce.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_LinearRandomForce.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_LinearRandomForce.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(LinearRandomForce)");
             printf(" Error In PyType_ReadyLinearRandomForce");
             return;
        }
        Py_INCREF(&Dtool_LinearRandomForce.As_PyTypeObject());
        PyDict_SetItemString(Dtool_LinearRandomForce.As_PyTypeObject().tp_dict,"LinearRandomForce",&Dtool_LinearRandomForce.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_LinearRandomForce.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_LinearRandomForce[0],&Dtool_LinearRandomForce.As_PyObject()));
        RegisterRuntimeClass(&Dtool_LinearRandomForce,LinearRandomForce::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_LinearRandomForce.As_PyTypeObject());
        PyModule_AddObject(module, "LinearRandomForce",(PyObject *)&Dtool_LinearRandomForce.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. LinearJitterForce | LinearJitterForce
//********************************************************************
PyMethodDef Dtool_Methods_LinearJitterForce[]= {
  { "getClassType",(PyCFunction ) &Dtool_LinearJitterForce_get_class_type_194, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearJitterForce_get_class_type_194_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_LinearJitterForce(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_LinearRandomForce._Dtool_ClassInit(NULL);
        Dtool_LinearJitterForce.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LinearRandomForce.As_PyTypeObject());
        Dtool_LinearJitterForce.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_LinearJitterForce.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_LinearJitterForce.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_LinearJitterForce.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(LinearJitterForce)");
             printf(" Error In PyType_ReadyLinearJitterForce");
             return;
        }
        Py_INCREF(&Dtool_LinearJitterForce.As_PyTypeObject());
        PyDict_SetItemString(Dtool_LinearJitterForce.As_PyTypeObject().tp_dict,"LinearJitterForce",&Dtool_LinearJitterForce.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_LinearJitterForce.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_LinearJitterForce[0],&Dtool_LinearJitterForce.As_PyObject()));
        RegisterRuntimeClass(&Dtool_LinearJitterForce,LinearJitterForce::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_LinearJitterForce.As_PyTypeObject());
        PyModule_AddObject(module, "LinearJitterForce",(PyObject *)&Dtool_LinearJitterForce.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. LinearNoiseForce | LinearNoiseForce
//********************************************************************
PyMethodDef Dtool_Methods_LinearNoiseForce[]= {
  { "getClassType",(PyCFunction ) &Dtool_LinearNoiseForce_get_class_type_197, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearNoiseForce_get_class_type_197_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_LinearNoiseForce(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_LinearNoiseForce.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : LinearNoiseForce\n"
          "// Description : Repeating noise force vector.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_LinearRandomForce._Dtool_ClassInit(NULL);
        Dtool_LinearNoiseForce.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LinearRandomForce.As_PyTypeObject());
        Dtool_LinearNoiseForce.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_LinearNoiseForce.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_LinearNoiseForce.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_LinearNoiseForce.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(LinearNoiseForce)");
             printf(" Error In PyType_ReadyLinearNoiseForce");
             return;
        }
        Py_INCREF(&Dtool_LinearNoiseForce.As_PyTypeObject());
        PyDict_SetItemString(Dtool_LinearNoiseForce.As_PyTypeObject().tp_dict,"LinearNoiseForce",&Dtool_LinearNoiseForce.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_LinearNoiseForce.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_LinearNoiseForce[0],&Dtool_LinearNoiseForce.As_PyObject()));
        RegisterRuntimeClass(&Dtool_LinearNoiseForce,LinearNoiseForce::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_LinearNoiseForce.As_PyTypeObject());
        PyModule_AddObject(module, "LinearNoiseForce",(PyObject *)&Dtool_LinearNoiseForce.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. LinearSinkForce | LinearSinkForce
//********************************************************************
PyMethodDef Dtool_Methods_LinearSinkForce[]= {
  { "getClassType",(PyCFunction ) &Dtool_LinearSinkForce_get_class_type_200, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearSinkForce_get_class_type_200_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_LinearSinkForce(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_LinearSinkForce.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : LinearSinkForce\n"
          "// Description : Attractor force.  Think black hole.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_LinearDistanceForce._Dtool_ClassInit(NULL);
        Dtool_LinearSinkForce.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LinearDistanceForce.As_PyTypeObject());
        Dtool_LinearSinkForce.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_LinearSinkForce.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_LinearSinkForce.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_LinearSinkForce.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(LinearSinkForce)");
             printf(" Error In PyType_ReadyLinearSinkForce");
             return;
        }
        Py_INCREF(&Dtool_LinearSinkForce.As_PyTypeObject());
        PyDict_SetItemString(Dtool_LinearSinkForce.As_PyTypeObject().tp_dict,"LinearSinkForce",&Dtool_LinearSinkForce.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_LinearSinkForce.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_LinearSinkForce[0],&Dtool_LinearSinkForce.As_PyObject()));
        RegisterRuntimeClass(&Dtool_LinearSinkForce,LinearSinkForce::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_LinearSinkForce.As_PyTypeObject());
        PyModule_AddObject(module, "LinearSinkForce",(PyObject *)&Dtool_LinearSinkForce.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. LinearSourceForce | LinearSourceForce
//********************************************************************
PyMethodDef Dtool_Methods_LinearSourceForce[]= {
  { "getClassType",(PyCFunction ) &Dtool_LinearSourceForce_get_class_type_203, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearSourceForce_get_class_type_203_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_LinearSourceForce(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_LinearSourceForce.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : LinearSourceForce\n"
          "// Description : Repellant force.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_LinearDistanceForce._Dtool_ClassInit(NULL);
        Dtool_LinearSourceForce.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LinearDistanceForce.As_PyTypeObject());
        Dtool_LinearSourceForce.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_LinearSourceForce.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_LinearSourceForce.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_LinearSourceForce.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(LinearSourceForce)");
             printf(" Error In PyType_ReadyLinearSourceForce");
             return;
        }
        Py_INCREF(&Dtool_LinearSourceForce.As_PyTypeObject());
        PyDict_SetItemString(Dtool_LinearSourceForce.As_PyTypeObject().tp_dict,"LinearSourceForce",&Dtool_LinearSourceForce.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_LinearSourceForce.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_LinearSourceForce[0],&Dtool_LinearSourceForce.As_PyObject()));
        RegisterRuntimeClass(&Dtool_LinearSourceForce,LinearSourceForce::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_LinearSourceForce.As_PyTypeObject());
        PyModule_AddObject(module, "LinearSourceForce",(PyObject *)&Dtool_LinearSourceForce.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. LinearUserDefinedForce | LinearUserDefinedForce
//********************************************************************
PyMethodDef Dtool_Methods_LinearUserDefinedForce[]= {
  { "getClassType",(PyCFunction ) &Dtool_LinearUserDefinedForce_get_class_type_207, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearUserDefinedForce_get_class_type_207_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_LinearUserDefinedForce(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_LinearUserDefinedForce.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : LinearUserDefinedForce\n"
          "// Description : a programmable force that takes an evaluator fn.\n"
          "//\n"
          "//        NOTE : AS OF Interrogate => Squeak, this class does NOT\n"
          "//               get FFI'd due to the function pointer bug, and is\n"
          "//               currently NOT getting interrogated.  Change this\n"
          "//               in the makefile when the time is right or this class\n"
          "//               becomes needed...\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_LinearForce._Dtool_ClassInit(NULL);
        Dtool_LinearUserDefinedForce.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LinearForce.As_PyTypeObject());
        Dtool_LinearUserDefinedForce.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_LinearUserDefinedForce.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_LinearUserDefinedForce.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_LinearUserDefinedForce.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(LinearUserDefinedForce)");
             printf(" Error In PyType_ReadyLinearUserDefinedForce");
             return;
        }
        Py_INCREF(&Dtool_LinearUserDefinedForce.As_PyTypeObject());
        PyDict_SetItemString(Dtool_LinearUserDefinedForce.As_PyTypeObject().tp_dict,"LinearUserDefinedForce",&Dtool_LinearUserDefinedForce.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_LinearUserDefinedForce.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_LinearUserDefinedForce[0],&Dtool_LinearUserDefinedForce.As_PyObject()));
        RegisterRuntimeClass(&Dtool_LinearUserDefinedForce,LinearUserDefinedForce::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_LinearUserDefinedForce.As_PyTypeObject());
        PyModule_AddObject(module, "LinearUserDefinedForce",(PyObject *)&Dtool_LinearUserDefinedForce.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. LinearVectorForce | LinearVectorForce
//********************************************************************
PyMethodDef Dtool_Methods_LinearVectorForce[]= {
  { "setVector",(PyCFunction ) &Dtool_LinearVectorForce_set_vector_210, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearVectorForce_set_vector_210_comment},
  { "getLocalVector",(PyCFunction ) &Dtool_LinearVectorForce_get_local_vector_211, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearVectorForce_get_local_vector_211_comment},
  { "getClassType",(PyCFunction ) &Dtool_LinearVectorForce_get_class_type_212, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_LinearVectorForce_get_class_type_212_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_LinearVectorForce(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_LinearVectorForce.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////\n"
          "//       Class : LinearVectorForce\n"
          "// Description : Simple directed vector force.  Suitable for\n"
          "//               gravity, non-turbulent wind, etc...\n"
          "////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_LinearForce._Dtool_ClassInit(NULL);
        Dtool_LinearVectorForce.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_LinearForce.As_PyTypeObject());
        Dtool_LinearVectorForce.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_LinearVectorForce.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_LinearVectorForce.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_LinearVectorForce.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(LinearVectorForce)");
             printf(" Error In PyType_ReadyLinearVectorForce");
             return;
        }
        Py_INCREF(&Dtool_LinearVectorForce.As_PyTypeObject());
        PyDict_SetItemString(Dtool_LinearVectorForce.As_PyTypeObject().tp_dict,"LinearVectorForce",&Dtool_LinearVectorForce.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_LinearVectorForce.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_LinearVectorForce[2],&Dtool_LinearVectorForce.As_PyObject()));
        RegisterRuntimeClass(&Dtool_LinearVectorForce,LinearVectorForce::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_LinearVectorForce.As_PyTypeObject());
        PyModule_AddObject(module, "LinearVectorForce",(PyObject *)&Dtool_LinearVectorForce.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PhysicsCollisionHandler | PhysicsCollisionHandler
//********************************************************************
PyMethodDef Dtool_Methods_PhysicsCollisionHandler[]= {
  { "setAlmostStationarySpeed",(PyCFunction ) &Dtool_PhysicsCollisionHandler_set_almost_stationary_speed_216, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsCollisionHandler_set_almost_stationary_speed_216_comment},
  { "getAlmostStationarySpeed",(PyCFunction ) &Dtool_PhysicsCollisionHandler_get_almost_stationary_speed_217, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsCollisionHandler_get_almost_stationary_speed_217_comment},
  { "setStaticFrictionCoef",(PyCFunction ) &Dtool_PhysicsCollisionHandler_set_static_friction_coef_218, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsCollisionHandler_set_static_friction_coef_218_comment},
  { "getStaticFrictionCoef",(PyCFunction ) &Dtool_PhysicsCollisionHandler_get_static_friction_coef_219, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsCollisionHandler_get_static_friction_coef_219_comment},
  { "setDynamicFrictionCoef",(PyCFunction ) &Dtool_PhysicsCollisionHandler_set_dynamic_friction_coef_220, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsCollisionHandler_set_dynamic_friction_coef_220_comment},
  { "getDynamicFrictionCoef",(PyCFunction ) &Dtool_PhysicsCollisionHandler_get_dynamic_friction_coef_221, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsCollisionHandler_get_dynamic_friction_coef_221_comment},
  { "getClassType",(PyCFunction ) &Dtool_PhysicsCollisionHandler_get_class_type_222, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsCollisionHandler_get_class_type_222_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PhysicsCollisionHandler(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PhysicsCollisionHandler.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PhysicsCollisionHandler\n"
          "// Description : A specialized kind of CollisionHandler that simply\n"
          "//               pushes back on things that attempt to move into solid\n"
          "//               walls.  This also puts forces onto the physics objects\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CollisionHandlerPusher._Dtool_ClassInit(NULL);
        Dtool_PhysicsCollisionHandler.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CollisionHandlerPusher.As_PyTypeObject());
        Dtool_PhysicsCollisionHandler.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PhysicsCollisionHandler.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PhysicsCollisionHandler.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PhysicsCollisionHandler.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PhysicsCollisionHandler)");
             printf(" Error In PyType_ReadyPhysicsCollisionHandler");
             return;
        }
        Py_INCREF(&Dtool_PhysicsCollisionHandler.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PhysicsCollisionHandler.As_PyTypeObject().tp_dict,"PhysicsCollisionHandler",&Dtool_PhysicsCollisionHandler.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_PhysicsCollisionHandler.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_PhysicsCollisionHandler[6],&Dtool_PhysicsCollisionHandler.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PhysicsCollisionHandler,PhysicsCollisionHandler::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PhysicsCollisionHandler.As_PyTypeObject());
        PyModule_AddObject(module, "PhysicsCollisionHandler",(PyObject *)&Dtool_PhysicsCollisionHandler.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PhysicsManager | PhysicsManager
//********************************************************************
PyMethodDef Dtool_Methods_PhysicsManager[]= {
  { "attachLinearIntegrator",(PyCFunction ) &Dtool_PhysicsManager_attach_linear_integrator_226, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsManager_attach_linear_integrator_226_comment},
  { "attachAngularIntegrator",(PyCFunction ) &Dtool_PhysicsManager_attach_angular_integrator_227, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsManager_attach_angular_integrator_227_comment},
  { "attachPhysical",(PyCFunction ) &Dtool_PhysicsManager_attach_physical_228, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsManager_attach_physical_228_comment},
  { "attachPhysicalnode",(PyCFunction ) &Dtool_PhysicsManager_attach_physicalnode_229, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsManager_attach_physicalnode_229_comment},
  { "attachPhysicalNode",(PyCFunction ) &Dtool_PhysicsManager_attach_physical_node_230, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsManager_attach_physical_node_230_comment},
  { "addLinearForce",(PyCFunction ) &Dtool_PhysicsManager_add_linear_force_231, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsManager_add_linear_force_231_comment},
  { "addAngularForce",(PyCFunction ) &Dtool_PhysicsManager_add_angular_force_232, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsManager_add_angular_force_232_comment},
  { "clearLinearForces",(PyCFunction ) &Dtool_PhysicsManager_clear_linear_forces_233, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsManager_clear_linear_forces_233_comment},
  { "clearAngularForces",(PyCFunction ) &Dtool_PhysicsManager_clear_angular_forces_234, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsManager_clear_angular_forces_234_comment},
  { "clearPhysicals",(PyCFunction ) &Dtool_PhysicsManager_clear_physicals_235, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsManager_clear_physicals_235_comment},
  { "setViscosity",(PyCFunction ) &Dtool_PhysicsManager_set_viscosity_236, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsManager_set_viscosity_236_comment},
  { "getViscosity",(PyCFunction ) &Dtool_PhysicsManager_get_viscosity_237, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsManager_get_viscosity_237_comment},
  { "removePhysical",(PyCFunction ) &Dtool_PhysicsManager_remove_physical_238, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsManager_remove_physical_238_comment},
  { "removePhysicalNode",(PyCFunction ) &Dtool_PhysicsManager_remove_physical_node_239, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsManager_remove_physical_node_239_comment},
  { "removeLinearForce",(PyCFunction ) &Dtool_PhysicsManager_remove_linear_force_240, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsManager_remove_linear_force_240_comment},
  { "removeAngularForce",(PyCFunction ) &Dtool_PhysicsManager_remove_angular_force_241, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsManager_remove_angular_force_241_comment},
  { "doPhysics",(PyCFunction ) &Dtool_PhysicsManager_do_physics_242, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsManager_do_physics_242_comment},
  { "initRandomSeed",(PyCFunction ) &Dtool_PhysicsManager_init_random_seed_243, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsManager_init_random_seed_243_comment},
  { "output",(PyCFunction ) &Dtool_PhysicsManager_output_244, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsManager_output_244_comment},
  { "writePhysicals",(PyCFunction ) &Dtool_PhysicsManager_write_physicals_245, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsManager_write_physicals_245_comment},
  { "writeLinearForces",(PyCFunction ) &Dtool_PhysicsManager_write_linear_forces_246, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsManager_write_linear_forces_246_comment},
  { "writeAngularForces",(PyCFunction ) &Dtool_PhysicsManager_write_angular_forces_247, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsManager_write_angular_forces_247_comment},
  { "write",(PyCFunction ) &Dtool_PhysicsManager_write_248, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsManager_write_248_comment},
  { "debugOutput",(PyCFunction ) &Dtool_PhysicsManager_debug_output_249, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PhysicsManager_debug_output_249_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     PhysicsManager
//////////////////
static PyObject *  Dtool_Repr_PhysicsManager(PyObject * self)
{
    PhysicsManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsManager,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     PhysicsManager
//////////////////
static PyObject *  Dtool_Str_PhysicsManager(PyObject * self)
{
    PhysicsManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PhysicsManager,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_PhysicsManager(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PhysicsManager.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PhysicsManager\n"
          "// Description : Physics don't get much higher-level than this.\n"
          "//               Attach as many Physicals (particle systems, etc..)\n"
          "//               as you want, pick an integrator and go.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_PhysicsManager.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_PhysicsManager.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PhysicsManager.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PhysicsManager.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_PhysicsManager.As_PyTypeObject().tp_repr = & Dtool_Repr_PhysicsManager;
        // __str__
        Dtool_PhysicsManager.As_PyTypeObject().tp_str = & Dtool_Str_PhysicsManager;
        if(PyType_Ready(&Dtool_PhysicsManager.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PhysicsManager)");
             printf(" Error In PyType_ReadyPhysicsManager");
             return;
        }
        Py_INCREF(&Dtool_PhysicsManager.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PhysicsManager.As_PyTypeObject().tp_dict,"PhysicsManager",&Dtool_PhysicsManager.As_PyObject());
        RegisterRuntimeClass(&Dtool_PhysicsManager,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PhysicsManager.As_PyTypeObject());
        PyModule_AddObject(module, "PhysicsManager",(PyObject *)&Dtool_PhysicsManager.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..PhysicsObject
//********************************************************************
   Dtool_PyModuleClassInit_PhysicsObject(module);
//********************************************************************
//*** Module Init Updcall ..PhysicsObjectCollection
//********************************************************************
   Dtool_PyModuleClassInit_PhysicsObjectCollection(module);
//********************************************************************
//*** Module Init Updcall ..BaseForce
//********************************************************************
   Dtool_PyModuleClassInit_BaseForce(module);
//********************************************************************
//*** Module Init Updcall ..LinearForce
//********************************************************************
   Dtool_PyModuleClassInit_LinearForce(module);
//********************************************************************
//*** Module Init Updcall ..AngularForce
//********************************************************************
   Dtool_PyModuleClassInit_AngularForce(module);
//********************************************************************
//*** Module Init Updcall ..Physical
//********************************************************************
   Dtool_PyModuleClassInit_Physical(module);
//********************************************************************
//*** Module Init Updcall ..PhysicalNode
//********************************************************************
   Dtool_PyModuleClassInit_PhysicalNode(module);
//********************************************************************
//*** Module Init Updcall ..ActorNode
//********************************************************************
   Dtool_PyModuleClassInit_ActorNode(module);
//********************************************************************
//*** Module Init Updcall ..BaseIntegrator
//********************************************************************
   Dtool_PyModuleClassInit_BaseIntegrator(module);
//********************************************************************
//*** Module Init Updcall ..AngularIntegrator
//********************************************************************
   Dtool_PyModuleClassInit_AngularIntegrator(module);
//********************************************************************
//*** Module Init Updcall ..AngularEulerIntegrator
//********************************************************************
   Dtool_PyModuleClassInit_AngularEulerIntegrator(module);
//********************************************************************
//*** Module Init Updcall ..AngularVectorForce
//********************************************************************
   Dtool_PyModuleClassInit_AngularVectorForce(module);
//********************************************************************
//*** Module Init Updcall ..ForceNode
//********************************************************************
   Dtool_PyModuleClassInit_ForceNode(module);
//********************************************************************
//*** Module Init Updcall ..LinearControlForce
//********************************************************************
   Dtool_PyModuleClassInit_LinearControlForce(module);
//********************************************************************
//*** Module Init Updcall ..LinearCylinderVortexForce
//********************************************************************
   Dtool_PyModuleClassInit_LinearCylinderVortexForce(module);
//********************************************************************
//*** Module Init Updcall ..LinearDistanceForce
//********************************************************************
   Dtool_PyModuleClassInit_LinearDistanceForce(module);
//********************************************************************
//*** Module Init Updcall ..LinearIntegrator
//********************************************************************
   Dtool_PyModuleClassInit_LinearIntegrator(module);
//********************************************************************
//*** Module Init Updcall ..LinearEulerIntegrator
//********************************************************************
   Dtool_PyModuleClassInit_LinearEulerIntegrator(module);
//********************************************************************
//*** Module Init Updcall ..LinearFrictionForce
//********************************************************************
   Dtool_PyModuleClassInit_LinearFrictionForce(module);
//********************************************************************
//*** Module Init Updcall ..LinearRandomForce
//********************************************************************
   Dtool_PyModuleClassInit_LinearRandomForce(module);
//********************************************************************
//*** Module Init Updcall ..LinearJitterForce
//********************************************************************
   Dtool_PyModuleClassInit_LinearJitterForce(module);
//********************************************************************
//*** Module Init Updcall ..LinearNoiseForce
//********************************************************************
   Dtool_PyModuleClassInit_LinearNoiseForce(module);
//********************************************************************
//*** Module Init Updcall ..LinearSinkForce
//********************************************************************
   Dtool_PyModuleClassInit_LinearSinkForce(module);
//********************************************************************
//*** Module Init Updcall ..LinearSourceForce
//********************************************************************
   Dtool_PyModuleClassInit_LinearSourceForce(module);
//********************************************************************
//*** Module Init Updcall ..LinearUserDefinedForce
//********************************************************************
   Dtool_PyModuleClassInit_LinearUserDefinedForce(module);
//********************************************************************
//*** Module Init Updcall ..LinearVectorForce
//********************************************************************
   Dtool_PyModuleClassInit_LinearVectorForce(module);
//********************************************************************
//*** Module Init Updcall ..PhysicsCollisionHandler
//********************************************************************
   Dtool_PyModuleClassInit_PhysicsCollisionHandler(module);
//********************************************************************
//*** Module Init Updcall ..PhysicsManager
//********************************************************************
   Dtool_PyModuleClassInit_PhysicsManager(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libphysics_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687213608,  /* file_identifier */
  "libphysics",  /* library_name */
  "9fJJ",  /* library_hash_name */
  "pandaphysics",  /* module_name */
  "libphysics.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  653  /* next_index */
};

Configure(_in_configure_libphysics);
ConfigureFn(_in_configure_libphysics) {
  interrogate_request_module(&_in_module_def);
}

