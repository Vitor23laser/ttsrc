/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir direct/src/dcparser -Idirect/src/dcparser -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libdcparser_igate.cxx -od built_Rocket/pandac/input/libdcparser.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Idirect/src/dcparser -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWITHIN_PANDA=1 -DWANT_NATIVE_NET=1 -DBUILDING_DIRECT -module p3direct -library libdcparser dcArrayParameter.h dcAtomicField.h dcClass.h dcClassParameter.h dcDeclaration.h dcField.h dcFile.h dcKeyword.h dcKeywordList.h dcLexerDefs.h dcMolecularField.h dcNumericRange.h dcPackData.h dcPacker.h dcPackerCatalog.h dcPackerInterface.h dcParameter.h dcParserDefs.h dcPython.h dcSimpleParameter.h dcSubatomicType.h dcSwitch.h dcSwitchParameter.h dcTypedef.h dcbase.h dcindent.h dcparser_composite.cxx hashGenerator.h primeNumberGenerator.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libdcparser
#include "py_panda.h"  

#include "configVariableBool.h"
#include "dcArrayParameter.h"
#include "dcAtomicField.h"
#include "dcClass.h"
#include "dcClassParameter.h"
#include "dcDeclaration.h"
#include "dcField.h"
#include "dcFile.h"
#include "dcKeyword.h"
#include "dcKeywordList.h"
#include "dcLexerDefs.h"
#include "dcMolecularField.h"
#include "dcNumericRange.h"
#include "dcPackData.h"
#include "dcPacker.h"
#include "dcPackerCatalog.h"
#include "dcPackerInterface.h"
#include "dcParameter.h"
#include "dcParserDefs.h"
#include "dcPython.h"
#include "dcSimpleParameter.h"
#include "dcSubatomicType.h"
#include "dcSwitch.h"
#include "dcSwitchParameter.h"
#include "dcTypedef.h"
#include "dcbase.h"
#include "dcindent.h"
#include "hashGenerator.h"
#include "indent.h"
#include <math.h>
#include "pStatCollector.h"
#include "primeNumberGenerator.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. DCPackerInterface
//********************************************************************
typedef  DCPackerInterface  DCPackerInterface_localtype;
Define_Module_Class(p3direct,DCPackerInterface,DCPackerInterface_localtype,DCPackerInterface);
//********************************************************************
//*** prototypes for .. DCKeywordList
//********************************************************************
typedef  DCKeywordList  DCKeywordList_localtype;
Define_Module_Class(p3direct,DCKeywordList,DCKeywordList_localtype,DCKeywordList);
//********************************************************************
//*** prototypes for .. DCField
//********************************************************************
typedef  DCField  DCField_localtype;
Define_Module_Class(p3direct,DCField,DCField_localtype,DCField);
//********************************************************************
//*** prototypes for .. DCPackData
//********************************************************************
typedef  DCPackData  DCPackData_localtype;
Define_Module_Class(p3direct,DCPackData,DCPackData_localtype,DCPackData);
//********************************************************************
//*** prototypes for .. DCPacker
//********************************************************************
typedef  DCPacker  DCPacker_localtype;
Define_Module_Class(p3direct,DCPacker,DCPacker_localtype,DCPacker);
//********************************************************************
//*** prototypes for .. DCParameter
//********************************************************************
typedef  DCParameter  DCParameter_localtype;
Define_Module_Class(p3direct,DCParameter,DCParameter_localtype,DCParameter);
//********************************************************************
//*** prototypes for .. DCArrayParameter
//********************************************************************
typedef  DCArrayParameter  DCArrayParameter_localtype;
Define_Module_Class(p3direct,DCArrayParameter,DCArrayParameter_localtype,DCArrayParameter);
//********************************************************************
//*** prototypes for .. DCAtomicField
//********************************************************************
typedef  DCAtomicField  DCAtomicField_localtype;
Define_Module_Class(p3direct,DCAtomicField,DCAtomicField_localtype,DCAtomicField);
//********************************************************************
//*** prototypes for .. DCDeclaration
//********************************************************************
typedef  DCDeclaration  DCDeclaration_localtype;
Define_Module_Class(p3direct,DCDeclaration,DCDeclaration_localtype,DCDeclaration);
//********************************************************************
//*** prototypes for .. DCClass
//********************************************************************
typedef  DCClass  DCClass_localtype;
Define_Module_Class(p3direct,DCClass,DCClass_localtype,DCClass);
//********************************************************************
//*** prototypes for .. DCClassParameter
//********************************************************************
typedef  DCClassParameter  DCClassParameter_localtype;
Define_Module_Class(p3direct,DCClassParameter,DCClassParameter_localtype,DCClassParameter);
//********************************************************************
//*** prototypes for .. DCFile
//********************************************************************
typedef  DCFile  DCFile_localtype;
Define_Module_Class(p3direct,DCFile,DCFile_localtype,DCFile);
//********************************************************************
//*** prototypes for .. DCKeyword
//********************************************************************
typedef  DCKeyword  DCKeyword_localtype;
Define_Module_Class(p3direct,DCKeyword,DCKeyword_localtype,DCKeyword);
//********************************************************************
//*** prototypes for .. DCMolecularField
//********************************************************************
typedef  DCMolecularField  DCMolecularField_localtype;
Define_Module_Class(p3direct,DCMolecularField,DCMolecularField_localtype,DCMolecularField);
//********************************************************************
//*** prototypes for .. DCSimpleParameter
//********************************************************************
typedef  DCSimpleParameter  DCSimpleParameter_localtype;
Define_Module_Class(p3direct,DCSimpleParameter,DCSimpleParameter_localtype,DCSimpleParameter);
//********************************************************************
//*** prototypes for .. DCSwitch
//********************************************************************
typedef  DCSwitch  DCSwitch_localtype;
Define_Module_Class(p3direct,DCSwitch,DCSwitch_localtype,DCSwitch);
//********************************************************************
//*** prototypes for .. DCSwitchParameter
//********************************************************************
typedef  DCSwitchParameter  DCSwitchParameter_localtype;
Define_Module_Class(p3direct,DCSwitchParameter,DCSwitchParameter_localtype,DCSwitchParameter);
//********************************************************************
//*** prototypes for .. DCTypedef
//********************************************************************
typedef  DCTypedef  DCTypedef_localtype;
Define_Module_Class(p3direct,DCTypedef,DCTypedef_localtype,DCTypedef);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Datagram;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_DatagramIterator;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Filename;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_istream;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. DCPackerInterface 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &DCPackerInterface::get_name(void) const
 *******************************************************************/
static PyObject *Dtool_DCPackerInterface_get_name_5(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPackerInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPackerInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &DCPackerInterface::get_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getName", key_word_list));
        else
            (PyArg_Parse(args, ":getName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const DCPackerInterface*)local_this)->get_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getName(const DCPackerInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPackerInterface_get_name_5_comment =
    "C++ Interface:\n"
    "getName(const DCPackerInterface this)\n"
    "\n"
    "// Filename: dcPackerInterface.I\n"
    "// Created by:  drose (18Jun04)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPackerInterface::get_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the name of this field, or empty string\n"
    "//               if the field is unnamed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPackerInterface_get_name_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DCPackerInterface::find_seek_index(basic_string< char > const &name) const
 *******************************************************************/
static PyObject *Dtool_DCPackerInterface_find_seek_index_6(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPackerInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPackerInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DCPackerInterface::find_seek_index(basic_string< char > const &name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:findSeekIndex", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:findSeekIndex", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DCPackerInterface*)local_this)->find_seek_index(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findSeekIndex(const DCPackerInterface this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPackerInterface_find_seek_index_6_comment =
    "C++ Interface:\n"
    "findSeekIndex(const DCPackerInterface this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPackerInterface::find_seek_index\n"
    "//       Access: Published\n"
    "//  Description: Returns the index number to be passed to a future\n"
    "//               call to DCPacker::seek() to seek directly to the\n"
    "//               named field without having to look up the field name\n"
    "//               in a table later, or -1 if the named field cannot be\n"
    "//               found.\n"
    "//\n"
    "//               If the named field is nested within a switch or some\n"
    "//               similar dynamic structure that reveals different\n"
    "//               fields based on the contents of the data, this\n"
    "//               mechanism cannot be used to pre-fetch the field index\n"
    "//               number--you must seek for the field by name.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPackerInterface_find_seek_index_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual DCField *DCPackerInterface::as_field(void)
 * virtual DCField const *DCPackerInterface::as_field(void) const
 *******************************************************************/
static PyObject *Dtool_DCPackerInterface_as_field_7(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPackerInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPackerInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // -2 virtual DCField const *DCPackerInterface::as_field(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":asField", key_word_list));
        else
            (PyArg_Parse(args, ":asField"));
        if(!PyErr_Occurred())
        {
            DCField const *return_value = ((const DCPackerInterface*)local_this)->as_field();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCField,false, true);
            }
        }
        PyErr_Clear(); 
    }

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 virtual DCField *DCPackerInterface::as_field(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":asField", key_word_list));
        else
            (PyArg_Parse(args, ":asField"));
        if(!PyErr_Occurred())
        {
            DCField *return_value = (local_this)->as_field();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCField,false, false);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "asField(const DCPackerInterface this)\n"
          "asField(non-const DCPackerInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPackerInterface_as_field_7_comment =
    "C++ Interface:\n"
    "asField(const DCPackerInterface this)\n"
    "asField(non-const DCPackerInterface this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPackerInterface::as_field\n"
    "//       Access: Published, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPackerInterface::as_field\n"
    "//       Access: Published, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPackerInterface_as_field_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual DCSwitchParameter *DCPackerInterface::as_switch_parameter(void)
 * virtual DCSwitchParameter const *DCPackerInterface::as_switch_parameter(void) const
 *******************************************************************/
static PyObject *Dtool_DCPackerInterface_as_switch_parameter_8(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPackerInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPackerInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 virtual DCSwitchParameter *DCPackerInterface::as_switch_parameter(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":asSwitchParameter", key_word_list));
        else
            (PyArg_Parse(args, ":asSwitchParameter"));
        if(!PyErr_Occurred())
        {
            DCSwitchParameter *return_value = (local_this)->as_switch_parameter();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCSwitchParameter,false, false);
            }
        }
        PyErr_Clear(); 
    }

    {
      // -2 virtual DCSwitchParameter const *DCPackerInterface::as_switch_parameter(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":asSwitchParameter", key_word_list));
        else
            (PyArg_Parse(args, ":asSwitchParameter"));
        if(!PyErr_Occurred())
        {
            DCSwitchParameter const *return_value = ((const DCPackerInterface*)local_this)->as_switch_parameter();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCSwitchParameter,false, true);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "asSwitchParameter(non-const DCPackerInterface this)\n"
          "asSwitchParameter(const DCPackerInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPackerInterface_as_switch_parameter_8_comment =
    "C++ Interface:\n"
    "asSwitchParameter(non-const DCPackerInterface this)\n"
    "asSwitchParameter(const DCPackerInterface this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPackerInterface::as_switch_parameter\n"
    "//       Access: Published, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPackerInterface::as_switch_parameter\n"
    "//       Access: Published, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPackerInterface_as_switch_parameter_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual DCClassParameter *DCPackerInterface::as_class_parameter(void)
 * virtual DCClassParameter const *DCPackerInterface::as_class_parameter(void) const
 *******************************************************************/
static PyObject *Dtool_DCPackerInterface_as_class_parameter_9(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPackerInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPackerInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // -2 virtual DCClassParameter const *DCPackerInterface::as_class_parameter(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":asClassParameter", key_word_list));
        else
            (PyArg_Parse(args, ":asClassParameter"));
        if(!PyErr_Occurred())
        {
            DCClassParameter const *return_value = ((const DCPackerInterface*)local_this)->as_class_parameter();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCClassParameter,false, true);
            }
        }
        PyErr_Clear(); 
    }

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 virtual DCClassParameter *DCPackerInterface::as_class_parameter(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":asClassParameter", key_word_list));
        else
            (PyArg_Parse(args, ":asClassParameter"));
        if(!PyErr_Occurred())
        {
            DCClassParameter *return_value = (local_this)->as_class_parameter();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCClassParameter,false, false);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "asClassParameter(const DCPackerInterface this)\n"
          "asClassParameter(non-const DCPackerInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPackerInterface_as_class_parameter_9_comment =
    "C++ Interface:\n"
    "asClassParameter(const DCPackerInterface this)\n"
    "asClassParameter(non-const DCPackerInterface this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPackerInterface::as_class_parameter\n"
    "//       Access: Published, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPackerInterface::as_class_parameter\n"
    "//       Access: Published, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPackerInterface_as_class_parameter_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DCPackerInterface::check_match(DCPackerInterface const *other) const
 * bool DCPackerInterface::check_match(basic_string< char > const &description, DCFile *dcfile) const
 * bool DCPackerInterface::check_match(basic_string< char > const &description, DCFile *dcfile = ((void *)(0))) const
 *******************************************************************/
static PyObject *Dtool_DCPackerInterface_check_match_10(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPackerInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPackerInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 bool DCPackerInterface::check_match(basic_string< char > const &description, DCFile *dcfile = ((void *)(0))) const
                char *param1_str; int param1_len;
                static char * key_word_list[] = {(char *)"description", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:checkMatch", key_word_list, &param1_str, &param1_len));
                else
                    (PyArg_Parse(args, "s#:checkMatch", &param1_str, &param1_len));
                if(!PyErr_Occurred())
                {
                    bool return_value = ((const DCPackerInterface*)local_this)->check_match(basic_string<char>(param1_str, param1_len));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline bool DCPackerInterface::check_match(DCPackerInterface const *other) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"other", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:checkMatch", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:checkMatch", &param1));
                if(!PyErr_Occurred())
                {
                    DCPackerInterface *param1_this = (DCPackerInterface *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DCPackerInterface, 1, "DCPackerInterface.checkMatch", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = ((const DCPackerInterface*)local_this)->check_match(param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-bool DCPackerInterface::check_match(basic_string< char > const &description, DCFile *dcfile) const
                char *param1_str; int param1_len;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"description", (char *)"dcfile", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:checkMatch", key_word_list, &param1_str, &param1_len, &param2))
                {
                    DCFile *param2_this = (DCFile *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DCFile, 2, "DCPackerInterface.checkMatch", 0, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        bool return_value = ((const DCPackerInterface*)local_this)->check_match(basic_string<char>(param1_str, param1_len), param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "checkMatch() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "checkMatch(const DCPackerInterface this, string description)\n"
          "checkMatch(const DCPackerInterface this, const DCPackerInterface other)\n"
          "checkMatch(const DCPackerInterface this, string description, non-const DCFile dcfile)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPackerInterface_check_match_10_comment =
    "C++ Interface:\n"
    "checkMatch(const DCPackerInterface this, string description)\n"
    "checkMatch(const DCPackerInterface this, const DCPackerInterface other)\n"
    "checkMatch(const DCPackerInterface this, string description, non-const DCFile dcfile)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPackerInterface::check_match\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the other interface is bitwise the\n"
    "//               same as this one--that is, a uint32 only matches a\n"
    "//               uint32, etc. Names of components, and range limits,\n"
    "//               are not compared.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPackerInterface::check_match\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this interface is bitwise the same as\n"
    "//               the interface described with the indicated formatted\n"
    "//               string, e.g. \"(uint8, uint8, int16)\", or false\n"
    "//               otherwise.\n"
    "//\n"
    "//               If DCFile is not NULL, it specifies the DCFile that\n"
    "//               was previously loaded, from which some predefined\n"
    "//               structs and typedefs may be referenced in the\n"
    "//               description string.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPackerInterface_check_match_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCField *DCPackerInterface::downcast_to_DCField(void)
 *******************************************************************/
static PyObject *Dtool_DCPackerInterface_downcast_to_DCField_20(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPackerInterface * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPackerInterface,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-DCField *DCPackerInterface::downcast_to_DCField(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToDCField", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToDCField"));
        if(!PyErr_Occurred())
        {
            DCField *return_value = (DCField *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCField,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPackerInterface.downcastToDCField() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToDCField(non-const DCPackerInterface this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPackerInterface_downcast_to_DCField_20_comment =
    "C++ Interface:\n"
    "downcastToDCField(non-const DCPackerInterface this)\n"
    "\n"
    "downcast from DCPackerInterface to DCField\n"
    "";
#else
static const char * Dtool_DCPackerInterface_downcast_to_DCField_20_comment = NULL;
#endif

int  Dtool_Init_DCPackerInterface(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (DCPackerInterface)");
       return -1;
}
inline void  * Dtool_UpcastInterface_DCPackerInterface(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DCPackerInterface)
    {
        printf("DCPackerInterface ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DCPackerInterface * local_this = (DCPackerInterface *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DCPackerInterface)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DCPackerInterface(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DCPackerInterface)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DCKeywordList 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * bool DCKeywordList::has_keyword(DCKeyword const *keyword) const
 * bool DCKeywordList::has_keyword(basic_string< char > const &name) const
 *******************************************************************/
static PyObject *Dtool_DCKeywordList_has_keyword_13(PyObject *self, PyObject *args,PyObject *kwds) {
    DCKeywordList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCKeywordList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 bool DCKeywordList::has_keyword(DCKeyword const *keyword) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"keyword", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:hasKeyword", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:hasKeyword", &param1));
            if(!PyErr_Occurred())
            {
                DCKeyword *param1_this = (DCKeyword *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DCKeyword, 1, "DCKeywordList.hasKeyword", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const DCKeywordList*)local_this)->has_keyword(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 bool DCKeywordList::has_keyword(basic_string< char > const &name) const
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:hasKeyword", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:hasKeyword", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                bool return_value = ((const DCKeywordList*)local_this)->has_keyword(basic_string<char>(param1_str, param1_len));
                Py_XDECREF(coerced);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasKeyword(const DCKeywordList this, const DCKeyword keyword)\n"
          "hasKeyword(const DCKeywordList this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCKeywordList_has_keyword_13_comment =
    "C++ Interface:\n"
    "hasKeyword(const DCKeywordList this, const DCKeyword keyword)\n"
    "hasKeyword(const DCKeywordList this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCKeywordList::has_keyword\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this list includes the indicated\n"
    "//               keyword, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCKeywordList::has_keyword\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this list includes the indicated\n"
    "//               keyword, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCKeywordList_has_keyword_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DCKeywordList::get_num_keywords(void) const
 *******************************************************************/
static PyObject *Dtool_DCKeywordList_get_num_keywords_14(PyObject *self, PyObject *args,PyObject *kwds) {
    DCKeywordList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCKeywordList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DCKeywordList::get_num_keywords(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumKeywords", key_word_list));
        else
            (PyArg_Parse(args, ":getNumKeywords"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DCKeywordList*)local_this)->get_num_keywords();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumKeywords(const DCKeywordList this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCKeywordList_get_num_keywords_14_comment =
    "C++ Interface:\n"
    "getNumKeywords(const DCKeywordList this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCKeywordList::get_num_keywords\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of keywords in the list.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCKeywordList_get_num_keywords_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCKeyword const *DCKeywordList::get_keyword(int n) const
 *******************************************************************/
static PyObject *Dtool_DCKeywordList_get_keyword_15(PyObject *self, PyObject *args,PyObject *kwds) {
    DCKeywordList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCKeywordList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DCKeyword const *DCKeywordList::get_keyword(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getKeyword", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getKeyword", &param1));
        if(!PyErr_Occurred())
        {
            DCKeyword const *return_value = ((const DCKeywordList*)local_this)->get_keyword((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCKeyword,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getKeyword(const DCKeywordList this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCKeywordList_get_keyword_15_comment =
    "C++ Interface:\n"
    "getKeyword(const DCKeywordList this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCKeywordList::get_keyword\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth keyword in the list.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCKeywordList_get_keyword_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCKeyword const *DCKeywordList::get_keyword_by_name(basic_string< char > const &name) const
 *******************************************************************/
static PyObject *Dtool_DCKeywordList_get_keyword_by_name_16(PyObject *self, PyObject *args,PyObject *kwds) {
    DCKeywordList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCKeywordList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DCKeyword const *DCKeywordList::get_keyword_by_name(basic_string< char > const &name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getKeywordByName", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:getKeywordByName", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            DCKeyword const *return_value = ((const DCKeywordList*)local_this)->get_keyword_by_name(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCKeyword,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getKeywordByName(const DCKeywordList this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCKeywordList_get_keyword_by_name_16_comment =
    "C++ Interface:\n"
    "getKeywordByName(const DCKeywordList this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCKeywordList::get_keyword_by_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the keyword in the list with the indicated\n"
    "//               name, or NULL if there is no keyword in the list with\n"
    "//               that name.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCKeywordList_get_keyword_by_name_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DCKeywordList::compare_keywords(DCKeywordList const &other) const
 *******************************************************************/
static PyObject *Dtool_DCKeywordList_compare_keywords_17(PyObject *self, PyObject *args,PyObject *kwds) {
    DCKeywordList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCKeywordList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool DCKeywordList::compare_keywords(DCKeywordList const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:compareKeywords", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:compareKeywords", &param1));
            if(!PyErr_Occurred())
            {
                DCKeywordList *param1_this = (DCKeywordList *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DCKeywordList, 1, "DCKeywordList.compareKeywords", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const DCKeywordList*)local_this)->compare_keywords(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "compareKeywords(const DCKeywordList this, const DCKeywordList other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCKeywordList_compare_keywords_17_comment =
    "C++ Interface:\n"
    "compareKeywords(const DCKeywordList this, const DCKeywordList other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCKeywordList::compare_keywords\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this list has the same keywords\n"
    "//               as the other list, false if some keywords differ.\n"
    "//               Order is not considered important.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCKeywordList_compare_keywords_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCField *DCKeywordList::downcast_to_DCField(void)
 *******************************************************************/
static PyObject *Dtool_DCKeywordList_downcast_to_DCField_22(PyObject *self, PyObject *args,PyObject *kwds) {
    DCKeywordList * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCKeywordList,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-DCField *DCKeywordList::downcast_to_DCField(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":downcastToDCField", key_word_list));
        else
            (PyArg_Parse(args, ":downcastToDCField"));
        if(!PyErr_Occurred())
        {
            DCField *return_value = (DCField *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCField,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCKeywordList.downcastToDCField() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "downcastToDCField(non-const DCKeywordList this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCKeywordList_downcast_to_DCField_22_comment =
    "C++ Interface:\n"
    "downcastToDCField(non-const DCKeywordList this)\n"
    "\n"
    "downcast from DCKeywordList to DCField\n"
    "";
#else
static const char * Dtool_DCKeywordList_downcast_to_DCField_22_comment = NULL;
#endif

int  Dtool_Init_DCKeywordList(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (DCKeywordList)");
       return -1;
}
inline void  * Dtool_UpcastInterface_DCKeywordList(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DCKeywordList)
    {
        printf("DCKeywordList ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DCKeywordList * local_this = (DCKeywordList *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DCKeywordList)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DCKeywordList(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DCKeywordList)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DCField 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline int DCField::get_number(void) const
 *******************************************************************/
static PyObject *Dtool_DCField_get_number_24(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DCField::get_number(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumber", key_word_list));
        else
            (PyArg_Parse(args, ":getNumber"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DCField*)local_this)->get_number();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumber(const DCField this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_get_number_24_comment =
    "C++ Interface:\n"
    "getNumber(const DCField this)\n"
    "\n"
    "// Filename: dcField.I\n"
    "// Created by:  drose (10Jan06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::get_number\n"
    "//       Access: Published\n"
    "//  Description: Returns a unique index number associated with this\n"
    "//               field.  This is defined implicitly when the .dc\n"
    "//               file(s) are read.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCField_get_number_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DCClass *DCField::get_class(void) const
 *******************************************************************/
static PyObject *Dtool_DCField_get_class_25(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline DCClass *DCField::get_class(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getClass", key_word_list));
        else
            (PyArg_Parse(args, ":getClass"));
        if(!PyErr_Occurred())
        {
            DCClass *return_value = ((const DCField*)local_this)->get_class();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCClass,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClass(const DCField this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_get_class_25_comment =
    "C++ Interface:\n"
    "getClass(const DCField this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::get_class\n"
    "//       Access: Published\n"
    "//  Description: Returns the DCClass pointer for the class that\n"
    "//               contains this field.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCField_get_class_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static DCField *DCField::get_field_from_number(int number)
 *******************************************************************/
static PyObject *Dtool_DCField_get_field_from_number_26(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static DCField *DCField::get_field_from_number(int number)
        int param0;
        static char * key_word_list[] = {(char *)"number", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getFieldFromNumber", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:getFieldFromNumber", &param0));
        if(!PyErr_Occurred())
        {
            DCField *return_value = DCField::get_field_from_number((int)param0);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCField,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFieldFromNumber(int number)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_get_field_from_number_26_comment =
    "C++ Interface:\n"
    "getFieldFromNumber(int number)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::get_field_from_number\n"
    "//       Access: Static, Published\n"
    "//  Description: Returns the DCField that matches the index number\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCField_get_field_from_number_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual DCField *DCField::as_field(void)
 * virtual DCField const *DCField::as_field(void) const
 *******************************************************************/
static PyObject *Dtool_DCField_as_field_27(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // -2 virtual DCField const *DCField::as_field(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":asField", key_word_list));
        else
            (PyArg_Parse(args, ":asField"));
        if(!PyErr_Occurred())
        {
            DCField const *return_value = ((const DCField*)local_this)->as_field();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCField,false, true);
            }
        }
        PyErr_Clear(); 
    }

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 virtual DCField *DCField::as_field(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":asField", key_word_list));
        else
            (PyArg_Parse(args, ":asField"));
        if(!PyErr_Occurred())
        {
            DCField *return_value = (local_this)->as_field();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCField,false, false);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "asField(const DCField this)\n"
          "asField(non-const DCField this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_as_field_27_comment =
    "C++ Interface:\n"
    "asField(const DCField this)\n"
    "asField(non-const DCField this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::as_field\n"
    "//       Access: Published, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::as_field\n"
    "//       Access: Published, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCField_as_field_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual DCAtomicField *DCField::as_atomic_field(void)
 * virtual DCAtomicField const *DCField::as_atomic_field(void) const
 *******************************************************************/
static PyObject *Dtool_DCField_as_atomic_field_28(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 virtual DCAtomicField *DCField::as_atomic_field(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":asAtomicField", key_word_list));
        else
            (PyArg_Parse(args, ":asAtomicField"));
        if(!PyErr_Occurred())
        {
            DCAtomicField *return_value = (local_this)->as_atomic_field();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCAtomicField,false, false);
            }
        }
        PyErr_Clear(); 
    }

    {
      // -2 virtual DCAtomicField const *DCField::as_atomic_field(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":asAtomicField", key_word_list));
        else
            (PyArg_Parse(args, ":asAtomicField"));
        if(!PyErr_Occurred())
        {
            DCAtomicField const *return_value = ((const DCField*)local_this)->as_atomic_field();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCAtomicField,false, true);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "asAtomicField(non-const DCField this)\n"
          "asAtomicField(const DCField this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_as_atomic_field_28_comment =
    "C++ Interface:\n"
    "asAtomicField(non-const DCField this)\n"
    "asAtomicField(const DCField this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::as_atomic_field\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns the same field pointer converted to an atomic\n"
    "//               field pointer, if this is in fact an atomic field;\n"
    "//               otherwise, returns NULL.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::as_atomic_field\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns the same field pointer converted to an atomic\n"
    "//               field pointer, if this is in fact an atomic field;\n"
    "//               otherwise, returns NULL.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCField_as_atomic_field_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual DCMolecularField *DCField::as_molecular_field(void)
 * virtual DCMolecularField const *DCField::as_molecular_field(void) const
 *******************************************************************/
static PyObject *Dtool_DCField_as_molecular_field_29(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // -2 virtual DCMolecularField const *DCField::as_molecular_field(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":asMolecularField", key_word_list));
        else
            (PyArg_Parse(args, ":asMolecularField"));
        if(!PyErr_Occurred())
        {
            DCMolecularField const *return_value = ((const DCField*)local_this)->as_molecular_field();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCMolecularField,false, true);
            }
        }
        PyErr_Clear(); 
    }

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 virtual DCMolecularField *DCField::as_molecular_field(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":asMolecularField", key_word_list));
        else
            (PyArg_Parse(args, ":asMolecularField"));
        if(!PyErr_Occurred())
        {
            DCMolecularField *return_value = (local_this)->as_molecular_field();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCMolecularField,false, false);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "asMolecularField(const DCField this)\n"
          "asMolecularField(non-const DCField this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_as_molecular_field_29_comment =
    "C++ Interface:\n"
    "asMolecularField(const DCField this)\n"
    "asMolecularField(non-const DCField this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::as_molecular_field\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns the same field pointer converted to a\n"
    "//               molecular field pointer, if this is in fact a\n"
    "//               molecular field; otherwise, returns NULL.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::as_molecular_field\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Returns the same field pointer converted to a\n"
    "//               molecular field pointer, if this is in fact a\n"
    "//               molecular field; otherwise, returns NULL.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCField_as_molecular_field_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual DCParameter *DCField::as_parameter(void)
 * virtual DCParameter const *DCField::as_parameter(void) const
 *******************************************************************/
static PyObject *Dtool_DCField_as_parameter_30(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // -2 virtual DCParameter const *DCField::as_parameter(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":asParameter", key_word_list));
        else
            (PyArg_Parse(args, ":asParameter"));
        if(!PyErr_Occurred())
        {
            DCParameter const *return_value = ((const DCField*)local_this)->as_parameter();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCParameter,false, true);
            }
        }
        PyErr_Clear(); 
    }

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 virtual DCParameter *DCField::as_parameter(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":asParameter", key_word_list));
        else
            (PyArg_Parse(args, ":asParameter"));
        if(!PyErr_Occurred())
        {
            DCParameter *return_value = (local_this)->as_parameter();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCParameter,false, false);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "asParameter(const DCField this)\n"
          "asParameter(non-const DCField this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_as_parameter_30_comment =
    "C++ Interface:\n"
    "asParameter(const DCField this)\n"
    "asParameter(non-const DCField this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::as_parameter\n"
    "//       Access: Published, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::as_parameter\n"
    "//       Access: Published, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCField_as_parameter_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DCField::format_data(basic_string< char > const &packed_data, bool show_field_names)
 * basic_string< char > DCField::format_data(basic_string< char > const &packed_data, bool show_field_names = (1))
 *******************************************************************/
static PyObject *Dtool_DCField_format_data_31(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-basic_string< char > DCField::format_data(basic_string< char > const &packed_data, bool show_field_names = (1))
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"packed_data", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:formatData", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:formatData", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                basic_string< char > return_value = (local_this)->format_data(basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DCField.formatData() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-basic_string< char > DCField::format_data(basic_string< char > const &packed_data, bool show_field_names)
            char *param1_str; int param1_len;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"packed_data", (char *)"show_field_names", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:formatData", key_word_list, &param1_str, &param1_len, &param2))
            {
                basic_string< char > return_value = (local_this)->format_data(basic_string<char>(param1_str, param1_len), (PyObject_IsTrue(param2)!=0));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DCField.formatData() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "formatData() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "formatData(non-const DCField this, string packed_data)\n"
          "formatData(non-const DCField this, string packed_data, bool show_field_names)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_format_data_31_comment =
    "C++ Interface:\n"
    "formatData(non-const DCField this, string packed_data)\n"
    "formatData(non-const DCField this, string packed_data, bool show_field_names)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::format_data\n"
    "//       Access: Published\n"
    "//  Description: Given a blob that represents the packed data for this\n"
    "//               field, returns a string formatting it for human\n"
    "//               consumption.  Returns empty string if there is an error.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCField_format_data_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DCField::parse_string(basic_string< char > const &formatted_string)
 *******************************************************************/
static PyObject *Dtool_DCField_parse_string_32(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-basic_string< char > DCField::parse_string(basic_string< char > const &formatted_string)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"formatted_string", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:parseString", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:parseString", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = (local_this)->parse_string(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCField.parseString() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "parseString(non-const DCField this, string formatted_string)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_parse_string_32_comment =
    "C++ Interface:\n"
    "parseString(non-const DCField this, string formatted_string)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::parse_string\n"
    "//       Access: Published\n"
    "//  Description: Given a human-formatted string (for instance, as\n"
    "//               returned by format_data(), above) that represents the\n"
    "//               value of this field, parse the string and return the\n"
    "//               corresponding packed data.  Returns empty string if\n"
    "//               there is an error.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCField_parse_string_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DCField::validate_ranges(basic_string< char > const &packed_data) const
 *******************************************************************/
static PyObject *Dtool_DCField_validate_ranges_33(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool DCField::validate_ranges(basic_string< char > const &packed_data) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"packed_data", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:validateRanges", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:validateRanges", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DCField*)local_this)->validate_ranges(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "validateRanges(const DCField this, string packed_data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_validate_ranges_33_comment =
    "C++ Interface:\n"
    "validateRanges(const DCField this, string packed_data)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::validate_ranges\n"
    "//       Access: Published\n"
    "//  Description: Verifies that all of the packed values in the field\n"
    "//               data are within the specified ranges and that there\n"
    "//               are no extra bytes on the end of the record.  Returns\n"
    "//               true if all fields are valid, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCField_validate_ranges_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DCField::has_default_value(void) const
 *******************************************************************/
static PyObject *Dtool_DCField_has_default_value_34(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DCField::has_default_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasDefaultValue", key_word_list));
        else
            (PyArg_Parse(args, ":hasDefaultValue"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DCField*)local_this)->has_default_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasDefaultValue(const DCField this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_has_default_value_34_comment =
    "C++ Interface:\n"
    "hasDefaultValue(const DCField this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::has_default_value\n"
    "//       Access: Published\n"
    "//  Description: Returns true if a default value has been explicitly\n"
    "//               established for this field, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCField_has_default_value_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &DCField::get_default_value(void) const
 *******************************************************************/
static PyObject *Dtool_DCField_get_default_value_35(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &DCField::get_default_value(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDefaultValue", key_word_list));
        else
            (PyArg_Parse(args, ":getDefaultValue"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const DCField*)local_this)->get_default_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDefaultValue(const DCField this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_get_default_value_35_comment =
    "C++ Interface:\n"
    "getDefaultValue(const DCField this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::get_default_value\n"
    "//       Access: Published\n"
    "//  Description: Returns the default value for this field.  If a\n"
    "//               default value has been explicitly set\n"
    "//               (e.g. has_default_value() returns true), returns that\n"
    "//               value; otherwise, returns an implicit default for the\n"
    "//               field.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCField_get_default_value_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DCField::is_bogus_field(void) const
 *******************************************************************/
static PyObject *Dtool_DCField_is_bogus_field_36(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DCField::is_bogus_field(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isBogusField", key_word_list));
        else
            (PyArg_Parse(args, ":isBogusField"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DCField*)local_this)->is_bogus_field();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isBogusField(const DCField this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_is_bogus_field_36_comment =
    "C++ Interface:\n"
    "isBogusField(const DCField this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::is_bogus_field\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the field has been flagged as a bogus\n"
    "//               field.  This is set for fields that are generated by\n"
    "//               the parser as placeholder for missing fields, as\n"
    "//               when reading a partial file; it should not occur in a\n"
    "//               normal valid dc file.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCField_is_bogus_field_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DCField::is_required(void) const
 *******************************************************************/
static PyObject *Dtool_DCField_is_required_37(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DCField::is_required(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isRequired", key_word_list));
        else
            (PyArg_Parse(args, ":isRequired"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DCField*)local_this)->is_required();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isRequired(const DCField this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_is_required_37_comment =
    "C++ Interface:\n"
    "isRequired(const DCField this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::is_required\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the \"required\" flag is set for this\n"
    "//               field, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCField_is_required_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DCField::is_broadcast(void) const
 *******************************************************************/
static PyObject *Dtool_DCField_is_broadcast_38(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DCField::is_broadcast(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isBroadcast", key_word_list));
        else
            (PyArg_Parse(args, ":isBroadcast"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DCField*)local_this)->is_broadcast();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isBroadcast(const DCField this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_is_broadcast_38_comment =
    "C++ Interface:\n"
    "isBroadcast(const DCField this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::is_broadcast\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the \"broadcast\" flag is set for this\n"
    "//               field, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCField_is_broadcast_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DCField::is_ram(void) const
 *******************************************************************/
static PyObject *Dtool_DCField_is_ram_39(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DCField::is_ram(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isRam", key_word_list));
        else
            (PyArg_Parse(args, ":isRam"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DCField*)local_this)->is_ram();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isRam(const DCField this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_is_ram_39_comment =
    "C++ Interface:\n"
    "isRam(const DCField this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::is_ram\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the \"ram\" flag is set for this\n"
    "//               field, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCField_is_ram_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DCField::is_db(void) const
 *******************************************************************/
static PyObject *Dtool_DCField_is_db_40(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DCField::is_db(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isDb", key_word_list));
        else
            (PyArg_Parse(args, ":isDb"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DCField*)local_this)->is_db();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isDb(const DCField this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_is_db_40_comment =
    "C++ Interface:\n"
    "isDb(const DCField this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::is_db\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the \"db\" flag is set for this\n"
    "//               field, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCField_is_db_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DCField::is_clsend(void) const
 *******************************************************************/
static PyObject *Dtool_DCField_is_clsend_41(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DCField::is_clsend(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isClsend", key_word_list));
        else
            (PyArg_Parse(args, ":isClsend"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DCField*)local_this)->is_clsend();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isClsend(const DCField this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_is_clsend_41_comment =
    "C++ Interface:\n"
    "isClsend(const DCField this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::is_clsend\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the \"clsend\" flag is set for this\n"
    "//               field, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCField_is_clsend_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DCField::is_clrecv(void) const
 *******************************************************************/
static PyObject *Dtool_DCField_is_clrecv_42(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DCField::is_clrecv(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isClrecv", key_word_list));
        else
            (PyArg_Parse(args, ":isClrecv"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DCField*)local_this)->is_clrecv();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isClrecv(const DCField this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_is_clrecv_42_comment =
    "C++ Interface:\n"
    "isClrecv(const DCField this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::is_clrecv\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the \"clrecv\" flag is set for this\n"
    "//               field, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCField_is_clrecv_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DCField::is_ownsend(void) const
 *******************************************************************/
static PyObject *Dtool_DCField_is_ownsend_43(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DCField::is_ownsend(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isOwnsend", key_word_list));
        else
            (PyArg_Parse(args, ":isOwnsend"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DCField*)local_this)->is_ownsend();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isOwnsend(const DCField this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_is_ownsend_43_comment =
    "C++ Interface:\n"
    "isOwnsend(const DCField this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::is_ownsend\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the \"ownsend\" flag is set for this\n"
    "//               field, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCField_is_ownsend_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DCField::is_ownrecv(void) const
 *******************************************************************/
static PyObject *Dtool_DCField_is_ownrecv_44(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DCField::is_ownrecv(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isOwnrecv", key_word_list));
        else
            (PyArg_Parse(args, ":isOwnrecv"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DCField*)local_this)->is_ownrecv();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isOwnrecv(const DCField this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_is_ownrecv_44_comment =
    "C++ Interface:\n"
    "isOwnrecv(const DCField this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::is_ownrecv\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the \"ownrecv\" flag is set for this\n"
    "//               field, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCField_is_ownrecv_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DCField::is_airecv(void) const
 *******************************************************************/
static PyObject *Dtool_DCField_is_airecv_45(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DCField::is_airecv(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isAirecv", key_word_list));
        else
            (PyArg_Parse(args, ":isAirecv"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DCField*)local_this)->is_airecv();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isAirecv(const DCField this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_is_airecv_45_comment =
    "C++ Interface:\n"
    "isAirecv(const DCField this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::is_airecv\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the \"airecv\" flag is set for this\n"
    "//               field, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCField_is_airecv_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DCField::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_DCField_output_46(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline void DCField::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DCField.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const DCField*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const DCField this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_output_46_comment =
    "C++ Interface:\n"
    "output(const DCField this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : DCField::output\n"
    "//       Access : Published\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCField_output_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DCField::write(ostream &out, int indent_level) const
 *******************************************************************/
static PyObject *Dtool_DCField_write_47(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline void DCField::write(ostream &out, int indent_level) const
            PyObject *param1;
            int param2;
            static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DCField.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const DCField*)local_this)->write(*param1_this, (int)param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const DCField this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_write_47_comment =
    "C++ Interface:\n"
    "write(const DCField this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : DCField::\n"
    "//       Access : Published\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCField_write_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DCField::pack_args(DCPacker &packer, PyObject *sequence) const
 *******************************************************************/
static PyObject *Dtool_DCField_pack_args_48(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool DCField::pack_args(DCPacker &packer, PyObject *sequence) const
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"packer", (char *)"sequence", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:packArgs", key_word_list, &param1, &param2))
            {
                DCPacker *param1_this = (DCPacker *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DCPacker, 1, "DCField.packArgs", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const DCField*)local_this)->pack_args(*param1_this, param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "packArgs(const DCField this, non-const DCPacker packer, any sequence)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_pack_args_48_comment =
    "C++ Interface:\n"
    "packArgs(const DCField this, non-const DCPacker packer, any sequence)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::pack_args\n"
    "//       Access: Published\n"
    "//  Description: Packs the Python arguments from the indicated tuple\n"
    "//               into the packer.  Returns true on success, false on\n"
    "//               failure.\n"
    "//\n"
    "//               It is assumed that the packer is currently positioned\n"
    "//               on this field.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCField_pack_args_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PyObject *DCField::unpack_args(DCPacker &packer) const
 *******************************************************************/
static PyObject *Dtool_DCField_unpack_args_49(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-PyObject *DCField::unpack_args(DCPacker &packer) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"packer", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:unpackArgs", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:unpackArgs", &param1));
            if(!PyErr_Occurred())
            {
                DCPacker *param1_this = (DCPacker *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DCPacker, 1, "DCField.unpackArgs", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    PyObject *return_value = ((const DCField*)local_this)->unpack_args(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return  return_value;
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unpackArgs(const DCField this, non-const DCPacker packer)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_unpack_args_49_comment =
    "C++ Interface:\n"
    "unpackArgs(const DCField this, non-const DCPacker packer)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::unpack_args\n"
    "//       Access: Published\n"
    "//  Description: Unpacks the values from the packer, beginning at\n"
    "//               the current point in the unpack_buffer, into a Python\n"
    "//               tuple and returns the tuple.\n"
    "//\n"
    "//               It is assumed that the packer is currently positioned\n"
    "//               on this field.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCField_unpack_args_49_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DCField::receive_update(DCPacker &packer, PyObject *distobj) const
 *******************************************************************/
static PyObject *Dtool_DCField_receive_update_50(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void DCField::receive_update(DCPacker &packer, PyObject *distobj) const
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"packer", (char *)"distobj", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:receiveUpdate", key_word_list, &param1, &param2))
            {
                DCPacker *param1_this = (DCPacker *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DCPacker, 1, "DCField.receiveUpdate", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const DCField*)local_this)->receive_update(*param1_this, param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "receiveUpdate(const DCField this, non-const DCPacker packer, any distobj)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_receive_update_50_comment =
    "C++ Interface:\n"
    "receiveUpdate(const DCField this, non-const DCPacker packer, any distobj)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::receive_update\n"
    "//       Access: Published\n"
    "//  Description: Extracts the update message out of the datagram and\n"
    "//               applies it to the indicated object by calling the\n"
    "//               appropriate method.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCField_receive_update_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Datagram DCField::client_format_update(unsigned int do_id, PyObject *args) const
 *******************************************************************/
static PyObject *Dtool_DCField_client_format_update_51(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-Datagram DCField::client_format_update(unsigned int do_id, PyObject *args) const
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"do_id", (char *)"args", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:clientFormatUpdate", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                Datagram result = ((const DCField*)local_this)->client_format_update(PyLong_AsUnsignedLong(param1_uint), param2);
                Datagram *return_value = new Datagram(result);
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Datagram,true, false, (return_value)->as_typed_object()->get_type_index());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clientFormatUpdate(const DCField this, unsigned int do_id, any args)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_client_format_update_51_comment =
    "C++ Interface:\n"
    "clientFormatUpdate(const DCField this, unsigned int do_id, any args)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::client_format_update\n"
    "//       Access: Published\n"
    "//  Description: Generates a datagram containing the message necessary\n"
    "//               to send an update for the indicated distributed\n"
    "//               object from the client.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCField_client_format_update_51_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Datagram DCField::ai_format_update(unsigned int do_id, unsigned __int64 to_id, unsigned __int64 from_id, PyObject *args) const
 *******************************************************************/
static PyObject *Dtool_DCField_ai_format_update_52(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-Datagram DCField::ai_format_update(unsigned int do_id, unsigned __int64 to_id, unsigned __int64 from_id, PyObject *args) const
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        static char * key_word_list[] = {(char *)"do_id", (char *)"to_id", (char *)"from_id", (char *)"args", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOO:aiFormatUpdate", key_word_list, &param1, &param2, &param3, &param4))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_long = PyNumber_Long(param2); PyObject *param3_long = PyNumber_Long(param3);
            if (!((param1_uint == NULL)|| (param2_long == NULL)|| (param3_long == NULL)))
            {
                Datagram result = ((const DCField*)local_this)->ai_format_update(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLongLong(param2_long), PyLong_AsUnsignedLongLong(param3_long), param4);
                Datagram *return_value = new Datagram(result);
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_long); Py_XDECREF(param3_long);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Datagram,true, false, (return_value)->as_typed_object()->get_type_index());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "aiFormatUpdate(const DCField this, unsigned int do_id, unsigned long long to_id, unsigned long long from_id, any args)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_ai_format_update_52_comment =
    "C++ Interface:\n"
    "aiFormatUpdate(const DCField this, unsigned int do_id, unsigned long long to_id, unsigned long long from_id, any args)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::ai_format_update\n"
    "//       Access: Published\n"
    "//  Description: Generates a datagram containing the message necessary\n"
    "//               to send an update for the indicated distributed\n"
    "//               object from the AI.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCField_ai_format_update_52_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Datagram DCField::ai_format_update_msg_type(unsigned int do_id, unsigned __int64 to_id, unsigned __int64 from_id, int msg_type, PyObject *args) const
 *******************************************************************/
static PyObject *Dtool_DCField_ai_format_update_msg_type_53(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-Datagram DCField::ai_format_update_msg_type(unsigned int do_id, unsigned __int64 to_id, unsigned __int64 from_id, int msg_type, PyObject *args) const
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        int param4;
        PyObject *param5;
        static char * key_word_list[] = {(char *)"do_id", (char *)"to_id", (char *)"from_id", (char *)"msg_type", (char *)"args", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOiO:aiFormatUpdateMsgType", key_word_list, &param1, &param2, &param3, &param4, &param5))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_long = PyNumber_Long(param2); PyObject *param3_long = PyNumber_Long(param3);
            if (!((param1_uint == NULL)|| (param2_long == NULL)|| (param3_long == NULL)))
            {
                Datagram result = ((const DCField*)local_this)->ai_format_update_msg_type(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLongLong(param2_long), PyLong_AsUnsignedLongLong(param3_long), (int)param4, param5);
                Datagram *return_value = new Datagram(result);
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_long); Py_XDECREF(param3_long);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Datagram,true, false, (return_value)->as_typed_object()->get_type_index());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "aiFormatUpdateMsgType(const DCField this, unsigned int do_id, unsigned long long to_id, unsigned long long from_id, int msg_type, any args)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_ai_format_update_msg_type_53_comment =
    "C++ Interface:\n"
    "aiFormatUpdateMsgType(const DCField this, unsigned int do_id, unsigned long long to_id, unsigned long long from_id, int msg_type, any args)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCField::ai_format_update_msg_type\n"
    "//       Access: Published\n"
    "//  Description: Generates a datagram containing the message necessary\n"
    "//               to send an update, with the msg type,\n"
    "//               for the indicated distributed\n"
    "//               object from the AI.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCField_ai_format_update_msg_type_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCPackerInterface *DCField::upcast_to_DCPackerInterface(void)
 *******************************************************************/
static PyObject *Dtool_DCField_upcast_to_DCPackerInterface_19(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-DCPackerInterface *DCField::upcast_to_DCPackerInterface(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToDCPackerInterface", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToDCPackerInterface"));
        if(!PyErr_Occurred())
        {
            DCPackerInterface *return_value = (DCPackerInterface *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCPackerInterface,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCField.upcastToDCPackerInterface() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToDCPackerInterface(non-const DCField this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_upcast_to_DCPackerInterface_19_comment =
    "C++ Interface:\n"
    "upcastToDCPackerInterface(non-const DCField this)\n"
    "\n"
    "upcast from DCField to DCPackerInterface\n"
    "";
#else
static const char * Dtool_DCField_upcast_to_DCPackerInterface_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCKeywordList *DCField::upcast_to_DCKeywordList(void)
 *******************************************************************/
static PyObject *Dtool_DCField_upcast_to_DCKeywordList_21(PyObject *self, PyObject *args,PyObject *kwds) {
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-DCKeywordList *DCField::upcast_to_DCKeywordList(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToDCKeywordList", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToDCKeywordList"));
        if(!PyErr_Occurred())
        {
            DCKeywordList *return_value = (DCKeywordList *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCKeywordList,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCField.upcastToDCKeywordList() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToDCKeywordList(non-const DCField this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCField_upcast_to_DCKeywordList_21_comment =
    "C++ Interface:\n"
    "upcastToDCKeywordList(non-const DCField this)\n"
    "\n"
    "upcast from DCField to DCKeywordList\n"
    "";
#else
static const char * Dtool_DCField_upcast_to_DCKeywordList_21_comment = NULL;
#endif

int  Dtool_Init_DCField(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (DCField)");
       return -1;
}
inline void  * Dtool_UpcastInterface_DCField(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DCField)
    {
        printf("DCField ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DCField * local_this = (DCField *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DCField)
        return local_this;
    if(requested_type == &Dtool_DCKeywordList)
        return ( DCKeywordList *) local_this;
    if(requested_type == &Dtool_DCPackerInterface)
        return ( DCPackerInterface *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DCField(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DCField)
        return from_this;
    if(from_type == &Dtool_DCKeywordList)
    {
          DCKeywordList* other_this = (DCKeywordList*)from_this;
          return (DCField*)other_this;
    }
    if(from_type == &Dtool_DCPackerInterface)
    {
          DCPackerInterface* other_this = (DCPackerInterface*)from_this;
          return (DCField*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DCPackData 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DCPackData::clear(void)
 *******************************************************************/
static PyObject *Dtool_DCPackData_clear_57(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPackData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPackData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DCPackData::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPackData.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const DCPackData this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPackData_clear_57_comment =
    "C++ Interface:\n"
    "clear(non-const DCPackData this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPackData::clear\n"
    "//       Access: Published\n"
    "//  Description: Empties the contents of the data (without necessarily\n"
    "//               freeing its allocated memory).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPackData_clear_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DCPackData::get_string(void) const
 *******************************************************************/
static PyObject *Dtool_DCPackData_get_string_58(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPackData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPackData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > DCPackData::get_string(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getString", key_word_list));
        else
            (PyArg_Parse(args, ":getString"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DCPackData*)local_this)->get_string();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getString(const DCPackData this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPackData_get_string_58_comment =
    "C++ Interface:\n"
    "getString(const DCPackData this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPackData::get_string\n"
    "//       Access: Published\n"
    "//  Description: Returns the data buffer as a string.  Also see\n"
    "//               get_data().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPackData_get_string_58_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int DCPackData::get_length(void) const
 *******************************************************************/
static PyObject *Dtool_DCPackData_get_length_59(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPackData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPackData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int DCPackData::get_length(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLength", key_word_list));
        else
            (PyArg_Parse(args, ":getLength"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const DCPackData*)local_this)->get_length();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLength(const DCPackData this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPackData_get_length_59_comment =
    "C++ Interface:\n"
    "getLength(const DCPackData this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPackData::get_length\n"
    "//       Access: Published\n"
    "//  Description: Returns the current length of the buffer.  This is\n"
    "//               the number of useful bytes stored in the buffer, not\n"
    "//               the amount of memory it takes up.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPackData_get_length_59_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DCPackData::DCPackData(void)
 *******************************************************************/
int  Dtool_Init_DCPackData(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline DCPackData::DCPackData(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":DCPackData", key_word_list))
        {
            DCPackData *return_value = new DCPackData();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DCPackData,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DCPackData()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DCPackData(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DCPackData)
    {
        printf("DCPackData ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DCPackData * local_this = (DCPackData *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DCPackData)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DCPackData(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DCPackData)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DCPacker 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DCPacker::clear_data(void)
 *******************************************************************/
static PyObject *Dtool_DCPacker_clear_data_63(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DCPacker::clear_data(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearData", key_word_list));
        else
            (PyArg_Parse(args, ":clearData"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_data();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.clearData() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearData(non-const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_clear_data_63_comment =
    "C++ Interface:\n"
    "clearData(non-const DCPacker this)\n"
    "\n"
    "// Filename: dcPacker.I\n"
    "// Created by:  drose (15Jun04)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::clear_data\n"
    "//       Access: Published\n"
    "//  Description: Empties the data in the pack buffer and unpack\n"
    "//               buffer.  This should be called between calls to\n"
    "//               begin_pack(), unless you want to concatenate all of\n"
    "//               the pack results together.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_clear_data_63_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DCPacker::begin_pack(DCPackerInterface const *root)
 *******************************************************************/
static PyObject *Dtool_DCPacker_begin_pack_64(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DCPacker::begin_pack(DCPackerInterface const *root)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"root", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:beginPack", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:beginPack", &param1));
            if(!PyErr_Occurred())
            {
                DCPackerInterface *param1_this = (DCPackerInterface *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DCPackerInterface, 1, "DCPacker.beginPack", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->begin_pack(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DCPacker.beginPack() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "beginPack(non-const DCPacker this, const DCPackerInterface root)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_begin_pack_64_comment =
    "C++ Interface:\n"
    "beginPack(non-const DCPacker this, const DCPackerInterface root)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::begin_pack\n"
    "//       Access: Published\n"
    "//  Description: Begins a packing session.  The parameter is the DC\n"
    "//               object that describes the packing format; it may be a\n"
    "//               DCParameter or DCField.\n"
    "//\n"
    "//               Unless you call clear_data() between sessions,\n"
    "//               multiple packing sessions will be concatenated\n"
    "//               together into the same buffer.  If you wish to add\n"
    "//               bytes to the buffer between packing sessions, use\n"
    "//               append_data() or get_write_pointer().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_begin_pack_64_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DCPacker::end_pack(void)
 *******************************************************************/
static PyObject *Dtool_DCPacker_end_pack_65(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool DCPacker::end_pack(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":endPack", key_word_list));
        else
            (PyArg_Parse(args, ":endPack"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->end_pack();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.endPack() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "endPack(non-const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_end_pack_65_comment =
    "C++ Interface:\n"
    "endPack(non-const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::end_pack\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Finishes a packing session.\n"
    "//\n"
    "//               The return value is true on success, or false if\n"
    "//               there has been some error during packing.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_end_pack_65_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DCPacker::set_unpack_data(basic_string< char > const &data)
 *******************************************************************/
static PyObject *Dtool_DCPacker_set_unpack_data_66(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DCPacker::set_unpack_data(basic_string< char > const &data)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"data", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setUnpackData", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setUnpackData", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_unpack_data(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.setUnpackData() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setUnpackData(non-const DCPacker this, string data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_set_unpack_data_66_comment =
    "C++ Interface:\n"
    "setUnpackData(non-const DCPacker this, string data)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::set_unpack_data\n"
    "//       Access: Public\n"
    "//  Description: Sets up the unpack_data pointer.  You may call this\n"
    "//               before calling the version of begin_unpack() that\n"
    "//               takes only one parameter.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::set_unpack_data\n"
    "//       Access: Public\n"
    "//  Description: Sets up the unpack_data pointer.  You may call this\n"
    "//               before calling the version of begin_unpack() that\n"
    "//               takes only one parameter.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_set_unpack_data_66_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DCPacker::begin_unpack(DCPackerInterface const *root)
 *******************************************************************/
static PyObject *Dtool_DCPacker_begin_unpack_67(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DCPacker::begin_unpack(DCPackerInterface const *root)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"root", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:beginUnpack", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:beginUnpack", &param1));
            if(!PyErr_Occurred())
            {
                DCPackerInterface *param1_this = (DCPackerInterface *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DCPackerInterface, 1, "DCPacker.beginUnpack", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->begin_unpack(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DCPacker.beginUnpack() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "beginUnpack(non-const DCPacker this, const DCPackerInterface root)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_begin_unpack_67_comment =
    "C++ Interface:\n"
    "beginUnpack(non-const DCPacker this, const DCPackerInterface root)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::begin_unpack\n"
    "//       Access: Public\n"
    "//  Description: Begins an unpacking session.  You must have\n"
    "//               previously called set_unpack_data() to specify a\n"
    "//               buffer to unpack.\n"
    "//\n"
    "//               If there was data left in the buffer after a previous\n"
    "//               begin_unpack() .. end_unpack() session, the new\n"
    "//               session will resume from the current point.  This\n"
    "//               method may be used, therefore, to unpack a sequence\n"
    "//               of objects from the same buffer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_begin_unpack_67_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DCPacker::end_unpack(void)
 *******************************************************************/
static PyObject *Dtool_DCPacker_end_unpack_68(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool DCPacker::end_unpack(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":endUnpack", key_word_list));
        else
            (PyArg_Parse(args, ":endUnpack"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->end_unpack();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.endUnpack() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "endUnpack(non-const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_end_unpack_68_comment =
    "C++ Interface:\n"
    "endUnpack(non-const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::end_unpack\n"
    "//       Access: Published\n"
    "//  Description: Finishes the unpacking session.\n"
    "//\n"
    "//               The return value is true on success, or false if\n"
    "//               there has been some error during unpacking (or if all\n"
    "//               fields have not been unpacked).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_end_unpack_68_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DCPacker::begin_repack(DCPackerInterface const *root)
 *******************************************************************/
static PyObject *Dtool_DCPacker_begin_repack_69(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DCPacker::begin_repack(DCPackerInterface const *root)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"root", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:beginRepack", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:beginRepack", &param1));
            if(!PyErr_Occurred())
            {
                DCPackerInterface *param1_this = (DCPackerInterface *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DCPackerInterface, 1, "DCPacker.beginRepack", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->begin_repack(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DCPacker.beginRepack() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "beginRepack(non-const DCPacker this, const DCPackerInterface root)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_begin_repack_69_comment =
    "C++ Interface:\n"
    "beginRepack(non-const DCPacker this, const DCPackerInterface root)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::begin_repack\n"
    "//       Access: Public\n"
    "//  Description: Begins a repacking session.  You must have previously\n"
    "//               called set_unpack_data() to specify a buffer to\n"
    "//               unpack.\n"
    "//\n"
    "//               Unlike begin_pack() or begin_unpack() you may not\n"
    "//               concatenate the results of multiple begin_repack()\n"
    "//               sessions in one buffer.\n"
    "//\n"
    "//               Also, unlike in packing or unpacking modes, you may\n"
    "//               not walk through the fields from beginning to end, or\n"
    "//               even pack two consecutive fields at once.  Instead,\n"
    "//               you must call seek() for each field you wish to\n"
    "//               modify and pack only that one field; then call seek()\n"
    "//               again to modify another field.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_begin_repack_69_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DCPacker::end_repack(void)
 *******************************************************************/
static PyObject *Dtool_DCPacker_end_repack_70(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool DCPacker::end_repack(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":endRepack", key_word_list));
        else
            (PyArg_Parse(args, ":endRepack"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->end_repack();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.endRepack() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "endRepack(non-const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_end_repack_70_comment =
    "C++ Interface:\n"
    "endRepack(non-const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::end_repack\n"
    "//       Access: Published\n"
    "//  Description: Finishes the repacking session.\n"
    "//\n"
    "//               The return value is true on success, or false if\n"
    "//               there has been some error during repacking (or if all\n"
    "//               fields have not been repacked).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_end_repack_70_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DCPacker::seek(basic_string< char > const &field_name)
 * bool DCPacker::seek(int seek_index)
 *******************************************************************/
static PyObject *Dtool_DCPacker_seek_71(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 bool DCPacker::seek(basic_string< char > const &field_name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"field_name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:seek", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:seek", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->seek(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
        PyErr_Clear(); 
    }

    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 bool DCPacker::seek(int seek_index)
        int param1;
        static char * key_word_list[] = {(char *)"seek_index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:seek", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:seek", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->seek((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "seek(non-const DCPacker this, string field_name)\n"
          "seek(non-const DCPacker this, int seek_index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_seek_71_comment =
    "C++ Interface:\n"
    "seek(non-const DCPacker this, string field_name)\n"
    "seek(non-const DCPacker this, int seek_index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::seek\n"
    "//       Access: Published\n"
    "//  Description: Sets the current unpack (or repack) position to the\n"
    "//               named field.  In unpack mode, the next call to\n"
    "//               unpack_*() or push() will begin to read the named\n"
    "//               field.  In repack mode, the next call to pack_*() or\n"
    "//               push() will modify the named field.\n"
    "//\n"
    "//               Returns true if successful, false if the field is not\n"
    "//               known (or if the packer is in an invalid mode).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::seek\n"
    "//       Access: Published\n"
    "//  Description: Seeks to the field indentified by seek_index, which\n"
    "//               was returned by an earlier call to\n"
    "//               DCField::find_seek_index() to get the index of some\n"
    "//               nested field.  Also see the version of seek() that\n"
    "//               accepts a field name.\n"
    "//\n"
    "//               Returns true if successful, false if the field is not\n"
    "//               known (or if the packer is in an invalid mode).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_seek_71_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DCPacker::has_nested_fields(void) const
 *******************************************************************/
static PyObject *Dtool_DCPacker_has_nested_fields_72(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DCPacker::has_nested_fields(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasNestedFields", key_word_list));
        else
            (PyArg_Parse(args, ":hasNestedFields"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DCPacker*)local_this)->has_nested_fields();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasNestedFields(const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_has_nested_fields_72_comment =
    "C++ Interface:\n"
    "hasNestedFields(const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::has_nested_fields\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the current field has any nested\n"
    "//               fields (and thus expects a push() .. pop()\n"
    "//               interface), or false otherwise.  If this returns\n"
    "//               true, get_num_nested_fields() may be called to\n"
    "//               determine how many nested fields are expected.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_has_nested_fields_72_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DCPacker::get_num_nested_fields(void) const
 *******************************************************************/
static PyObject *Dtool_DCPacker_get_num_nested_fields_73(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DCPacker::get_num_nested_fields(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumNestedFields", key_word_list));
        else
            (PyArg_Parse(args, ":getNumNestedFields"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DCPacker*)local_this)->get_num_nested_fields();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumNestedFields(const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_get_num_nested_fields_73_comment =
    "C++ Interface:\n"
    "getNumNestedFields(const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::get_num_nested_fields\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of nested fields associated with\n"
    "//               the current field, if has_nested_fields() returned\n"
    "//               true.\n"
    "//\n"
    "//               The return value may be -1 to indicate that a\n"
    "//               variable number of nested fields are accepted by this\n"
    "//               field type (e.g. a variable-length array).\n"
    "//\n"
    "//               Note that this method is unreliable to determine how\n"
    "//               many fields you must traverse before you can call\n"
    "//               pop(), since particularly in the presence of a\n"
    "//               DCSwitch, it may change during traversal.  Use\n"
    "//               more_nested_fields() instead.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_get_num_nested_fields_73_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DCPacker::more_nested_fields(void) const
 *******************************************************************/
static PyObject *Dtool_DCPacker_more_nested_fields_74(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DCPacker::more_nested_fields(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":moreNestedFields", key_word_list));
        else
            (PyArg_Parse(args, ":moreNestedFields"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DCPacker*)local_this)->more_nested_fields();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "moreNestedFields(const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_more_nested_fields_74_comment =
    "C++ Interface:\n"
    "moreNestedFields(const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::more_nested_fields\n"
    "//       Access: Published\n"
    "//  Description: Returns true if there are more nested fields to pack\n"
    "//               or unpack in the current push sequence, false if it\n"
    "//               is time to call pop().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_more_nested_fields_74_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DCPackerInterface const *DCPacker::get_current_parent(void) const
 *******************************************************************/
static PyObject *Dtool_DCPacker_get_current_parent_75(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline DCPackerInterface const *DCPacker::get_current_parent(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCurrentParent", key_word_list));
        else
            (PyArg_Parse(args, ":getCurrentParent"));
        if(!PyErr_Occurred())
        {
            DCPackerInterface const *return_value = ((const DCPacker*)local_this)->get_current_parent();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCPackerInterface,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCurrentParent(const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_get_current_parent_75_comment =
    "C++ Interface:\n"
    "getCurrentParent(const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::get_current_parent\n"
    "//       Access: Published\n"
    "//  Description: Returns the field that we left in our last call to\n"
    "//               push(): the owner of the current level of fields.\n"
    "//               This may be NULL at the beginning of the pack\n"
    "//               operation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_get_current_parent_75_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DCPackerInterface const *DCPacker::get_current_field(void) const
 *******************************************************************/
static PyObject *Dtool_DCPacker_get_current_field_76(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline DCPackerInterface const *DCPacker::get_current_field(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCurrentField", key_word_list));
        else
            (PyArg_Parse(args, ":getCurrentField"));
        if(!PyErr_Occurred())
        {
            DCPackerInterface const *return_value = ((const DCPacker*)local_this)->get_current_field();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCPackerInterface,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCurrentField(const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_get_current_field_76_comment =
    "C++ Interface:\n"
    "getCurrentField(const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::get_current_field\n"
    "//       Access: Published\n"
    "//  Description: Returns the field that will be referenced by the next\n"
    "//               call to pack_*() or unpack_*().  This will be NULL if\n"
    "//               we have unpacked (or packed) all fields, or if it is\n"
    "//               time to call pop().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_get_current_field_76_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DCSwitchParameter const *DCPacker::get_last_switch(void) const
 *******************************************************************/
static PyObject *Dtool_DCPacker_get_last_switch_77(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline DCSwitchParameter const *DCPacker::get_last_switch(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLastSwitch", key_word_list));
        else
            (PyArg_Parse(args, ":getLastSwitch"));
        if(!PyErr_Occurred())
        {
            DCSwitchParameter const *return_value = ((const DCPacker*)local_this)->get_last_switch();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCSwitchParameter,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLastSwitch(const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_get_last_switch_77_comment =
    "C++ Interface:\n"
    "getLastSwitch(const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::get_last_switch\n"
    "//       Access: Published\n"
    "//  Description: Returns a pointer to the last DCSwitch instance that\n"
    "//               we have passed by and selected one case of during the\n"
    "//               pack/unpack process.  Each time we encounter a new\n"
    "//               DCSwitch and select a case, this will change state.\n"
    "//\n"
    "//               This may be used to detect when a DCSwitch has been\n"
    "//               selected.  At the moment this changes state,\n"
    "//               get_current_parent() will contain the particular\n"
    "//               SwitchCase that was selected by the switch.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_get_last_switch_77_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DCPackType DCPacker::get_pack_type(void) const
 *******************************************************************/
static PyObject *Dtool_DCPacker_get_pack_type_78(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline DCPackType DCPacker::get_pack_type(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPackType", key_word_list));
        else
            (PyArg_Parse(args, ":getPackType"));
        if(!PyErr_Occurred())
        {
            DCPackType return_value = ((const DCPacker*)local_this)->get_pack_type();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPackType(const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_get_pack_type_78_comment =
    "C++ Interface:\n"
    "getPackType(const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::get_pack_type\n"
    "//       Access: Published\n"
    "//  Description: Returns the type of value expected by the current\n"
    "//               field.  See the enumerated type definition at the top\n"
    "//               of DCPackerInterface.h.  If this returns one of\n"
    "//               PT_double, PT_int, PT_int64, or PT_string, then you\n"
    "//               should call the corresponding pack_double(),\n"
    "//               pack_int() function (or unpack_double(),\n"
    "//               unpack_int(), etc.) to transfer data.  Otherwise, you\n"
    "//               should call push() and begin packing or unpacking the\n"
    "//               nested fields.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_get_pack_type_78_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DCPacker::get_current_field_name(void) const
 *******************************************************************/
static PyObject *Dtool_DCPacker_get_current_field_name_79(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > DCPacker::get_current_field_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCurrentFieldName", key_word_list));
        else
            (PyArg_Parse(args, ":getCurrentFieldName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DCPacker*)local_this)->get_current_field_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCurrentFieldName(const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_get_current_field_name_79_comment =
    "C++ Interface:\n"
    "getCurrentFieldName(const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::get_current_field_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the name of the current field, if it has a\n"
    "//               name, or the empty string if the field does not have\n"
    "//               a name or there is no current field.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_get_current_field_name_79_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DCPacker::push(void)
 *******************************************************************/
static PyObject *Dtool_DCPacker_push_80(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DCPacker::push(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":push", key_word_list));
        else
            (PyArg_Parse(args, ":push"));
        if(!PyErr_Occurred())
        {
            (local_this)->push();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.push() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "push(non-const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_push_80_comment =
    "C++ Interface:\n"
    "push(non-const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::push\n"
    "//       Access: Published\n"
    "//  Description: Marks the beginning of a nested series of fields.\n"
    "//\n"
    "//               This must be called before filling the elements of an\n"
    "//               array or the individual fields in a structure field.\n"
    "//               It must also be balanced by a matching pop().\n"
    "//\n"
    "//               It is necessary to use push() / pop() only if\n"
    "//               has_nested_fields() returns true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_push_80_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DCPacker::pop(void)
 *******************************************************************/
static PyObject *Dtool_DCPacker_pop_81(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DCPacker::pop(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":pop", key_word_list));
        else
            (PyArg_Parse(args, ":pop"));
        if(!PyErr_Occurred())
        {
            (local_this)->pop();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.pop() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "pop(non-const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_pop_81_comment =
    "C++ Interface:\n"
    "pop(non-const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::pop\n"
    "//       Access: Published\n"
    "//  Description: Marks the end of a nested series of fields.\n"
    "//\n"
    "//               This must be called to match a previous push() only\n"
    "//               after all the expected number of nested fields have\n"
    "//               been packed.  It is an error to call it too early, or\n"
    "//               too late.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_pop_81_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DCPacker::pack_double(double value)
 *******************************************************************/
static PyObject *Dtool_DCPacker_pack_double_82(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DCPacker::pack_double(double value)
        double param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:packDouble", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:packDouble", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->pack_double((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.packDouble() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "packDouble(non-const DCPacker this, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_pack_double_82_comment =
    "C++ Interface:\n"
    "packDouble(non-const DCPacker this, float value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::pack_double\n"
    "//       Access: Published\n"
    "//  Description: Packs the indicated numeric or string value into the\n"
    "//               stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_pack_double_82_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DCPacker::pack_int(int value)
 *******************************************************************/
static PyObject *Dtool_DCPacker_pack_int_83(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DCPacker::pack_int(int value)
        int param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:packInt", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:packInt", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->pack_int((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.packInt() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "packInt(non-const DCPacker this, int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_pack_int_83_comment =
    "C++ Interface:\n"
    "packInt(non-const DCPacker this, int value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::pack_int\n"
    "//       Access: Published\n"
    "//  Description: Packs the indicated numeric or string value into the\n"
    "//               stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_pack_int_83_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DCPacker::pack_uint(unsigned int value)
 *******************************************************************/
static PyObject *Dtool_DCPacker_pack_uint_84(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DCPacker::pack_uint(unsigned int value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:packUint", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:packUint", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->pack_uint(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.packUint() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "packUint(non-const DCPacker this, unsigned int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_pack_uint_84_comment =
    "C++ Interface:\n"
    "packUint(non-const DCPacker this, unsigned int value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::pack_uint\n"
    "//       Access: Published\n"
    "//  Description: Packs the indicated numeric or string value into the\n"
    "//               stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_pack_uint_84_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DCPacker::pack_int64(__int64 value)
 *******************************************************************/
static PyObject *Dtool_DCPacker_pack_int64_85(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DCPacker::pack_int64(__int64 value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:packInt64", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:packInt64", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_long = PyNumber_Long(param1);
            if (!((param1_long == NULL)))
            {
                (local_this)->pack_int64(PyLong_AsLongLong(param1_long));
                 Py_XDECREF(param1_long);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.packInt64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "packInt64(non-const DCPacker this, long long value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_pack_int64_85_comment =
    "C++ Interface:\n"
    "packInt64(non-const DCPacker this, long long value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::pack_int64\n"
    "//       Access: Published\n"
    "//  Description: Packs the indicated numeric or string value into the\n"
    "//               stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_pack_int64_85_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DCPacker::pack_uint64(unsigned __int64 value)
 *******************************************************************/
static PyObject *Dtool_DCPacker_pack_uint64_86(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DCPacker::pack_uint64(unsigned __int64 value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:packUint64", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:packUint64", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_long = PyNumber_Long(param1);
            if (!((param1_long == NULL)))
            {
                (local_this)->pack_uint64(PyLong_AsUnsignedLongLong(param1_long));
                 Py_XDECREF(param1_long);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.packUint64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "packUint64(non-const DCPacker this, unsigned long long value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_pack_uint64_86_comment =
    "C++ Interface:\n"
    "packUint64(non-const DCPacker this, unsigned long long value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::pack_uint64\n"
    "//       Access: Published\n"
    "//  Description: Packs the indicated numeric or string value into the\n"
    "//               stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_pack_uint64_86_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DCPacker::pack_string(basic_string< char > const &value)
 *******************************************************************/
static PyObject *Dtool_DCPacker_pack_string_87(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DCPacker::pack_string(basic_string< char > const &value)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:packString", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:packString", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->pack_string(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.packString() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "packString(non-const DCPacker this, string value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_pack_string_87_comment =
    "C++ Interface:\n"
    "packString(non-const DCPacker this, string value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::pack_string\n"
    "//       Access: Published\n"
    "//  Description: Packs the indicated numeric or string value into the\n"
    "//               stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_pack_string_87_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DCPacker::pack_literal_value(basic_string< char > const &value)
 *******************************************************************/
static PyObject *Dtool_DCPacker_pack_literal_value_88(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DCPacker::pack_literal_value(basic_string< char > const &value)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:packLiteralValue", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:packLiteralValue", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->pack_literal_value(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.packLiteralValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "packLiteralValue(non-const DCPacker this, string value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_pack_literal_value_88_comment =
    "C++ Interface:\n"
    "packLiteralValue(non-const DCPacker this, string value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::pack_literal_value\n"
    "//       Access: Published\n"
    "//  Description: Adds the indicated string value into the stream,\n"
    "//               representing a single pre-packed field element, or a\n"
    "//               whole group of field elements at once.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_pack_literal_value_88_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DCPacker::pack_default_value(void)
 *******************************************************************/
static PyObject *Dtool_DCPacker_pack_default_value_89(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DCPacker::pack_default_value(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":packDefaultValue", key_word_list));
        else
            (PyArg_Parse(args, ":packDefaultValue"));
        if(!PyErr_Occurred())
        {
            (local_this)->pack_default_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.packDefaultValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "packDefaultValue(non-const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_pack_default_value_89_comment =
    "C++ Interface:\n"
    "packDefaultValue(non-const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::pack_default_value\n"
    "//       Access: Published\n"
    "//  Description: Adds the default value for the current element into\n"
    "//               the stream.  If no default has been set for the\n"
    "//               current element, creates a sensible default.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_pack_default_value_89_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double DCPacker::unpack_double(void)
 *******************************************************************/
static PyObject *Dtool_DCPacker_unpack_double_90(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline double DCPacker::unpack_double(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":unpackDouble", key_word_list));
        else
            (PyArg_Parse(args, ":unpackDouble"));
        if(!PyErr_Occurred())
        {
            double return_value = (local_this)->unpack_double();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.unpackDouble() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unpackDouble(non-const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_unpack_double_90_comment =
    "C++ Interface:\n"
    "unpackDouble(non-const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::unpack_double\n"
    "//       Access: Published\n"
    "//  Description: Unpacks the current numeric or string value from the\n"
    "//               stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::unpack_double\n"
    "//       Access: Public\n"
    "//  Description: Unpacks the current numeric or string value from the\n"
    "//               stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_unpack_double_90_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DCPacker::unpack_int(void)
 *******************************************************************/
static PyObject *Dtool_DCPacker_unpack_int_91(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int DCPacker::unpack_int(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":unpackInt", key_word_list));
        else
            (PyArg_Parse(args, ":unpackInt"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->unpack_int();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.unpackInt() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unpackInt(non-const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_unpack_int_91_comment =
    "C++ Interface:\n"
    "unpackInt(non-const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::unpack_int\n"
    "//       Access: Published\n"
    "//  Description: Unpacks the current numeric or string value from the\n"
    "//               stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::unpack_int\n"
    "//       Access: Public\n"
    "//  Description: Unpacks the current numeric or string value from the\n"
    "//               stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_unpack_int_91_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int DCPacker::unpack_uint(void)
 *******************************************************************/
static PyObject *Dtool_DCPacker_unpack_uint_92(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline unsigned int DCPacker::unpack_uint(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":unpackUint", key_word_list));
        else
            (PyArg_Parse(args, ":unpackUint"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = (local_this)->unpack_uint();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.unpackUint() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unpackUint(non-const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_unpack_uint_92_comment =
    "C++ Interface:\n"
    "unpackUint(non-const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::unpack_uint\n"
    "//       Access: Published\n"
    "//  Description: Unpacks the current numeric or string value from the\n"
    "//               stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::unpack_uint\n"
    "//       Access: Public\n"
    "//  Description: Unpacks the current numeric or string value from the\n"
    "//               stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_unpack_uint_92_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline __int64 DCPacker::unpack_int64(void)
 *******************************************************************/
static PyObject *Dtool_DCPacker_unpack_int64_93(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline __int64 DCPacker::unpack_int64(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":unpackInt64", key_word_list));
        else
            (PyArg_Parse(args, ":unpackInt64"));
        if(!PyErr_Occurred())
        {
            __int64 return_value = (local_this)->unpack_int64();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromLongLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.unpackInt64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unpackInt64(non-const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_unpack_int64_93_comment =
    "C++ Interface:\n"
    "unpackInt64(non-const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::unpack_int64\n"
    "//       Access: Published\n"
    "//  Description: Unpacks the current numeric or string value from the\n"
    "//               stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::unpack_int64\n"
    "//       Access: Public\n"
    "//  Description: Unpacks the current numeric or string value from the\n"
    "//               stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_unpack_int64_93_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned __int64 DCPacker::unpack_uint64(void)
 *******************************************************************/
static PyObject *Dtool_DCPacker_unpack_uint64_94(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline unsigned __int64 DCPacker::unpack_uint64(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":unpackUint64", key_word_list));
        else
            (PyArg_Parse(args, ":unpackUint64"));
        if(!PyErr_Occurred())
        {
            unsigned __int64 return_value = (local_this)->unpack_uint64();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromUnsignedLongLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.unpackUint64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unpackUint64(non-const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_unpack_uint64_94_comment =
    "C++ Interface:\n"
    "unpackUint64(non-const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::unpack_uint64\n"
    "//       Access: Published\n"
    "//  Description: Unpacks the current numeric or string value from the\n"
    "//               stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::unpack_uint64\n"
    "//       Access: Public\n"
    "//  Description: Unpacks the current numeric or string value from the\n"
    "//               stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_unpack_uint64_94_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DCPacker::unpack_string(void)
 *******************************************************************/
static PyObject *Dtool_DCPacker_unpack_string_95(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline basic_string< char > DCPacker::unpack_string(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":unpackString", key_word_list));
        else
            (PyArg_Parse(args, ":unpackString"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = (local_this)->unpack_string();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.unpackString() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unpackString(non-const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_unpack_string_95_comment =
    "C++ Interface:\n"
    "unpackString(non-const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::unpack_string\n"
    "//       Access: Published\n"
    "//  Description: Unpacks the current numeric or string value from the\n"
    "//               stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::unpack_string\n"
    "//       Access: Public\n"
    "//  Description: Unpacks the current numeric or string value from the\n"
    "//               stream.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_unpack_string_95_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DCPacker::unpack_literal_value(void)
 *******************************************************************/
static PyObject *Dtool_DCPacker_unpack_literal_value_96(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline basic_string< char > DCPacker::unpack_literal_value(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":unpackLiteralValue", key_word_list));
        else
            (PyArg_Parse(args, ":unpackLiteralValue"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = (local_this)->unpack_literal_value();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.unpackLiteralValue() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unpackLiteralValue(non-const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_unpack_literal_value_96_comment =
    "C++ Interface:\n"
    "unpackLiteralValue(non-const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::unpack_literal_value\n"
    "//       Access: Published\n"
    "//  Description: Returns the literal string that represents the packed\n"
    "//               value of the current field, and advances the field\n"
    "//               pointer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::unpack_literal_value\n"
    "//       Access: Public\n"
    "//  Description: Returns the literal string that represents the packed\n"
    "//               value of the current field, and advances the field\n"
    "//               pointer.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_unpack_literal_value_96_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DCPacker::unpack_validate(void)
 *******************************************************************/
static PyObject *Dtool_DCPacker_unpack_validate_97(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DCPacker::unpack_validate(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":unpackValidate", key_word_list));
        else
            (PyArg_Parse(args, ":unpackValidate"));
        if(!PyErr_Occurred())
        {
            (local_this)->unpack_validate();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.unpackValidate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unpackValidate(non-const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_unpack_validate_97_comment =
    "C++ Interface:\n"
    "unpackValidate(non-const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::unpack_validate\n"
    "//       Access: Published\n"
    "//  Description: Internally unpacks the current numeric or string\n"
    "//               value and validates it against the type range limits,\n"
    "//               but does not return the value.  If the current field\n"
    "//               contains nested fields, validates all of them.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_unpack_validate_97_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DCPacker::unpack_skip(void)
 *******************************************************************/
static PyObject *Dtool_DCPacker_unpack_skip_98(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DCPacker::unpack_skip(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":unpackSkip", key_word_list));
        else
            (PyArg_Parse(args, ":unpackSkip"));
        if(!PyErr_Occurred())
        {
            (local_this)->unpack_skip();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.unpackSkip() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unpackSkip(non-const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_unpack_skip_98_comment =
    "C++ Interface:\n"
    "unpackSkip(non-const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::unpack_skip\n"
    "//       Access: Published\n"
    "//  Description: Skips the current field without unpacking it and\n"
    "//               advances to the next field.  If the current field\n"
    "//               contains nested fields, skips all of them.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_unpack_skip_98_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DCPacker::pack_object(PyObject *object)
 *******************************************************************/
static PyObject *Dtool_DCPacker_pack_object_99(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DCPacker::pack_object(PyObject *object)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"object", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:packObject", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:packObject", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->pack_object(param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.packObject() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "packObject(non-const DCPacker this, any object)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_pack_object_99_comment =
    "C++ Interface:\n"
    "packObject(non-const DCPacker this, any object)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::pack_object\n"
    "//       Access: Published\n"
    "//  Description: Packs the Python object of whatever type into the\n"
    "//               packer.  Each numeric object and string object maps\n"
    "//               to the corresponding pack_value() call; a tuple or\n"
    "//               sequence maps to a push() followed by all of the\n"
    "//               tuple's contents followed by a pop().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_pack_object_99_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PyObject *DCPacker::unpack_object(void)
 *******************************************************************/
static PyObject *Dtool_DCPacker_unpack_object_100(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-PyObject *DCPacker::unpack_object(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":unpackObject", key_word_list));
        else
            (PyArg_Parse(args, ":unpackObject"));
        if(!PyErr_Occurred())
        {
            PyObject *return_value = (local_this)->unpack_object();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return  return_value;
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.unpackObject() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "unpackObject(non-const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_unpack_object_100_comment =
    "C++ Interface:\n"
    "unpackObject(non-const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::unpack_object\n"
    "//       Access: Published\n"
    "//  Description: Unpacks a Python object of the appropriate type from\n"
    "//               the stream for the current field.  This may be an\n"
    "//               integer or a string for a simple field object; if the\n"
    "//               current field represents a list of fields it will be\n"
    "//               a tuple.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_unpack_object_100_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DCPacker::parse_and_pack(basic_string< char > const &formatted_object)
 * bool DCPacker::parse_and_pack(istream &in)
 *******************************************************************/
static PyObject *Dtool_DCPacker_parse_and_pack_101(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 bool DCPacker::parse_and_pack(basic_string< char > const &formatted_object)
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"formatted_object", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:parseAndPack", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:parseAndPack", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                bool return_value = (local_this)->parse_and_pack(basic_string<char>(param1_str, param1_len));
                Py_XDECREF(coerced);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 bool DCPacker::parse_and_pack(istream &in)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"in", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:parseAndPack", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:parseAndPack", &param1));
            if(!PyErr_Occurred())
            {
                istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_istream, 1, "DCPacker.parseAndPack", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->parse_and_pack(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "parseAndPack(non-const DCPacker this, string formatted_object)\n"
          "parseAndPack(non-const DCPacker this, non-const Istream in)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_parse_and_pack_101_comment =
    "C++ Interface:\n"
    "parseAndPack(non-const DCPacker this, string formatted_object)\n"
    "parseAndPack(non-const DCPacker this, non-const Istream in)\n"
    "\n"
    "// HAVE_PYTHON\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::parse_and_pack\n"
    "//       Access: Published\n"
    "//  Description: Parses an object's value according to the DC file\n"
    "//               syntax (e.g. as a default value string) and packs it.\n"
    "//               Returns true on success, false on a parse error.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::parse_and_pack\n"
    "//       Access: Published\n"
    "//  Description: Parses an object's value according to the DC file\n"
    "//               syntax (e.g. as a default value string) and packs it.\n"
    "//               Returns true on success, false on a parse error.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_parse_and_pack_101_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DCPacker::unpack_and_format(bool show_field_names)
 * basic_string< char > DCPacker::unpack_and_format(bool show_field_names = (1))
 * void DCPacker::unpack_and_format(ostream &out, bool show_field_names)
 * void DCPacker::unpack_and_format(ostream &out, bool show_field_names = (1))
 *******************************************************************/
static PyObject *Dtool_DCPacker_unpack_and_format_102(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-basic_string< char > DCPacker::unpack_and_format(bool show_field_names = (1))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":unpackAndFormat", key_word_list));
            else
                (PyArg_Parse(args, ":unpackAndFormat"));
            if(!PyErr_Occurred())
            {
                basic_string< char > return_value = (local_this)->unpack_and_format();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DCPacker.unpackAndFormat() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 void DCPacker::unpack_and_format(ostream &out, bool show_field_names = (1))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:unpackAndFormat", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:unpackAndFormat", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DCPacker.unpackAndFormat", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->unpack_and_format(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 basic_string< char > DCPacker::unpack_and_format(bool show_field_names)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"show_field_names", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:unpackAndFormat", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:unpackAndFormat", &param1));
                if(!PyErr_Occurred())
                {
                    basic_string< char > return_value = (local_this)->unpack_and_format((PyObject_IsTrue(param1)!=0));
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-void DCPacker::unpack_and_format(ostream &out, bool show_field_names)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"show_field_names", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:unpackAndFormat", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DCPacker.unpackAndFormat", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->unpack_and_format(*param1_this, (PyObject_IsTrue(param2)!=0));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call DCPacker.unpackAndFormat() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "unpackAndFormat() takes 1, 2, or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "unpackAndFormat(non-const DCPacker this)\n"
          "unpackAndFormat(non-const DCPacker this, non-const Ostream out)\n"
          "unpackAndFormat(non-const DCPacker this, bool show_field_names)\n"
          "unpackAndFormat(non-const DCPacker this, non-const Ostream out, bool show_field_names)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_unpack_and_format_102_comment =
    "C++ Interface:\n"
    "unpackAndFormat(non-const DCPacker this)\n"
    "unpackAndFormat(non-const DCPacker this, non-const Ostream out)\n"
    "unpackAndFormat(non-const DCPacker this, bool show_field_names)\n"
    "unpackAndFormat(non-const DCPacker this, non-const Ostream out, bool show_field_names)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::unpack_and_format\n"
    "//       Access: Published\n"
    "//  Description: Unpacks an object and formats its value into a syntax\n"
    "//               suitable for parsing in the dc file (e.g. as a\n"
    "//               default value), or as an input to parse_object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::unpack_and_format\n"
    "//       Access: Published\n"
    "//  Description: Unpacks an object and formats its value into a syntax\n"
    "//               suitable for parsing in the dc file (e.g. as a\n"
    "//               default value), or as an input to parse_object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_unpack_and_format_102_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DCPacker::had_parse_error(void) const
 *******************************************************************/
static PyObject *Dtool_DCPacker_had_parse_error_103(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DCPacker::had_parse_error(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hadParseError", key_word_list));
        else
            (PyArg_Parse(args, ":hadParseError"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DCPacker*)local_this)->had_parse_error();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hadParseError(const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_had_parse_error_103_comment =
    "C++ Interface:\n"
    "hadParseError(const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::had_parse_error\n"
    "//       Access: Published\n"
    "//  Description: Returns true if there has been an parse error\n"
    "//               since the most recent call to begin(); this can only\n"
    "//               happen if you call parse_and_pack().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_had_parse_error_103_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DCPacker::had_pack_error(void) const
 *******************************************************************/
static PyObject *Dtool_DCPacker_had_pack_error_104(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DCPacker::had_pack_error(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hadPackError", key_word_list));
        else
            (PyArg_Parse(args, ":hadPackError"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DCPacker*)local_this)->had_pack_error();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hadPackError(const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_had_pack_error_104_comment =
    "C++ Interface:\n"
    "hadPackError(const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::had_pack_error\n"
    "//       Access: Published\n"
    "//  Description: Returns true if there has been an packing error\n"
    "//               since the most recent call to begin(); in particular,\n"
    "//               this may be called after end() has returned false to\n"
    "//               determine the nature of the failure.\n"
    "//\n"
    "//               A return value of true indicates there was a push/pop\n"
    "//               mismatch, or the push/pop structure did not match the\n"
    "//               data structure, or there were the wrong number of\n"
    "//               elements in a nested push/pop structure, or on unpack\n"
    "//               that the data stream was truncated.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_had_pack_error_104_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DCPacker::had_range_error(void) const
 *******************************************************************/
static PyObject *Dtool_DCPacker_had_range_error_105(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DCPacker::had_range_error(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hadRangeError", key_word_list));
        else
            (PyArg_Parse(args, ":hadRangeError"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DCPacker*)local_this)->had_range_error();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hadRangeError(const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_had_range_error_105_comment =
    "C++ Interface:\n"
    "hadRangeError(const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::had_range_error\n"
    "//       Access: Published\n"
    "//  Description: Returns true if there has been an range validation\n"
    "//               error since the most recent call to begin(); in\n"
    "//               particular, this may be called after end() has\n"
    "//               returned false to determine the nature of the\n"
    "//               failure.\n"
    "//\n"
    "//               A return value of true indicates a value that was\n"
    "//               packed or unpacked did not fit within the specified\n"
    "//               legal range for a parameter, or within the limits of\n"
    "//               the field size.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_had_range_error_105_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DCPacker::had_error(void) const
 *******************************************************************/
static PyObject *Dtool_DCPacker_had_error_106(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DCPacker::had_error(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hadError", key_word_list));
        else
            (PyArg_Parse(args, ":hadError"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DCPacker*)local_this)->had_error();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hadError(const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_had_error_106_comment =
    "C++ Interface:\n"
    "hadError(const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::had_error\n"
    "//       Access: Published\n"
    "//  Description: Returns true if there has been any error (either a\n"
    "//               pack error or a range error) since the most recent\n"
    "//               call to begin().  If this returns true, then the\n"
    "//               matching call to end() will indicate an error\n"
    "//               (false).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_had_error_106_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int DCPacker::get_num_unpacked_bytes(void) const
 *******************************************************************/
static PyObject *Dtool_DCPacker_get_num_unpacked_bytes_107(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int DCPacker::get_num_unpacked_bytes(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumUnpackedBytes", key_word_list));
        else
            (PyArg_Parse(args, ":getNumUnpackedBytes"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const DCPacker*)local_this)->get_num_unpacked_bytes();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumUnpackedBytes(const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_get_num_unpacked_bytes_107_comment =
    "C++ Interface:\n"
    "getNumUnpackedBytes(const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::get_num_unpacked_bytes\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of bytes that have been unpacked\n"
    "//               so far, or after unpack_end(), the total number of\n"
    "//               bytes that were unpacked at all.  This can be used to\n"
    "//               validate that all of the bytes in the buffer were\n"
    "//               actually unpacked (which is not otherwise considered\n"
    "//               an error).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_get_num_unpacked_bytes_107_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int DCPacker::get_length(void) const
 *******************************************************************/
static PyObject *Dtool_DCPacker_get_length_108(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int DCPacker::get_length(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLength", key_word_list));
        else
            (PyArg_Parse(args, ":getLength"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const DCPacker*)local_this)->get_length();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLength(const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_get_length_108_comment =
    "C++ Interface:\n"
    "getLength(const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::get_length\n"
    "//       Access: Published\n"
    "//  Description: Returns the current length of the buffer.  This is\n"
    "//               the number of useful bytes stored in the buffer, not\n"
    "//               the amount of memory it takes up.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_get_length_108_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DCPacker::get_string(void) const
 *******************************************************************/
static PyObject *Dtool_DCPacker_get_string_109(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > DCPacker::get_string(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getString", key_word_list));
        else
            (PyArg_Parse(args, ":getString"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DCPacker*)local_this)->get_string();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getString(const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_get_string_109_comment =
    "C++ Interface:\n"
    "getString(const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::get_string\n"
    "//       Access: Published\n"
    "//  Description: Returns the packed data buffer as a string.  Also see\n"
    "//               get_data().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::get_string\n"
    "//       Access: Published\n"
    "//  Description: Copies the packed data into the indicated string.\n"
    "//               Also see get_data().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_get_string_109_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int DCPacker::get_unpack_length(void) const
 *******************************************************************/
static PyObject *Dtool_DCPacker_get_unpack_length_110(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int DCPacker::get_unpack_length(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUnpackLength", key_word_list));
        else
            (PyArg_Parse(args, ":getUnpackLength"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const DCPacker*)local_this)->get_unpack_length();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUnpackLength(const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_get_unpack_length_110_comment =
    "C++ Interface:\n"
    "getUnpackLength(const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::get_unpack_length\n"
    "//       Access: Published\n"
    "//  Description: Returns the total number of bytes in the unpack data\n"
    "//               buffer.  This is the buffer used when unpacking; it\n"
    "//               is separate from the pack data returned by\n"
    "//               get_length(), which is filled during packing.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_get_unpack_length_110_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DCPacker::get_unpack_string(void) const
 *******************************************************************/
static PyObject *Dtool_DCPacker_get_unpack_string_111(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > DCPacker::get_unpack_string(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getUnpackString", key_word_list));
        else
            (PyArg_Parse(args, ":getUnpackString"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DCPacker*)local_this)->get_unpack_string();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getUnpackString(const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_get_unpack_string_111_comment =
    "C++ Interface:\n"
    "getUnpackString(const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::get_unpack_string\n"
    "//       Access: Published\n"
    "//  Description: Returns the unpack data buffer, as a string.\n"
    "//               This is the buffer used when unpacking; it is\n"
    "//               separate from the pack data returned by get_string(),\n"
    "//               which is filled during packing.  Also see\n"
    "//               get_unpack_data().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_get_unpack_string_111_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline int DCPacker::get_num_stack_elements_ever_allocated(void)
 *******************************************************************/
static PyObject *Dtool_DCPacker_get_num_stack_elements_ever_allocated_112(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline int DCPacker::get_num_stack_elements_ever_allocated(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumStackElementsEverAllocated", key_word_list))
        {
            int return_value = DCPacker::get_num_stack_elements_ever_allocated();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumStackElementsEverAllocated()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_get_num_stack_elements_ever_allocated_112_comment =
    "C++ Interface:\n"
    "getNumStackElementsEverAllocated()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::StackElement::get_num_stack_elements_ever_allocated\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the number of DCPacker::StackElement pointers\n"
    "//               ever simultaneously allocated; these are now either\n"
    "//               in active use or have been recycled into the deleted\n"
    "//               DCPacker::StackElement pool to be used again.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_get_num_stack_elements_ever_allocated_112_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DCPacker::raw_pack_int8(int value)
 *******************************************************************/
static PyObject *Dtool_DCPacker_raw_pack_int8_113(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DCPacker::raw_pack_int8(int value)
        int param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:rawPackInt8", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:rawPackInt8", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->raw_pack_int8((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.rawPackInt8() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "rawPackInt8(non-const DCPacker this, int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_raw_pack_int8_113_comment =
    "C++ Interface:\n"
    "rawPackInt8(non-const DCPacker this, int value)\n"
    "\n"
    "// The following methods are used only for packing (or unpacking)\n"
    "// raw data into the buffer between packing sessions (e.g. between\n"
    "// calls to end_pack() and the next begin_pack()).\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::raw_pack_int8\n"
    "//       Access: Published\n"
    "//  Description: Packs the data into the buffer between packing\n"
    "//               sessions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_raw_pack_int8_113_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DCPacker::raw_pack_int16(int value)
 *******************************************************************/
static PyObject *Dtool_DCPacker_raw_pack_int16_114(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DCPacker::raw_pack_int16(int value)
        int param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:rawPackInt16", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:rawPackInt16", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->raw_pack_int16((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.rawPackInt16() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "rawPackInt16(non-const DCPacker this, int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_raw_pack_int16_114_comment =
    "C++ Interface:\n"
    "rawPackInt16(non-const DCPacker this, int value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::raw_pack_int16\n"
    "//       Access: Published\n"
    "//  Description: Packs the data into the buffer between packing\n"
    "//               sessions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_raw_pack_int16_114_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DCPacker::raw_pack_int32(int value)
 *******************************************************************/
static PyObject *Dtool_DCPacker_raw_pack_int32_115(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DCPacker::raw_pack_int32(int value)
        int param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:rawPackInt32", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:rawPackInt32", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->raw_pack_int32((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.rawPackInt32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "rawPackInt32(non-const DCPacker this, int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_raw_pack_int32_115_comment =
    "C++ Interface:\n"
    "rawPackInt32(non-const DCPacker this, int value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::raw_pack_int32\n"
    "//       Access: Published\n"
    "//  Description: Packs the data into the buffer between packing\n"
    "//               sessions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_raw_pack_int32_115_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DCPacker::raw_pack_int64(__int64 value)
 *******************************************************************/
static PyObject *Dtool_DCPacker_raw_pack_int64_116(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DCPacker::raw_pack_int64(__int64 value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:rawPackInt64", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:rawPackInt64", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_long = PyNumber_Long(param1);
            if (!((param1_long == NULL)))
            {
                (local_this)->raw_pack_int64(PyLong_AsLongLong(param1_long));
                 Py_XDECREF(param1_long);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.rawPackInt64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "rawPackInt64(non-const DCPacker this, long long value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_raw_pack_int64_116_comment =
    "C++ Interface:\n"
    "rawPackInt64(non-const DCPacker this, long long value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::raw_pack_int64\n"
    "//       Access: Published\n"
    "//  Description: Packs the data into the buffer between packing\n"
    "//               sessions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_raw_pack_int64_116_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DCPacker::raw_pack_uint8(unsigned int value)
 *******************************************************************/
static PyObject *Dtool_DCPacker_raw_pack_uint8_117(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DCPacker::raw_pack_uint8(unsigned int value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:rawPackUint8", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:rawPackUint8", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->raw_pack_uint8(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.rawPackUint8() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "rawPackUint8(non-const DCPacker this, unsigned int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_raw_pack_uint8_117_comment =
    "C++ Interface:\n"
    "rawPackUint8(non-const DCPacker this, unsigned int value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::raw_pack_uint8\n"
    "//       Access: Published\n"
    "//  Description: Packs the data into the buffer between packing\n"
    "//               sessions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_raw_pack_uint8_117_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DCPacker::raw_pack_uint16(unsigned int value)
 *******************************************************************/
static PyObject *Dtool_DCPacker_raw_pack_uint16_118(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DCPacker::raw_pack_uint16(unsigned int value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:rawPackUint16", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:rawPackUint16", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->raw_pack_uint16(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.rawPackUint16() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "rawPackUint16(non-const DCPacker this, unsigned int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_raw_pack_uint16_118_comment =
    "C++ Interface:\n"
    "rawPackUint16(non-const DCPacker this, unsigned int value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::raw_pack_uint16\n"
    "//       Access: Published\n"
    "//  Description: Packs the data into the buffer between packing\n"
    "//               sessions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_raw_pack_uint16_118_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DCPacker::raw_pack_uint32(unsigned int value)
 *******************************************************************/
static PyObject *Dtool_DCPacker_raw_pack_uint32_119(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DCPacker::raw_pack_uint32(unsigned int value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:rawPackUint32", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:rawPackUint32", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->raw_pack_uint32(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.rawPackUint32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "rawPackUint32(non-const DCPacker this, unsigned int value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_raw_pack_uint32_119_comment =
    "C++ Interface:\n"
    "rawPackUint32(non-const DCPacker this, unsigned int value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::raw_pack_uint32\n"
    "//       Access: Published\n"
    "//  Description: Packs the data into the buffer between packing\n"
    "//               sessions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_raw_pack_uint32_119_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DCPacker::raw_pack_uint64(unsigned __int64 value)
 *******************************************************************/
static PyObject *Dtool_DCPacker_raw_pack_uint64_120(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DCPacker::raw_pack_uint64(unsigned __int64 value)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:rawPackUint64", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:rawPackUint64", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_long = PyNumber_Long(param1);
            if (!((param1_long == NULL)))
            {
                (local_this)->raw_pack_uint64(PyLong_AsUnsignedLongLong(param1_long));
                 Py_XDECREF(param1_long);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.rawPackUint64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "rawPackUint64(non-const DCPacker this, unsigned long long value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_raw_pack_uint64_120_comment =
    "C++ Interface:\n"
    "rawPackUint64(non-const DCPacker this, unsigned long long value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::raw_pack_uint64\n"
    "//       Access: Published\n"
    "//  Description: Packs the data into the buffer between packing\n"
    "//               sessions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_raw_pack_uint64_120_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DCPacker::raw_pack_float64(double value)
 *******************************************************************/
static PyObject *Dtool_DCPacker_raw_pack_float64_121(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DCPacker::raw_pack_float64(double value)
        double param1;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:rawPackFloat64", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:rawPackFloat64", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->raw_pack_float64((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.rawPackFloat64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "rawPackFloat64(non-const DCPacker this, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_raw_pack_float64_121_comment =
    "C++ Interface:\n"
    "rawPackFloat64(non-const DCPacker this, float value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::raw_pack_float64\n"
    "//       Access: Published\n"
    "//  Description: Packs the data into the buffer between packing\n"
    "//               sessions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_raw_pack_float64_121_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DCPacker::raw_pack_string(basic_string< char > const &value)
 *******************************************************************/
static PyObject *Dtool_DCPacker_raw_pack_string_122(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DCPacker::raw_pack_string(basic_string< char > const &value)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:rawPackString", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:rawPackString", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->raw_pack_string(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.rawPackString() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "rawPackString(non-const DCPacker this, string value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_raw_pack_string_122_comment =
    "C++ Interface:\n"
    "rawPackString(non-const DCPacker this, string value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::raw_pack_string\n"
    "//       Access: Published\n"
    "//  Description: Packs the data into the buffer between packing\n"
    "//               sessions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_raw_pack_string_122_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DCPacker::raw_unpack_int8(void)
 *******************************************************************/
static PyObject *Dtool_DCPacker_raw_unpack_int8_123(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int DCPacker::raw_unpack_int8(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":rawUnpackInt8", key_word_list));
        else
            (PyArg_Parse(args, ":rawUnpackInt8"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->raw_unpack_int8();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.rawUnpackInt8() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "rawUnpackInt8(non-const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_raw_unpack_int8_123_comment =
    "C++ Interface:\n"
    "rawUnpackInt8(non-const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::raw_unpack_int8\n"
    "//       Access: Published\n"
    "//  Description: Unpacks the data from the buffer between unpacking\n"
    "//               sessions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::raw_unpack_int8\n"
    "//       Access: Public\n"
    "//  Description: Unpacks the data from the buffer between unpacking\n"
    "//               sessions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_raw_unpack_int8_123_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DCPacker::raw_unpack_int16(void)
 *******************************************************************/
static PyObject *Dtool_DCPacker_raw_unpack_int16_124(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int DCPacker::raw_unpack_int16(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":rawUnpackInt16", key_word_list));
        else
            (PyArg_Parse(args, ":rawUnpackInt16"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->raw_unpack_int16();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.rawUnpackInt16() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "rawUnpackInt16(non-const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_raw_unpack_int16_124_comment =
    "C++ Interface:\n"
    "rawUnpackInt16(non-const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::raw_unpack_int16\n"
    "//       Access: Published\n"
    "//  Description: Unpacks the data from the buffer between unpacking\n"
    "//               sessions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::raw_unpack_int16\n"
    "//       Access: Public\n"
    "//  Description: Unpacks the data from the buffer between unpacking\n"
    "//               sessions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_raw_unpack_int16_124_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DCPacker::raw_unpack_int32(void)
 *******************************************************************/
static PyObject *Dtool_DCPacker_raw_unpack_int32_125(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int DCPacker::raw_unpack_int32(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":rawUnpackInt32", key_word_list));
        else
            (PyArg_Parse(args, ":rawUnpackInt32"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->raw_unpack_int32();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.rawUnpackInt32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "rawUnpackInt32(non-const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_raw_unpack_int32_125_comment =
    "C++ Interface:\n"
    "rawUnpackInt32(non-const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::raw_unpack_int32\n"
    "//       Access: Published\n"
    "//  Description: Unpacks the data from the buffer between unpacking\n"
    "//               sessions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::raw_unpack_int32\n"
    "//       Access: Public\n"
    "//  Description: Unpacks the data from the buffer between unpacking\n"
    "//               sessions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_raw_unpack_int32_125_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline __int64 DCPacker::raw_unpack_int64(void)
 *******************************************************************/
static PyObject *Dtool_DCPacker_raw_unpack_int64_126(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline __int64 DCPacker::raw_unpack_int64(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":rawUnpackInt64", key_word_list));
        else
            (PyArg_Parse(args, ":rawUnpackInt64"));
        if(!PyErr_Occurred())
        {
            __int64 return_value = (local_this)->raw_unpack_int64();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromLongLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.rawUnpackInt64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "rawUnpackInt64(non-const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_raw_unpack_int64_126_comment =
    "C++ Interface:\n"
    "rawUnpackInt64(non-const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::raw_unpack_int64\n"
    "//       Access: Published\n"
    "//  Description: Unpacks the data from the buffer between unpacking\n"
    "//               sessions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::raw_unpack_int64\n"
    "//       Access: Public\n"
    "//  Description: Unpacks the data from the buffer between unpacking\n"
    "//               sessions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_raw_unpack_int64_126_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int DCPacker::raw_unpack_uint8(void)
 *******************************************************************/
static PyObject *Dtool_DCPacker_raw_unpack_uint8_127(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline unsigned int DCPacker::raw_unpack_uint8(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":rawUnpackUint8", key_word_list));
        else
            (PyArg_Parse(args, ":rawUnpackUint8"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = (local_this)->raw_unpack_uint8();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.rawUnpackUint8() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "rawUnpackUint8(non-const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_raw_unpack_uint8_127_comment =
    "C++ Interface:\n"
    "rawUnpackUint8(non-const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::raw_unpack_uint8\n"
    "//       Access: Published\n"
    "//  Description: Unpacks the data from the buffer between unpacking\n"
    "//               sessions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::raw_unpack_uint8\n"
    "//       Access: Public\n"
    "//  Description: Unpacks the data from the buffer between unpacking\n"
    "//               sessions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_raw_unpack_uint8_127_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int DCPacker::raw_unpack_uint16(void)
 *******************************************************************/
static PyObject *Dtool_DCPacker_raw_unpack_uint16_128(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline unsigned int DCPacker::raw_unpack_uint16(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":rawUnpackUint16", key_word_list));
        else
            (PyArg_Parse(args, ":rawUnpackUint16"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = (local_this)->raw_unpack_uint16();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.rawUnpackUint16() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "rawUnpackUint16(non-const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_raw_unpack_uint16_128_comment =
    "C++ Interface:\n"
    "rawUnpackUint16(non-const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::raw_unpack_uint16\n"
    "//       Access: Published\n"
    "//  Description: Unpacks the data from the buffer between unpacking\n"
    "//               sessions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::raw_unpack_uint16\n"
    "//       Access: Public\n"
    "//  Description: Unpacks the data from the buffer between unpacking\n"
    "//               sessions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_raw_unpack_uint16_128_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int DCPacker::raw_unpack_uint32(void)
 *******************************************************************/
static PyObject *Dtool_DCPacker_raw_unpack_uint32_129(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline unsigned int DCPacker::raw_unpack_uint32(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":rawUnpackUint32", key_word_list));
        else
            (PyArg_Parse(args, ":rawUnpackUint32"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = (local_this)->raw_unpack_uint32();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.rawUnpackUint32() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "rawUnpackUint32(non-const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_raw_unpack_uint32_129_comment =
    "C++ Interface:\n"
    "rawUnpackUint32(non-const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::raw_unpack_uint32\n"
    "//       Access: Published\n"
    "//  Description: Unpacks the data from the buffer between unpacking\n"
    "//               sessions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::raw_unpack_uint32\n"
    "//       Access: Public\n"
    "//  Description: Unpacks the data from the buffer between unpacking\n"
    "//               sessions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_raw_unpack_uint32_129_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned __int64 DCPacker::raw_unpack_uint64(void)
 *******************************************************************/
static PyObject *Dtool_DCPacker_raw_unpack_uint64_130(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline unsigned __int64 DCPacker::raw_unpack_uint64(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":rawUnpackUint64", key_word_list));
        else
            (PyArg_Parse(args, ":rawUnpackUint64"));
        if(!PyErr_Occurred())
        {
            unsigned __int64 return_value = (local_this)->raw_unpack_uint64();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLong_FromUnsignedLongLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.rawUnpackUint64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "rawUnpackUint64(non-const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_raw_unpack_uint64_130_comment =
    "C++ Interface:\n"
    "rawUnpackUint64(non-const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::raw_unpack_uint64\n"
    "//       Access: Published\n"
    "//  Description: Unpacks the data from the buffer between unpacking\n"
    "//               sessions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::raw_unpack_uint64\n"
    "//       Access: Public\n"
    "//  Description: Unpacks the data from the buffer between unpacking\n"
    "//               sessions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_raw_unpack_uint64_130_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double DCPacker::raw_unpack_float64(void)
 *******************************************************************/
static PyObject *Dtool_DCPacker_raw_unpack_float64_131(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline double DCPacker::raw_unpack_float64(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":rawUnpackFloat64", key_word_list));
        else
            (PyArg_Parse(args, ":rawUnpackFloat64"));
        if(!PyErr_Occurred())
        {
            double return_value = (local_this)->raw_unpack_float64();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.rawUnpackFloat64() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "rawUnpackFloat64(non-const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_raw_unpack_float64_131_comment =
    "C++ Interface:\n"
    "rawUnpackFloat64(non-const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::raw_unpack_float64\n"
    "//       Access: Published\n"
    "//  Description: Unpacks the data from the buffer between unpacking\n"
    "//               sessions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::raw_unpack_float64\n"
    "//       Access: Public\n"
    "//  Description: Unpacks the data from the buffer between unpacking\n"
    "//               sessions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_raw_unpack_float64_131_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DCPacker::raw_unpack_string(void)
 *******************************************************************/
static PyObject *Dtool_DCPacker_raw_unpack_string_132(PyObject *self, PyObject *args,PyObject *kwds) {
    DCPacker * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCPacker,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline basic_string< char > DCPacker::raw_unpack_string(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":rawUnpackString", key_word_list));
        else
            (PyArg_Parse(args, ":rawUnpackString"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = (local_this)->raw_unpack_string();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCPacker.rawUnpackString() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "rawUnpackString(non-const DCPacker this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCPacker_raw_unpack_string_132_comment =
    "C++ Interface:\n"
    "rawUnpackString(non-const DCPacker this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::raw_unpack_string\n"
    "//       Access: Published\n"
    "//  Description: Unpacks the data from the buffer between unpacking\n"
    "//               sessions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCPacker::raw_unpack_string\n"
    "//       Access: Public\n"
    "//  Description: Unpacks the data from the buffer between unpacking\n"
    "//               sessions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCPacker_raw_unpack_string_132_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCPacker::DCPacker(void)
 *******************************************************************/
int  Dtool_Init_DCPacker(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-DCPacker::DCPacker(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":DCPacker", key_word_list))
        {
            DCPacker *return_value = new DCPacker();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DCPacker,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DCPacker()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DCPacker(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DCPacker)
    {
        printf("DCPacker ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DCPacker * local_this = (DCPacker *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DCPacker)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DCPacker(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DCPacker)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DCParameter 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual DCSimpleParameter *DCParameter::as_simple_parameter(void)
 * virtual DCSimpleParameter const *DCParameter::as_simple_parameter(void) const
 *******************************************************************/
static PyObject *Dtool_DCParameter_as_simple_parameter_134(PyObject *self, PyObject *args,PyObject *kwds) {
    DCParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 virtual DCSimpleParameter *DCParameter::as_simple_parameter(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":asSimpleParameter", key_word_list));
        else
            (PyArg_Parse(args, ":asSimpleParameter"));
        if(!PyErr_Occurred())
        {
            DCSimpleParameter *return_value = (local_this)->as_simple_parameter();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCSimpleParameter,false, false);
            }
        }
        PyErr_Clear(); 
    }

    {
      // -2 virtual DCSimpleParameter const *DCParameter::as_simple_parameter(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":asSimpleParameter", key_word_list));
        else
            (PyArg_Parse(args, ":asSimpleParameter"));
        if(!PyErr_Occurred())
        {
            DCSimpleParameter const *return_value = ((const DCParameter*)local_this)->as_simple_parameter();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCSimpleParameter,false, true);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "asSimpleParameter(non-const DCParameter this)\n"
          "asSimpleParameter(const DCParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCParameter_as_simple_parameter_134_comment =
    "C++ Interface:\n"
    "asSimpleParameter(non-const DCParameter this)\n"
    "asSimpleParameter(const DCParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCParameter::as_simple_parameter\n"
    "//       Access: Published, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCParameter::as_simple_parameter\n"
    "//       Access: Published, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCParameter_as_simple_parameter_134_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual DCArrayParameter *DCParameter::as_array_parameter(void)
 * virtual DCArrayParameter const *DCParameter::as_array_parameter(void) const
 *******************************************************************/
static PyObject *Dtool_DCParameter_as_array_parameter_135(PyObject *self, PyObject *args,PyObject *kwds) {
    DCParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 virtual DCArrayParameter *DCParameter::as_array_parameter(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":asArrayParameter", key_word_list));
        else
            (PyArg_Parse(args, ":asArrayParameter"));
        if(!PyErr_Occurred())
        {
            DCArrayParameter *return_value = (local_this)->as_array_parameter();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCArrayParameter,false, false);
            }
        }
        PyErr_Clear(); 
    }

    {
      // -2 virtual DCArrayParameter const *DCParameter::as_array_parameter(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":asArrayParameter", key_word_list));
        else
            (PyArg_Parse(args, ":asArrayParameter"));
        if(!PyErr_Occurred())
        {
            DCArrayParameter const *return_value = ((const DCParameter*)local_this)->as_array_parameter();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCArrayParameter,false, true);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "asArrayParameter(non-const DCParameter this)\n"
          "asArrayParameter(const DCParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCParameter_as_array_parameter_135_comment =
    "C++ Interface:\n"
    "asArrayParameter(non-const DCParameter this)\n"
    "asArrayParameter(const DCParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCParameter::as_array_parameter\n"
    "//       Access: Published, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCParameter::as_array_parameter\n"
    "//       Access: Published, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCParameter_as_array_parameter_135_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual DCParameter *DCParameter::make_copy(void) const = 0
 *******************************************************************/
static PyObject *Dtool_DCParameter_make_copy_136(PyObject *self, PyObject *args,PyObject *kwds) {
    DCParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual DCParameter *DCParameter::make_copy(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":makeCopy", key_word_list));
        else
            (PyArg_Parse(args, ":makeCopy"));
        if(!PyErr_Occurred())
        {
            DCParameter *return_value = ((const DCParameter*)local_this)->make_copy();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCParameter,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "makeCopy(const DCParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCParameter_make_copy_136_comment =
    "C++ Interface:\n"
    "makeCopy(const DCParameter this)\n"
    "\n"
    "";
#else
static const char * Dtool_DCParameter_make_copy_136_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual bool DCParameter::is_valid(void) const = 0
 *******************************************************************/
static PyObject *Dtool_DCParameter_is_valid_137(PyObject *self, PyObject *args,PyObject *kwds) {
    DCParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-virtual bool DCParameter::is_valid(void) const = 0
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isValid", key_word_list));
        else
            (PyArg_Parse(args, ":isValid"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DCParameter*)local_this)->is_valid();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isValid(const DCParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCParameter_is_valid_137_comment =
    "C++ Interface:\n"
    "isValid(const DCParameter this)\n"
    "\n"
    "";
#else
static const char * Dtool_DCParameter_is_valid_137_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCTypedef const *DCParameter::get_typedef(void) const
 *******************************************************************/
static PyObject *Dtool_DCParameter_get_typedef_138(PyObject *self, PyObject *args,PyObject *kwds) {
    DCParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DCTypedef const *DCParameter::get_typedef(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTypedef", key_word_list));
        else
            (PyArg_Parse(args, ":getTypedef"));
        if(!PyErr_Occurred())
        {
            DCTypedef const *return_value = ((const DCParameter*)local_this)->get_typedef();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCTypedef,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTypedef(const DCParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCParameter_get_typedef_138_comment =
    "C++ Interface:\n"
    "getTypedef(const DCParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCParameter::get_typedef\n"
    "//       Access: Published\n"
    "//  Description: If this type has been referenced from a typedef,\n"
    "//               returns the DCTypedef instance, or NULL if the\n"
    "//               type was declared on-the-fly.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCParameter_get_typedef_138_comment = NULL;
#endif

int  Dtool_Init_DCParameter(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (DCParameter)");
       return -1;
}
inline void  * Dtool_UpcastInterface_DCParameter(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DCParameter)
    {
        printf("DCParameter ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DCParameter * local_this = (DCParameter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DCParameter)
        return local_this;
    if(requested_type == &Dtool_DCField)
        return ( DCField *) local_this;
    if(requested_type == &Dtool_DCKeywordList)
        return ( DCKeywordList *)( DCField *) local_this;
    if(requested_type == &Dtool_DCPackerInterface)
        return ( DCPackerInterface *)( DCField *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DCParameter(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DCParameter)
        return from_this;
    if(from_type == &Dtool_DCField)
    {
          DCField* other_this = (DCField*)from_this;
          return (DCParameter*)other_this;
    }
    if(from_type == &Dtool_DCKeywordList)
    {
          DCKeywordList* other_this = (DCKeywordList*)from_this;
          return (DCParameter*)other_this;
    }
    if(from_type == &Dtool_DCPackerInterface)
    {
          DCPackerInterface* other_this = (DCPackerInterface*)from_this;
          return (DCParameter*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DCArrayParameter 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * DCParameter *DCArrayParameter::get_element_type(void) const
 *******************************************************************/
static PyObject *Dtool_DCArrayParameter_get_element_type_140(PyObject *self, PyObject *args,PyObject *kwds) {
    DCArrayParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCArrayParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DCParameter *DCArrayParameter::get_element_type(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getElementType", key_word_list));
        else
            (PyArg_Parse(args, ":getElementType"));
        if(!PyErr_Occurred())
        {
            DCParameter *return_value = ((const DCArrayParameter*)local_this)->get_element_type();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCParameter,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getElementType(const DCArrayParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCArrayParameter_get_element_type_140_comment =
    "C++ Interface:\n"
    "getElementType(const DCArrayParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCArrayParameter::get_element_type\n"
    "//       Access: Published\n"
    "//  Description: Returns the type of the individual elements of this\n"
    "//               array.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCArrayParameter_get_element_type_140_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DCArrayParameter::get_array_size(void) const
 *******************************************************************/
static PyObject *Dtool_DCArrayParameter_get_array_size_141(PyObject *self, PyObject *args,PyObject *kwds) {
    DCArrayParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCArrayParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DCArrayParameter::get_array_size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getArraySize", key_word_list));
        else
            (PyArg_Parse(args, ":getArraySize"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DCArrayParameter*)local_this)->get_array_size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getArraySize(const DCArrayParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCArrayParameter_get_array_size_141_comment =
    "C++ Interface:\n"
    "getArraySize(const DCArrayParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCArrayParameter::get_array_size\n"
    "//       Access: Published\n"
    "//  Description: Returns the fixed number of elements in this array,\n"
    "//               or -1 if the array may contain a variable number of\n"
    "//               elements.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCArrayParameter_get_array_size_141_comment = NULL;
#endif

int  Dtool_Init_DCArrayParameter(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (DCArrayParameter)");
       return -1;
}
inline void  * Dtool_UpcastInterface_DCArrayParameter(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DCArrayParameter)
    {
        printf("DCArrayParameter ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DCArrayParameter * local_this = (DCArrayParameter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DCArrayParameter)
        return local_this;
    if(requested_type == &Dtool_DCField)
        return ( DCField *)( DCParameter *) local_this;
    if(requested_type == &Dtool_DCKeywordList)
        return ( DCKeywordList *)( DCField *)( DCParameter *) local_this;
    if(requested_type == &Dtool_DCPackerInterface)
        return ( DCPackerInterface *)( DCField *)( DCParameter *) local_this;
    if(requested_type == &Dtool_DCParameter)
        return ( DCParameter *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DCArrayParameter(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DCArrayParameter)
        return from_this;
    if(from_type == &Dtool_DCField)
    {
          DCField* other_this = (DCField*)from_this;
          return (DCArrayParameter*)other_this;
    }
    if(from_type == &Dtool_DCKeywordList)
    {
          DCKeywordList* other_this = (DCKeywordList*)from_this;
          return (DCArrayParameter*)other_this;
    }
    if(from_type == &Dtool_DCPackerInterface)
    {
          DCPackerInterface* other_this = (DCPackerInterface*)from_this;
          return (DCArrayParameter*)other_this;
    }
    if(from_type == &Dtool_DCParameter)
    {
          DCParameter* other_this = (DCParameter*)from_this;
          return (DCArrayParameter*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DCAtomicField 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * int DCAtomicField::get_num_elements(void) const
 *******************************************************************/
static PyObject *Dtool_DCAtomicField_get_num_elements_143(PyObject *self, PyObject *args,PyObject *kwds) {
    DCAtomicField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCAtomicField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DCAtomicField::get_num_elements(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumElements", key_word_list));
        else
            (PyArg_Parse(args, ":getNumElements"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DCAtomicField*)local_this)->get_num_elements();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumElements(const DCAtomicField this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCAtomicField_get_num_elements_143_comment =
    "C++ Interface:\n"
    "getNumElements(const DCAtomicField this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCAtomicField::get_num_elements\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of elements (parameters) of the\n"
    "//               atomic field.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCAtomicField_get_num_elements_143_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCParameter *DCAtomicField::get_element(int n) const
 *******************************************************************/
static PyObject *Dtool_DCAtomicField_get_element_144(PyObject *self, PyObject *args,PyObject *kwds) {
    DCAtomicField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCAtomicField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DCParameter *DCAtomicField::get_element(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getElement", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getElement", &param1));
        if(!PyErr_Occurred())
        {
            DCParameter *return_value = ((const DCAtomicField*)local_this)->get_element((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCParameter,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getElement(const DCAtomicField this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCAtomicField_get_element_144_comment =
    "C++ Interface:\n"
    "getElement(const DCAtomicField this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCAtomicField::get_element\n"
    "//       Access: Published\n"
    "//  Description: Returns the parameter object describing the\n"
    "//               nth element.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCAtomicField_get_element_144_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DCAtomicField::get_element_default(int n) const
 *******************************************************************/
static PyObject *Dtool_DCAtomicField_get_element_default_145(PyObject *self, PyObject *args,PyObject *kwds) {
    DCAtomicField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCAtomicField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > DCAtomicField::get_element_default(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getElementDefault", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getElementDefault", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DCAtomicField*)local_this)->get_element_default((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getElementDefault(const DCAtomicField this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCAtomicField_get_element_default_145_comment =
    "C++ Interface:\n"
    "getElementDefault(const DCAtomicField this, int n)\n"
    "\n"
    "// These five methods are deprecated and will be removed soon.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCAtomicField::get_element_default\n"
    "//       Access: Published\n"
    "//  Description: Returns the pre-formatted default value associated\n"
    "//               with the nth element of the field.  This is only\n"
    "//               valid if has_element_default() returns true, in which\n"
    "//               case this string represents the bytes that should be\n"
    "//               assigned to the field as a default value.\n"
    "//\n"
    "//               If the element is an array-type element, the returned\n"
    "//               value will include the two-byte length preceding the\n"
    "//               array data.\n"
    "//\n"
    "//               This is deprecated; use get_element() instead.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCAtomicField_get_element_default_145_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DCAtomicField::has_element_default(int n) const
 *******************************************************************/
static PyObject *Dtool_DCAtomicField_has_element_default_146(PyObject *self, PyObject *args,PyObject *kwds) {
    DCAtomicField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCAtomicField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool DCAtomicField::has_element_default(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:hasElementDefault", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:hasElementDefault", &param1));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DCAtomicField*)local_this)->has_element_default((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasElementDefault(const DCAtomicField this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCAtomicField_has_element_default_146_comment =
    "C++ Interface:\n"
    "hasElementDefault(const DCAtomicField this, int n)\n"
    "\n"
    "// These five methods are deprecated and will be removed soon.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCAtomicField::has_element_default\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the nth element of the field has a\n"
    "//               default value specified, false otherwise.\n"
    "//\n"
    "//               This is deprecated; use get_element() instead.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCAtomicField_has_element_default_146_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DCAtomicField::get_element_name(int n) const
 *******************************************************************/
static PyObject *Dtool_DCAtomicField_get_element_name_147(PyObject *self, PyObject *args,PyObject *kwds) {
    DCAtomicField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCAtomicField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > DCAtomicField::get_element_name(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getElementName", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getElementName", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DCAtomicField*)local_this)->get_element_name((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getElementName(const DCAtomicField this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCAtomicField_get_element_name_147_comment =
    "C++ Interface:\n"
    "getElementName(const DCAtomicField this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCAtomicField::get_element_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the name of the nth element of the field.\n"
    "//               This name is strictly for documentary purposes; it\n"
    "//               does not generally affect operation.  If a name is\n"
    "//               not specified, this will be the empty string.\n"
    "//\n"
    "//               This method is deprecated; use\n"
    "//               get_element()->get_name() instead.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCAtomicField_get_element_name_147_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCSubatomicType DCAtomicField::get_element_type(int n) const
 *******************************************************************/
static PyObject *Dtool_DCAtomicField_get_element_type_148(PyObject *self, PyObject *args,PyObject *kwds) {
    DCAtomicField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCAtomicField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DCSubatomicType DCAtomicField::get_element_type(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getElementType", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getElementType", &param1));
        if(!PyErr_Occurred())
        {
            DCSubatomicType return_value = ((const DCAtomicField*)local_this)->get_element_type((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getElementType(const DCAtomicField this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCAtomicField_get_element_type_148_comment =
    "C++ Interface:\n"
    "getElementType(const DCAtomicField this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCAtomicField::get_element_type\n"
    "//       Access: Published\n"
    "//  Description: Returns the numeric type of the nth element of the\n"
    "//               field.  This method is deprecated; use\n"
    "//               get_element() instead.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCAtomicField_get_element_type_148_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DCAtomicField::get_element_divisor(int n) const
 *******************************************************************/
static PyObject *Dtool_DCAtomicField_get_element_divisor_149(PyObject *self, PyObject *args,PyObject *kwds) {
    DCAtomicField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCAtomicField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DCAtomicField::get_element_divisor(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getElementDivisor", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getElementDivisor", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DCAtomicField*)local_this)->get_element_divisor((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getElementDivisor(const DCAtomicField this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCAtomicField_get_element_divisor_149_comment =
    "C++ Interface:\n"
    "getElementDivisor(const DCAtomicField this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCAtomicField::get_element_divisor\n"
    "//       Access: Published\n"
    "//  Description: Returns the divisor associated with the nth element\n"
    "//               of the field.  This implements an implicit\n"
    "//               fixed-point system; floating-point values are to be\n"
    "//               multiplied by this value before encoding into a\n"
    "//               packet, and divided by this number after decoding.\n"
    "//\n"
    "//               This method is deprecated; use\n"
    "//               get_element()->get_divisor() instead.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCAtomicField_get_element_divisor_149_comment = NULL;
#endif

int  Dtool_Init_DCAtomicField(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (DCAtomicField)");
       return -1;
}
inline void  * Dtool_UpcastInterface_DCAtomicField(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DCAtomicField)
    {
        printf("DCAtomicField ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DCAtomicField * local_this = (DCAtomicField *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DCAtomicField)
        return local_this;
    if(requested_type == &Dtool_DCField)
        return ( DCField *) local_this;
    if(requested_type == &Dtool_DCKeywordList)
        return ( DCKeywordList *)( DCField *) local_this;
    if(requested_type == &Dtool_DCPackerInterface)
        return ( DCPackerInterface *)( DCField *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DCAtomicField(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DCAtomicField)
        return from_this;
    if(from_type == &Dtool_DCField)
    {
          DCField* other_this = (DCField*)from_this;
          return (DCAtomicField*)other_this;
    }
    if(from_type == &Dtool_DCKeywordList)
    {
          DCKeywordList* other_this = (DCKeywordList*)from_this;
          return (DCAtomicField*)other_this;
    }
    if(from_type == &Dtool_DCPackerInterface)
    {
          DCPackerInterface* other_this = (DCPackerInterface*)from_this;
          return (DCAtomicField*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DCDeclaration 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual DCClass *DCDeclaration::as_class(void)
 * virtual DCClass const *DCDeclaration::as_class(void) const
 *******************************************************************/
static PyObject *Dtool_DCDeclaration_as_class_152(PyObject *self, PyObject *args,PyObject *kwds) {
    DCDeclaration * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCDeclaration,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 virtual DCClass *DCDeclaration::as_class(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":asClass", key_word_list));
        else
            (PyArg_Parse(args, ":asClass"));
        if(!PyErr_Occurred())
        {
            DCClass *return_value = (local_this)->as_class();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCClass,false, false);
            }
        }
        PyErr_Clear(); 
    }

    {
      // -2 virtual DCClass const *DCDeclaration::as_class(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":asClass", key_word_list));
        else
            (PyArg_Parse(args, ":asClass"));
        if(!PyErr_Occurred())
        {
            DCClass const *return_value = ((const DCDeclaration*)local_this)->as_class();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCClass,false, true);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "asClass(non-const DCDeclaration this)\n"
          "asClass(const DCDeclaration this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCDeclaration_as_class_152_comment =
    "C++ Interface:\n"
    "asClass(non-const DCDeclaration this)\n"
    "asClass(const DCDeclaration this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCDeclaration::as_class\n"
    "//       Access: Published, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCDeclaration::as_class\n"
    "//       Access: Published, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCDeclaration_as_class_152_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual DCSwitch *DCDeclaration::as_switch(void)
 * virtual DCSwitch const *DCDeclaration::as_switch(void) const
 *******************************************************************/
static PyObject *Dtool_DCDeclaration_as_switch_153(PyObject *self, PyObject *args,PyObject *kwds) {
    DCDeclaration * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCDeclaration,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // -2 virtual DCSwitch *DCDeclaration::as_switch(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":asSwitch", key_word_list));
        else
            (PyArg_Parse(args, ":asSwitch"));
        if(!PyErr_Occurred())
        {
            DCSwitch *return_value = (local_this)->as_switch();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCSwitch,false, false);
            }
        }
        PyErr_Clear(); 
    }

    {
      // -2 virtual DCSwitch const *DCDeclaration::as_switch(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":asSwitch", key_word_list));
        else
            (PyArg_Parse(args, ":asSwitch"));
        if(!PyErr_Occurred())
        {
            DCSwitch const *return_value = ((const DCDeclaration*)local_this)->as_switch();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCSwitch,false, true);
            }
        }
        PyErr_Clear(); 
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "asSwitch(non-const DCDeclaration this)\n"
          "asSwitch(const DCDeclaration this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCDeclaration_as_switch_153_comment =
    "C++ Interface:\n"
    "asSwitch(non-const DCDeclaration this)\n"
    "asSwitch(const DCDeclaration this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCDeclaration::as_switch\n"
    "//       Access: Published, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCDeclaration::as_switch\n"
    "//       Access: Published, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCDeclaration_as_switch_153_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void DCDeclaration::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_DCDeclaration_output_154(PyObject *self, PyObject *args,PyObject *kwds) {
    DCDeclaration * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCDeclaration,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void DCDeclaration::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DCDeclaration.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const DCDeclaration*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const DCDeclaration this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCDeclaration_output_154_comment =
    "C++ Interface:\n"
    "output(const DCDeclaration this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : DCDeclaration::output\n"
    "//       Access : Published, Virtual\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCDeclaration_output_154_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DCDeclaration::write(ostream &out, int indent_level) const
 *******************************************************************/
static PyObject *Dtool_DCDeclaration_write_155(PyObject *self, PyObject *args,PyObject *kwds) {
    DCDeclaration * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCDeclaration,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void DCDeclaration::write(ostream &out, int indent_level) const
            PyObject *param1;
            int param2;
            static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DCDeclaration.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const DCDeclaration*)local_this)->write(*param1_this, (int)param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const DCDeclaration this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCDeclaration_write_155_comment =
    "C++ Interface:\n"
    "write(const DCDeclaration this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : DCDeclaration::\n"
    "//       Access : Published\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCDeclaration_write_155_comment = NULL;
#endif

int  Dtool_Init_DCDeclaration(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (DCDeclaration)");
       return -1;
}
inline void  * Dtool_UpcastInterface_DCDeclaration(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DCDeclaration)
    {
        printf("DCDeclaration ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DCDeclaration * local_this = (DCDeclaration *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DCDeclaration)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DCDeclaration(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DCDeclaration)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DCClass 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline DCFile *DCClass::get_dc_file(void) const
 *******************************************************************/
static PyObject *Dtool_DCClass_get_dc_file_157(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline DCFile *DCClass::get_dc_file(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDcFile", key_word_list));
        else
            (PyArg_Parse(args, ":getDcFile"));
        if(!PyErr_Occurred())
        {
            DCFile *return_value = ((const DCClass*)local_this)->get_dc_file();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCFile,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDcFile(const DCClass this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_get_dc_file_157_comment =
    "C++ Interface:\n"
    "getDcFile(const DCClass this)\n"
    "\n"
    "// Filename: dcClass.I\n"
    "// Created by:  drose (15Sep04)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::get_dc_file\n"
    "//       Access: Published\n"
    "//  Description: Returns the DCFile object that contains the class.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_get_dc_file_157_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &DCClass::get_name(void) const
 *******************************************************************/
static PyObject *Dtool_DCClass_get_name_158(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &DCClass::get_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getName", key_word_list));
        else
            (PyArg_Parse(args, ":getName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const DCClass*)local_this)->get_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getName(const DCClass this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_get_name_158_comment =
    "C++ Interface:\n"
    "getName(const DCClass this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::get_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the name of this class.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_get_name_158_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DCClass::get_number(void) const
 *******************************************************************/
static PyObject *Dtool_DCClass_get_number_159(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DCClass::get_number(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumber", key_word_list));
        else
            (PyArg_Parse(args, ":getNumber"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DCClass*)local_this)->get_number();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumber(const DCClass this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_get_number_159_comment =
    "C++ Interface:\n"
    "getNumber(const DCClass this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::get_number\n"
    "//       Access: Published\n"
    "//  Description: Returns a unique index number associated with this\n"
    "//               class.  This is defined implicitly when the .dc\n"
    "//               file(s) are read.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_get_number_159_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DCClass::get_num_parents(void) const
 *******************************************************************/
static PyObject *Dtool_DCClass_get_num_parents_160(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DCClass::get_num_parents(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumParents", key_word_list));
        else
            (PyArg_Parse(args, ":getNumParents"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DCClass*)local_this)->get_num_parents();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumParents(const DCClass this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_get_num_parents_160_comment =
    "C++ Interface:\n"
    "getNumParents(const DCClass this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::get_num_parents\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of base classes this class\n"
    "//               inherits from.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_get_num_parents_160_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCClass *DCClass::get_parent(int n) const
 *******************************************************************/
static PyObject *Dtool_DCClass_get_parent_161(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DCClass *DCClass::get_parent(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParent", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParent", &param1));
        if(!PyErr_Occurred())
        {
            DCClass *return_value = ((const DCClass*)local_this)->get_parent((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCClass,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParent(const DCClass this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_get_parent_161_comment =
    "C++ Interface:\n"
    "getParent(const DCClass this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::get_parent\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth parent class this class inherits\n"
    "//               from.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_get_parent_161_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DCClass::has_constructor(void) const
 *******************************************************************/
static PyObject *Dtool_DCClass_has_constructor_162(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool DCClass::has_constructor(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasConstructor", key_word_list));
        else
            (PyArg_Parse(args, ":hasConstructor"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DCClass*)local_this)->has_constructor();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasConstructor(const DCClass this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_has_constructor_162_comment =
    "C++ Interface:\n"
    "hasConstructor(const DCClass this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::has_constructor\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this class has a constructor method,\n"
    "//               false if it just uses the default constructor.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_has_constructor_162_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCField *DCClass::get_constructor(void) const
 *******************************************************************/
static PyObject *Dtool_DCClass_get_constructor_163(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DCField *DCClass::get_constructor(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getConstructor", key_word_list));
        else
            (PyArg_Parse(args, ":getConstructor"));
        if(!PyErr_Occurred())
        {
            DCField *return_value = ((const DCClass*)local_this)->get_constructor();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCField,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getConstructor(const DCClass this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_get_constructor_163_comment =
    "C++ Interface:\n"
    "getConstructor(const DCClass this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::get_constructor\n"
    "//       Access: Published\n"
    "//  Description: Returns the constructor method for this class if it\n"
    "//               is defined, or NULL if the class uses the default\n"
    "//               constructor.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_get_constructor_163_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DCClass::get_num_fields(void) const
 *******************************************************************/
static PyObject *Dtool_DCClass_get_num_fields_164(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DCClass::get_num_fields(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumFields", key_word_list));
        else
            (PyArg_Parse(args, ":getNumFields"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DCClass*)local_this)->get_num_fields();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumFields(const DCClass this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_get_num_fields_164_comment =
    "C++ Interface:\n"
    "getNumFields(const DCClass this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::get_num_fields\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of fields defined directly in this\n"
    "//               class, ignoring inheritance.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_get_num_fields_164_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCField *DCClass::get_field(int n) const
 *******************************************************************/
static PyObject *Dtool_DCClass_get_field_165(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DCField *DCClass::get_field(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getField", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getField", &param1));
        if(!PyErr_Occurred())
        {
            DCField *return_value = ((const DCClass*)local_this)->get_field((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCField,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getField(const DCClass this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_get_field_165_comment =
    "C++ Interface:\n"
    "getField(const DCClass this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::get_field\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth field in the class.  This is not\n"
    "//               necessarily the field with index n; this is the nth\n"
    "//               field defined in the class directly, ignoring\n"
    "//               inheritance.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_get_field_165_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCField *DCClass::get_field_by_name(basic_string< char > const &name) const
 *******************************************************************/
static PyObject *Dtool_DCClass_get_field_by_name_166(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DCField *DCClass::get_field_by_name(basic_string< char > const &name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getFieldByName", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:getFieldByName", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            DCField *return_value = ((const DCClass*)local_this)->get_field_by_name(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCField,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFieldByName(const DCClass this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_get_field_by_name_166_comment =
    "C++ Interface:\n"
    "getFieldByName(const DCClass this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::get_field_by_name\n"
    "//       Access: Published\n"
    "//  Description: Returns a pointer to the DCField that shares the\n"
    "//               indicated name.  If the named field is not found in\n"
    "//               the current class, the parent classes will be\n"
    "//               searched, so the value returned may not actually be a\n"
    "//               field within this class.  Returns NULL if there is no\n"
    "//               such field defined.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_get_field_by_name_166_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCField *DCClass::get_field_by_index(int index_number) const
 *******************************************************************/
static PyObject *Dtool_DCClass_get_field_by_index_167(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DCField *DCClass::get_field_by_index(int index_number) const
        int param1;
        static char * key_word_list[] = {(char *)"index_number", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getFieldByIndex", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getFieldByIndex", &param1));
        if(!PyErr_Occurred())
        {
            DCField *return_value = ((const DCClass*)local_this)->get_field_by_index((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCField,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFieldByIndex(const DCClass this, int index_number)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_get_field_by_index_167_comment =
    "C++ Interface:\n"
    "getFieldByIndex(const DCClass this, int index_number)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::get_field_by_index\n"
    "//       Access: Published\n"
    "//  Description: Returns a pointer to the DCField that has the\n"
    "//               indicated index number.  If the numbered field is not\n"
    "//               found in the current class, the parent classes will\n"
    "//               be searched, so the value returned may not actually\n"
    "//               be a field within this class.  Returns NULL if there\n"
    "//               is no such field defined.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_get_field_by_index_167_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DCClass::get_num_inherited_fields(void) const
 *******************************************************************/
static PyObject *Dtool_DCClass_get_num_inherited_fields_168(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DCClass::get_num_inherited_fields(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumInheritedFields", key_word_list));
        else
            (PyArg_Parse(args, ":getNumInheritedFields"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DCClass*)local_this)->get_num_inherited_fields();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumInheritedFields(const DCClass this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_get_num_inherited_fields_168_comment =
    "C++ Interface:\n"
    "getNumInheritedFields(const DCClass this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::get_num_inherited_fields\n"
    "//       Access: Published\n"
    "//  Description: Returns the total number of field fields defined in\n"
    "//               this class and all ancestor classes.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_get_num_inherited_fields_168_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCField *DCClass::get_inherited_field(int n) const
 *******************************************************************/
static PyObject *Dtool_DCClass_get_inherited_field_169(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DCField *DCClass::get_inherited_field(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getInheritedField", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getInheritedField", &param1));
        if(!PyErr_Occurred())
        {
            DCField *return_value = ((const DCClass*)local_this)->get_inherited_field((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCField,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInheritedField(const DCClass this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_get_inherited_field_169_comment =
    "C++ Interface:\n"
    "getInheritedField(const DCClass this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::get_inherited_field\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth field field in the class and all of\n"
    "//               its ancestors.  \n"
    "//\n"
    "//               This *used* to be the same thing as\n"
    "//               get_field_by_index(), back when the fields were\n"
    "//               numbered sequentially within a class's inheritance\n"
    "//               hierarchy.  Now that fields have a globally unique\n"
    "//               index number, this is no longer true.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_get_inherited_field_169_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DCClass::is_struct(void) const
 *******************************************************************/
static PyObject *Dtool_DCClass_is_struct_170(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DCClass::is_struct(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isStruct", key_word_list));
        else
            (PyArg_Parse(args, ":isStruct"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DCClass*)local_this)->is_struct();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isStruct(const DCClass this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_is_struct_170_comment =
    "C++ Interface:\n"
    "isStruct(const DCClass this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::is_struct\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the class has been identified with\n"
    "//               the \"struct\" keyword in the dc file, false if it was\n"
    "//               declared with \"dclass\".\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_is_struct_170_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DCClass::is_bogus_class(void) const
 *******************************************************************/
static PyObject *Dtool_DCClass_is_bogus_class_171(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DCClass::is_bogus_class(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isBogusClass", key_word_list));
        else
            (PyArg_Parse(args, ":isBogusClass"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DCClass*)local_this)->is_bogus_class();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isBogusClass(const DCClass this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_is_bogus_class_171_comment =
    "C++ Interface:\n"
    "isBogusClass(const DCClass this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::is_bogus_class\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the class has been flagged as a bogus\n"
    "//               class.  This is set for classes that are generated by\n"
    "//               the parser as placeholder for missing classes, as\n"
    "//               when reading a partial file; it should not occur in a\n"
    "//               normal valid dc file.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_is_bogus_class_171_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DCClass::inherits_from_bogus_class(void) const
 *******************************************************************/
static PyObject *Dtool_DCClass_inherits_from_bogus_class_172(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool DCClass::inherits_from_bogus_class(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":inheritsFromBogusClass", key_word_list));
        else
            (PyArg_Parse(args, ":inheritsFromBogusClass"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DCClass*)local_this)->inherits_from_bogus_class();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "inheritsFromBogusClass(const DCClass this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_inherits_from_bogus_class_172_comment =
    "C++ Interface:\n"
    "inheritsFromBogusClass(const DCClass this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : DCClass::inherits_from_bogus_class\n"
    "//       Access : Published\n"
    "//  Description : Returns true if this class, or any class in the\n"
    "//                inheritance heirarchy for this class, is a \"bogus\"\n"
    "//                class--a forward reference to an as-yet-undefined\n"
    "//                class.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_inherits_from_bogus_class_172_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DCClass::start_generate(void)
 *******************************************************************/
static PyObject *Dtool_DCClass_start_generate_173(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DCClass::start_generate(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":startGenerate", key_word_list));
        else
            (PyArg_Parse(args, ":startGenerate"));
        if(!PyErr_Occurred())
        {
            (local_this)->start_generate();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCClass.startGenerate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "startGenerate(non-const DCClass this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_start_generate_173_comment =
    "C++ Interface:\n"
    "startGenerate(non-const DCClass this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::start_generate\n"
    "//       Access: Published\n"
    "//  Description: Starts the PStats timer going on the \"generate\" task,\n"
    "//               that is, marks the beginning of the process of\n"
    "//               generating a new object, for the purposes of timing\n"
    "//               this process.\n"
    "//\n"
    "//               This should balance with a corresponding call to\n"
    "//               stop_generate().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_start_generate_173_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DCClass::stop_generate(void)
 *******************************************************************/
static PyObject *Dtool_DCClass_stop_generate_174(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DCClass::stop_generate(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":stopGenerate", key_word_list));
        else
            (PyArg_Parse(args, ":stopGenerate"));
        if(!PyErr_Occurred())
        {
            (local_this)->stop_generate();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCClass.stopGenerate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "stopGenerate(non-const DCClass this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_stop_generate_174_comment =
    "C++ Interface:\n"
    "stopGenerate(non-const DCClass this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::stop_generate\n"
    "//       Access: Published\n"
    "//  Description: Stops the PStats timer on the \"generate\" task.\n"
    "//               This should balance with a preceding call to\n"
    "//               start_generate().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_stop_generate_174_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void DCClass::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_DCClass_output_175(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void DCClass::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DCClass.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const DCClass*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const DCClass this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_output_175_comment =
    "C++ Interface:\n"
    "output(const DCClass this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : DCClass::output\n"
    "//       Access : Published, Virtual\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "// HAVE_PYTHON\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function : DCClass::output\n"
    "//       Access : Public, Virtual\n"
    "//  Description : Write a string representation of this instance to\n"
    "//                <out>.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_output_175_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DCClass::has_class_def(void) const
 *******************************************************************/
static PyObject *Dtool_DCClass_has_class_def_176(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool DCClass::has_class_def(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasClassDef", key_word_list));
        else
            (PyArg_Parse(args, ":hasClassDef"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DCClass*)local_this)->has_class_def();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasClassDef(const DCClass this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_has_class_def_176_comment =
    "C++ Interface:\n"
    "hasClassDef(const DCClass this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::has_class_def\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the DCClass object has an associated\n"
    "//               Python class definition, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_has_class_def_176_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DCClass::set_class_def(PyObject *class_def)
 *******************************************************************/
static PyObject *Dtool_DCClass_set_class_def_177(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DCClass::set_class_def(PyObject *class_def)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"class_def", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setClassDef", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setClassDef", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_class_def(param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCClass.setClassDef() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setClassDef(non-const DCClass this, any class_def)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_set_class_def_177_comment =
    "C++ Interface:\n"
    "setClassDef(non-const DCClass this, any class_def)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::set_class_def\n"
    "//       Access: Published\n"
    "//  Description: Sets the class object associated with this\n"
    "//               DistributedClass.  This object will be used to\n"
    "//               construct new instances of the class.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_set_class_def_177_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PyObject *DCClass::get_class_def(void) const
 *******************************************************************/
static PyObject *Dtool_DCClass_get_class_def_178(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PyObject *DCClass::get_class_def(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassDef", key_word_list));
        else
            (PyArg_Parse(args, ":getClassDef"));
        if(!PyErr_Occurred())
        {
            PyObject *return_value = ((const DCClass*)local_this)->get_class_def();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return  return_value;
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassDef(const DCClass this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_get_class_def_178_comment =
    "C++ Interface:\n"
    "getClassDef(const DCClass this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::get_class_def\n"
    "//       Access: Published\n"
    "//  Description: Returns the class object that was previously\n"
    "//               associated with this DistributedClass.  This will\n"
    "//               return a new reference to the object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_get_class_def_178_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DCClass::has_owner_class_def(void) const
 *******************************************************************/
static PyObject *Dtool_DCClass_has_owner_class_def_179(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool DCClass::has_owner_class_def(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasOwnerClassDef", key_word_list));
        else
            (PyArg_Parse(args, ":hasOwnerClassDef"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DCClass*)local_this)->has_owner_class_def();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasOwnerClassDef(const DCClass this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_has_owner_class_def_179_comment =
    "C++ Interface:\n"
    "hasOwnerClassDef(const DCClass this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::has_owner_class_def\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the DCClass object has an associated\n"
    "//               Python owner class definition, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_has_owner_class_def_179_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DCClass::set_owner_class_def(PyObject *owner_class_def)
 *******************************************************************/
static PyObject *Dtool_DCClass_set_owner_class_def_180(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DCClass::set_owner_class_def(PyObject *owner_class_def)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"owner_class_def", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setOwnerClassDef", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setOwnerClassDef", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_owner_class_def(param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCClass.setOwnerClassDef() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setOwnerClassDef(non-const DCClass this, any owner_class_def)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_set_owner_class_def_180_comment =
    "C++ Interface:\n"
    "setOwnerClassDef(non-const DCClass this, any owner_class_def)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::set_owner_class_def\n"
    "//       Access: Published\n"
    "//  Description: Sets the owner class object associated with this\n"
    "//               DistributedClass.  This object will be used to\n"
    "//               construct new owner instances of the class.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_set_owner_class_def_180_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PyObject *DCClass::get_owner_class_def(void) const
 *******************************************************************/
static PyObject *Dtool_DCClass_get_owner_class_def_181(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PyObject *DCClass::get_owner_class_def(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOwnerClassDef", key_word_list));
        else
            (PyArg_Parse(args, ":getOwnerClassDef"));
        if(!PyErr_Occurred())
        {
            PyObject *return_value = ((const DCClass*)local_this)->get_owner_class_def();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return  return_value;
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOwnerClassDef(const DCClass this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_get_owner_class_def_181_comment =
    "C++ Interface:\n"
    "getOwnerClassDef(const DCClass this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::get_owner_class_def\n"
    "//       Access: Published\n"
    "//  Description: Returns the owner class object that was previously\n"
    "//               associated with this DistributedClass.  This will\n"
    "//               return a new reference to the object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_get_owner_class_def_181_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DCClass::receive_update(PyObject *distobj, DatagramIterator &di) const
 *******************************************************************/
static PyObject *Dtool_DCClass_receive_update_182(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void DCClass::receive_update(PyObject *distobj, DatagramIterator &di) const
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"distobj", (char *)"di", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:receiveUpdate", key_word_list, &param1, &param2))
            {
                DatagramIterator *param2_this = (DatagramIterator *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DatagramIterator, 2, "DCClass.receiveUpdate", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    ((const DCClass*)local_this)->receive_update(param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "receiveUpdate(const DCClass this, any distobj, non-const DatagramIterator di)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_receive_update_182_comment =
    "C++ Interface:\n"
    "receiveUpdate(const DCClass this, any distobj, non-const DatagramIterator di)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::receive_update\n"
    "//       Access: Published\n"
    "//  Description: Extracts the update message out of the packer and\n"
    "//               applies it to the indicated object by calling the\n"
    "//               appropriate method.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_receive_update_182_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DCClass::receive_update_broadcast_required(PyObject *distobj, DatagramIterator &di) const
 *******************************************************************/
static PyObject *Dtool_DCClass_receive_update_broadcast_required_183(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void DCClass::receive_update_broadcast_required(PyObject *distobj, DatagramIterator &di) const
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"distobj", (char *)"di", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:receiveUpdateBroadcastRequired", key_word_list, &param1, &param2))
            {
                DatagramIterator *param2_this = (DatagramIterator *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DatagramIterator, 2, "DCClass.receiveUpdateBroadcastRequired", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    ((const DCClass*)local_this)->receive_update_broadcast_required(param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "receiveUpdateBroadcastRequired(const DCClass this, any distobj, non-const DatagramIterator di)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_receive_update_broadcast_required_183_comment =
    "C++ Interface:\n"
    "receiveUpdateBroadcastRequired(const DCClass this, any distobj, non-const DatagramIterator di)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::receive_update_broadcast_required\n"
    "//       Access: Published\n"
    "//  Description: Processes a big datagram that includes all of the\n"
    "//               \"required\" fields that are sent along with a normal\n"
    "//               \"generate with required\" message.  This is all of the\n"
    "//               atomic fields that are marked \"broadcast required\".\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_receive_update_broadcast_required_183_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DCClass::receive_update_broadcast_required_owner(PyObject *distobj, DatagramIterator &di) const
 *******************************************************************/
static PyObject *Dtool_DCClass_receive_update_broadcast_required_owner_184(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void DCClass::receive_update_broadcast_required_owner(PyObject *distobj, DatagramIterator &di) const
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"distobj", (char *)"di", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:receiveUpdateBroadcastRequiredOwner", key_word_list, &param1, &param2))
            {
                DatagramIterator *param2_this = (DatagramIterator *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DatagramIterator, 2, "DCClass.receiveUpdateBroadcastRequiredOwner", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    ((const DCClass*)local_this)->receive_update_broadcast_required_owner(param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "receiveUpdateBroadcastRequiredOwner(const DCClass this, any distobj, non-const DatagramIterator di)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_receive_update_broadcast_required_owner_184_comment =
    "C++ Interface:\n"
    "receiveUpdateBroadcastRequiredOwner(const DCClass this, any distobj, non-const DatagramIterator di)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::receive_update_broadcast_required_owner\n"
    "//       Access: Published\n"
    "//  Description: Processes a big datagram that includes all of the\n"
    "//               \"required\" fields that are sent along with a normal\n"
    "//               \"generate with required\" message.  This is all of the\n"
    "//               atomic fields that are marked \"broadcast ownrecv\". Should\n"
    "//               be used for 'owner-view' objects.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_receive_update_broadcast_required_owner_184_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DCClass::receive_update_all_required(PyObject *distobj, DatagramIterator &di) const
 *******************************************************************/
static PyObject *Dtool_DCClass_receive_update_all_required_185(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void DCClass::receive_update_all_required(PyObject *distobj, DatagramIterator &di) const
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"distobj", (char *)"di", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:receiveUpdateAllRequired", key_word_list, &param1, &param2))
            {
                DatagramIterator *param2_this = (DatagramIterator *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DatagramIterator, 2, "DCClass.receiveUpdateAllRequired", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    ((const DCClass*)local_this)->receive_update_all_required(param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "receiveUpdateAllRequired(const DCClass this, any distobj, non-const DatagramIterator di)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_receive_update_all_required_185_comment =
    "C++ Interface:\n"
    "receiveUpdateAllRequired(const DCClass this, any distobj, non-const DatagramIterator di)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::receive_update_all_required\n"
    "//       Access: Published\n"
    "//  Description: Processes a big datagram that includes all of the\n"
    "//               \"required\" fields that are sent when an avatar is\n"
    "//               created.  This is all of the atomic fields that are\n"
    "//               marked \"required\", whether they are broadcast or not.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_receive_update_all_required_185_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DCClass::receive_update_other(PyObject *distobj, DatagramIterator &di) const
 *******************************************************************/
static PyObject *Dtool_DCClass_receive_update_other_186(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void DCClass::receive_update_other(PyObject *distobj, DatagramIterator &di) const
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"distobj", (char *)"di", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:receiveUpdateOther", key_word_list, &param1, &param2))
            {
                DatagramIterator *param2_this = (DatagramIterator *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DatagramIterator, 2, "DCClass.receiveUpdateOther", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    ((const DCClass*)local_this)->receive_update_other(param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "receiveUpdateOther(const DCClass this, any distobj, non-const DatagramIterator di)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_receive_update_other_186_comment =
    "C++ Interface:\n"
    "receiveUpdateOther(const DCClass this, any distobj, non-const DatagramIterator di)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::receive_update_other\n"
    "//       Access: Published\n"
    "//  Description: Processes a datagram that lists some additional\n"
    "//               fields that are broadcast in one chunk.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_receive_update_other_186_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DCClass::direct_update(PyObject *distobj, basic_string< char > const &field_name, Datagram const &datagram)
 * void DCClass::direct_update(PyObject *distobj, basic_string< char > const &field_name, basic_string< char > const &value_blob)
 *******************************************************************/
static PyObject *Dtool_DCClass_direct_update_187(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 void DCClass::direct_update(PyObject *distobj, basic_string< char > const &field_name, basic_string< char > const &value_blob)
            PyObject *param1;
            char *param2_str; int param2_len;
            char *param3_str; int param3_len;
            static char * key_word_list[] = {(char *)"distobj", (char *)"field_name", (char *)"value_blob", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#s#:directUpdate", key_word_list, &param1, &param2_str, &param2_len, &param3_str, &param3_len))
            {
                (local_this)->direct_update(param1, basic_string<char>(param2_str, param2_len), basic_string<char>(param3_str, param3_len));
                Py_XDECREF(coerced);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 void DCClass::direct_update(PyObject *distobj, basic_string< char > const &field_name, Datagram const &datagram)
            PyObject *param1;
            char *param2_str; int param2_len;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"distobj", (char *)"field_name", (char *)"datagram", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#O:directUpdate", key_word_list, &param1, &param2_str, &param2_len, &param3))
            {
                Datagram *param3_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_Datagram, 3, "DCClass.directUpdate", 1, coerced_ptr, report_errors);

                if (!((param3_this == NULL)))
                {
                    (local_this)->direct_update(param1, basic_string<char>(param2_str, param2_len), *param3_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "directUpdate(non-const DCClass this, any distobj, string field_name, string value_blob)\n"
          "directUpdate(non-const DCClass this, any distobj, string field_name, const Datagram datagram)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_direct_update_187_comment =
    "C++ Interface:\n"
    "directUpdate(non-const DCClass this, any distobj, string field_name, string value_blob)\n"
    "directUpdate(non-const DCClass this, any distobj, string field_name, const Datagram datagram)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::direct_update\n"
    "//       Access: Published\n"
    "//  Description: Processes an update for a named field from a packed\n"
    "//               value blob.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::direct_update\n"
    "//       Access: Published\n"
    "//  Description: Processes an update for a named field from a packed\n"
    "//               datagram.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_direct_update_187_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DCClass::pack_required_field(DCPacker &packer, PyObject *distobj, DCField const *field) const
 * bool DCClass::pack_required_field(Datagram &datagram, PyObject *distobj, DCField const *field) const
 *******************************************************************/
static PyObject *Dtool_DCClass_pack_required_field_188(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 bool DCClass::pack_required_field(Datagram &datagram, PyObject *distobj, DCField const *field) const
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"datagram", (char *)"distobj", (char *)"field", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:packRequiredField", key_word_list, &param1, &param2, &param3))
            {
                Datagram *param1_this = (Datagram *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Datagram, 1, "DCClass.packRequiredField", 0, coerced_ptr, report_errors);
DCField *param3_this = (DCField *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_DCField, 3, "DCClass.packRequiredField", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param3_this == NULL)))
                {
                    bool return_value = ((const DCClass*)local_this)->pack_required_field(*param1_this, param2, param3_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 bool DCClass::pack_required_field(DCPacker &packer, PyObject *distobj, DCField const *field) const
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"packer", (char *)"distobj", (char *)"field", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:packRequiredField", key_word_list, &param1, &param2, &param3))
            {
                DCPacker *param1_this = (DCPacker *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DCPacker, 1, "DCClass.packRequiredField", 0, coerced_ptr, report_errors);
DCField *param3_this = (DCField *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_DCField, 3, "DCClass.packRequiredField", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param3_this == NULL)))
                {
                    bool return_value = ((const DCClass*)local_this)->pack_required_field(*param1_this, param2, param3_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "packRequiredField(const DCClass this, non-const Datagram datagram, any distobj, const DCField field)\n"
          "packRequiredField(const DCClass this, non-const DCPacker packer, any distobj, const DCField field)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_pack_required_field_188_comment =
    "C++ Interface:\n"
    "packRequiredField(const DCClass this, non-const Datagram datagram, any distobj, const DCField field)\n"
    "packRequiredField(const DCClass this, non-const DCPacker packer, any distobj, const DCField field)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::pack_required_field\n"
    "//       Access: Published\n"
    "//  Description: Looks up the current value of the indicated field by\n"
    "//               calling the appropriate get*() function, then packs\n"
    "//               that value into the datagram.  This field is\n"
    "//               presumably either a required field or a specified\n"
    "//               optional field, and we are building up a datagram for\n"
    "//               the generate-with-required message.\n"
    "//\n"
    "//               Returns true on success, false on failure.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::pack_required_field\n"
    "//       Access: Published\n"
    "//  Description: Looks up the current value of the indicated field by\n"
    "//               calling the appropriate get*() function, then packs\n"
    "//               that value into the packer.  This field is\n"
    "//               presumably either a required field or a specified\n"
    "//               optional field, and we are building up a datagram for\n"
    "//               the generate-with-required message.\n"
    "//\n"
    "//               Returns true on success, false on failure.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_pack_required_field_188_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Datagram DCClass::client_format_update(basic_string< char > const &field_name, unsigned int do_id, PyObject *args) const
 *******************************************************************/
static PyObject *Dtool_DCClass_client_format_update_189(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-Datagram DCClass::client_format_update(basic_string< char > const &field_name, unsigned int do_id, PyObject *args) const
        char *param1_str; int param1_len;
        PyObject *param2;
        PyObject *param3;
        static char * key_word_list[] = {(char *)"field_name", (char *)"do_id", (char *)"args", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#OO:clientFormatUpdate", key_word_list, &param1_str, &param1_len, &param2, &param3))
        {
             PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param2_uint == NULL)))
            {
                Datagram result = ((const DCClass*)local_this)->client_format_update(basic_string<char>(param1_str, param1_len), PyLong_AsUnsignedLong(param2_uint), param3);
                Datagram *return_value = new Datagram(result);
                 Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Datagram,true, false, (return_value)->as_typed_object()->get_type_index());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clientFormatUpdate(const DCClass this, string field_name, unsigned int do_id, any args)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_client_format_update_189_comment =
    "C++ Interface:\n"
    "clientFormatUpdate(const DCClass this, string field_name, unsigned int do_id, any args)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::client_format_update\n"
    "//       Access: Published\n"
    "//  Description: Generates a datagram containing the message necessary\n"
    "//               to send an update for the indicated distributed\n"
    "//               object from the client.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_client_format_update_189_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Datagram DCClass::ai_format_update(basic_string< char > const &field_name, unsigned int do_id, unsigned __int64 to_id, unsigned __int64 from_id, PyObject *args) const
 *******************************************************************/
static PyObject *Dtool_DCClass_ai_format_update_190(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-Datagram DCClass::ai_format_update(basic_string< char > const &field_name, unsigned int do_id, unsigned __int64 to_id, unsigned __int64 from_id, PyObject *args) const
        char *param1_str; int param1_len;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        PyObject *param5;
        static char * key_word_list[] = {(char *)"field_name", (char *)"do_id", (char *)"to_id", (char *)"from_id", (char *)"args", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#OOOO:aiFormatUpdate", key_word_list, &param1_str, &param1_len, &param2, &param3, &param4, &param5))
        {
             PyObject *param2_uint = PyNumber_Long(param2); PyObject *param3_long = PyNumber_Long(param3); PyObject *param4_long = PyNumber_Long(param4);
            if (!((param2_uint == NULL)|| (param3_long == NULL)|| (param4_long == NULL)))
            {
                Datagram result = ((const DCClass*)local_this)->ai_format_update(basic_string<char>(param1_str, param1_len), PyLong_AsUnsignedLong(param2_uint), PyLong_AsUnsignedLongLong(param3_long), PyLong_AsUnsignedLongLong(param4_long), param5);
                Datagram *return_value = new Datagram(result);
                 Py_XDECREF(param2_uint); Py_XDECREF(param3_long); Py_XDECREF(param4_long);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Datagram,true, false, (return_value)->as_typed_object()->get_type_index());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "aiFormatUpdate(const DCClass this, string field_name, unsigned int do_id, unsigned long long to_id, unsigned long long from_id, any args)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_ai_format_update_190_comment =
    "C++ Interface:\n"
    "aiFormatUpdate(const DCClass this, string field_name, unsigned int do_id, unsigned long long to_id, unsigned long long from_id, any args)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::ai_format_update\n"
    "//       Access: Published\n"
    "//  Description: Generates a datagram containing the message necessary\n"
    "//               to send an update for the indicated distributed\n"
    "//               object from the AI.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_ai_format_update_190_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Datagram DCClass::ai_format_update_msg_type(basic_string< char > const &field_name, unsigned int do_id, unsigned __int64 to_id, unsigned __int64 from_id, int msg_type, PyObject *args) const
 *******************************************************************/
static PyObject *Dtool_DCClass_ai_format_update_msg_type_191(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-Datagram DCClass::ai_format_update_msg_type(basic_string< char > const &field_name, unsigned int do_id, unsigned __int64 to_id, unsigned __int64 from_id, int msg_type, PyObject *args) const
        char *param1_str; int param1_len;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        int param5;
        PyObject *param6;
        static char * key_word_list[] = {(char *)"field_name", (char *)"do_id", (char *)"to_id", (char *)"from_id", (char *)"msg_type", (char *)"args", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#OOOiO:aiFormatUpdateMsgType", key_word_list, &param1_str, &param1_len, &param2, &param3, &param4, &param5, &param6))
        {
             PyObject *param2_uint = PyNumber_Long(param2); PyObject *param3_long = PyNumber_Long(param3); PyObject *param4_long = PyNumber_Long(param4);
            if (!((param2_uint == NULL)|| (param3_long == NULL)|| (param4_long == NULL)))
            {
                Datagram result = ((const DCClass*)local_this)->ai_format_update_msg_type(basic_string<char>(param1_str, param1_len), PyLong_AsUnsignedLong(param2_uint), PyLong_AsUnsignedLongLong(param3_long), PyLong_AsUnsignedLongLong(param4_long), (int)param5, param6);
                Datagram *return_value = new Datagram(result);
                 Py_XDECREF(param2_uint); Py_XDECREF(param3_long); Py_XDECREF(param4_long);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Datagram,true, false, (return_value)->as_typed_object()->get_type_index());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "aiFormatUpdateMsgType(const DCClass this, string field_name, unsigned int do_id, unsigned long long to_id, unsigned long long from_id, int msg_type, any args)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_ai_format_update_msg_type_191_comment =
    "C++ Interface:\n"
    "aiFormatUpdateMsgType(const DCClass this, string field_name, unsigned int do_id, unsigned long long to_id, unsigned long long from_id, int msg_type, any args)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::ai_format_update_msg_type\n"
    "//       Access: Published\n"
    "//  Description: Generates a datagram containing the message necessary\n"
    "//               to send an update, using the indicated msg type\n"
    "//               for the indicated distributed\n"
    "//               object from the AI.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_ai_format_update_msg_type_191_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Datagram DCClass::ai_format_generate(PyObject *distobj, unsigned int do_id, unsigned int parent_id, unsigned int zone_id, unsigned __int64 district_channel_id, unsigned __int64 from_channel_id, PyObject *optional_fields) const
 *******************************************************************/
static PyObject *Dtool_DCClass_ai_format_generate_192(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-Datagram DCClass::ai_format_generate(PyObject *distobj, unsigned int do_id, unsigned int parent_id, unsigned int zone_id, unsigned __int64 district_channel_id, unsigned __int64 from_channel_id, PyObject *optional_fields) const
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        PyObject *param5;
        PyObject *param6;
        PyObject *param7;
        static char * key_word_list[] = {(char *)"distobj", (char *)"do_id", (char *)"parent_id", (char *)"zone_id", (char *)"district_channel_id", (char *)"from_channel_id", (char *)"optional_fields", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOOOOO:aiFormatGenerate", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7))
        {
             PyObject *param2_uint = PyNumber_Long(param2); PyObject *param3_uint = PyNumber_Long(param3); PyObject *param4_uint = PyNumber_Long(param4); PyObject *param5_long = PyNumber_Long(param5); PyObject *param6_long = PyNumber_Long(param6);
            if (!((param2_uint == NULL)|| (param3_uint == NULL)|| (param4_uint == NULL)|| (param5_long == NULL)|| (param6_long == NULL)))
            {
                Datagram result = ((const DCClass*)local_this)->ai_format_generate(param1, PyLong_AsUnsignedLong(param2_uint), PyLong_AsUnsignedLong(param3_uint), PyLong_AsUnsignedLong(param4_uint), PyLong_AsUnsignedLongLong(param5_long), PyLong_AsUnsignedLongLong(param6_long), param7);
                Datagram *return_value = new Datagram(result);
                 Py_XDECREF(param2_uint); Py_XDECREF(param3_uint); Py_XDECREF(param4_uint); Py_XDECREF(param5_long); Py_XDECREF(param6_long);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Datagram,true, false, (return_value)->as_typed_object()->get_type_index());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "aiFormatGenerate(const DCClass this, any distobj, unsigned int do_id, unsigned int parent_id, unsigned int zone_id, unsigned long long district_channel_id, unsigned long long from_channel_id, any optional_fields)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_ai_format_generate_192_comment =
    "C++ Interface:\n"
    "aiFormatGenerate(const DCClass this, any distobj, unsigned int do_id, unsigned int parent_id, unsigned int zone_id, unsigned long long district_channel_id, unsigned long long from_channel_id, any optional_fields)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::ai_format_generate\n"
    "//       Access: Published\n"
    "//  Description: Generates a datagram containing the message necessary\n"
    "//               to generate a new distributed object from the AI.\n"
    "//               This requires querying the object for the initial\n"
    "//               value of its required fields.\n"
    "//\n"
    "//               optional_fields is a list of fieldNames to generate\n"
    "//               in addition to the normal required fields.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_ai_format_generate_192_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Datagram DCClass::client_format_generate_CMU(PyObject *distobj, unsigned int do_id, unsigned int zone_id, PyObject *optional_fields) const
 *******************************************************************/
static PyObject *Dtool_DCClass_client_format_generate_CMU_193(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-Datagram DCClass::client_format_generate_CMU(PyObject *distobj, unsigned int do_id, unsigned int zone_id, PyObject *optional_fields) const
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        static char * key_word_list[] = {(char *)"distobj", (char *)"do_id", (char *)"zone_id", (char *)"optional_fields", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOO:clientFormatGenerateCMU", key_word_list, &param1, &param2, &param3, &param4))
        {
             PyObject *param2_uint = PyNumber_Long(param2); PyObject *param3_uint = PyNumber_Long(param3);
            if (!((param2_uint == NULL)|| (param3_uint == NULL)))
            {
                Datagram result = ((const DCClass*)local_this)->client_format_generate_CMU(param1, PyLong_AsUnsignedLong(param2_uint), PyLong_AsUnsignedLong(param3_uint), param4);
                Datagram *return_value = new Datagram(result);
                 Py_XDECREF(param2_uint); Py_XDECREF(param3_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Datagram,true, false, (return_value)->as_typed_object()->get_type_index());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clientFormatGenerateCMU(const DCClass this, any distobj, unsigned int do_id, unsigned int zone_id, any optional_fields)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_client_format_generate_CMU_193_comment =
    "C++ Interface:\n"
    "clientFormatGenerateCMU(const DCClass this, any distobj, unsigned int do_id, unsigned int zone_id, any optional_fields)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::client_format_generate_CMU\n"
    "//       Access: Published\n"
    "//  Description: Generates a datagram containing the message necessary\n"
    "//               to generate a new distributed object from the client.\n"
    "//               This requires querying the object for the initial\n"
    "//               value of its required fields.\n"
    "//\n"
    "//               optional_fields is a list of fieldNames to generate\n"
    "//               in addition to the normal required fields.\n"
    "//\n"
    "//               This method is only called by the CMU implementation.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_client_format_generate_CMU_193_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Datagram DCClass::ai_database_generate_context(unsigned int context_id, unsigned int parent_id, unsigned int zone_id, unsigned __int64 owner_channel, unsigned __int64 database_server_id, unsigned __int64 from_channel_id) const
 *******************************************************************/
static PyObject *Dtool_DCClass_ai_database_generate_context_194(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-Datagram DCClass::ai_database_generate_context(unsigned int context_id, unsigned int parent_id, unsigned int zone_id, unsigned __int64 owner_channel, unsigned __int64 database_server_id, unsigned __int64 from_channel_id) const
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        PyObject *param5;
        PyObject *param6;
        static char * key_word_list[] = {(char *)"context_id", (char *)"parent_id", (char *)"zone_id", (char *)"owner_channel", (char *)"database_server_id", (char *)"from_channel_id", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOOOO:aiDatabaseGenerateContext", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2); PyObject *param3_uint = PyNumber_Long(param3); PyObject *param4_long = PyNumber_Long(param4); PyObject *param5_long = PyNumber_Long(param5); PyObject *param6_long = PyNumber_Long(param6);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)|| (param3_uint == NULL)|| (param4_long == NULL)|| (param5_long == NULL)|| (param6_long == NULL)))
            {
                Datagram result = ((const DCClass*)local_this)->ai_database_generate_context(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint), PyLong_AsUnsignedLong(param3_uint), PyLong_AsUnsignedLongLong(param4_long), PyLong_AsUnsignedLongLong(param5_long), PyLong_AsUnsignedLongLong(param6_long));
                Datagram *return_value = new Datagram(result);
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint); Py_XDECREF(param3_uint); Py_XDECREF(param4_long); Py_XDECREF(param5_long); Py_XDECREF(param6_long);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Datagram,true, false, (return_value)->as_typed_object()->get_type_index());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "aiDatabaseGenerateContext(const DCClass this, unsigned int context_id, unsigned int parent_id, unsigned int zone_id, unsigned long long owner_channel, unsigned long long database_server_id, unsigned long long from_channel_id)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_ai_database_generate_context_194_comment =
    "C++ Interface:\n"
    "aiDatabaseGenerateContext(const DCClass this, unsigned int context_id, unsigned int parent_id, unsigned int zone_id, unsigned long long owner_channel, unsigned long long database_server_id, unsigned long long from_channel_id)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::ai_database_generate_context\n"
    "//       Access: Published\n"
    "//  Description: Generates a datagram containing the message necessary\n"
    "//               to create a new database distributed object from the AI.\n"
    "//\n"
    "//               First Pass is to only incldue required values\n"
    "//               (with Defaults).                   \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_ai_database_generate_context_194_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Datagram DCClass::ai_database_generate_context_old(unsigned int context_id, unsigned int parent_id, unsigned int zone_id, unsigned __int64 database_server_id, unsigned __int64 from_channel_id) const
 *******************************************************************/
static PyObject *Dtool_DCClass_ai_database_generate_context_old_195(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-Datagram DCClass::ai_database_generate_context_old(unsigned int context_id, unsigned int parent_id, unsigned int zone_id, unsigned __int64 database_server_id, unsigned __int64 from_channel_id) const
        PyObject *param1;
        PyObject *param2;
        PyObject *param3;
        PyObject *param4;
        PyObject *param5;
        static char * key_word_list[] = {(char *)"context_id", (char *)"parent_id", (char *)"zone_id", (char *)"database_server_id", (char *)"from_channel_id", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOOO:aiDatabaseGenerateContextOld", key_word_list, &param1, &param2, &param3, &param4, &param5))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2); PyObject *param3_uint = PyNumber_Long(param3); PyObject *param4_long = PyNumber_Long(param4); PyObject *param5_long = PyNumber_Long(param5);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)|| (param3_uint == NULL)|| (param4_long == NULL)|| (param5_long == NULL)))
            {
                Datagram result = ((const DCClass*)local_this)->ai_database_generate_context_old(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint), PyLong_AsUnsignedLong(param3_uint), PyLong_AsUnsignedLongLong(param4_long), PyLong_AsUnsignedLongLong(param5_long));
                Datagram *return_value = new Datagram(result);
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint); Py_XDECREF(param3_uint); Py_XDECREF(param4_long); Py_XDECREF(param5_long);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Datagram,true, false, (return_value)->as_typed_object()->get_type_index());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "aiDatabaseGenerateContextOld(const DCClass this, unsigned int context_id, unsigned int parent_id, unsigned int zone_id, unsigned long long database_server_id, unsigned long long from_channel_id)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClass_ai_database_generate_context_old_195_comment =
    "C++ Interface:\n"
    "aiDatabaseGenerateContextOld(const DCClass this, unsigned int context_id, unsigned int parent_id, unsigned int zone_id, unsigned long long database_server_id, unsigned long long from_channel_id)\n"
    "\n"
    "// TODO: remove this once Skyler has things working with the new server\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClass::ai_database_generate_context_old\n"
    "//       Access: Published\n"
    "//  Description: Generates a datagram containing the message necessary\n"
    "//               to create a new database distributed object from the AI.\n"
    "//\n"
    "//               First Pass is to only incldue required values\n"
    "//               (with Defaults).                   \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClass_ai_database_generate_context_old_195_comment = NULL;
#endif

int  Dtool_Init_DCClass(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (DCClass)");
       return -1;
}
inline void  * Dtool_UpcastInterface_DCClass(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DCClass)
    {
        printf("DCClass ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DCClass * local_this = (DCClass *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DCClass)
        return local_this;
    if(requested_type == &Dtool_DCDeclaration)
        return ( DCDeclaration *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DCClass(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DCClass)
        return from_this;
    if(from_type == &Dtool_DCDeclaration)
    {
          DCDeclaration* other_this = (DCDeclaration*)from_this;
          return (DCClass*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DCClassParameter 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * DCClass const *DCClassParameter::get_class(void) const
 *******************************************************************/
static PyObject *Dtool_DCClassParameter_get_class_197(PyObject *self, PyObject *args,PyObject *kwds) {
    DCClassParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClassParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DCClass const *DCClassParameter::get_class(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getClass", key_word_list));
        else
            (PyArg_Parse(args, ":getClass"));
        if(!PyErr_Occurred())
        {
            DCClass const *return_value = ((const DCClassParameter*)local_this)->get_class();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCClass,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClass(const DCClassParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCClassParameter_get_class_197_comment =
    "C++ Interface:\n"
    "getClass(const DCClassParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCClassParameter::get_class\n"
    "//       Access: Published\n"
    "//  Description: Returns the class object this parameter represents.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCClassParameter_get_class_197_comment = NULL;
#endif

int  Dtool_Init_DCClassParameter(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (DCClassParameter)");
       return -1;
}
inline void  * Dtool_UpcastInterface_DCClassParameter(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DCClassParameter)
    {
        printf("DCClassParameter ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DCClassParameter * local_this = (DCClassParameter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DCClassParameter)
        return local_this;
    if(requested_type == &Dtool_DCField)
        return ( DCField *)( DCParameter *) local_this;
    if(requested_type == &Dtool_DCKeywordList)
        return ( DCKeywordList *)( DCField *)( DCParameter *) local_this;
    if(requested_type == &Dtool_DCPackerInterface)
        return ( DCPackerInterface *)( DCField *)( DCParameter *) local_this;
    if(requested_type == &Dtool_DCParameter)
        return ( DCParameter *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DCClassParameter(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DCClassParameter)
        return from_this;
    if(from_type == &Dtool_DCField)
    {
          DCField* other_this = (DCField*)from_this;
          return (DCClassParameter*)other_this;
    }
    if(from_type == &Dtool_DCKeywordList)
    {
          DCKeywordList* other_this = (DCKeywordList*)from_this;
          return (DCClassParameter*)other_this;
    }
    if(from_type == &Dtool_DCPackerInterface)
    {
          DCPackerInterface* other_this = (DCPackerInterface*)from_this;
          return (DCClassParameter*)other_this;
    }
    if(from_type == &Dtool_DCParameter)
    {
          DCParameter* other_this = (DCParameter*)from_this;
          return (DCClassParameter*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DCFile 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void DCFile::clear(void)
 *******************************************************************/
static PyObject *Dtool_DCFile_clear_202(PyObject *self, PyObject *args,PyObject *kwds) {
    DCFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DCFile::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCFile.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const DCFile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCFile_clear_202_comment =
    "C++ Interface:\n"
    "clear(non-const DCFile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCFile::clear\n"
    "//       Access: Published\n"
    "//  Description: Removes all of the classes defined within the DCFile\n"
    "//               and prepares it for reading a new file.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCFile_clear_202_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DCFile::read_all(void)
 *******************************************************************/
static PyObject *Dtool_DCFile_read_all_203(PyObject *self, PyObject *args,PyObject *kwds) {
    DCFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool DCFile::read_all(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":readAll", key_word_list));
        else
            (PyArg_Parse(args, ":readAll"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->read_all();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DCFile.readAll() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "readAll(non-const DCFile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCFile_read_all_203_comment =
    "C++ Interface:\n"
    "readAll(non-const DCFile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCFile::read_all\n"
    "//       Access: Published\n"
    "//  Description: This special method reads all of the .dc files named\n"
    "//               by the \"dc-file\" config.prc variable, and loads them\n"
    "//               into the DCFile namespace.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCFile_read_all_203_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DCFile::read(Filename filename)
 * bool DCFile::read(istream &in, basic_string< char > const &filename)
 * bool DCFile::read(istream &in, basic_string< char > const &filename = ((string())))
 *******************************************************************/
static PyObject *Dtool_DCFile_read_204(PyObject *self, PyObject *args,PyObject *kwds) {
    DCFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool DCFile::read(istream &in, basic_string< char > const &filename = ((string())))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"in", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:read", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:read", &param1));
                if(!PyErr_Occurred())
                {
                    istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_istream, 1, "DCFile.read", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = (local_this)->read(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool DCFile::read(Filename filename)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"filename", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:read", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:read", &param1));
                if(!PyErr_Occurred())
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "DCFile.read", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = (local_this)->read(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool DCFile::read(istream &in, basic_string< char > const &filename)
                PyObject *param1;
                char *param2_str; int param2_len;
                static char * key_word_list[] = {(char *)"in", (char *)"filename", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:read", key_word_list, &param1, &param2_str, &param2_len))
                {
                    istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_istream, 1, "DCFile.read", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = (local_this)->read(*param1_this, basic_string<char>(param2_str, param2_len));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call DCFile.read() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "read() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "read(non-const DCFile this, non-const Istream in)\n"
          "read(non-const DCFile this, const Filename filename)\n"
          "read(non-const DCFile this, non-const Istream in, string filename)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCFile_read_204_comment =
    "C++ Interface:\n"
    "read(non-const DCFile this, non-const Istream in)\n"
    "read(non-const DCFile this, const Filename filename)\n"
    "read(non-const DCFile this, non-const Istream in, string filename)\n"
    "\n"
    "// WITHIN_PANDA\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCFile::read\n"
    "//       Access: Published\n"
    "//  Description: Opens and reads the indicated .dc file by name.  The\n"
    "//               distributed classes defined in the file will be\n"
    "//               appended to the set of distributed classes already\n"
    "//               recorded, if any.\n"
    "//\n"
    "//               Returns true if the file is successfully read, false\n"
    "//               if there was an error (in which case the file might\n"
    "//               have been partially read).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCFile::read\n"
    "//       Access: Published\n"
    "//  Description: Parses the already-opened input stream for\n"
    "//               distributed class descriptions.  The filename\n"
    "//               parameter is optional and is only used when reporting\n"
    "//               errors.\n"
    "//\n"
    "//               The distributed classes defined in the file will be\n"
    "//               appended to the set of distributed classes already\n"
    "//               recorded, if any.\n"
    "//\n"
    "//               Returns true if the file is successfully read, false\n"
    "//               if there was an error (in which case the file might\n"
    "//               have been partially read).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCFile_read_204_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DCFile::write(Filename filename, bool brief) const
 * bool DCFile::write(ostream &out, bool brief) const
 *******************************************************************/
static PyObject *Dtool_DCFile_write_205(PyObject *self, PyObject *args,PyObject *kwds) {
    DCFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 bool DCFile::write(Filename filename, bool brief) const
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"filename", (char *)"brief", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:write", key_word_list, &param1, &param2))
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "DCFile.write", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const DCFile*)local_this)->write(*param1_this, (PyObject_IsTrue(param2)!=0));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 bool DCFile::write(ostream &out, bool brief) const
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"out", (char *)"brief", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:write", key_word_list, &param1, &param2))
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DCFile.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const DCFile*)local_this)->write(*param1_this, (PyObject_IsTrue(param2)!=0));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const DCFile this, const Filename filename, bool brief)\n"
          "write(const DCFile this, non-const Ostream out, bool brief)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCFile_write_205_comment =
    "C++ Interface:\n"
    "write(const DCFile this, const Filename filename, bool brief)\n"
    "write(const DCFile this, non-const Ostream out, bool brief)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCFile::write\n"
    "//       Access: Published\n"
    "//  Description: Opens the indicated filename for output and writes a\n"
    "//               parseable description of all the known distributed\n"
    "//               classes to the file.\n"
    "//\n"
    "//               Returns true if the description is successfully\n"
    "//               written, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCFile::write\n"
    "//       Access: Published\n"
    "//  Description: Writes a parseable description of all the known\n"
    "//               distributed classes to the stream.\n"
    "//\n"
    "//               Returns true if the description is successfully\n"
    "//               written, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCFile_write_205_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DCFile::get_num_classes(void) const
 *******************************************************************/
static PyObject *Dtool_DCFile_get_num_classes_206(PyObject *self, PyObject *args,PyObject *kwds) {
    DCFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DCFile::get_num_classes(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumClasses", key_word_list));
        else
            (PyArg_Parse(args, ":getNumClasses"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DCFile*)local_this)->get_num_classes();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumClasses(const DCFile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCFile_get_num_classes_206_comment =
    "C++ Interface:\n"
    "getNumClasses(const DCFile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCFile::get_num_classes\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of classes read from the .dc\n"
    "//               file(s).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCFile_get_num_classes_206_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCClass *DCFile::get_class(int n) const
 *******************************************************************/
static PyObject *Dtool_DCFile_get_class_207(PyObject *self, PyObject *args,PyObject *kwds) {
    DCFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DCClass *DCFile::get_class(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getClass", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getClass", &param1));
        if(!PyErr_Occurred())
        {
            DCClass *return_value = ((const DCFile*)local_this)->get_class((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCClass,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClass(const DCFile this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCFile_get_class_207_comment =
    "C++ Interface:\n"
    "getClass(const DCFile this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCFile::get_class\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth class read from the .dc file(s).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCFile_get_class_207_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCClass *DCFile::get_class_by_name(basic_string< char > const &name) const
 *******************************************************************/
static PyObject *Dtool_DCFile_get_class_by_name_208(PyObject *self, PyObject *args,PyObject *kwds) {
    DCFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DCClass *DCFile::get_class_by_name(basic_string< char > const &name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getClassByName", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:getClassByName", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            DCClass *return_value = ((const DCFile*)local_this)->get_class_by_name(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCClass,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassByName(const DCFile this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCFile_get_class_by_name_208_comment =
    "C++ Interface:\n"
    "getClassByName(const DCFile this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCFile::get_class_by_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the class that has the indicated name, or\n"
    "//               NULL if there is no such class.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCFile_get_class_by_name_208_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCSwitch *DCFile::get_switch_by_name(basic_string< char > const &name) const
 *******************************************************************/
static PyObject *Dtool_DCFile_get_switch_by_name_209(PyObject *self, PyObject *args,PyObject *kwds) {
    DCFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DCSwitch *DCFile::get_switch_by_name(basic_string< char > const &name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getSwitchByName", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:getSwitchByName", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            DCSwitch *return_value = ((const DCFile*)local_this)->get_switch_by_name(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCSwitch,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSwitchByName(const DCFile this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCFile_get_switch_by_name_209_comment =
    "C++ Interface:\n"
    "getSwitchByName(const DCFile this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCFile::get_switch_by_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the switch that has the indicated name, or\n"
    "//               NULL if there is no such switch.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCFile_get_switch_by_name_209_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCField *DCFile::get_field_by_index(int index_number) const
 *******************************************************************/
static PyObject *Dtool_DCFile_get_field_by_index_210(PyObject *self, PyObject *args,PyObject *kwds) {
    DCFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DCField *DCFile::get_field_by_index(int index_number) const
        int param1;
        static char * key_word_list[] = {(char *)"index_number", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getFieldByIndex", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getFieldByIndex", &param1));
        if(!PyErr_Occurred())
        {
            DCField *return_value = ((const DCFile*)local_this)->get_field_by_index((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCField,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFieldByIndex(const DCFile this, int index_number)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCFile_get_field_by_index_210_comment =
    "C++ Interface:\n"
    "getFieldByIndex(const DCFile this, int index_number)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCFile::get_field_by_index\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns a pointer to the one DCField that has the\n"
    "//               indicated index number, of all the DCFields across\n"
    "//               all classes in the file.\n"
    "//\n"
    "//               This method is only valid if dc-multiple-inheritance\n"
    "//               is set true in the Config.prc file.  Without this\n"
    "//               setting, different DCFields may share the same index\n"
    "//               number, so this global lookup is not possible.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCFile_get_field_by_index_210_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DCFile::all_objects_valid(void) const
 *******************************************************************/
static PyObject *Dtool_DCFile_all_objects_valid_211(PyObject *self, PyObject *args,PyObject *kwds) {
    DCFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DCFile::all_objects_valid(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":allObjectsValid", key_word_list));
        else
            (PyArg_Parse(args, ":allObjectsValid"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DCFile*)local_this)->all_objects_valid();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "allObjectsValid(const DCFile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCFile_all_objects_valid_211_comment =
    "C++ Interface:\n"
    "allObjectsValid(const DCFile this)\n"
    "\n"
    "// Filename: dcFile.I\n"
    "// Created by:  drose (10Jan06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCFile::all_objects_valid\n"
    "//       Access: Published\n"
    "//  Description: Returns true if all of the classes read from the DC\n"
    "//               file were defined and valid, or false if any of them\n"
    "//               were undefined (\"bogus classes\").  If this is true,\n"
    "//               we might have read a partial file.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCFile_all_objects_valid_211_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DCFile::get_num_import_modules(void) const
 *******************************************************************/
static PyObject *Dtool_DCFile_get_num_import_modules_212(PyObject *self, PyObject *args,PyObject *kwds) {
    DCFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DCFile::get_num_import_modules(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumImportModules", key_word_list));
        else
            (PyArg_Parse(args, ":getNumImportModules"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DCFile*)local_this)->get_num_import_modules();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumImportModules(const DCFile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCFile_get_num_import_modules_212_comment =
    "C++ Interface:\n"
    "getNumImportModules(const DCFile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCFile::get_num_import_modules\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of import lines read from the .dc\n"
    "//               file(s).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCFile_get_num_import_modules_212_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DCFile::get_import_module(int n) const
 *******************************************************************/
static PyObject *Dtool_DCFile_get_import_module_213(PyObject *self, PyObject *args,PyObject *kwds) {
    DCFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > DCFile::get_import_module(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getImportModule", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getImportModule", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DCFile*)local_this)->get_import_module((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getImportModule(const DCFile this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCFile_get_import_module_213_comment =
    "C++ Interface:\n"
    "getImportModule(const DCFile this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCFile::get_import_module\n"
    "//       Access: Published\n"
    "//  Description: Returns the module named by the nth import line read\n"
    "//               from the .dc file(s).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCFile_get_import_module_213_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DCFile::get_num_import_symbols(int n) const
 *******************************************************************/
static PyObject *Dtool_DCFile_get_num_import_symbols_214(PyObject *self, PyObject *args,PyObject *kwds) {
    DCFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DCFile::get_num_import_symbols(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getNumImportSymbols", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getNumImportSymbols", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DCFile*)local_this)->get_num_import_symbols((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumImportSymbols(const DCFile this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCFile_get_num_import_symbols_214_comment =
    "C++ Interface:\n"
    "getNumImportSymbols(const DCFile this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCFile::get_num_import_symbols\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of symbols explicitly imported by\n"
    "//               the nth import line.  If this is 0, the line is\n"
    "//               \"import modulename\"; if it is more than 0, the line\n"
    "//               is \"from modulename import symbol, symbol ... \".\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCFile_get_num_import_symbols_214_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DCFile::get_import_symbol(int n, int i) const
 *******************************************************************/
static PyObject *Dtool_DCFile_get_import_symbol_215(PyObject *self, PyObject *args,PyObject *kwds) {
    DCFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > DCFile::get_import_symbol(int n, int i) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"n", (char *)"i", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getImportSymbol", key_word_list, &param1, &param2))
        {
            basic_string< char > return_value = ((const DCFile*)local_this)->get_import_symbol((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getImportSymbol(const DCFile this, int n, int i)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCFile_get_import_symbol_215_comment =
    "C++ Interface:\n"
    "getImportSymbol(const DCFile this, int n, int i)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCFile::get_import_symbol\n"
    "//       Access: Published\n"
    "//  Description: Returns the ith symbol named by the nth import line\n"
    "//               read from the .dc file(s).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCFile_get_import_symbol_215_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DCFile::get_num_typedefs(void) const
 *******************************************************************/
static PyObject *Dtool_DCFile_get_num_typedefs_216(PyObject *self, PyObject *args,PyObject *kwds) {
    DCFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DCFile::get_num_typedefs(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumTypedefs", key_word_list));
        else
            (PyArg_Parse(args, ":getNumTypedefs"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DCFile*)local_this)->get_num_typedefs();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumTypedefs(const DCFile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCFile_get_num_typedefs_216_comment =
    "C++ Interface:\n"
    "getNumTypedefs(const DCFile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCFile::get_num_typedefs\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of typedefs read from the .dc\n"
    "//               file(s).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCFile_get_num_typedefs_216_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCTypedef *DCFile::get_typedef(int n) const
 *******************************************************************/
static PyObject *Dtool_DCFile_get_typedef_217(PyObject *self, PyObject *args,PyObject *kwds) {
    DCFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DCTypedef *DCFile::get_typedef(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getTypedef", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getTypedef", &param1));
        if(!PyErr_Occurred())
        {
            DCTypedef *return_value = ((const DCFile*)local_this)->get_typedef((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCTypedef,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTypedef(const DCFile this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCFile_get_typedef_217_comment =
    "C++ Interface:\n"
    "getTypedef(const DCFile this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCFile::get_typedef\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth typedef read from the .dc file(s).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCFile_get_typedef_217_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCTypedef *DCFile::get_typedef_by_name(basic_string< char > const &name) const
 *******************************************************************/
static PyObject *Dtool_DCFile_get_typedef_by_name_218(PyObject *self, PyObject *args,PyObject *kwds) {
    DCFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DCTypedef *DCFile::get_typedef_by_name(basic_string< char > const &name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getTypedefByName", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:getTypedefByName", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            DCTypedef *return_value = ((const DCFile*)local_this)->get_typedef_by_name(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCTypedef,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTypedefByName(const DCFile this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCFile_get_typedef_by_name_218_comment =
    "C++ Interface:\n"
    "getTypedefByName(const DCFile this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCFile::get_typedef_by_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the typedef that has the indicated name, or\n"
    "//               NULL if there is no such typedef name.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCFile_get_typedef_by_name_218_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DCFile::get_num_keywords(void) const
 *******************************************************************/
static PyObject *Dtool_DCFile_get_num_keywords_219(PyObject *self, PyObject *args,PyObject *kwds) {
    DCFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DCFile::get_num_keywords(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumKeywords", key_word_list));
        else
            (PyArg_Parse(args, ":getNumKeywords"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DCFile*)local_this)->get_num_keywords();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumKeywords(const DCFile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCFile_get_num_keywords_219_comment =
    "C++ Interface:\n"
    "getNumKeywords(const DCFile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCFile::get_num_keywords\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of keywords read from the .dc\n"
    "//               file(s).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCFile_get_num_keywords_219_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCKeyword const *DCFile::get_keyword(int n) const
 *******************************************************************/
static PyObject *Dtool_DCFile_get_keyword_220(PyObject *self, PyObject *args,PyObject *kwds) {
    DCFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DCKeyword const *DCFile::get_keyword(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getKeyword", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getKeyword", &param1));
        if(!PyErr_Occurred())
        {
            DCKeyword const *return_value = ((const DCFile*)local_this)->get_keyword((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCKeyword,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getKeyword(const DCFile this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCFile_get_keyword_220_comment =
    "C++ Interface:\n"
    "getKeyword(const DCFile this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCFile::get_keyword\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth keyword read from the .dc file(s).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCFile_get_keyword_220_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCKeyword const *DCFile::get_keyword_by_name(basic_string< char > const &name) const
 *******************************************************************/
static PyObject *Dtool_DCFile_get_keyword_by_name_221(PyObject *self, PyObject *args,PyObject *kwds) {
    DCFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DCKeyword const *DCFile::get_keyword_by_name(basic_string< char > const &name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getKeywordByName", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:getKeywordByName", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            DCKeyword const *return_value = ((const DCFile*)local_this)->get_keyword_by_name(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCKeyword,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getKeywordByName(const DCFile this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCFile_get_keyword_by_name_221_comment =
    "C++ Interface:\n"
    "getKeywordByName(const DCFile this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCFile::get_keyword_by_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the keyword that has the indicated name, or\n"
    "//               NULL if there is no such keyword name.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCFile_get_keyword_by_name_221_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * unsigned long int DCFile::get_hash(void) const
 *******************************************************************/
static PyObject *Dtool_DCFile_get_hash_222(PyObject *self, PyObject *args,PyObject *kwds) {
    DCFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCFile,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-unsigned long int DCFile::get_hash(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHash", key_word_list));
        else
            (PyArg_Parse(args, ":getHash"));
        if(!PyErr_Occurred())
        {
            unsigned long int return_value = ((const DCFile*)local_this)->get_hash();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHash(const DCFile this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCFile_get_hash_222_comment =
    "C++ Interface:\n"
    "getHash(const DCFile this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCFile::get_hash\n"
    "//       Access: Published\n"
    "//  Description: Returns a 32-bit hash index associated with this\n"
    "//               file.  This number is guaranteed to be consistent if\n"
    "//               the contents of the file have not changed, and it is\n"
    "//               very likely to be different if the contents of the\n"
    "//               file do change.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCFile_get_hash_222_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCFile::DCFile(void)
 *******************************************************************/
int  Dtool_Init_DCFile(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-DCFile::DCFile(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":DCFile", key_word_list))
        {
            DCFile *return_value = new DCFile();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DCFile,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DCFile()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DCFile(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DCFile)
    {
        printf("DCFile ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DCFile * local_this = (DCFile *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DCFile)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DCFile(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DCFile)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DCKeyword 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * basic_string< char > const &DCKeyword::get_name(void) const
 *******************************************************************/
static PyObject *Dtool_DCKeyword_get_name_224(PyObject *self, PyObject *args,PyObject *kwds) {
    DCKeyword * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCKeyword,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > const &DCKeyword::get_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getName", key_word_list));
        else
            (PyArg_Parse(args, ":getName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const DCKeyword*)local_this)->get_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getName(const DCKeyword this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCKeyword_get_name_224_comment =
    "C++ Interface:\n"
    "getName(const DCKeyword this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCKeyword::get_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the name of this keyword.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCKeyword_get_name_224_comment = NULL;
#endif

int  Dtool_Init_DCKeyword(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (DCKeyword)");
       return -1;
}
inline void  * Dtool_UpcastInterface_DCKeyword(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DCKeyword)
    {
        printf("DCKeyword ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DCKeyword * local_this = (DCKeyword *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DCKeyword)
        return local_this;
    if(requested_type == &Dtool_DCDeclaration)
        return ( DCDeclaration *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DCKeyword(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DCKeyword)
        return from_this;
    if(from_type == &Dtool_DCDeclaration)
    {
          DCDeclaration* other_this = (DCDeclaration*)from_this;
          return (DCKeyword*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DCMolecularField 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * int DCMolecularField::get_num_atomics(void) const
 *******************************************************************/
static PyObject *Dtool_DCMolecularField_get_num_atomics_226(PyObject *self, PyObject *args,PyObject *kwds) {
    DCMolecularField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCMolecularField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DCMolecularField::get_num_atomics(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumAtomics", key_word_list));
        else
            (PyArg_Parse(args, ":getNumAtomics"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DCMolecularField*)local_this)->get_num_atomics();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumAtomics(const DCMolecularField this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCMolecularField_get_num_atomics_226_comment =
    "C++ Interface:\n"
    "getNumAtomics(const DCMolecularField this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCMolecularField::get_num_atomics\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of atomic fields that make up this\n"
    "//               molecular field.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCMolecularField_get_num_atomics_226_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCAtomicField *DCMolecularField::get_atomic(int n) const
 *******************************************************************/
static PyObject *Dtool_DCMolecularField_get_atomic_227(PyObject *self, PyObject *args,PyObject *kwds) {
    DCMolecularField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCMolecularField,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DCAtomicField *DCMolecularField::get_atomic(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getAtomic", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getAtomic", &param1));
        if(!PyErr_Occurred())
        {
            DCAtomicField *return_value = ((const DCMolecularField*)local_this)->get_atomic((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCAtomicField,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAtomic(const DCMolecularField this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCMolecularField_get_atomic_227_comment =
    "C++ Interface:\n"
    "getAtomic(const DCMolecularField this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCMolecularField::get_atomic\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth atomic field that makes up this\n"
    "//               molecular field.  This may or may not be a field of\n"
    "//               this particular class; it might be defined in a\n"
    "//               parent class.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCMolecularField_get_atomic_227_comment = NULL;
#endif

int  Dtool_Init_DCMolecularField(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (DCMolecularField)");
       return -1;
}
inline void  * Dtool_UpcastInterface_DCMolecularField(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DCMolecularField)
    {
        printf("DCMolecularField ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DCMolecularField * local_this = (DCMolecularField *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DCMolecularField)
        return local_this;
    if(requested_type == &Dtool_DCField)
        return ( DCField *) local_this;
    if(requested_type == &Dtool_DCKeywordList)
        return ( DCKeywordList *)( DCField *) local_this;
    if(requested_type == &Dtool_DCPackerInterface)
        return ( DCPackerInterface *)( DCField *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DCMolecularField(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DCMolecularField)
        return from_this;
    if(from_type == &Dtool_DCField)
    {
          DCField* other_this = (DCField*)from_this;
          return (DCMolecularField*)other_this;
    }
    if(from_type == &Dtool_DCKeywordList)
    {
          DCKeywordList* other_this = (DCKeywordList*)from_this;
          return (DCMolecularField*)other_this;
    }
    if(from_type == &Dtool_DCPackerInterface)
    {
          DCPackerInterface* other_this = (DCPackerInterface*)from_this;
          return (DCMolecularField*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DCSimpleParameter 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * DCSubatomicType DCSimpleParameter::get_type(void) const
 *******************************************************************/
static PyObject *Dtool_DCSimpleParameter_get_type_230(PyObject *self, PyObject *args,PyObject *kwds) {
    DCSimpleParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCSimpleParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DCSubatomicType DCSimpleParameter::get_type(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getType", key_word_list));
        else
            (PyArg_Parse(args, ":getType"));
        if(!PyErr_Occurred())
        {
            DCSubatomicType return_value = ((const DCSimpleParameter*)local_this)->get_type();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getType(const DCSimpleParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCSimpleParameter_get_type_230_comment =
    "C++ Interface:\n"
    "getType(const DCSimpleParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCSimpleParameter::get_type\n"
    "//       Access: Published\n"
    "//  Description: Returns the particular subatomic type represented by\n"
    "//               this instance.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCSimpleParameter_get_type_230_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DCSimpleParameter::has_modulus(void) const
 *******************************************************************/
static PyObject *Dtool_DCSimpleParameter_has_modulus_231(PyObject *self, PyObject *args,PyObject *kwds) {
    DCSimpleParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCSimpleParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool DCSimpleParameter::has_modulus(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasModulus", key_word_list));
        else
            (PyArg_Parse(args, ":hasModulus"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DCSimpleParameter*)local_this)->has_modulus();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasModulus(const DCSimpleParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCSimpleParameter_has_modulus_231_comment =
    "C++ Interface:\n"
    "hasModulus(const DCSimpleParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCSimpleParameter::has_modulus\n"
    "//       Access: Published\n"
    "//  Description: Returns true if there is a modulus associated, false\n"
    "//               otherwise.,\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCSimpleParameter_has_modulus_231_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * double DCSimpleParameter::get_modulus(void) const
 *******************************************************************/
static PyObject *Dtool_DCSimpleParameter_get_modulus_232(PyObject *self, PyObject *args,PyObject *kwds) {
    DCSimpleParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCSimpleParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-double DCSimpleParameter::get_modulus(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getModulus", key_word_list));
        else
            (PyArg_Parse(args, ":getModulus"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const DCSimpleParameter*)local_this)->get_modulus();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getModulus(const DCSimpleParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCSimpleParameter_get_modulus_232_comment =
    "C++ Interface:\n"
    "getModulus(const DCSimpleParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCSimpleParameter::get_modulus\n"
    "//       Access: Published\n"
    "//  Description: Returns the modulus associated with this type, if\n"
    "//               any.  It is an error to call this if has_modulus()\n"
    "//               returned false.\n"
    "//\n"
    "//               If present, this is the modulus that is used to\n"
    "//               constrain the numeric value of the field before it is\n"
    "//               packed (and range-checked).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCSimpleParameter_get_modulus_232_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DCSimpleParameter::get_divisor(void) const
 *******************************************************************/
static PyObject *Dtool_DCSimpleParameter_get_divisor_233(PyObject *self, PyObject *args,PyObject *kwds) {
    DCSimpleParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCSimpleParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DCSimpleParameter::get_divisor(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDivisor", key_word_list));
        else
            (PyArg_Parse(args, ":getDivisor"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DCSimpleParameter*)local_this)->get_divisor();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDivisor(const DCSimpleParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCSimpleParameter_get_divisor_233_comment =
    "C++ Interface:\n"
    "getDivisor(const DCSimpleParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCSimpleParameter::get_divisor\n"
    "//       Access: Published\n"
    "//  Description: Returns the divisor associated with this type.  This\n"
    "//               is 1 by default, but if this is other than one it\n"
    "//               represents the scale to apply when packing and\n"
    "//               unpacking numeric values (to store fixed-point values\n"
    "//               in an integer field).  It is only meaningful for\n"
    "//               numeric-type fields.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCSimpleParameter_get_divisor_233_comment = NULL;
#endif

int  Dtool_Init_DCSimpleParameter(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (DCSimpleParameter)");
       return -1;
}
inline void  * Dtool_UpcastInterface_DCSimpleParameter(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DCSimpleParameter)
    {
        printf("DCSimpleParameter ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DCSimpleParameter * local_this = (DCSimpleParameter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DCSimpleParameter)
        return local_this;
    if(requested_type == &Dtool_DCField)
        return ( DCField *)( DCParameter *) local_this;
    if(requested_type == &Dtool_DCKeywordList)
        return ( DCKeywordList *)( DCField *)( DCParameter *) local_this;
    if(requested_type == &Dtool_DCPackerInterface)
        return ( DCPackerInterface *)( DCField *)( DCParameter *) local_this;
    if(requested_type == &Dtool_DCParameter)
        return ( DCParameter *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DCSimpleParameter(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DCSimpleParameter)
        return from_this;
    if(from_type == &Dtool_DCField)
    {
          DCField* other_this = (DCField*)from_this;
          return (DCSimpleParameter*)other_this;
    }
    if(from_type == &Dtool_DCKeywordList)
    {
          DCKeywordList* other_this = (DCKeywordList*)from_this;
          return (DCSimpleParameter*)other_this;
    }
    if(from_type == &Dtool_DCPackerInterface)
    {
          DCPackerInterface* other_this = (DCPackerInterface*)from_this;
          return (DCSimpleParameter*)other_this;
    }
    if(from_type == &Dtool_DCParameter)
    {
          DCParameter* other_this = (DCParameter*)from_this;
          return (DCSimpleParameter*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DCSwitch 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * basic_string< char > const &DCSwitch::get_name(void) const
 *******************************************************************/
static PyObject *Dtool_DCSwitch_get_name_236(PyObject *self, PyObject *args,PyObject *kwds) {
    DCSwitch * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCSwitch,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > const &DCSwitch::get_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getName", key_word_list));
        else
            (PyArg_Parse(args, ":getName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const DCSwitch*)local_this)->get_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getName(const DCSwitch this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCSwitch_get_name_236_comment =
    "C++ Interface:\n"
    "getName(const DCSwitch this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCSwitch::get_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the name of this switch.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCSwitch_get_name_236_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCField *DCSwitch::get_key_parameter(void) const
 *******************************************************************/
static PyObject *Dtool_DCSwitch_get_key_parameter_237(PyObject *self, PyObject *args,PyObject *kwds) {
    DCSwitch * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCSwitch,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DCField *DCSwitch::get_key_parameter(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getKeyParameter", key_word_list));
        else
            (PyArg_Parse(args, ":getKeyParameter"));
        if(!PyErr_Occurred())
        {
            DCField *return_value = ((const DCSwitch*)local_this)->get_key_parameter();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCField,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getKeyParameter(const DCSwitch this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCSwitch_get_key_parameter_237_comment =
    "C++ Interface:\n"
    "getKeyParameter(const DCSwitch this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCSwitch::get_key_parameter\n"
    "//       Access: Published\n"
    "//  Description: Returns the key parameter on which the switch is\n"
    "//               based.  The value of this parameter in the record\n"
    "//               determines which one of the several cases within the\n"
    "//               switch will be used.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCSwitch_get_key_parameter_237_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DCSwitch::get_num_cases(void) const
 *******************************************************************/
static PyObject *Dtool_DCSwitch_get_num_cases_238(PyObject *self, PyObject *args,PyObject *kwds) {
    DCSwitch * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCSwitch,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DCSwitch::get_num_cases(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumCases", key_word_list));
        else
            (PyArg_Parse(args, ":getNumCases"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DCSwitch*)local_this)->get_num_cases();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumCases(const DCSwitch this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCSwitch_get_num_cases_238_comment =
    "C++ Interface:\n"
    "getNumCases(const DCSwitch this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCSwitch::get_num_cases\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of different cases within the\n"
    "//               switch.  The legal values for case_index range from 0\n"
    "//               to get_num_cases() - 1.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCSwitch_get_num_cases_238_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DCSwitch::get_case_by_value(basic_string< char > const &case_value) const
 *******************************************************************/
static PyObject *Dtool_DCSwitch_get_case_by_value_239(PyObject *self, PyObject *args,PyObject *kwds) {
    DCSwitch * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCSwitch,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DCSwitch::get_case_by_value(basic_string< char > const &case_value) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"case_value", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getCaseByValue", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:getCaseByValue", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DCSwitch*)local_this)->get_case_by_value(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCaseByValue(const DCSwitch this, string case_value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCSwitch_get_case_by_value_239_comment =
    "C++ Interface:\n"
    "getCaseByValue(const DCSwitch this, string case_value)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCSwitch::get_case_by_value\n"
    "//       Access: Published\n"
    "//  Description: Returns the index number of the case with the\n"
    "//               indicated packed value, or -1 if no case has this\n"
    "//               value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCSwitch_get_case_by_value_239_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCPackerInterface *DCSwitch::get_case(int n) const
 *******************************************************************/
static PyObject *Dtool_DCSwitch_get_case_240(PyObject *self, PyObject *args,PyObject *kwds) {
    DCSwitch * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCSwitch,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DCPackerInterface *DCSwitch::get_case(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getCase", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getCase", &param1));
        if(!PyErr_Occurred())
        {
            DCPackerInterface *return_value = ((const DCSwitch*)local_this)->get_case((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCPackerInterface,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCase(const DCSwitch this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCSwitch_get_case_240_comment =
    "C++ Interface:\n"
    "getCase(const DCSwitch this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCSwitch::get_case\n"
    "//       Access: Published\n"
    "//  Description: Returns the DCPackerInterface that packs the nth case.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCSwitch_get_case_240_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCPackerInterface *DCSwitch::get_default_case(void) const
 *******************************************************************/
static PyObject *Dtool_DCSwitch_get_default_case_241(PyObject *self, PyObject *args,PyObject *kwds) {
    DCSwitch * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCSwitch,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DCPackerInterface *DCSwitch::get_default_case(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDefaultCase", key_word_list));
        else
            (PyArg_Parse(args, ":getDefaultCase"));
        if(!PyErr_Occurred())
        {
            DCPackerInterface *return_value = ((const DCSwitch*)local_this)->get_default_case();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCPackerInterface,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDefaultCase(const DCSwitch this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCSwitch_get_default_case_241_comment =
    "C++ Interface:\n"
    "getDefaultCase(const DCSwitch this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCSwitch::get_default_case\n"
    "//       Access: Published\n"
    "//  Description: Returns the DCPackerInterface that packs the default\n"
    "//               case, or NULL if there is no default case.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCSwitch_get_default_case_241_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DCSwitch::get_value(int case_index) const
 *******************************************************************/
static PyObject *Dtool_DCSwitch_get_value_242(PyObject *self, PyObject *args,PyObject *kwds) {
    DCSwitch * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCSwitch,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > DCSwitch::get_value(int case_index) const
        int param1;
        static char * key_word_list[] = {(char *)"case_index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getValue", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getValue", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DCSwitch*)local_this)->get_value((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getValue(const DCSwitch this, int case_index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCSwitch_get_value_242_comment =
    "C++ Interface:\n"
    "getValue(const DCSwitch this, int case_index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCSwitch::get_value\n"
    "//       Access: Published\n"
    "//  Description: Returns the packed value associated with the\n"
    "//               indicated case.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCSwitch_get_value_242_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DCSwitch::get_num_fields(int case_index) const
 *******************************************************************/
static PyObject *Dtool_DCSwitch_get_num_fields_243(PyObject *self, PyObject *args,PyObject *kwds) {
    DCSwitch * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCSwitch,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DCSwitch::get_num_fields(int case_index) const
        int param1;
        static char * key_word_list[] = {(char *)"case_index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getNumFields", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getNumFields", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DCSwitch*)local_this)->get_num_fields((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumFields(const DCSwitch this, int case_index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCSwitch_get_num_fields_243_comment =
    "C++ Interface:\n"
    "getNumFields(const DCSwitch this, int case_index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCSwitch::get_num_fields\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of fields in the indicated case.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCSwitch_get_num_fields_243_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCField *DCSwitch::get_field(int case_index, int n) const
 *******************************************************************/
static PyObject *Dtool_DCSwitch_get_field_244(PyObject *self, PyObject *args,PyObject *kwds) {
    DCSwitch * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCSwitch,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DCField *DCSwitch::get_field(int case_index, int n) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"case_index", (char *)"n", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getField", key_word_list, &param1, &param2))
        {
            DCField *return_value = ((const DCSwitch*)local_this)->get_field((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCField,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getField(const DCSwitch this, int case_index, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCSwitch_get_field_244_comment =
    "C++ Interface:\n"
    "getField(const DCSwitch this, int case_index, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCSwitch::get_num_fields\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth field in the indicated case.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCSwitch_get_field_244_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DCField *DCSwitch::get_field_by_name(int case_index, basic_string< char > const &name) const
 *******************************************************************/
static PyObject *Dtool_DCSwitch_get_field_by_name_245(PyObject *self, PyObject *args,PyObject *kwds) {
    DCSwitch * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCSwitch,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DCField *DCSwitch::get_field_by_name(int case_index, basic_string< char > const &name) const
        int param1;
        char *param2_str; int param2_len;
        static char * key_word_list[] = {(char *)"case_index", (char *)"name", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "is#:getFieldByName", key_word_list, &param1, &param2_str, &param2_len))
        {
            DCField *return_value = ((const DCSwitch*)local_this)->get_field_by_name((int)param1, basic_string<char>(param2_str, param2_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCField,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFieldByName(const DCSwitch this, int case_index, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCSwitch_get_field_by_name_245_comment =
    "C++ Interface:\n"
    "getFieldByName(const DCSwitch this, int case_index, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCSwitch::get_field_by_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the field with the given name from the\n"
    "//               indicated case, or NULL if no field has this name.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCSwitch_get_field_by_name_245_comment = NULL;
#endif

int  Dtool_Init_DCSwitch(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (DCSwitch)");
       return -1;
}
inline void  * Dtool_UpcastInterface_DCSwitch(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DCSwitch)
    {
        printf("DCSwitch ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DCSwitch * local_this = (DCSwitch *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DCSwitch)
        return local_this;
    if(requested_type == &Dtool_DCDeclaration)
        return ( DCDeclaration *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DCSwitch(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DCSwitch)
        return from_this;
    if(from_type == &Dtool_DCDeclaration)
    {
          DCDeclaration* other_this = (DCDeclaration*)from_this;
          return (DCSwitch*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DCSwitchParameter 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * DCSwitch const *DCSwitchParameter::get_switch(void) const
 *******************************************************************/
static PyObject *Dtool_DCSwitchParameter_get_switch_247(PyObject *self, PyObject *args,PyObject *kwds) {
    DCSwitchParameter * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCSwitchParameter,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-DCSwitch const *DCSwitchParameter::get_switch(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSwitch", key_word_list));
        else
            (PyArg_Parse(args, ":getSwitch"));
        if(!PyErr_Occurred())
        {
            DCSwitch const *return_value = ((const DCSwitchParameter*)local_this)->get_switch();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DCSwitch,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSwitch(const DCSwitchParameter this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCSwitchParameter_get_switch_247_comment =
    "C++ Interface:\n"
    "getSwitch(const DCSwitchParameter this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCSwitchParameter::get_switch\n"
    "//       Access: Published\n"
    "//  Description: Returns the switch object this parameter represents.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCSwitchParameter_get_switch_247_comment = NULL;
#endif

int  Dtool_Init_DCSwitchParameter(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (DCSwitchParameter)");
       return -1;
}
inline void  * Dtool_UpcastInterface_DCSwitchParameter(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DCSwitchParameter)
    {
        printf("DCSwitchParameter ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DCSwitchParameter * local_this = (DCSwitchParameter *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DCSwitchParameter)
        return local_this;
    if(requested_type == &Dtool_DCField)
        return ( DCField *)( DCParameter *) local_this;
    if(requested_type == &Dtool_DCKeywordList)
        return ( DCKeywordList *)( DCField *)( DCParameter *) local_this;
    if(requested_type == &Dtool_DCPackerInterface)
        return ( DCPackerInterface *)( DCField *)( DCParameter *) local_this;
    if(requested_type == &Dtool_DCParameter)
        return ( DCParameter *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DCSwitchParameter(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DCSwitchParameter)
        return from_this;
    if(from_type == &Dtool_DCField)
    {
          DCField* other_this = (DCField*)from_this;
          return (DCSwitchParameter*)other_this;
    }
    if(from_type == &Dtool_DCKeywordList)
    {
          DCKeywordList* other_this = (DCKeywordList*)from_this;
          return (DCSwitchParameter*)other_this;
    }
    if(from_type == &Dtool_DCPackerInterface)
    {
          DCPackerInterface* other_this = (DCPackerInterface*)from_this;
          return (DCSwitchParameter*)other_this;
    }
    if(from_type == &Dtool_DCParameter)
    {
          DCParameter* other_this = (DCParameter*)from_this;
          return (DCSwitchParameter*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DCTypedef 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * int DCTypedef::get_number(void) const
 *******************************************************************/
static PyObject *Dtool_DCTypedef_get_number_250(PyObject *self, PyObject *args,PyObject *kwds) {
    DCTypedef * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCTypedef,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DCTypedef::get_number(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumber", key_word_list));
        else
            (PyArg_Parse(args, ":getNumber"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DCTypedef*)local_this)->get_number();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumber(const DCTypedef this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCTypedef_get_number_250_comment =
    "C++ Interface:\n"
    "getNumber(const DCTypedef this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCTypedef::get_number\n"
    "//       Access: Published\n"
    "//  Description: Returns a unique index number associated with this\n"
    "//               typedef definition.  This is defined implicitly when\n"
    "//               the .dc file(s) are read.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCTypedef_get_number_250_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > const &DCTypedef::get_name(void) const
 *******************************************************************/
static PyObject *Dtool_DCTypedef_get_name_251(PyObject *self, PyObject *args,PyObject *kwds) {
    DCTypedef * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCTypedef,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > const &DCTypedef::get_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getName", key_word_list));
        else
            (PyArg_Parse(args, ":getName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const DCTypedef*)local_this)->get_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getName(const DCTypedef this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCTypedef_get_name_251_comment =
    "C++ Interface:\n"
    "getName(const DCTypedef this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCTypedef::get_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the name of this typedef.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCTypedef_get_name_251_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DCTypedef::get_description(void) const
 *******************************************************************/
static PyObject *Dtool_DCTypedef_get_description_252(PyObject *self, PyObject *args,PyObject *kwds) {
    DCTypedef * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCTypedef,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > DCTypedef::get_description(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDescription", key_word_list));
        else
            (PyArg_Parse(args, ":getDescription"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DCTypedef*)local_this)->get_description();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDescription(const DCTypedef this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCTypedef_get_description_252_comment =
    "C++ Interface:\n"
    "getDescription(const DCTypedef this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCTypedef::get_description\n"
    "//       Access: Published\n"
    "//  Description: Returns a brief decription of the typedef, useful for\n"
    "//               human consumption.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCTypedef_get_description_252_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DCTypedef::is_bogus_typedef(void) const
 *******************************************************************/
static PyObject *Dtool_DCTypedef_is_bogus_typedef_253(PyObject *self, PyObject *args,PyObject *kwds) {
    DCTypedef * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCTypedef,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool DCTypedef::is_bogus_typedef(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isBogusTypedef", key_word_list));
        else
            (PyArg_Parse(args, ":isBogusTypedef"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DCTypedef*)local_this)->is_bogus_typedef();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isBogusTypedef(const DCTypedef this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCTypedef_is_bogus_typedef_253_comment =
    "C++ Interface:\n"
    "isBogusTypedef(const DCTypedef this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCTypedef::is_bogus_typedef\n"
    "//       Access: Public\n"
    "//  Description: Returns true if the typedef has been flagged as a bogus\n"
    "//               typedef.  This is set for typedefs that are generated by\n"
    "//               the parser as placeholder for missing typedefs, as\n"
    "//               when reading a partial file; it should not occur in a\n"
    "//               normal valid dc file.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCTypedef_is_bogus_typedef_253_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DCTypedef::is_implicit_typedef(void) const
 *******************************************************************/
static PyObject *Dtool_DCTypedef_is_implicit_typedef_254(PyObject *self, PyObject *args,PyObject *kwds) {
    DCTypedef * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCTypedef,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool DCTypedef::is_implicit_typedef(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isImplicitTypedef", key_word_list));
        else
            (PyArg_Parse(args, ":isImplicitTypedef"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DCTypedef*)local_this)->is_implicit_typedef();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isImplicitTypedef(const DCTypedef this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DCTypedef_is_implicit_typedef_254_comment =
    "C++ Interface:\n"
    "isImplicitTypedef(const DCTypedef this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DCTypedef::is_implicit_typedef\n"
    "//       Access: Public\n"
    "//  Description: Returns true if the typedef has been flagged as an\n"
    "//               implicit typedef, meaning it was created for a\n"
    "//               DCClass that was referenced inline as a type.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DCTypedef_is_implicit_typedef_254_comment = NULL;
#endif

int  Dtool_Init_DCTypedef(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (DCTypedef)");
       return -1;
}
inline void  * Dtool_UpcastInterface_DCTypedef(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DCTypedef)
    {
        printf("DCTypedef ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DCTypedef * local_this = (DCTypedef *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DCTypedef)
        return local_this;
    if(requested_type == &Dtool_DCDeclaration)
        return ( DCDeclaration *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DCTypedef(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DCTypedef)
        return from_this;
    if(from_type == &Dtool_DCDeclaration)
    {
          DCDeclaration* other_this = (DCDeclaration*)from_this;
          return (DCTypedef*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. DCPackerInterface | DCPackerInterface
//********************************************************************
PyMethodDef Dtool_Methods_DCPackerInterface[]= {
  { "getName",(PyCFunction ) &Dtool_DCPackerInterface_get_name_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPackerInterface_get_name_5_comment},
  { "findSeekIndex",(PyCFunction ) &Dtool_DCPackerInterface_find_seek_index_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPackerInterface_find_seek_index_6_comment},
  { "asField",(PyCFunction ) &Dtool_DCPackerInterface_as_field_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPackerInterface_as_field_7_comment},
  { "asSwitchParameter",(PyCFunction ) &Dtool_DCPackerInterface_as_switch_parameter_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPackerInterface_as_switch_parameter_8_comment},
  { "asClassParameter",(PyCFunction ) &Dtool_DCPackerInterface_as_class_parameter_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPackerInterface_as_class_parameter_9_comment},
  { "checkMatch",(PyCFunction ) &Dtool_DCPackerInterface_check_match_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPackerInterface_check_match_10_comment},
  { "downcastToDCField",(PyCFunction ) &Dtool_DCPackerInterface_downcast_to_DCField_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPackerInterface_downcast_to_DCField_20_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DCPackerInterface(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DCPackerInterface.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DCPackerInterface\n"
          "// Description : This defines the internal interface for packing\n"
          "//               values into a DCField.  The various different DC\n"
          "//               objects inherit from this.  \n"
          "//\n"
          "//               Normally these methods are called only by the\n"
          "//               DCPacker object; the user wouldn't normally call\n"
          "//               these directly.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_DCPackerInterface.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_DCPackerInterface.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DCPackerInterface.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DCPackerInterface.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DCPackerInterface.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DCPackerInterface)");
             printf(" Error In PyType_ReadyDCPackerInterface");
             return;
        }
        Py_INCREF(&Dtool_DCPackerInterface.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DCPackerInterface.As_PyTypeObject().tp_dict,"DCPackerInterface",&Dtool_DCPackerInterface.As_PyObject());
        RegisterRuntimeClass(&Dtool_DCPackerInterface,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DCPackerInterface.As_PyTypeObject());
        PyModule_AddObject(module, "DCPackerInterface",(PyObject *)&Dtool_DCPackerInterface.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DCKeywordList | DCKeywordList
//********************************************************************
PyMethodDef Dtool_Methods_DCKeywordList[]= {
  { "hasKeyword",(PyCFunction ) &Dtool_DCKeywordList_has_keyword_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCKeywordList_has_keyword_13_comment},
  { "getNumKeywords",(PyCFunction ) &Dtool_DCKeywordList_get_num_keywords_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCKeywordList_get_num_keywords_14_comment},
  { "getKeyword",(PyCFunction ) &Dtool_DCKeywordList_get_keyword_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCKeywordList_get_keyword_15_comment},
  { "getKeywordByName",(PyCFunction ) &Dtool_DCKeywordList_get_keyword_by_name_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCKeywordList_get_keyword_by_name_16_comment},
  { "compareKeywords",(PyCFunction ) &Dtool_DCKeywordList_compare_keywords_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCKeywordList_compare_keywords_17_comment},
  { "downcastToDCField",(PyCFunction ) &Dtool_DCKeywordList_downcast_to_DCField_22, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCKeywordList_downcast_to_DCField_22_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DCKeywordList(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DCKeywordList.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DCKeywordList\n"
          "// Description : This is a list of keywords (see DCKeyword) that may\n"
          "//               be set on a particular field.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_DCKeywordList.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_DCKeywordList.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DCKeywordList.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DCKeywordList.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DCKeywordList.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DCKeywordList)");
             printf(" Error In PyType_ReadyDCKeywordList");
             return;
        }
        Py_INCREF(&Dtool_DCKeywordList.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DCKeywordList.As_PyTypeObject().tp_dict,"DCKeywordList",&Dtool_DCKeywordList.As_PyObject());
        RegisterRuntimeClass(&Dtool_DCKeywordList,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DCKeywordList.As_PyTypeObject());
        PyModule_AddObject(module, "DCKeywordList",(PyObject *)&Dtool_DCKeywordList.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DCField | DCField
//********************************************************************
PyMethodDef Dtool_Methods_DCField[]= {
  { "getNumber",(PyCFunction ) &Dtool_DCField_get_number_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_get_number_24_comment},
  { "getClass",(PyCFunction ) &Dtool_DCField_get_class_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_get_class_25_comment},
  { "getFieldFromNumber",(PyCFunction ) &Dtool_DCField_get_field_from_number_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_get_field_from_number_26_comment},
  { "asField",(PyCFunction ) &Dtool_DCField_as_field_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_as_field_27_comment},
  { "asAtomicField",(PyCFunction ) &Dtool_DCField_as_atomic_field_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_as_atomic_field_28_comment},
  { "asMolecularField",(PyCFunction ) &Dtool_DCField_as_molecular_field_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_as_molecular_field_29_comment},
  { "asParameter",(PyCFunction ) &Dtool_DCField_as_parameter_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_as_parameter_30_comment},
  { "formatData",(PyCFunction ) &Dtool_DCField_format_data_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_format_data_31_comment},
  { "parseString",(PyCFunction ) &Dtool_DCField_parse_string_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_parse_string_32_comment},
  { "validateRanges",(PyCFunction ) &Dtool_DCField_validate_ranges_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_validate_ranges_33_comment},
  { "hasDefaultValue",(PyCFunction ) &Dtool_DCField_has_default_value_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_has_default_value_34_comment},
  { "getDefaultValue",(PyCFunction ) &Dtool_DCField_get_default_value_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_get_default_value_35_comment},
  { "isBogusField",(PyCFunction ) &Dtool_DCField_is_bogus_field_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_is_bogus_field_36_comment},
  { "isRequired",(PyCFunction ) &Dtool_DCField_is_required_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_is_required_37_comment},
  { "isBroadcast",(PyCFunction ) &Dtool_DCField_is_broadcast_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_is_broadcast_38_comment},
  { "isRam",(PyCFunction ) &Dtool_DCField_is_ram_39, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_is_ram_39_comment},
  { "isDb",(PyCFunction ) &Dtool_DCField_is_db_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_is_db_40_comment},
  { "isClsend",(PyCFunction ) &Dtool_DCField_is_clsend_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_is_clsend_41_comment},
  { "isClrecv",(PyCFunction ) &Dtool_DCField_is_clrecv_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_is_clrecv_42_comment},
  { "isOwnsend",(PyCFunction ) &Dtool_DCField_is_ownsend_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_is_ownsend_43_comment},
  { "isOwnrecv",(PyCFunction ) &Dtool_DCField_is_ownrecv_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_is_ownrecv_44_comment},
  { "isAirecv",(PyCFunction ) &Dtool_DCField_is_airecv_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_is_airecv_45_comment},
  { "output",(PyCFunction ) &Dtool_DCField_output_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_output_46_comment},
  { "write",(PyCFunction ) &Dtool_DCField_write_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_write_47_comment},
  { "packArgs",(PyCFunction ) &Dtool_DCField_pack_args_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_pack_args_48_comment},
  { "unpackArgs",(PyCFunction ) &Dtool_DCField_unpack_args_49, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_unpack_args_49_comment},
  { "receiveUpdate",(PyCFunction ) &Dtool_DCField_receive_update_50, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_receive_update_50_comment},
  { "clientFormatUpdate",(PyCFunction ) &Dtool_DCField_client_format_update_51, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_client_format_update_51_comment},
  { "aiFormatUpdate",(PyCFunction ) &Dtool_DCField_ai_format_update_52, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_ai_format_update_52_comment},
  { "aiFormatUpdateMsgType",(PyCFunction ) &Dtool_DCField_ai_format_update_msg_type_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_ai_format_update_msg_type_53_comment},
  { "upcastToDCPackerInterface",(PyCFunction ) &Dtool_DCField_upcast_to_DCPackerInterface_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_upcast_to_DCPackerInterface_19_comment},
  { "upcastToDCKeywordList",(PyCFunction ) &Dtool_DCField_upcast_to_DCKeywordList_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCField_upcast_to_DCKeywordList_21_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     DCField
//////////////////
static PyObject *  Dtool_Repr_DCField(PyObject * self)
{
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     DCField
//////////////////
static PyObject *  Dtool_Str_DCField(PyObject * self)
{
    DCField * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCField,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os,0);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_DCField(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DCField.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DCField\n"
          "// Description : A single field of a Distributed Class, either atomic\n"
          "//               or molecular.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DCPackerInterface._Dtool_ClassInit(NULL);
        Dtool_DCKeywordList._Dtool_ClassInit(NULL);
        Dtool_DCField.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_DCPackerInterface.As_PyTypeObject(),&Dtool_DCKeywordList.As_PyTypeObject());
        Dtool_DCField.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DCField.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DCField.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_DCField.As_PyTypeObject().tp_repr = & Dtool_Repr_DCField;
        // __str__
        Dtool_DCField.As_PyTypeObject().tp_str = & Dtool_Str_DCField;
        if(PyType_Ready(&Dtool_DCField.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DCField)");
             printf(" Error In PyType_ReadyDCField");
             return;
        }
        Py_INCREF(&Dtool_DCField.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DCField.As_PyTypeObject().tp_dict,"DCField",&Dtool_DCField.As_PyObject());
        //  Static Method getFieldFromNumber
        PyDict_SetItemString(Dtool_DCField.As_PyTypeObject().tp_dict,"getFieldFromNumber",PyCFunction_New(&Dtool_Methods_DCField[2],&Dtool_DCField.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DCField,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DCField.As_PyTypeObject());
        PyModule_AddObject(module, "DCField",(PyObject *)&Dtool_DCField.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DCPackData | DCPackData
//********************************************************************
PyMethodDef Dtool_Methods_DCPackData[]= {
  { "clear",(PyCFunction ) &Dtool_DCPackData_clear_57, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPackData_clear_57_comment},
  { "getString",(PyCFunction ) &Dtool_DCPackData_get_string_58, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPackData_get_string_58_comment},
  { "getLength",(PyCFunction ) &Dtool_DCPackData_get_length_59, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPackData_get_length_59_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DCPackData(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DCPackData.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DCPackData\n"
          "// Description : This is a block of data that receives the results of\n"
          "//               DCPacker.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_DCPackData.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_DCPackData.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DCPackData.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DCPackData.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DCPackData.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DCPackData)");
             printf(" Error In PyType_ReadyDCPackData");
             return;
        }
        Py_INCREF(&Dtool_DCPackData.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DCPackData.As_PyTypeObject().tp_dict,"DCPackData",&Dtool_DCPackData.As_PyObject());
        RegisterRuntimeClass(&Dtool_DCPackData,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DCPackData.As_PyTypeObject());
        PyModule_AddObject(module, "DCPackData",(PyObject *)&Dtool_DCPackData.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DCPacker | DCPacker
//********************************************************************
PyMethodDef Dtool_Methods_DCPacker[]= {
  { "clearData",(PyCFunction ) &Dtool_DCPacker_clear_data_63, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_clear_data_63_comment},
  { "beginPack",(PyCFunction ) &Dtool_DCPacker_begin_pack_64, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_begin_pack_64_comment},
  { "endPack",(PyCFunction ) &Dtool_DCPacker_end_pack_65, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_end_pack_65_comment},
  { "setUnpackData",(PyCFunction ) &Dtool_DCPacker_set_unpack_data_66, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_set_unpack_data_66_comment},
  { "beginUnpack",(PyCFunction ) &Dtool_DCPacker_begin_unpack_67, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_begin_unpack_67_comment},
  { "endUnpack",(PyCFunction ) &Dtool_DCPacker_end_unpack_68, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_end_unpack_68_comment},
  { "beginRepack",(PyCFunction ) &Dtool_DCPacker_begin_repack_69, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_begin_repack_69_comment},
  { "endRepack",(PyCFunction ) &Dtool_DCPacker_end_repack_70, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_end_repack_70_comment},
  { "seek",(PyCFunction ) &Dtool_DCPacker_seek_71, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_seek_71_comment},
  { "hasNestedFields",(PyCFunction ) &Dtool_DCPacker_has_nested_fields_72, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_has_nested_fields_72_comment},
  { "getNumNestedFields",(PyCFunction ) &Dtool_DCPacker_get_num_nested_fields_73, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_get_num_nested_fields_73_comment},
  { "moreNestedFields",(PyCFunction ) &Dtool_DCPacker_more_nested_fields_74, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_more_nested_fields_74_comment},
  { "getCurrentParent",(PyCFunction ) &Dtool_DCPacker_get_current_parent_75, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_get_current_parent_75_comment},
  { "getCurrentField",(PyCFunction ) &Dtool_DCPacker_get_current_field_76, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_get_current_field_76_comment},
  { "getLastSwitch",(PyCFunction ) &Dtool_DCPacker_get_last_switch_77, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_get_last_switch_77_comment},
  { "getPackType",(PyCFunction ) &Dtool_DCPacker_get_pack_type_78, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_get_pack_type_78_comment},
  { "getCurrentFieldName",(PyCFunction ) &Dtool_DCPacker_get_current_field_name_79, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_get_current_field_name_79_comment},
  { "push",(PyCFunction ) &Dtool_DCPacker_push_80, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_push_80_comment},
  { "pop",(PyCFunction ) &Dtool_DCPacker_pop_81, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_pop_81_comment},
  { "packDouble",(PyCFunction ) &Dtool_DCPacker_pack_double_82, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_pack_double_82_comment},
  { "packInt",(PyCFunction ) &Dtool_DCPacker_pack_int_83, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_pack_int_83_comment},
  { "packUint",(PyCFunction ) &Dtool_DCPacker_pack_uint_84, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_pack_uint_84_comment},
  { "packInt64",(PyCFunction ) &Dtool_DCPacker_pack_int64_85, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_pack_int64_85_comment},
  { "packUint64",(PyCFunction ) &Dtool_DCPacker_pack_uint64_86, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_pack_uint64_86_comment},
  { "packString",(PyCFunction ) &Dtool_DCPacker_pack_string_87, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_pack_string_87_comment},
  { "packLiteralValue",(PyCFunction ) &Dtool_DCPacker_pack_literal_value_88, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_pack_literal_value_88_comment},
  { "packDefaultValue",(PyCFunction ) &Dtool_DCPacker_pack_default_value_89, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_pack_default_value_89_comment},
  { "unpackDouble",(PyCFunction ) &Dtool_DCPacker_unpack_double_90, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_unpack_double_90_comment},
  { "unpackInt",(PyCFunction ) &Dtool_DCPacker_unpack_int_91, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_unpack_int_91_comment},
  { "unpackUint",(PyCFunction ) &Dtool_DCPacker_unpack_uint_92, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_unpack_uint_92_comment},
  { "unpackInt64",(PyCFunction ) &Dtool_DCPacker_unpack_int64_93, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_unpack_int64_93_comment},
  { "unpackUint64",(PyCFunction ) &Dtool_DCPacker_unpack_uint64_94, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_unpack_uint64_94_comment},
  { "unpackString",(PyCFunction ) &Dtool_DCPacker_unpack_string_95, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_unpack_string_95_comment},
  { "unpackLiteralValue",(PyCFunction ) &Dtool_DCPacker_unpack_literal_value_96, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_unpack_literal_value_96_comment},
  { "unpackValidate",(PyCFunction ) &Dtool_DCPacker_unpack_validate_97, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_unpack_validate_97_comment},
  { "unpackSkip",(PyCFunction ) &Dtool_DCPacker_unpack_skip_98, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_unpack_skip_98_comment},
  { "packObject",(PyCFunction ) &Dtool_DCPacker_pack_object_99, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_pack_object_99_comment},
  { "unpackObject",(PyCFunction ) &Dtool_DCPacker_unpack_object_100, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_unpack_object_100_comment},
  { "parseAndPack",(PyCFunction ) &Dtool_DCPacker_parse_and_pack_101, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_parse_and_pack_101_comment},
  { "unpackAndFormat",(PyCFunction ) &Dtool_DCPacker_unpack_and_format_102, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_unpack_and_format_102_comment},
  { "hadParseError",(PyCFunction ) &Dtool_DCPacker_had_parse_error_103, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_had_parse_error_103_comment},
  { "hadPackError",(PyCFunction ) &Dtool_DCPacker_had_pack_error_104, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_had_pack_error_104_comment},
  { "hadRangeError",(PyCFunction ) &Dtool_DCPacker_had_range_error_105, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_had_range_error_105_comment},
  { "hadError",(PyCFunction ) &Dtool_DCPacker_had_error_106, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_had_error_106_comment},
  { "getNumUnpackedBytes",(PyCFunction ) &Dtool_DCPacker_get_num_unpacked_bytes_107, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_get_num_unpacked_bytes_107_comment},
  { "getLength",(PyCFunction ) &Dtool_DCPacker_get_length_108, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_get_length_108_comment},
  { "getString",(PyCFunction ) &Dtool_DCPacker_get_string_109, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_get_string_109_comment},
  { "getUnpackLength",(PyCFunction ) &Dtool_DCPacker_get_unpack_length_110, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_get_unpack_length_110_comment},
  { "getUnpackString",(PyCFunction ) &Dtool_DCPacker_get_unpack_string_111, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_get_unpack_string_111_comment},
  { "getNumStackElementsEverAllocated",(PyCFunction ) &Dtool_DCPacker_get_num_stack_elements_ever_allocated_112, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_get_num_stack_elements_ever_allocated_112_comment},
  { "rawPackInt8",(PyCFunction ) &Dtool_DCPacker_raw_pack_int8_113, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_raw_pack_int8_113_comment},
  { "rawPackInt16",(PyCFunction ) &Dtool_DCPacker_raw_pack_int16_114, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_raw_pack_int16_114_comment},
  { "rawPackInt32",(PyCFunction ) &Dtool_DCPacker_raw_pack_int32_115, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_raw_pack_int32_115_comment},
  { "rawPackInt64",(PyCFunction ) &Dtool_DCPacker_raw_pack_int64_116, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_raw_pack_int64_116_comment},
  { "rawPackUint8",(PyCFunction ) &Dtool_DCPacker_raw_pack_uint8_117, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_raw_pack_uint8_117_comment},
  { "rawPackUint16",(PyCFunction ) &Dtool_DCPacker_raw_pack_uint16_118, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_raw_pack_uint16_118_comment},
  { "rawPackUint32",(PyCFunction ) &Dtool_DCPacker_raw_pack_uint32_119, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_raw_pack_uint32_119_comment},
  { "rawPackUint64",(PyCFunction ) &Dtool_DCPacker_raw_pack_uint64_120, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_raw_pack_uint64_120_comment},
  { "rawPackFloat64",(PyCFunction ) &Dtool_DCPacker_raw_pack_float64_121, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_raw_pack_float64_121_comment},
  { "rawPackString",(PyCFunction ) &Dtool_DCPacker_raw_pack_string_122, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_raw_pack_string_122_comment},
  { "rawUnpackInt8",(PyCFunction ) &Dtool_DCPacker_raw_unpack_int8_123, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_raw_unpack_int8_123_comment},
  { "rawUnpackInt16",(PyCFunction ) &Dtool_DCPacker_raw_unpack_int16_124, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_raw_unpack_int16_124_comment},
  { "rawUnpackInt32",(PyCFunction ) &Dtool_DCPacker_raw_unpack_int32_125, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_raw_unpack_int32_125_comment},
  { "rawUnpackInt64",(PyCFunction ) &Dtool_DCPacker_raw_unpack_int64_126, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_raw_unpack_int64_126_comment},
  { "rawUnpackUint8",(PyCFunction ) &Dtool_DCPacker_raw_unpack_uint8_127, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_raw_unpack_uint8_127_comment},
  { "rawUnpackUint16",(PyCFunction ) &Dtool_DCPacker_raw_unpack_uint16_128, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_raw_unpack_uint16_128_comment},
  { "rawUnpackUint32",(PyCFunction ) &Dtool_DCPacker_raw_unpack_uint32_129, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_raw_unpack_uint32_129_comment},
  { "rawUnpackUint64",(PyCFunction ) &Dtool_DCPacker_raw_unpack_uint64_130, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_raw_unpack_uint64_130_comment},
  { "rawUnpackFloat64",(PyCFunction ) &Dtool_DCPacker_raw_unpack_float64_131, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_raw_unpack_float64_131_comment},
  { "rawUnpackString",(PyCFunction ) &Dtool_DCPacker_raw_unpack_string_132, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCPacker_raw_unpack_string_132_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DCPacker(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DCPacker.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DCPacker\n"
          "// Description : This class can be used for packing a series of\n"
          "//               numeric and string data into a binary stream,\n"
          "//               according to the DC specification.\n"
          "//\n"
          "//               See also direct/src/doc/dcPacker.txt for a more\n"
          "//               complete description and examples of using this\n"
          "//               class.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_DCPacker.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_DCPacker.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DCPacker.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DCPacker.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DCPacker.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DCPacker)");
             printf(" Error In PyType_ReadyDCPacker");
             return;
        }
        Py_INCREF(&Dtool_DCPacker.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DCPacker.As_PyTypeObject().tp_dict,"DCPacker",&Dtool_DCPacker.As_PyObject());
        //  Static Method getNumStackElementsEverAllocated
        PyDict_SetItemString(Dtool_DCPacker.As_PyTypeObject().tp_dict,"getNumStackElementsEverAllocated",PyCFunction_New(&Dtool_Methods_DCPacker[49],&Dtool_DCPacker.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DCPacker,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DCPacker.As_PyTypeObject());
        PyModule_AddObject(module, "DCPacker",(PyObject *)&Dtool_DCPacker.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DCParameter | DCParameter
//********************************************************************
PyMethodDef Dtool_Methods_DCParameter[]= {
  { "asSimpleParameter",(PyCFunction ) &Dtool_DCParameter_as_simple_parameter_134, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCParameter_as_simple_parameter_134_comment},
  { "asArrayParameter",(PyCFunction ) &Dtool_DCParameter_as_array_parameter_135, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCParameter_as_array_parameter_135_comment},
  { "makeCopy",(PyCFunction ) &Dtool_DCParameter_make_copy_136, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCParameter_make_copy_136_comment},
  { "isValid",(PyCFunction ) &Dtool_DCParameter_is_valid_137, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCParameter_is_valid_137_comment},
  { "getTypedef",(PyCFunction ) &Dtool_DCParameter_get_typedef_138, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCParameter_get_typedef_138_comment},
  { "__copy__", (PyCFunction)&copy_from_make_copy, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DCParameter(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DCParameter.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DCParameter\n"
          "// Description : Represents the type specification for a single\n"
          "//               parameter within a field specification.  This may be\n"
          "//               a simple type, or it may be a class or an array\n"
          "//               reference.\n"
          "//\n"
          "//               This may also be a typedef reference to another type,\n"
          "//               which has the same properties as the referenced type,\n"
          "//               but a different name.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DCField._Dtool_ClassInit(NULL);
        Dtool_DCParameter.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DCField.As_PyTypeObject());
        Dtool_DCParameter.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DCParameter.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DCParameter.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DCParameter.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DCParameter)");
             printf(" Error In PyType_ReadyDCParameter");
             return;
        }
        Py_INCREF(&Dtool_DCParameter.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DCParameter.As_PyTypeObject().tp_dict,"DCParameter",&Dtool_DCParameter.As_PyObject());
        RegisterRuntimeClass(&Dtool_DCParameter,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DCParameter.As_PyTypeObject());
        PyModule_AddObject(module, "DCParameter",(PyObject *)&Dtool_DCParameter.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DCArrayParameter | DCArrayParameter
//********************************************************************
PyMethodDef Dtool_Methods_DCArrayParameter[]= {
  { "getElementType",(PyCFunction ) &Dtool_DCArrayParameter_get_element_type_140, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCArrayParameter_get_element_type_140_comment},
  { "getArraySize",(PyCFunction ) &Dtool_DCArrayParameter_get_array_size_141, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCArrayParameter_get_array_size_141_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DCArrayParameter(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DCArrayParameter.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DCArrayParameter\n"
          "// Description : This represents an array of some other kind of\n"
          "//               object, meaning this parameter type accepts an\n"
          "//               arbitrary (or possibly fixed) number of nested\n"
          "//               fields, all of which are of the same type.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DCParameter._Dtool_ClassInit(NULL);
        Dtool_DCArrayParameter.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DCParameter.As_PyTypeObject());
        Dtool_DCArrayParameter.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DCArrayParameter.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DCArrayParameter.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DCArrayParameter.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DCArrayParameter)");
             printf(" Error In PyType_ReadyDCArrayParameter");
             return;
        }
        Py_INCREF(&Dtool_DCArrayParameter.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DCArrayParameter.As_PyTypeObject().tp_dict,"DCArrayParameter",&Dtool_DCArrayParameter.As_PyObject());
        RegisterRuntimeClass(&Dtool_DCArrayParameter,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DCArrayParameter.As_PyTypeObject());
        PyModule_AddObject(module, "DCArrayParameter",(PyObject *)&Dtool_DCArrayParameter.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DCAtomicField | DCAtomicField
//********************************************************************
PyMethodDef Dtool_Methods_DCAtomicField[]= {
  { "getNumElements",(PyCFunction ) &Dtool_DCAtomicField_get_num_elements_143, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCAtomicField_get_num_elements_143_comment},
  { "getElement",(PyCFunction ) &Dtool_DCAtomicField_get_element_144, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCAtomicField_get_element_144_comment},
  { "getElementDefault",(PyCFunction ) &Dtool_DCAtomicField_get_element_default_145, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCAtomicField_get_element_default_145_comment},
  { "hasElementDefault",(PyCFunction ) &Dtool_DCAtomicField_has_element_default_146, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCAtomicField_has_element_default_146_comment},
  { "getElementName",(PyCFunction ) &Dtool_DCAtomicField_get_element_name_147, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCAtomicField_get_element_name_147_comment},
  { "getElementType",(PyCFunction ) &Dtool_DCAtomicField_get_element_type_148, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCAtomicField_get_element_type_148_comment},
  { "getElementDivisor",(PyCFunction ) &Dtool_DCAtomicField_get_element_divisor_149, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCAtomicField_get_element_divisor_149_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DCAtomicField(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DCField._Dtool_ClassInit(NULL);
        Dtool_DCAtomicField.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DCField.As_PyTypeObject());
        Dtool_DCAtomicField.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DCAtomicField.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DCAtomicField.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DCAtomicField.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DCAtomicField)");
             printf(" Error In PyType_ReadyDCAtomicField");
             return;
        }
        Py_INCREF(&Dtool_DCAtomicField.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DCAtomicField.As_PyTypeObject().tp_dict,"DCAtomicField",&Dtool_DCAtomicField.As_PyObject());
        RegisterRuntimeClass(&Dtool_DCAtomicField,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DCAtomicField.As_PyTypeObject());
        PyModule_AddObject(module, "DCAtomicField",(PyObject *)&Dtool_DCAtomicField.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DCDeclaration | DCDeclaration
//********************************************************************
PyMethodDef Dtool_Methods_DCDeclaration[]= {
  { "asClass",(PyCFunction ) &Dtool_DCDeclaration_as_class_152, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCDeclaration_as_class_152_comment},
  { "asSwitch",(PyCFunction ) &Dtool_DCDeclaration_as_switch_153, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCDeclaration_as_switch_153_comment},
  { "output",(PyCFunction ) &Dtool_DCDeclaration_output_154, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCDeclaration_output_154_comment},
  { "write",(PyCFunction ) &Dtool_DCDeclaration_write_155, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCDeclaration_write_155_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     DCDeclaration
//////////////////
static PyObject *  Dtool_Repr_DCDeclaration(PyObject * self)
{
    DCDeclaration * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCDeclaration,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     DCDeclaration
//////////////////
static PyObject *  Dtool_Str_DCDeclaration(PyObject * self)
{
    DCDeclaration * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCDeclaration,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os,0);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_DCDeclaration(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DCDeclaration.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DCDeclaration\n"
          "// Description : This is a common interface for a declaration in a DC\n"
          "//               file.  Currently, this is either a class or a typedef\n"
          "//               declaration (import declarations are still collected\n"
          "//               together at the top, and don't inherit from this\n"
          "//               object).  Its only purpose is so that classes and\n"
          "//               typedefs can be stored in one list together so they\n"
          "//               can be ordered correctly on output.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_DCDeclaration.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_DCDeclaration.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DCDeclaration.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DCDeclaration.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_DCDeclaration.As_PyTypeObject().tp_repr = & Dtool_Repr_DCDeclaration;
        // __str__
        Dtool_DCDeclaration.As_PyTypeObject().tp_str = & Dtool_Str_DCDeclaration;
        if(PyType_Ready(&Dtool_DCDeclaration.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DCDeclaration)");
             printf(" Error In PyType_ReadyDCDeclaration");
             return;
        }
        Py_INCREF(&Dtool_DCDeclaration.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DCDeclaration.As_PyTypeObject().tp_dict,"DCDeclaration",&Dtool_DCDeclaration.As_PyObject());
        RegisterRuntimeClass(&Dtool_DCDeclaration,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DCDeclaration.As_PyTypeObject());
        PyModule_AddObject(module, "DCDeclaration",(PyObject *)&Dtool_DCDeclaration.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DCClass | DCClass
//********************************************************************
PyMethodDef Dtool_Methods_DCClass[]= {
  { "getDcFile",(PyCFunction ) &Dtool_DCClass_get_dc_file_157, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_get_dc_file_157_comment},
  { "getName",(PyCFunction ) &Dtool_DCClass_get_name_158, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_get_name_158_comment},
  { "getNumber",(PyCFunction ) &Dtool_DCClass_get_number_159, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_get_number_159_comment},
  { "getNumParents",(PyCFunction ) &Dtool_DCClass_get_num_parents_160, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_get_num_parents_160_comment},
  { "getParent",(PyCFunction ) &Dtool_DCClass_get_parent_161, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_get_parent_161_comment},
  { "hasConstructor",(PyCFunction ) &Dtool_DCClass_has_constructor_162, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_has_constructor_162_comment},
  { "getConstructor",(PyCFunction ) &Dtool_DCClass_get_constructor_163, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_get_constructor_163_comment},
  { "getNumFields",(PyCFunction ) &Dtool_DCClass_get_num_fields_164, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_get_num_fields_164_comment},
  { "getField",(PyCFunction ) &Dtool_DCClass_get_field_165, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_get_field_165_comment},
  { "getFieldByName",(PyCFunction ) &Dtool_DCClass_get_field_by_name_166, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_get_field_by_name_166_comment},
  { "getFieldByIndex",(PyCFunction ) &Dtool_DCClass_get_field_by_index_167, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_get_field_by_index_167_comment},
  { "getNumInheritedFields",(PyCFunction ) &Dtool_DCClass_get_num_inherited_fields_168, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_get_num_inherited_fields_168_comment},
  { "getInheritedField",(PyCFunction ) &Dtool_DCClass_get_inherited_field_169, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_get_inherited_field_169_comment},
  { "isStruct",(PyCFunction ) &Dtool_DCClass_is_struct_170, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_is_struct_170_comment},
  { "isBogusClass",(PyCFunction ) &Dtool_DCClass_is_bogus_class_171, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_is_bogus_class_171_comment},
  { "inheritsFromBogusClass",(PyCFunction ) &Dtool_DCClass_inherits_from_bogus_class_172, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_inherits_from_bogus_class_172_comment},
  { "startGenerate",(PyCFunction ) &Dtool_DCClass_start_generate_173, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_start_generate_173_comment},
  { "stopGenerate",(PyCFunction ) &Dtool_DCClass_stop_generate_174, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_stop_generate_174_comment},
  { "output",(PyCFunction ) &Dtool_DCClass_output_175, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_output_175_comment},
  { "hasClassDef",(PyCFunction ) &Dtool_DCClass_has_class_def_176, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_has_class_def_176_comment},
  { "setClassDef",(PyCFunction ) &Dtool_DCClass_set_class_def_177, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_set_class_def_177_comment},
  { "getClassDef",(PyCFunction ) &Dtool_DCClass_get_class_def_178, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_get_class_def_178_comment},
  { "hasOwnerClassDef",(PyCFunction ) &Dtool_DCClass_has_owner_class_def_179, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_has_owner_class_def_179_comment},
  { "setOwnerClassDef",(PyCFunction ) &Dtool_DCClass_set_owner_class_def_180, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_set_owner_class_def_180_comment},
  { "getOwnerClassDef",(PyCFunction ) &Dtool_DCClass_get_owner_class_def_181, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_get_owner_class_def_181_comment},
  { "receiveUpdate",(PyCFunction ) &Dtool_DCClass_receive_update_182, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_receive_update_182_comment},
  { "receiveUpdateBroadcastRequired",(PyCFunction ) &Dtool_DCClass_receive_update_broadcast_required_183, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_receive_update_broadcast_required_183_comment},
  { "receiveUpdateBroadcastRequiredOwner",(PyCFunction ) &Dtool_DCClass_receive_update_broadcast_required_owner_184, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_receive_update_broadcast_required_owner_184_comment},
  { "receiveUpdateAllRequired",(PyCFunction ) &Dtool_DCClass_receive_update_all_required_185, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_receive_update_all_required_185_comment},
  { "receiveUpdateOther",(PyCFunction ) &Dtool_DCClass_receive_update_other_186, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_receive_update_other_186_comment},
  { "directUpdate",(PyCFunction ) &Dtool_DCClass_direct_update_187, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_direct_update_187_comment},
  { "packRequiredField",(PyCFunction ) &Dtool_DCClass_pack_required_field_188, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_pack_required_field_188_comment},
  { "clientFormatUpdate",(PyCFunction ) &Dtool_DCClass_client_format_update_189, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_client_format_update_189_comment},
  { "aiFormatUpdate",(PyCFunction ) &Dtool_DCClass_ai_format_update_190, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_ai_format_update_190_comment},
  { "aiFormatUpdateMsgType",(PyCFunction ) &Dtool_DCClass_ai_format_update_msg_type_191, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_ai_format_update_msg_type_191_comment},
  { "aiFormatGenerate",(PyCFunction ) &Dtool_DCClass_ai_format_generate_192, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_ai_format_generate_192_comment},
  { "clientFormatGenerateCMU",(PyCFunction ) &Dtool_DCClass_client_format_generate_CMU_193, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_client_format_generate_CMU_193_comment},
  { "aiDatabaseGenerateContext",(PyCFunction ) &Dtool_DCClass_ai_database_generate_context_194, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_ai_database_generate_context_194_comment},
  { "aiDatabaseGenerateContextOld",(PyCFunction ) &Dtool_DCClass_ai_database_generate_context_old_195, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClass_ai_database_generate_context_old_195_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     DCClass
//////////////////
static PyObject *  Dtool_Repr_DCClass(PyObject * self)
{
    DCClass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCClass,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_DCClass(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DCClass.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DCClass\n"
          "// Description : Defines a particular DistributedClass as read from an\n"
          "//               input .dc file.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DCDeclaration._Dtool_ClassInit(NULL);
        Dtool_DCClass.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DCDeclaration.As_PyTypeObject());
        Dtool_DCClass.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DCClass.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DCClass.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_DCClass.As_PyTypeObject().tp_repr = & Dtool_Repr_DCClass;
        // __str__ Repr Proxy
        Dtool_DCClass.As_PyTypeObject().tp_str = & Dtool_Repr_DCClass;
        if(PyType_Ready(&Dtool_DCClass.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DCClass)");
             printf(" Error In PyType_ReadyDCClass");
             return;
        }
        Py_INCREF(&Dtool_DCClass.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DCClass.As_PyTypeObject().tp_dict,"DCClass",&Dtool_DCClass.As_PyObject());
        RegisterRuntimeClass(&Dtool_DCClass,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DCClass.As_PyTypeObject());
        PyModule_AddObject(module, "DCClass",(PyObject *)&Dtool_DCClass.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DCClassParameter | DCClassParameter
//********************************************************************
PyMethodDef Dtool_Methods_DCClassParameter[]= {
  { "getClass",(PyCFunction ) &Dtool_DCClassParameter_get_class_197, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCClassParameter_get_class_197_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DCClassParameter(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DCClassParameter.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DCClassParameter\n"
          "// Description : This represents a class (or struct) object used as a\n"
          "//               parameter itself.  This means that all the fields of\n"
          "//               the class get packed into the message.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DCParameter._Dtool_ClassInit(NULL);
        Dtool_DCClassParameter.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DCParameter.As_PyTypeObject());
        Dtool_DCClassParameter.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DCClassParameter.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DCClassParameter.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DCClassParameter.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DCClassParameter)");
             printf(" Error In PyType_ReadyDCClassParameter");
             return;
        }
        Py_INCREF(&Dtool_DCClassParameter.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DCClassParameter.As_PyTypeObject().tp_dict,"DCClassParameter",&Dtool_DCClassParameter.As_PyObject());
        RegisterRuntimeClass(&Dtool_DCClassParameter,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DCClassParameter.As_PyTypeObject());
        PyModule_AddObject(module, "DCClassParameter",(PyObject *)&Dtool_DCClassParameter.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DCFile | DCFile
//********************************************************************
PyMethodDef Dtool_Methods_DCFile[]= {
  { "clear",(PyCFunction ) &Dtool_DCFile_clear_202, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCFile_clear_202_comment},
  { "readAll",(PyCFunction ) &Dtool_DCFile_read_all_203, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCFile_read_all_203_comment},
  { "read",(PyCFunction ) &Dtool_DCFile_read_204, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCFile_read_204_comment},
  { "write",(PyCFunction ) &Dtool_DCFile_write_205, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCFile_write_205_comment},
  { "getNumClasses",(PyCFunction ) &Dtool_DCFile_get_num_classes_206, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCFile_get_num_classes_206_comment},
  { "getClass",(PyCFunction ) &Dtool_DCFile_get_class_207, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCFile_get_class_207_comment},
  { "getClassByName",(PyCFunction ) &Dtool_DCFile_get_class_by_name_208, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCFile_get_class_by_name_208_comment},
  { "getSwitchByName",(PyCFunction ) &Dtool_DCFile_get_switch_by_name_209, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCFile_get_switch_by_name_209_comment},
  { "getFieldByIndex",(PyCFunction ) &Dtool_DCFile_get_field_by_index_210, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCFile_get_field_by_index_210_comment},
  { "allObjectsValid",(PyCFunction ) &Dtool_DCFile_all_objects_valid_211, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCFile_all_objects_valid_211_comment},
  { "getNumImportModules",(PyCFunction ) &Dtool_DCFile_get_num_import_modules_212, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCFile_get_num_import_modules_212_comment},
  { "getImportModule",(PyCFunction ) &Dtool_DCFile_get_import_module_213, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCFile_get_import_module_213_comment},
  { "getNumImportSymbols",(PyCFunction ) &Dtool_DCFile_get_num_import_symbols_214, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCFile_get_num_import_symbols_214_comment},
  { "getImportSymbol",(PyCFunction ) &Dtool_DCFile_get_import_symbol_215, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCFile_get_import_symbol_215_comment},
  { "getNumTypedefs",(PyCFunction ) &Dtool_DCFile_get_num_typedefs_216, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCFile_get_num_typedefs_216_comment},
  { "getTypedef",(PyCFunction ) &Dtool_DCFile_get_typedef_217, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCFile_get_typedef_217_comment},
  { "getTypedefByName",(PyCFunction ) &Dtool_DCFile_get_typedef_by_name_218, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCFile_get_typedef_by_name_218_comment},
  { "getNumKeywords",(PyCFunction ) &Dtool_DCFile_get_num_keywords_219, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCFile_get_num_keywords_219_comment},
  { "getKeyword",(PyCFunction ) &Dtool_DCFile_get_keyword_220, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCFile_get_keyword_220_comment},
  { "getKeywordByName",(PyCFunction ) &Dtool_DCFile_get_keyword_by_name_221, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCFile_get_keyword_by_name_221_comment},
  { "getHash",(PyCFunction ) &Dtool_DCFile_get_hash_222, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCFile_get_hash_222_comment},
  { NULL, NULL }
};

//////////////////
//  A LocalHash(getKey) Function for this type
//     DCFile
//////////////////
static long  DTool_HashKey_DCFile(PyObject * self)
{
    DCFile * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DCFile,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return -1;
    };
    return local_this->get_hash();
}

void   Dtool_PyModuleClassInit_DCFile(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DCFile.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DCFile\n"
          "// Description : Represents the complete list of Distributed Class\n"
          "//               descriptions as read from a .dc file.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_DCFile.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_DCFile.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DCFile.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DCFile.As_PyTypeObject().tp_dict);
        // __hash__
        Dtool_DCFile.As_PyTypeObject().tp_hash = &DTool_HashKey_DCFile;
        Dtool_DCFile.As_PyTypeObject().tp_compare = &DTOOL_PyObject_Compare;
        if(PyType_Ready(&Dtool_DCFile.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DCFile)");
             printf(" Error In PyType_ReadyDCFile");
             return;
        }
        Py_INCREF(&Dtool_DCFile.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DCFile.As_PyTypeObject().tp_dict,"DCFile",&Dtool_DCFile.As_PyObject());
        RegisterRuntimeClass(&Dtool_DCFile,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DCFile.As_PyTypeObject());
        PyModule_AddObject(module, "DCFile",(PyObject *)&Dtool_DCFile.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DCKeyword | DCKeyword
//********************************************************************
PyMethodDef Dtool_Methods_DCKeyword[]= {
  { "getName",(PyCFunction ) &Dtool_DCKeyword_get_name_224, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCKeyword_get_name_224_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DCKeyword(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DCKeyword.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DCKeyword\n"
          "// Description : This represents a single keyword declaration in the\n"
          "//               dc file.  It is used to define a communication\n"
          "//               property associated with a field, for instance\n"
          "//               \"broadcast\" or \"airecv\".\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DCDeclaration._Dtool_ClassInit(NULL);
        Dtool_DCKeyword.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DCDeclaration.As_PyTypeObject());
        Dtool_DCKeyword.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DCKeyword.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DCKeyword.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DCKeyword.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DCKeyword)");
             printf(" Error In PyType_ReadyDCKeyword");
             return;
        }
        Py_INCREF(&Dtool_DCKeyword.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DCKeyword.As_PyTypeObject().tp_dict,"DCKeyword",&Dtool_DCKeyword.As_PyObject());
        RegisterRuntimeClass(&Dtool_DCKeyword,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DCKeyword.As_PyTypeObject());
        PyModule_AddObject(module, "DCKeyword",(PyObject *)&Dtool_DCKeyword.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DCMolecularField | DCMolecularField
//********************************************************************
PyMethodDef Dtool_Methods_DCMolecularField[]= {
  { "getNumAtomics",(PyCFunction ) &Dtool_DCMolecularField_get_num_atomics_226, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCMolecularField_get_num_atomics_226_comment},
  { "getAtomic",(PyCFunction ) &Dtool_DCMolecularField_get_atomic_227, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCMolecularField_get_atomic_227_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DCMolecularField(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DCMolecularField.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DCMolecularField\n"
          "// Description : A single molecular field of a Distributed Class, as\n"
          "//               read from a .dc file.  This represents a combination\n"
          "//               of two or more related atomic fields, that will often\n"
          "//               be treated as a unit.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DCField._Dtool_ClassInit(NULL);
        Dtool_DCMolecularField.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DCField.As_PyTypeObject());
        Dtool_DCMolecularField.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DCMolecularField.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DCMolecularField.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DCMolecularField.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DCMolecularField)");
             printf(" Error In PyType_ReadyDCMolecularField");
             return;
        }
        Py_INCREF(&Dtool_DCMolecularField.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DCMolecularField.As_PyTypeObject().tp_dict,"DCMolecularField",&Dtool_DCMolecularField.As_PyObject());
        RegisterRuntimeClass(&Dtool_DCMolecularField,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DCMolecularField.As_PyTypeObject());
        PyModule_AddObject(module, "DCMolecularField",(PyObject *)&Dtool_DCMolecularField.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DCSimpleParameter | DCSimpleParameter
//********************************************************************
PyMethodDef Dtool_Methods_DCSimpleParameter[]= {
  { "getType",(PyCFunction ) &Dtool_DCSimpleParameter_get_type_230, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCSimpleParameter_get_type_230_comment},
  { "hasModulus",(PyCFunction ) &Dtool_DCSimpleParameter_has_modulus_231, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCSimpleParameter_has_modulus_231_comment},
  { "getModulus",(PyCFunction ) &Dtool_DCSimpleParameter_get_modulus_232, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCSimpleParameter_get_modulus_232_comment},
  { "getDivisor",(PyCFunction ) &Dtool_DCSimpleParameter_get_divisor_233, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCSimpleParameter_get_divisor_233_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DCSimpleParameter(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DCSimpleParameter.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DCSimpleParameter\n"
          "// Description : This is the most fundamental kind of parameter type:\n"
          "//               a single number or string, one of the DCSubatomicType\n"
          "//               elements.  It may also optionally have a divisor,\n"
          "//               which is meaningful only for the numeric type\n"
          "//               elements (and represents a fixed-point numeric\n"
          "//               convention).\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DCParameter._Dtool_ClassInit(NULL);
        Dtool_DCSimpleParameter.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DCParameter.As_PyTypeObject());
        Dtool_DCSimpleParameter.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DCSimpleParameter.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DCSimpleParameter.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DCSimpleParameter.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DCSimpleParameter)");
             printf(" Error In PyType_ReadyDCSimpleParameter");
             return;
        }
        Py_INCREF(&Dtool_DCSimpleParameter.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DCSimpleParameter.As_PyTypeObject().tp_dict,"DCSimpleParameter",&Dtool_DCSimpleParameter.As_PyObject());
        RegisterRuntimeClass(&Dtool_DCSimpleParameter,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DCSimpleParameter.As_PyTypeObject());
        PyModule_AddObject(module, "DCSimpleParameter",(PyObject *)&Dtool_DCSimpleParameter.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DCSwitch | DCSwitch
//********************************************************************
PyMethodDef Dtool_Methods_DCSwitch[]= {
  { "getName",(PyCFunction ) &Dtool_DCSwitch_get_name_236, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCSwitch_get_name_236_comment},
  { "getKeyParameter",(PyCFunction ) &Dtool_DCSwitch_get_key_parameter_237, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCSwitch_get_key_parameter_237_comment},
  { "getNumCases",(PyCFunction ) &Dtool_DCSwitch_get_num_cases_238, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCSwitch_get_num_cases_238_comment},
  { "getCaseByValue",(PyCFunction ) &Dtool_DCSwitch_get_case_by_value_239, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCSwitch_get_case_by_value_239_comment},
  { "getCase",(PyCFunction ) &Dtool_DCSwitch_get_case_240, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCSwitch_get_case_240_comment},
  { "getDefaultCase",(PyCFunction ) &Dtool_DCSwitch_get_default_case_241, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCSwitch_get_default_case_241_comment},
  { "getValue",(PyCFunction ) &Dtool_DCSwitch_get_value_242, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCSwitch_get_value_242_comment},
  { "getNumFields",(PyCFunction ) &Dtool_DCSwitch_get_num_fields_243, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCSwitch_get_num_fields_243_comment},
  { "getField",(PyCFunction ) &Dtool_DCSwitch_get_field_244, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCSwitch_get_field_244_comment},
  { "getFieldByName",(PyCFunction ) &Dtool_DCSwitch_get_field_by_name_245, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCSwitch_get_field_by_name_245_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DCSwitch(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DCSwitch.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DCSwitch\n"
          "// Description : This represents a switch statement, which can appear\n"
          "//               inside a class body and represents two or more\n"
          "//               alternative unpacking schemes based on the first\n"
          "//               field read.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DCDeclaration._Dtool_ClassInit(NULL);
        Dtool_DCSwitch.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DCDeclaration.As_PyTypeObject());
        Dtool_DCSwitch.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DCSwitch.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DCSwitch.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DCSwitch.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DCSwitch)");
             printf(" Error In PyType_ReadyDCSwitch");
             return;
        }
        Py_INCREF(&Dtool_DCSwitch.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DCSwitch.As_PyTypeObject().tp_dict,"DCSwitch",&Dtool_DCSwitch.As_PyObject());
        RegisterRuntimeClass(&Dtool_DCSwitch,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DCSwitch.As_PyTypeObject());
        PyModule_AddObject(module, "DCSwitch",(PyObject *)&Dtool_DCSwitch.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DCSwitchParameter | DCSwitchParameter
//********************************************************************
PyMethodDef Dtool_Methods_DCSwitchParameter[]= {
  { "getSwitch",(PyCFunction ) &Dtool_DCSwitchParameter_get_switch_247, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCSwitchParameter_get_switch_247_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DCSwitchParameter(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DCSwitchParameter.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DCSwitchParameter\n"
          "// Description : This represents a switch object used as a\n"
          "//               parameter itself, which packs the appropriate fields\n"
          "//               of the switch into the message.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DCParameter._Dtool_ClassInit(NULL);
        Dtool_DCSwitchParameter.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DCParameter.As_PyTypeObject());
        Dtool_DCSwitchParameter.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DCSwitchParameter.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DCSwitchParameter.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DCSwitchParameter.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DCSwitchParameter)");
             printf(" Error In PyType_ReadyDCSwitchParameter");
             return;
        }
        Py_INCREF(&Dtool_DCSwitchParameter.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DCSwitchParameter.As_PyTypeObject().tp_dict,"DCSwitchParameter",&Dtool_DCSwitchParameter.As_PyObject());
        RegisterRuntimeClass(&Dtool_DCSwitchParameter,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DCSwitchParameter.As_PyTypeObject());
        PyModule_AddObject(module, "DCSwitchParameter",(PyObject *)&Dtool_DCSwitchParameter.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DCTypedef | DCTypedef
//********************************************************************
PyMethodDef Dtool_Methods_DCTypedef[]= {
  { "getNumber",(PyCFunction ) &Dtool_DCTypedef_get_number_250, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCTypedef_get_number_250_comment},
  { "getName",(PyCFunction ) &Dtool_DCTypedef_get_name_251, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCTypedef_get_name_251_comment},
  { "getDescription",(PyCFunction ) &Dtool_DCTypedef_get_description_252, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCTypedef_get_description_252_comment},
  { "isBogusTypedef",(PyCFunction ) &Dtool_DCTypedef_is_bogus_typedef_253, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCTypedef_is_bogus_typedef_253_comment},
  { "isImplicitTypedef",(PyCFunction ) &Dtool_DCTypedef_is_implicit_typedef_254, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DCTypedef_is_implicit_typedef_254_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DCTypedef(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DCTypedef.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DCTypedef\n"
          "// Description : This represents a single typedef declaration in the\n"
          "//               dc file.  It assigns a particular type to a new name,\n"
          "//               just like a C typedef.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DCDeclaration._Dtool_ClassInit(NULL);
        Dtool_DCTypedef.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DCDeclaration.As_PyTypeObject());
        Dtool_DCTypedef.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DCTypedef.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DCTypedef.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DCTypedef.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DCTypedef)");
             printf(" Error In PyType_ReadyDCTypedef");
             return;
        }
        Py_INCREF(&Dtool_DCTypedef.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DCTypedef.As_PyTypeObject().tp_dict,"DCTypedef",&Dtool_DCTypedef.As_PyObject());
        RegisterRuntimeClass(&Dtool_DCTypedef,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DCTypedef.As_PyTypeObject());
        PyModule_AddObject(module, "DCTypedef",(PyObject *)&Dtool_DCTypedef.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Enums  ..DCSubatomicType
//********************************************************************
   PyModule_AddIntConstant(module,"STInt8",0);
   PyModule_AddIntConstant(module,"STInt16",1);
   PyModule_AddIntConstant(module,"STInt32",2);
   PyModule_AddIntConstant(module,"STInt64",3);
   PyModule_AddIntConstant(module,"STUint8",4);
   PyModule_AddIntConstant(module,"STUint16",5);
   PyModule_AddIntConstant(module,"STUint32",6);
   PyModule_AddIntConstant(module,"STUint64",7);
   PyModule_AddIntConstant(module,"STFloat64",8);
   PyModule_AddIntConstant(module,"STString",9);
   PyModule_AddIntConstant(module,"STBlob",10);
   PyModule_AddIntConstant(module,"STBlob32",11);
   PyModule_AddIntConstant(module,"STInt16array",12);
   PyModule_AddIntConstant(module,"STInt32array",13);
   PyModule_AddIntConstant(module,"STUint16array",14);
   PyModule_AddIntConstant(module,"STUint32array",15);
   PyModule_AddIntConstant(module,"STInt8array",16);
   PyModule_AddIntConstant(module,"STUint8array",17);
   PyModule_AddIntConstant(module,"STUint32uint8array",18);
   PyModule_AddIntConstant(module,"STChar",19);
   PyModule_AddIntConstant(module,"STInvalid",20);
//********************************************************************
//*** Module Enums  ..DCPackType
//********************************************************************
   PyModule_AddIntConstant(module,"PTInvalid",0);
   PyModule_AddIntConstant(module,"PTDouble",1);
   PyModule_AddIntConstant(module,"PTInt",2);
   PyModule_AddIntConstant(module,"PTUint",3);
   PyModule_AddIntConstant(module,"PTInt64",4);
   PyModule_AddIntConstant(module,"PTUint64",5);
   PyModule_AddIntConstant(module,"PTString",6);
   PyModule_AddIntConstant(module,"PTBlob",7);
   PyModule_AddIntConstant(module,"PTArray",8);
   PyModule_AddIntConstant(module,"PTField",9);
   PyModule_AddIntConstant(module,"PTClass",10);
   PyModule_AddIntConstant(module,"PTSwitch",11);
//********************************************************************
//*** Module Init Updcall ..DCPackerInterface
//********************************************************************
   Dtool_PyModuleClassInit_DCPackerInterface(module);
//********************************************************************
//*** Module Init Updcall ..DCKeywordList
//********************************************************************
   Dtool_PyModuleClassInit_DCKeywordList(module);
//********************************************************************
//*** Module Init Updcall ..DCField
//********************************************************************
   Dtool_PyModuleClassInit_DCField(module);
//********************************************************************
//*** Module Init Updcall ..DCPackData
//********************************************************************
   Dtool_PyModuleClassInit_DCPackData(module);
//********************************************************************
//*** Module Init Updcall ..DCPacker
//********************************************************************
   Dtool_PyModuleClassInit_DCPacker(module);
//********************************************************************
//*** Module Init Updcall ..DCParameter
//********************************************************************
   Dtool_PyModuleClassInit_DCParameter(module);
//********************************************************************
//*** Module Init Updcall ..DCArrayParameter
//********************************************************************
   Dtool_PyModuleClassInit_DCArrayParameter(module);
//********************************************************************
//*** Module Init Updcall ..DCAtomicField
//********************************************************************
   Dtool_PyModuleClassInit_DCAtomicField(module);
//********************************************************************
//*** Module Init Updcall ..DCDeclaration
//********************************************************************
   Dtool_PyModuleClassInit_DCDeclaration(module);
//********************************************************************
//*** Module Init Updcall ..DCClass
//********************************************************************
   Dtool_PyModuleClassInit_DCClass(module);
//********************************************************************
//*** Module Init Updcall ..DCClassParameter
//********************************************************************
   Dtool_PyModuleClassInit_DCClassParameter(module);
//********************************************************************
//*** Module Init Updcall ..DCFile
//********************************************************************
   Dtool_PyModuleClassInit_DCFile(module);
//********************************************************************
//*** Module Init Updcall ..DCKeyword
//********************************************************************
   Dtool_PyModuleClassInit_DCKeyword(module);
//********************************************************************
//*** Module Init Updcall ..DCMolecularField
//********************************************************************
   Dtool_PyModuleClassInit_DCMolecularField(module);
//********************************************************************
//*** Module Init Updcall ..DCSimpleParameter
//********************************************************************
   Dtool_PyModuleClassInit_DCSimpleParameter(module);
//********************************************************************
//*** Module Init Updcall ..DCSwitch
//********************************************************************
   Dtool_PyModuleClassInit_DCSwitch(module);
//********************************************************************
//*** Module Init Updcall ..DCSwitchParameter
//********************************************************************
   Dtool_PyModuleClassInit_DCSwitchParameter(module);
//********************************************************************
//*** Module Init Updcall ..DCTypedef
//********************************************************************
   Dtool_PyModuleClassInit_DCTypedef(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libdcparser_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687213711,  /* file_identifier */
  "libdcparser",  /* library_name */
  "5HfQ",  /* library_hash_name */
  "p3direct",  /* module_name */
  "libdcparser.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  580  /* next_index */
};

Configure(_in_configure_libdcparser);
ConfigureFn(_in_configure_libdcparser) {
  interrogate_request_module(&_in_module_def);
}

