/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/vrpn -Ipanda/src/vrpn -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libvrpn_igate.cxx -od built_Rocket/pandac/input/libvrpn.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/vrpn -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sthirdparty/win-libs-vc9/vrpn/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDA -module panda -library libvrpn config_vrpn.h vrpnAnalog.h vrpnAnalogDevice.h vrpnButton.h vrpnButtonDevice.h vrpnClient.h vrpnDial.h vrpnDialDevice.h vrpnTracker.h vrpnTrackerDevice.h vrpn_composite.cxx vrpn_interface.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libvrpn
#include "py_panda.h"  

#include "clientAnalogDevice.h"
#include "clientBase.h"
#include "clientButtonDevice.h"
#include "clientDialDevice.h"
#include "clientTrackerDevice.h"
#include "config_vrpn.h"
#include "notifyCategoryProxy.h"
#include "pandabase.h"
#include "pvector.h"
#include "vrpnAnalog.h"
#include "vrpnAnalogDevice.h"
#include "vrpnButton.h"
#include "vrpnButtonDevice.h"
#include "vrpnClient.h"
#include "vrpnDial.h"
#include "vrpnDialDevice.h"
#include "vrpnTracker.h"
#include "vrpnTrackerDevice.h"
#include "vrpn_interface.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. VrpnClient
//********************************************************************
typedef  VrpnClient  VrpnClient_localtype;
Define_Module_ClassRef(panda,VrpnClient,VrpnClient_localtype,VrpnClient);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ClientBase;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. VrpnClient 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &VrpnClient::get_server_name(void) const
 *******************************************************************/
static PyObject *Dtool_VrpnClient_get_server_name_4(PyObject *self, PyObject *args,PyObject *kwds) {
    VrpnClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VrpnClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &VrpnClient::get_server_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getServerName", key_word_list));
        else
            (PyArg_Parse(args, ":getServerName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const VrpnClient*)local_this)->get_server_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getServerName(const VrpnClient this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VrpnClient_get_server_name_4_comment =
    "C++ Interface:\n"
    "getServerName(const VrpnClient this)\n"
    "\n"
    "// Filename: vrpnClient.I\n"
    "// Created by:  jason (04Aug00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VrpnClient::get_server_name\n"
    "//       Access: Public\n"
    "//  Description: Returns the name of the server as passed to the\n"
    "//               VrpnClient constructor.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VrpnClient_get_server_name_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool VrpnClient::is_valid(void) const
 *******************************************************************/
static PyObject *Dtool_VrpnClient_is_valid_5(PyObject *self, PyObject *args,PyObject *kwds) {
    VrpnClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VrpnClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool VrpnClient::is_valid(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isValid", key_word_list));
        else
            (PyArg_Parse(args, ":isValid"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const VrpnClient*)local_this)->is_valid();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isValid(const VrpnClient this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VrpnClient_is_valid_5_comment =
    "C++ Interface:\n"
    "isValid(const VrpnClient this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VrpnClient::is_valid\n"
    "//       Access: Public\n"
    "//  Description: Returns true if everything seems to be kosher with\n"
    "//               the server (even if there is no connection), or false\n"
    "//               otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VrpnClient_is_valid_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool VrpnClient::is_connected(void) const
 *******************************************************************/
static PyObject *Dtool_VrpnClient_is_connected_6(PyObject *self, PyObject *args,PyObject *kwds) {
    VrpnClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VrpnClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool VrpnClient::is_connected(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isConnected", key_word_list));
        else
            (PyArg_Parse(args, ":isConnected"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const VrpnClient*)local_this)->is_connected();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isConnected(const VrpnClient this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VrpnClient_is_connected_6_comment =
    "C++ Interface:\n"
    "isConnected(const VrpnClient this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VrpnClient::is_connected\n"
    "//       Access: Public\n"
    "//  Description: Returns true if the connection is established\n"
    "//               succesfully, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VrpnClient_is_connected_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void VrpnClient::write(ostream &out, int indent_level) const
 * void VrpnClient::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_VrpnClient_write_7(PyObject *self, PyObject *args,PyObject *kwds) {
    VrpnClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VrpnClient,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void VrpnClient::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "VrpnClient.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const VrpnClient*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-void VrpnClient::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "VrpnClient.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const VrpnClient*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const VrpnClient this, non-const Ostream out)\n"
          "write(const VrpnClient this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VrpnClient_write_7_comment =
    "C++ Interface:\n"
    "write(const VrpnClient this, non-const Ostream out)\n"
    "write(const VrpnClient this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: VrpnClient::write\n"
    "//       Access: Public\n"
    "//  Description: Writes a list of the active devices that the\n"
    "//               VrpnClient is currently polling each frame.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_VrpnClient_write_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle VrpnClient::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_VrpnClient_get_class_type_8(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle VrpnClient::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = VrpnClient::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_VrpnClient_get_class_type_8_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_VrpnClient_get_class_type_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * VrpnClient::VrpnClient(basic_string< char > const &server_name)
 *******************************************************************/
int  Dtool_Init_VrpnClient(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-VrpnClient::VrpnClient(basic_string< char > const &server_name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"server_name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:VrpnClient", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:VrpnClient", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            VrpnClient *return_value = new VrpnClient(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_VrpnClient,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "VrpnClient(string server_name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_VrpnClient(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_VrpnClient)
    {
        printf("VrpnClient ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    VrpnClient * local_this = (VrpnClient *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_VrpnClient)
        return local_this;
    if(requested_type == &Dtool_ClientBase)
        return ( ClientBase *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( ClientBase *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( ClientBase *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( ClientBase *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_VrpnClient(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_VrpnClient)
        return from_this;
    if(from_type == &Dtool_ClientBase)
    {
          ClientBase* other_this = (ClientBase*)from_this;
          return (VrpnClient*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (VrpnClient*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (VrpnClient*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (VrpnClient*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. VrpnClient | VrpnClient
//********************************************************************
PyMethodDef Dtool_Methods_VrpnClient[]= {
  { "getServerName",(PyCFunction ) &Dtool_VrpnClient_get_server_name_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VrpnClient_get_server_name_4_comment},
  { "isValid",(PyCFunction ) &Dtool_VrpnClient_is_valid_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VrpnClient_is_valid_5_comment},
  { "isConnected",(PyCFunction ) &Dtool_VrpnClient_is_connected_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VrpnClient_is_connected_6_comment},
  { "write",(PyCFunction ) &Dtool_VrpnClient_write_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VrpnClient_write_7_comment},
  { "getClassType",(PyCFunction ) &Dtool_VrpnClient_get_class_type_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_VrpnClient_get_class_type_8_comment},
  { NULL, NULL }
};

//////////////////
//  A __str__ Function
//     VrpnClient
//////////////////
static PyObject *  Dtool_Str_VrpnClient(PyObject * self)
{
    VrpnClient * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_VrpnClient,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_VrpnClient(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_VrpnClient.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : VrpnClient\n"
          "// Description : A specific ClientBase that connects to a VRPN server\n"
          "//               and records information on the connected VRPN\n"
          "//               devices.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_ClientBase._Dtool_ClassInit(NULL);
        Dtool_VrpnClient.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_ClientBase.As_PyTypeObject());
        Dtool_VrpnClient.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_VrpnClient.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_VrpnClient.As_PyTypeObject().tp_dict);
        // __str__
        Dtool_VrpnClient.As_PyTypeObject().tp_str = & Dtool_Str_VrpnClient;
        if(PyType_Ready(&Dtool_VrpnClient.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(VrpnClient)");
             printf(" Error In PyType_ReadyVrpnClient");
             return;
        }
        Py_INCREF(&Dtool_VrpnClient.As_PyTypeObject());
        PyDict_SetItemString(Dtool_VrpnClient.As_PyTypeObject().tp_dict,"VrpnClient",&Dtool_VrpnClient.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_VrpnClient.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_VrpnClient[4],&Dtool_VrpnClient.As_PyObject()));
        RegisterRuntimeClass(&Dtool_VrpnClient,VrpnClient::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_VrpnClient.As_PyTypeObject());
        PyModule_AddObject(module, "VrpnClient",(PyObject *)&Dtool_VrpnClient.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..VrpnClient
//********************************************************************
   Dtool_PyModuleClassInit_VrpnClient(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libvrpn_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212926,  /* file_identifier */
  "libvrpn",  /* library_name */
  "3cuF",  /* library_hash_name */
  "panda",  /* module_name */
  "libvrpn.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  27  /* next_index */
};

Configure(_in_configure_libvrpn);
ConfigureFn(_in_configure_libvrpn) {
  interrogate_request_module(&_in_module_def);
}

