/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir direct/src/interval -Idirect/src/interval -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libinterval_igate.cxx -od built_Rocket/pandac/input/libinterval.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Idirect/src/interval -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_DIRECT -module p3direct -library libinterval cConstrainHprInterval.h cConstrainPosHprInterval.h cConstrainPosInterval.h cConstrainTransformInterval.h cConstraintInterval.h cInterval.h cIntervalManager.h cLerpAnimEffectInterval.h cLerpInterval.h cLerpNodePathInterval.h cMetaInterval.h config_interval.h hideInterval.h interval_composite.cxx lerp_helpers.h showInterval.h waitInterval.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libinterval
#include "py_panda.h"  

#include "animControl.h"
#include "cConstrainHprInterval.h"
#include "cConstrainPosHprInterval.h"
#include "cConstrainPosInterval.h"
#include "cConstrainTransformInterval.h"
#include "cConstraintInterval.h"
#include "cInterval.h"
#include "cIntervalManager.h"
#include "cLerpAnimEffectInterval.h"
#include "cLerpInterval.h"
#include "cLerpNodePathInterval.h"
#include "cMetaInterval.h"
#include "config_interval.h"
#include "directbase.h"
#include "hideInterval.h"
#include "lerp_helpers.h"
#include "lquaternion.h"
#include "lvecBase3.h"
#include <math.h>
#include "nodePath.h"
#include "pdeque.h"
#include "plist.h"
#include "pmap.h"
#include "pmutex.h"
#include "pointerTo.h"
#include "pset.h"
#include "pvector.h"
#include "showInterval.h"
#include "textureStage.h"
#include "vector_int.h"
#include "waitInterval.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. CInterval
//********************************************************************
typedef  CInterval  CInterval_localtype;
Define_Module_ClassRef(p3direct,CInterval,CInterval_localtype,CInterval);
//********************************************************************
//*** prototypes for .. CConstraintInterval
//********************************************************************
typedef  CConstraintInterval  CConstraintInterval_localtype;
Define_Module_ClassRef(p3direct,CConstraintInterval,CConstraintInterval_localtype,CConstraintInterval);
//********************************************************************
//*** prototypes for .. CConstrainHprInterval
//********************************************************************
typedef  CConstrainHprInterval  CConstrainHprInterval_localtype;
Define_Module_ClassRef(p3direct,CConstrainHprInterval,CConstrainHprInterval_localtype,CConstrainHprInterval);
//********************************************************************
//*** prototypes for .. CConstrainPosHprInterval
//********************************************************************
typedef  CConstrainPosHprInterval  CConstrainPosHprInterval_localtype;
Define_Module_ClassRef(p3direct,CConstrainPosHprInterval,CConstrainPosHprInterval_localtype,CConstrainPosHprInterval);
//********************************************************************
//*** prototypes for .. CConstrainPosInterval
//********************************************************************
typedef  CConstrainPosInterval  CConstrainPosInterval_localtype;
Define_Module_ClassRef(p3direct,CConstrainPosInterval,CConstrainPosInterval_localtype,CConstrainPosInterval);
//********************************************************************
//*** prototypes for .. CConstrainTransformInterval
//********************************************************************
typedef  CConstrainTransformInterval  CConstrainTransformInterval_localtype;
Define_Module_ClassRef(p3direct,CConstrainTransformInterval,CConstrainTransformInterval_localtype,CConstrainTransformInterval);
//********************************************************************
//*** prototypes for .. CIntervalManager
//********************************************************************
typedef  CIntervalManager  CIntervalManager_localtype;
Define_Module_Class(p3direct,CIntervalManager,CIntervalManager_localtype,CIntervalManager);
//********************************************************************
//*** prototypes for .. CLerpInterval
//********************************************************************
typedef  CLerpInterval  CLerpInterval_localtype;
Define_Module_ClassRef(p3direct,CLerpInterval,CLerpInterval_localtype,CLerpInterval);
//********************************************************************
//*** prototypes for .. CLerpAnimEffectInterval
//********************************************************************
typedef  CLerpAnimEffectInterval  CLerpAnimEffectInterval_localtype;
Define_Module_ClassRef(p3direct,CLerpAnimEffectInterval,CLerpAnimEffectInterval_localtype,CLerpAnimEffectInterval);
//********************************************************************
//*** prototypes for .. CLerpNodePathInterval
//********************************************************************
typedef  CLerpNodePathInterval  CLerpNodePathInterval_localtype;
Define_Module_ClassRef(p3direct,CLerpNodePathInterval,CLerpNodePathInterval_localtype,CLerpNodePathInterval);
//********************************************************************
//*** prototypes for .. CMetaInterval
//********************************************************************
typedef  CMetaInterval  CMetaInterval_localtype;
Define_Module_ClassRef(p3direct,CMetaInterval,CMetaInterval_localtype,CMetaInterval);
//********************************************************************
//*** prototypes for .. HideInterval
//********************************************************************
typedef  HideInterval  HideInterval_localtype;
Define_Module_ClassRef(p3direct,HideInterval,HideInterval_localtype,HideInterval);
//********************************************************************
//*** prototypes for .. ShowInterval
//********************************************************************
typedef  ShowInterval  ShowInterval_localtype;
Define_Module_ClassRef(p3direct,ShowInterval,ShowInterval_localtype,ShowInterval);
//********************************************************************
//*** prototypes for .. WaitInterval
//********************************************************************
typedef  WaitInterval  WaitInterval_localtype;
Define_Module_ClassRef(p3direct,WaitInterval,WaitInterval_localtype,WaitInterval);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_AnimControl;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_EventQueue;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LQuaternionf;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase2f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_NodePath;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TextureStage;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. CInterval 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &CInterval::get_name(void) const
 *******************************************************************/
static PyObject *Dtool_CInterval_get_name_3(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &CInterval::get_name(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getName", key_word_list));
        else
            (PyArg_Parse(args, ":getName"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const CInterval*)local_this)->get_name();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getName(const CInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_get_name_3_comment =
    "C++ Interface:\n"
    "getName(const CInterval this)\n"
    "\n"
    "// Filename: cInterval.I\n"
    "// Created by:  drose (27Aug02)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::get_name\n"
    "//       Access: Published\n"
    "//  Description: Returns the interval's name.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_get_name_3_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double CInterval::get_duration(void) const
 *******************************************************************/
static PyObject *Dtool_CInterval_get_duration_4(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double CInterval::get_duration(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDuration", key_word_list));
        else
            (PyArg_Parse(args, ":getDuration"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const CInterval*)local_this)->get_duration();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDuration(const CInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_get_duration_4_comment =
    "C++ Interface:\n"
    "getDuration(const CInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::get_duration\n"
    "//       Access: Published\n"
    "//  Description: Returns the duration of the interval in seconds.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_get_duration_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CInterval::get_open_ended(void) const
 *******************************************************************/
static PyObject *Dtool_CInterval_get_open_ended_5(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CInterval::get_open_ended(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOpenEnded", key_word_list));
        else
            (PyArg_Parse(args, ":getOpenEnded"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CInterval*)local_this)->get_open_ended();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOpenEnded(const CInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_get_open_ended_5_comment =
    "C++ Interface:\n"
    "getOpenEnded(const CInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::get_open_ended\n"
    "//       Access: Published\n"
    "//  Description: Returns the state of the \"open_ended\" flag.  This is\n"
    "//               primarily intended for instantaneous intervals like\n"
    "//               FunctionIntervals; it indicates true if the interval\n"
    "//               has some lasting effect that should be applied even\n"
    "//               if the interval doesn't get started until after its\n"
    "//               finish time, or false if the interval is a transitive\n"
    "//               thing that doesn't need to be called late.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_get_open_ended_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CInterval::State CInterval::get_state(void) const
 *******************************************************************/
static PyObject *Dtool_CInterval_get_state_8(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline CInterval::State CInterval::get_state(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getState", key_word_list));
        else
            (PyArg_Parse(args, ":getState"));
        if(!PyErr_Occurred())
        {
            CInterval::State return_value = ((const CInterval*)local_this)->get_state();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getState(const CInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_get_state_8_comment =
    "C++ Interface:\n"
    "getState(const CInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::get_state\n"
    "//       Access: Published\n"
    "//  Description: Indicates the state the interval believes it is in:\n"
    "//               whether it has been started, is currently in the\n"
    "//               middle, or has been finalized.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_get_state_8_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CInterval::is_stopped(void) const
 *******************************************************************/
static PyObject *Dtool_CInterval_is_stopped_9(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CInterval::is_stopped(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isStopped", key_word_list));
        else
            (PyArg_Parse(args, ":isStopped"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CInterval*)local_this)->is_stopped();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isStopped(const CInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_is_stopped_9_comment =
    "C++ Interface:\n"
    "isStopped(const CInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::is_stopped\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the interval is in either its initial\n"
    "//               or final states (but not in a running or paused\n"
    "//               state).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_is_stopped_9_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CInterval::set_done_event(basic_string< char > const &event)
 *******************************************************************/
static PyObject *Dtool_CInterval_set_done_event_10(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CInterval::set_done_event(basic_string< char > const &event)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"event", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setDoneEvent", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setDoneEvent", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_done_event(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CInterval.setDoneEvent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDoneEvent(non-const CInterval this, string event)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_set_done_event_10_comment =
    "C++ Interface:\n"
    "setDoneEvent(non-const CInterval this, string event)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::set_done_event\n"
    "//       Access: Published\n"
    "//  Description: Sets the event that is generated whenever the\n"
    "//               interval reaches its final state, whether it is\n"
    "//               explicitly finished or whether it gets there on its\n"
    "//               own.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_set_done_event_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > const &CInterval::get_done_event(void) const
 *******************************************************************/
static PyObject *Dtool_CInterval_get_done_event_11(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > const &CInterval::get_done_event(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDoneEvent", key_word_list));
        else
            (PyArg_Parse(args, ":getDoneEvent"));
        if(!PyErr_Occurred())
        {
            basic_string< char > const &return_value = ((const CInterval*)local_this)->get_done_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDoneEvent(const CInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_get_done_event_11_comment =
    "C++ Interface:\n"
    "getDoneEvent(const CInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::get_done_event\n"
    "//       Access: Published\n"
    "//  Description: Returns the event that is generated whenever the\n"
    "//               interval reaches its final state, whether it is\n"
    "//               explicitly finished or whether it gets there on its\n"
    "//               own.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_get_done_event_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CInterval::set_t(double t)
 *******************************************************************/
static PyObject *Dtool_CInterval_set_t_12(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CInterval::set_t(double t)
        double param1;
        static char * key_word_list[] = {(char *)"t", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setT", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setT", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_t((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CInterval.setT() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setT(non-const CInterval this, float t)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_set_t_12_comment =
    "C++ Interface:\n"
    "setT(non-const CInterval this, float t)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::set_t\n"
    "//       Access: Published\n"
    "//  Description: Explicitly sets the time within the interval.\n"
    "//               Normally, you would use start() .. finish() to let\n"
    "//               the time play normally, but this may be used to set\n"
    "//               the time to some particular value.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_set_t_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double CInterval::get_t(void) const
 *******************************************************************/
static PyObject *Dtool_CInterval_get_t_13(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double CInterval::get_t(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getT", key_word_list));
        else
            (PyArg_Parse(args, ":getT"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const CInterval*)local_this)->get_t();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getT(const CInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_get_t_13_comment =
    "C++ Interface:\n"
    "getT(const CInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::get_t\n"
    "//       Access: Published\n"
    "//  Description: Returns the current time of the interval: the last\n"
    "//               value of t passed to priv_initialize(), priv_step(), or\n"
    "//               priv_finalize().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_get_t_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CInterval::set_auto_pause(bool auto_pause)
 *******************************************************************/
static PyObject *Dtool_CInterval_set_auto_pause_14(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CInterval::set_auto_pause(bool auto_pause)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"auto_pause", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAutoPause", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setAutoPause", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_auto_pause((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CInterval.setAutoPause() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAutoPause(non-const CInterval this, bool auto_pause)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_set_auto_pause_14_comment =
    "C++ Interface:\n"
    "setAutoPause(non-const CInterval this, bool auto_pause)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::set_auto_pause\n"
    "//       Access: Published\n"
    "//  Description: Changes the state of the 'auto_pause' flag.  If\n"
    "//               this is true, the interval may be arbitrarily\n"
    "//               interrupted when the system needs to reset due to\n"
    "//               some external event by calling\n"
    "//               CIntervalManager::interrupt().  If this\n"
    "//               is false (the default), the interval must always be\n"
    "//               explicitly finished or paused.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_set_auto_pause_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CInterval::get_auto_pause(void) const
 *******************************************************************/
static PyObject *Dtool_CInterval_get_auto_pause_15(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CInterval::get_auto_pause(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAutoPause", key_word_list));
        else
            (PyArg_Parse(args, ":getAutoPause"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CInterval*)local_this)->get_auto_pause();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAutoPause(const CInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_get_auto_pause_15_comment =
    "C++ Interface:\n"
    "getAutoPause(const CInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::get_auto_pause\n"
    "//       Access: Published\n"
    "//  Description: Returns the state of the 'auto_pause' flag.  See\n"
    "//               set_auto_pause().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_get_auto_pause_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CInterval::set_auto_finish(bool auto_finish)
 *******************************************************************/
static PyObject *Dtool_CInterval_set_auto_finish_16(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CInterval::set_auto_finish(bool auto_finish)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"auto_finish", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAutoFinish", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setAutoFinish", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_auto_finish((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CInterval.setAutoFinish() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAutoFinish(non-const CInterval this, bool auto_finish)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_set_auto_finish_16_comment =
    "C++ Interface:\n"
    "setAutoFinish(non-const CInterval this, bool auto_finish)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::set_auto_finish\n"
    "//       Access: Published\n"
    "//  Description: Changes the state of the 'auto_finish' flag.  If\n"
    "//               this is true, the interval may be arbitrarily\n"
    "//               finished when the system needs to reset due to\n"
    "//               some external event by calling\n"
    "//               CIntervalManager::interrupt().  If this\n"
    "//               is false (the default), the interval must always be\n"
    "//               explicitly finished or paused.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_set_auto_finish_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CInterval::get_auto_finish(void) const
 *******************************************************************/
static PyObject *Dtool_CInterval_get_auto_finish_17(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CInterval::get_auto_finish(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAutoFinish", key_word_list));
        else
            (PyArg_Parse(args, ":getAutoFinish"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CInterval*)local_this)->get_auto_finish();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAutoFinish(const CInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_get_auto_finish_17_comment =
    "C++ Interface:\n"
    "getAutoFinish(const CInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::get_auto_finish\n"
    "//       Access: Published\n"
    "//  Description: Returns the state of the 'auto_finish' flag.  See\n"
    "//               set_auto_finish().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_get_auto_finish_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CInterval::set_wants_t_callback(bool wants_t_callback)
 *******************************************************************/
static PyObject *Dtool_CInterval_set_wants_t_callback_18(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CInterval::set_wants_t_callback(bool wants_t_callback)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"wants_t_callback", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setWantsTCallback", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setWantsTCallback", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_wants_t_callback((PyObject_IsTrue(param1)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CInterval.setWantsTCallback() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWantsTCallback(non-const CInterval this, bool wants_t_callback)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_set_wants_t_callback_18_comment =
    "C++ Interface:\n"
    "setWantsTCallback(non-const CInterval this, bool wants_t_callback)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::set_wants_t_callback\n"
    "//       Access: Published\n"
    "//  Description: Changes the state of the 'wants_t_callback' flag.  If\n"
    "//               this is true, the interval will be returned by\n"
    "//               CIntervalManager::get_event() each time the\n"
    "//               interval's time value has been changed, regardless of\n"
    "//               whether it has any external events.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_set_wants_t_callback_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CInterval::get_wants_t_callback(void) const
 *******************************************************************/
static PyObject *Dtool_CInterval_get_wants_t_callback_19(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool CInterval::get_wants_t_callback(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWantsTCallback", key_word_list));
        else
            (PyArg_Parse(args, ":getWantsTCallback"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CInterval*)local_this)->get_wants_t_callback();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWantsTCallback(const CInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_get_wants_t_callback_19_comment =
    "C++ Interface:\n"
    "getWantsTCallback(const CInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::get_wants_t_callback\n"
    "//       Access: Published\n"
    "//  Description: Returns the state of the 'wants_t_callback' flag.\n"
    "//               See set_wants_t_callback().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_get_wants_t_callback_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CInterval::set_manager(CIntervalManager *manager)
 *******************************************************************/
static PyObject *Dtool_CInterval_set_manager_20(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CInterval::set_manager(CIntervalManager *manager)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"manager", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setManager", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setManager", &param1));
            if(!PyErr_Occurred())
            {
                CIntervalManager *param1_this = (CIntervalManager *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_CIntervalManager, 1, "CInterval.setManager", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_manager(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CInterval.setManager() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setManager(non-const CInterval this, non-const CIntervalManager manager)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_set_manager_20_comment =
    "C++ Interface:\n"
    "setManager(non-const CInterval this, non-const CIntervalManager manager)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::set_manager\n"
    "//       Access: Published\n"
    "//  Description: Indicates the CIntervalManager object which will be\n"
    "//               responsible for playing this interval.  This defaults\n"
    "//               to the global CIntervalManager; you should need to\n"
    "//               change this only if you have special requirements for\n"
    "//               playing this interval.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_set_manager_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CIntervalManager *CInterval::get_manager(void) const
 *******************************************************************/
static PyObject *Dtool_CInterval_get_manager_21(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline CIntervalManager *CInterval::get_manager(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getManager", key_word_list));
        else
            (PyArg_Parse(args, ":getManager"));
        if(!PyErr_Occurred())
        {
            CIntervalManager *return_value = ((const CInterval*)local_this)->get_manager();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_CIntervalManager,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getManager(const CInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_get_manager_21_comment =
    "C++ Interface:\n"
    "getManager(const CInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::get_manager\n"
    "//       Access: Published\n"
    "//  Description: Returns the CIntervalManager object which will be\n"
    "//               responsible for playing this interval.  Note that\n"
    "//               this can only return a C++ object; if the particular\n"
    "//               CIntervalManager object has been extended in the\n"
    "//               scripting language, this will return the encapsulated\n"
    "//               C++ object, not the full extended object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_get_manager_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CInterval::start(double start_t, double end_t, double play_rate)
 * void CInterval::start(double start_t, double end_t, double play_rate = (1))
 * void CInterval::start(double start_t, double end_t = (-1), double play_rate = (1))
 * void CInterval::start(double start_t = (0), double end_t = (-1), double play_rate = (1))
 *******************************************************************/
static PyObject *Dtool_CInterval_start_22(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void CInterval::start(double start_t = (0), double end_t = (-1), double play_rate = (1))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":start", key_word_list));
            else
                (PyArg_Parse(args, ":start"));
            if(!PyErr_Occurred())
            {
                (local_this)->start();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CInterval.start() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void CInterval::start(double start_t, double end_t = (-1), double play_rate = (1))
            double param1;
            static char * key_word_list[] = {(char *)"start_t", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:start", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:start", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->start((double)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CInterval.start() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void CInterval::start(double start_t, double end_t, double play_rate = (1))
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"start_t", (char *)"end_t", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:start", key_word_list, &param1, &param2))
            {
                (local_this)->start((double)param1, (double)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CInterval.start() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void CInterval::start(double start_t, double end_t, double play_rate)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"start_t", (char *)"end_t", (char *)"play_rate", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:start", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->start((double)param1, (double)param2, (double)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CInterval.start() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "start() takes 1, 2, 3, or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "start(non-const CInterval this)\n"
          "start(non-const CInterval this, float start_t)\n"
          "start(non-const CInterval this, float start_t, float end_t)\n"
          "start(non-const CInterval this, float start_t, float end_t, float play_rate)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_start_22_comment =
    "C++ Interface:\n"
    "start(non-const CInterval this)\n"
    "start(non-const CInterval this, float start_t)\n"
    "start(non-const CInterval this, float start_t, float end_t)\n"
    "start(non-const CInterval this, float start_t, float end_t, float play_rate)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::start\n"
    "//       Access: Published\n"
    "//  Description: Starts the interval playing by registering it with\n"
    "//               the current CIntervalManager.  The interval will\n"
    "//               play to the end and stop.\n"
    "//\n"
    "//               If end_t is less than zero, it indicates the end of\n"
    "//               the interval.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_start_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CInterval::loop(double start_t, double end_t, double play_rate)
 * void CInterval::loop(double start_t, double end_t, double play_rate = (1))
 * void CInterval::loop(double start_t, double end_t = (-1), double play_rate = (1))
 * void CInterval::loop(double start_t = (0), double end_t = (-1), double play_rate = (1))
 *******************************************************************/
static PyObject *Dtool_CInterval_loop_23(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void CInterval::loop(double start_t = (0), double end_t = (-1), double play_rate = (1))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":loop", key_word_list));
            else
                (PyArg_Parse(args, ":loop"));
            if(!PyErr_Occurred())
            {
                (local_this)->loop();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CInterval.loop() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void CInterval::loop(double start_t, double end_t = (-1), double play_rate = (1))
            double param1;
            static char * key_word_list[] = {(char *)"start_t", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:loop", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:loop", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->loop((double)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CInterval.loop() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void CInterval::loop(double start_t, double end_t, double play_rate = (1))
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"start_t", (char *)"end_t", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:loop", key_word_list, &param1, &param2))
            {
                (local_this)->loop((double)param1, (double)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CInterval.loop() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void CInterval::loop(double start_t, double end_t, double play_rate)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"start_t", (char *)"end_t", (char *)"play_rate", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:loop", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->loop((double)param1, (double)param2, (double)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CInterval.loop() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "loop() takes 1, 2, 3, or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "loop(non-const CInterval this)\n"
          "loop(non-const CInterval this, float start_t)\n"
          "loop(non-const CInterval this, float start_t, float end_t)\n"
          "loop(non-const CInterval this, float start_t, float end_t, float play_rate)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_loop_23_comment =
    "C++ Interface:\n"
    "loop(non-const CInterval this)\n"
    "loop(non-const CInterval this, float start_t)\n"
    "loop(non-const CInterval this, float start_t, float end_t)\n"
    "loop(non-const CInterval this, float start_t, float end_t, float play_rate)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::loop\n"
    "//       Access: Published\n"
    "//  Description: Starts the interval playing by registering it with\n"
    "//               the current CIntervalManager.  The interval will\n"
    "//               play until it is interrupted with finish() or\n"
    "//               pause(), looping back to start_t when it reaches\n"
    "//               end_t.\n"
    "//\n"
    "//               If end_t is less than zero, it indicates the end of\n"
    "//               the interval.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_loop_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * double CInterval::pause(void)
 *******************************************************************/
static PyObject *Dtool_CInterval_pause_24(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-double CInterval::pause(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":pause", key_word_list));
        else
            (PyArg_Parse(args, ":pause"));
        if(!PyErr_Occurred())
        {
            double return_value = (local_this)->pause();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CInterval.pause() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "pause(non-const CInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_pause_24_comment =
    "C++ Interface:\n"
    "pause(non-const CInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::pause\n"
    "//       Access: Published\n"
    "//  Description: Stops the interval from playing but leaves it in its\n"
    "//               current state.  It may later be resumed from this\n"
    "//               point by calling resume().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_pause_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CInterval::resume(void)
 * void CInterval::resume(double start_t)
 *******************************************************************/
static PyObject *Dtool_CInterval_resume_25(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void CInterval::resume(void)
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":resume", key_word_list));
            else
                (PyArg_Parse(args, ":resume"));
            if(!PyErr_Occurred())
            {
                (local_this)->resume();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CInterval.resume() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void CInterval::resume(double start_t)
            double param1;
            static char * key_word_list[] = {(char *)"start_t", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:resume", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:resume", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->resume((double)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CInterval.resume() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "resume() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "resume(non-const CInterval this)\n"
          "resume(non-const CInterval this, float start_t)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_resume_25_comment =
    "C++ Interface:\n"
    "resume(non-const CInterval this)\n"
    "resume(non-const CInterval this, float start_t)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::resume\n"
    "//       Access: Published\n"
    "//  Description: Restarts the interval from its current point after a\n"
    "//               previous call to pause().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::resume\n"
    "//       Access: Published\n"
    "//  Description: Restarts the interval from the indicated point after a\n"
    "//               previous call to pause().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_resume_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CInterval::resume_until(double end_t)
 *******************************************************************/
static PyObject *Dtool_CInterval_resume_until_26(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CInterval::resume_until(double end_t)
        double param1;
        static char * key_word_list[] = {(char *)"end_t", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:resumeUntil", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:resumeUntil", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->resume_until((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CInterval.resumeUntil() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resumeUntil(non-const CInterval this, float end_t)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_resume_until_26_comment =
    "C++ Interface:\n"
    "resumeUntil(non-const CInterval this, float end_t)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::resume_until\n"
    "//       Access: Published\n"
    "//  Description: Restarts the interval from the current point after a\n"
    "//               previous call to pause() (or a previous\n"
    "//               play-to-point-and-stop), to play until the indicated\n"
    "//               point and then stop.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_resume_until_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CInterval::finish(void)
 *******************************************************************/
static PyObject *Dtool_CInterval_finish_27(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CInterval::finish(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":finish", key_word_list));
        else
            (PyArg_Parse(args, ":finish"));
        if(!PyErr_Occurred())
        {
            (local_this)->finish();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CInterval.finish() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "finish(non-const CInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_finish_27_comment =
    "C++ Interface:\n"
    "finish(non-const CInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::finish\n"
    "//       Access: Published\n"
    "//  Description: Stops the interval from playing and sets it to its\n"
    "//               final state.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_finish_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CInterval::clear_to_initial(void)
 *******************************************************************/
static PyObject *Dtool_CInterval_clear_to_initial_28(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CInterval::clear_to_initial(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearToInitial", key_word_list));
        else
            (PyArg_Parse(args, ":clearToInitial"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_to_initial();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CInterval.clearToInitial() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearToInitial(non-const CInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_clear_to_initial_28_comment =
    "C++ Interface:\n"
    "clearToInitial(non-const CInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::clear_to_initial\n"
    "//       Access: Published\n"
    "//  Description: Pauses the interval, if it is playing, and resets its\n"
    "//               state to its initial state, abandoning any state\n"
    "//               changes already in progress in the middle of the\n"
    "//               interval.  Calling this is like pausing the interval\n"
    "//               and discarding it, creating a new one in its place.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_clear_to_initial_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool CInterval::is_playing(void) const
 *******************************************************************/
static PyObject *Dtool_CInterval_is_playing_29(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool CInterval::is_playing(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isPlaying", key_word_list));
        else
            (PyArg_Parse(args, ":isPlaying"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const CInterval*)local_this)->is_playing();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isPlaying(const CInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_is_playing_29_comment =
    "C++ Interface:\n"
    "isPlaying(const CInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::is_playing\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the interval is currently playing,\n"
    "//               false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_is_playing_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * double CInterval::get_play_rate(void) const
 *******************************************************************/
static PyObject *Dtool_CInterval_get_play_rate_30(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-double CInterval::get_play_rate(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPlayRate", key_word_list));
        else
            (PyArg_Parse(args, ":getPlayRate"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const CInterval*)local_this)->get_play_rate();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPlayRate(const CInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_get_play_rate_30_comment =
    "C++ Interface:\n"
    "getPlayRate(const CInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::get_play_rate\n"
    "//       Access: Published\n"
    "//  Description: Returns the play rate as set by the last call to\n"
    "//               start(), loop(), or set_play_rate().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_get_play_rate_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CInterval::set_play_rate(double play_rate)
 *******************************************************************/
static PyObject *Dtool_CInterval_set_play_rate_31(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CInterval::set_play_rate(double play_rate)
        double param1;
        static char * key_word_list[] = {(char *)"play_rate", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setPlayRate", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setPlayRate", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_play_rate((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CInterval.setPlayRate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPlayRate(non-const CInterval this, float play_rate)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_set_play_rate_31_comment =
    "C++ Interface:\n"
    "setPlayRate(non-const CInterval this, float play_rate)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::set_play_rate\n"
    "//       Access: Published\n"
    "//  Description: Changes the play rate of the interval.  If the\n"
    "//               interval is already started, this changes its speed\n"
    "//               on-the-fly.  Note that since play_rate is a parameter\n"
    "//               to start() and loop(), the next call to start() or\n"
    "//               loop() will reset this parameter.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_set_play_rate_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CInterval::priv_do_event(double t, CInterval::EventType event)
 *******************************************************************/
static PyObject *Dtool_CInterval_priv_do_event_32(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CInterval::priv_do_event(double t, CInterval::EventType event)
        double param1;
        int param2;
        static char * key_word_list[] = {(char *)"t", (char *)"event", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "di:privDoEvent", key_word_list, &param1, &param2))
        {
            (local_this)->priv_do_event((double)param1, (CInterval::EventType)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CInterval.privDoEvent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "privDoEvent(non-const CInterval this, float t, int event)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_priv_do_event_32_comment =
    "C++ Interface:\n"
    "privDoEvent(non-const CInterval this, float t, int event)\n"
    "\n"
    "// These functions control the actual playback of the interval.\n"
    "// Don't call them directly; they're intended to be called from a\n"
    "// supervising object, e.g. the Python start() .. finish()\n"
    "// interface.\n"
    "// These cannot be declared private because they must be accessible\n"
    "// to Python, but the method names are prefixed with priv_ to remind\n"
    "// you that you probably don't want to be using them directly.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::priv_do_event\n"
    "//       Access: Published\n"
    "//  Description: Calls the appropriate event function indicated by the\n"
    "//               EventType.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_priv_do_event_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void CInterval::priv_initialize(double t)
 *******************************************************************/
static PyObject *Dtool_CInterval_priv_initialize_33(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void CInterval::priv_initialize(double t)
        double param1;
        static char * key_word_list[] = {(char *)"t", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:privInitialize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:privInitialize", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->priv_initialize((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CInterval.privInitialize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "privInitialize(non-const CInterval this, float t)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_priv_initialize_33_comment =
    "C++ Interface:\n"
    "privInitialize(non-const CInterval this, float t)\n"
    "\n"
    "// These functions control the actual playback of the interval.\n"
    "// Don't call them directly; they're intended to be called from a\n"
    "// supervising object, e.g. the Python start() .. finish()\n"
    "// interface.\n"
    "// These cannot be declared private because they must be accessible\n"
    "// to Python, but the method names are prefixed with priv_ to remind\n"
    "// you that you probably don't want to be using them directly.\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::priv_initialize\n"
    "//       Access: Published, Virtual\n"
    "//  Description: This replaces the first call to priv_step(), and indicates\n"
    "//               that the interval has just begun.  This may be\n"
    "//               overridden by derived classes that need to do some\n"
    "//               explicit initialization on the first call.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_priv_initialize_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void CInterval::priv_instant(void)
 *******************************************************************/
static PyObject *Dtool_CInterval_priv_instant_34(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void CInterval::priv_instant(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":privInstant", key_word_list));
        else
            (PyArg_Parse(args, ":privInstant"));
        if(!PyErr_Occurred())
        {
            (local_this)->priv_instant();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CInterval.privInstant() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "privInstant(non-const CInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_priv_instant_34_comment =
    "C++ Interface:\n"
    "privInstant(non-const CInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::priv_instant\n"
    "//       Access: Published, Virtual\n"
    "//  Description: This is called in lieu of priv_initialize() .. priv_step()\n"
    "//               .. priv_finalize(), when everything is to happen within\n"
    "//               one frame.  The interval should initialize itself,\n"
    "//               then leave itself in the final state.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_priv_instant_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void CInterval::priv_step(double t)
 *******************************************************************/
static PyObject *Dtool_CInterval_priv_step_35(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void CInterval::priv_step(double t)
        double param1;
        static char * key_word_list[] = {(char *)"t", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:privStep", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:privStep", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->priv_step((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CInterval.privStep() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "privStep(non-const CInterval this, float t)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_priv_step_35_comment =
    "C++ Interface:\n"
    "privStep(non-const CInterval this, float t)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::priv_step\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Advances the time on the interval.  The time may\n"
    "//               either increase (the normal case) or decrease\n"
    "//               (e.g. if the interval is being played by a slider).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_priv_step_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void CInterval::priv_finalize(void)
 *******************************************************************/
static PyObject *Dtool_CInterval_priv_finalize_36(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void CInterval::priv_finalize(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":privFinalize", key_word_list));
        else
            (PyArg_Parse(args, ":privFinalize"));
        if(!PyErr_Occurred())
        {
            (local_this)->priv_finalize();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CInterval.privFinalize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "privFinalize(non-const CInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_priv_finalize_36_comment =
    "C++ Interface:\n"
    "privFinalize(non-const CInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::priv_finalize\n"
    "//       Access: Published, Virtual\n"
    "//  Description: This is called to stop an interval, forcing it to\n"
    "//               whatever state it would be after it played all the\n"
    "//               way through.  It's generally invoked by\n"
    "//               set_final_t().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_priv_finalize_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void CInterval::priv_reverse_initialize(double t)
 *******************************************************************/
static PyObject *Dtool_CInterval_priv_reverse_initialize_37(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void CInterval::priv_reverse_initialize(double t)
        double param1;
        static char * key_word_list[] = {(char *)"t", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:privReverseInitialize", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:privReverseInitialize", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->priv_reverse_initialize((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CInterval.privReverseInitialize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "privReverseInitialize(non-const CInterval this, float t)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_priv_reverse_initialize_37_comment =
    "C++ Interface:\n"
    "privReverseInitialize(non-const CInterval this, float t)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::reverse_initialize\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Similar to priv_initialize(), but this is called when the\n"
    "//               interval is being played backwards; it indicates that\n"
    "//               the interval should start at the finishing state and\n"
    "//               undo any intervening intervals.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_priv_reverse_initialize_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void CInterval::priv_reverse_instant(void)
 *******************************************************************/
static PyObject *Dtool_CInterval_priv_reverse_instant_38(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void CInterval::priv_reverse_instant(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":privReverseInstant", key_word_list));
        else
            (PyArg_Parse(args, ":privReverseInstant"));
        if(!PyErr_Occurred())
        {
            (local_this)->priv_reverse_instant();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CInterval.privReverseInstant() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "privReverseInstant(non-const CInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_priv_reverse_instant_38_comment =
    "C++ Interface:\n"
    "privReverseInstant(non-const CInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::reverse_instant\n"
    "//       Access: Published, Virtual\n"
    "//  Description: This is called in lieu of priv_reverse_initialize()\n"
    "//               .. priv_step() .. priv_reverse_finalize(), when everything is\n"
    "//               to happen within one frame.  The interval should\n"
    "//               initialize itself, then leave itself in the initial\n"
    "//               state.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_priv_reverse_instant_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void CInterval::priv_reverse_finalize(void)
 *******************************************************************/
static PyObject *Dtool_CInterval_priv_reverse_finalize_39(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void CInterval::priv_reverse_finalize(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":privReverseFinalize", key_word_list));
        else
            (PyArg_Parse(args, ":privReverseFinalize"));
        if(!PyErr_Occurred())
        {
            (local_this)->priv_reverse_finalize();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CInterval.privReverseFinalize() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "privReverseFinalize(non-const CInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_priv_reverse_finalize_39_comment =
    "C++ Interface:\n"
    "privReverseFinalize(non-const CInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::reverse_finalize\n"
    "//       Access: Published, Virtual\n"
    "//  Description: Called generally following a priv_reverse_initialize(),\n"
    "//               this indicates the interval should set itself to the\n"
    "//               initial state.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_priv_reverse_finalize_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void CInterval::priv_interrupt(void)
 *******************************************************************/
static PyObject *Dtool_CInterval_priv_interrupt_40(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-virtual void CInterval::priv_interrupt(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":privInterrupt", key_word_list));
        else
            (PyArg_Parse(args, ":privInterrupt"));
        if(!PyErr_Occurred())
        {
            (local_this)->priv_interrupt();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CInterval.privInterrupt() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "privInterrupt(non-const CInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_priv_interrupt_40_comment =
    "C++ Interface:\n"
    "privInterrupt(non-const CInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::priv_interrupt\n"
    "//       Access: Published, Virtual\n"
    "//  Description: This is called while the interval is playing to\n"
    "//               indicate that it is about to be interrupted; that is,\n"
    "//               priv_step() will not be called for a length of time.  But\n"
    "//               the interval should remain in its current state in\n"
    "//               anticipation of being eventually restarted when the\n"
    "//               calls to priv_step() eventually resume.\n"
    "//\n"
    "//               The purpose of this function is to allow self-running\n"
    "//               intervals like sound intervals to stop the actual\n"
    "//               sound playback during the pause.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_priv_interrupt_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void CInterval::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_CInterval_output_41(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void CInterval::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "CInterval.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const CInterval*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const CInterval this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_output_41_comment =
    "C++ Interface:\n"
    "output(const CInterval this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::output\n"
    "//       Access: Published, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_output_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void CInterval::write(ostream &out, int indent_level) const
 *******************************************************************/
static PyObject *Dtool_CInterval_write_42(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-virtual void CInterval::write(ostream &out, int indent_level) const
            PyObject *param1;
            int param2;
            static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "CInterval.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const CInterval*)local_this)->write(*param1_this, (int)param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const CInterval this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_write_42_comment =
    "C++ Interface:\n"
    "write(const CInterval this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::write\n"
    "//       Access: Published, Virtual\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_write_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CInterval::setup_play(double start_time, double end_time, double play_rate, bool do_loop)
 *******************************************************************/
static PyObject *Dtool_CInterval_setup_play_43(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CInterval::setup_play(double start_time, double end_time, double play_rate, bool do_loop)
        double param1;
        double param2;
        double param3;
        PyObject *param4;
        static char * key_word_list[] = {(char *)"start_time", (char *)"end_time", (char *)"play_rate", (char *)"do_loop", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dddO:setupPlay", key_word_list, &param1, &param2, &param3, &param4))
        {
            (local_this)->setup_play((double)param1, (double)param2, (double)param3, (PyObject_IsTrue(param4)!=0));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CInterval.setupPlay() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setupPlay(non-const CInterval this, float start_time, float end_time, float play_rate, bool do_loop)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_setup_play_43_comment =
    "C++ Interface:\n"
    "setupPlay(non-const CInterval this, float start_time, float end_time, float play_rate, bool do_loop)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::setup_play\n"
    "//       Access: Published\n"
    "//  Description: Called to prepare the interval for automatic timed\n"
    "//               playback, e.g. via a Python task.  The interval will\n"
    "//               be played from start_t to end_t, at a time factor\n"
    "//               specified by play_rate.  start_t must always be less\n"
    "//               than end_t (except for the exception for end_t == -1,\n"
    "//               below), but if play_rate is negative the interval\n"
    "//               will be played backwards.\n"
    "//\n"
    "//               Specify end_t of -1 to play the entire interval from\n"
    "//               start_t.\n"
    "//\n"
    "//               Call step_play() repeatedly to execute the interval.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_setup_play_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CInterval::setup_resume(void)
 *******************************************************************/
static PyObject *Dtool_CInterval_setup_resume_44(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CInterval::setup_resume(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":setupResume", key_word_list));
        else
            (PyArg_Parse(args, ":setupResume"));
        if(!PyErr_Occurred())
        {
            (local_this)->setup_resume();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CInterval.setupResume() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setupResume(non-const CInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_setup_resume_44_comment =
    "C++ Interface:\n"
    "setupResume(non-const CInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::setup_resume\n"
    "//       Access: Published\n"
    "//  Description: Called to prepare the interval for restarting at the\n"
    "//               current point within the interval after an\n"
    "//               interruption.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_setup_resume_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CInterval::setup_resume_until(double end_t)
 *******************************************************************/
static PyObject *Dtool_CInterval_setup_resume_until_45(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CInterval::setup_resume_until(double end_t)
        double param1;
        static char * key_word_list[] = {(char *)"end_t", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setupResumeUntil", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setupResumeUntil", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->setup_resume_until((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CInterval.setupResumeUntil() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setupResumeUntil(non-const CInterval this, float end_t)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_setup_resume_until_45_comment =
    "C++ Interface:\n"
    "setupResumeUntil(non-const CInterval this, float end_t)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::setup_resume_until\n"
    "//       Access: Published\n"
    "//  Description: Called to prepare the interval for restarting from\n"
    "//               the current point after a previous call to pause()\n"
    "//               (or a previous play-to-point-and-stop), to play until\n"
    "//               the indicated point and then stop.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_setup_resume_until_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool CInterval::step_play(void)
 *******************************************************************/
static PyObject *Dtool_CInterval_step_play_46(PyObject *self, PyObject *args,PyObject *kwds) {
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool CInterval::step_play(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":stepPlay", key_word_list));
        else
            (PyArg_Parse(args, ":stepPlay"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->step_play();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CInterval.stepPlay() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "stepPlay(non-const CInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_step_play_46_comment =
    "C++ Interface:\n"
    "stepPlay(non-const CInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CInterval::step_play\n"
    "//       Access: Published\n"
    "//  Description: Should be called once per frame to execute the\n"
    "//               automatic timed playback begun with setup_play().\n"
    "//\n"
    "//               Returns true if the interval should continue, false\n"
    "//               if it is done and should stop.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CInterval_step_play_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CInterval::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CInterval_get_class_type_47(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CInterval::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CInterval::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CInterval_get_class_type_47_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CInterval_get_class_type_47_comment = NULL;
#endif

int  Dtool_Init_CInterval(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (CInterval)");
       return -1;
}
inline void  * Dtool_UpcastInterface_CInterval(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CInterval)
    {
        printf("CInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CInterval * local_this = (CInterval *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CInterval)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CInterval(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CInterval)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CInterval*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CInterval*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (CInterval*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CConstraintInterval 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CConstraintInterval::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CConstraintInterval_get_class_type_53(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CConstraintInterval::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CConstraintInterval::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConstraintInterval_get_class_type_53_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CConstraintInterval_get_class_type_53_comment = NULL;
#endif

int  Dtool_Init_CConstraintInterval(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (CConstraintInterval)");
       return -1;
}
inline void  * Dtool_UpcastInterface_CConstraintInterval(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CConstraintInterval)
    {
        printf("CConstraintInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CConstraintInterval * local_this = (CConstraintInterval *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CConstraintInterval)
        return local_this;
    if(requested_type == &Dtool_CInterval)
        return ( CInterval *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( CInterval *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( CInterval *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( CInterval *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CConstraintInterval(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CConstraintInterval)
        return from_this;
    if(from_type == &Dtool_CInterval)
    {
          CInterval* other_this = (CInterval*)from_this;
          return (CConstraintInterval*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CConstraintInterval*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CConstraintInterval*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (CConstraintInterval*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CConstrainHprInterval 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline NodePath const &CConstrainHprInterval::get_node(void) const
 *******************************************************************/
static PyObject *Dtool_CConstrainHprInterval_get_node_57(PyObject *self, PyObject *args,PyObject *kwds) {
    CConstrainHprInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConstrainHprInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NodePath const &CConstrainHprInterval::get_node(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNode", key_word_list));
        else
            (PyArg_Parse(args, ":getNode"));
        if(!PyErr_Occurred())
        {
            NodePath const *return_value = &(((const CConstrainHprInterval*)local_this)->get_node());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNode(const CConstrainHprInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConstrainHprInterval_get_node_57_comment =
    "C++ Interface:\n"
    "getNode(const CConstrainHprInterval this)\n"
    "\n"
    "// Filename: cConstrainHprInterval.I\n"
    "// Created by:  pratt (10Mar08)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConstrainHprInterval::get_node\n"
    "//       Access: Published\n"
    "//  Description: Returns the \"source\" node.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConstrainHprInterval_get_node_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NodePath const &CConstrainHprInterval::get_target(void) const
 *******************************************************************/
static PyObject *Dtool_CConstrainHprInterval_get_target_58(PyObject *self, PyObject *args,PyObject *kwds) {
    CConstrainHprInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConstrainHprInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NodePath const &CConstrainHprInterval::get_target(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTarget", key_word_list));
        else
            (PyArg_Parse(args, ":getTarget"));
        if(!PyErr_Occurred())
        {
            NodePath const *return_value = &(((const CConstrainHprInterval*)local_this)->get_target());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTarget(const CConstrainHprInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConstrainHprInterval_get_target_58_comment =
    "C++ Interface:\n"
    "getTarget(const CConstrainHprInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConstrainHprInterval::get_target\n"
    "//       Access: Published\n"
    "//  Description: Returns the \"target\" node.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConstrainHprInterval_get_target_58_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CConstrainHprInterval::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CConstrainHprInterval_get_class_type_59(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CConstrainHprInterval::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CConstrainHprInterval::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConstrainHprInterval_get_class_type_59_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CConstrainHprInterval_get_class_type_59_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CConstrainHprInterval::CConstrainHprInterval(basic_string< char > const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3f const hprOffset)
 * CConstrainHprInterval::CConstrainHprInterval(basic_string< char > const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3f const hprOffset = ((zero())))
 *******************************************************************/
int  Dtool_Init_CConstrainHprInterval(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(5):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-CConstrainHprInterval::CConstrainHprInterval(basic_string< char > const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3f const hprOffset = ((zero())))
                char *param0_str; int param0_len;
                double param1;
                PyObject *param2;
                PyObject *param3;
                PyObject *param4;
                static char * key_word_list[] = {(char *)"name", (char *)"duration", (char *)"node", (char *)"target", (char *)"wrt", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#dOOO:CConstrainHprInterval", key_word_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4))
                {
                    NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "CConstrainHprInterval.CConstrainHprInterval", 1, coerced_ptr, report_errors);
NodePath *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_NodePath, 3, "CConstrainHprInterval.CConstrainHprInterval", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)|| (param3_this == NULL)))
                    {
                        CConstrainHprInterval *return_value = new CConstrainHprInterval(basic_string<char>(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4)!=0));
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_CConstrainHprInterval,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-CConstrainHprInterval::CConstrainHprInterval(basic_string< char > const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3f const hprOffset)
                char *param0_str; int param0_len;
                double param1;
                PyObject *param2;
                PyObject *param3;
                PyObject *param4;
                PyObject *param5;
                static char * key_word_list[] = {(char *)"name", (char *)"duration", (char *)"node", (char *)"target", (char *)"wrt", (char *)"hprOffset", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#dOOOO:CConstrainHprInterval", key_word_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4, &param5))
                {
                    NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "CConstrainHprInterval.CConstrainHprInterval", 1, coerced_ptr, report_errors);
NodePath *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_NodePath, 3, "CConstrainHprInterval.CConstrainHprInterval", 1, coerced_ptr, report_errors);
LVecBase3f *param5_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_LVecBase3f, 5, "CConstrainHprInterval.CConstrainHprInterval", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)|| (param3_this == NULL)|| (param5_this == NULL)))
                    {
                        CConstrainHprInterval *return_value = new CConstrainHprInterval(basic_string<char>(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4)!=0), *param5_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_CConstrainHprInterval,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "CConstrainHprInterval() takes 5 or 6 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "CConstrainHprInterval(string name, float duration, const NodePath node, const NodePath target, bool wrt)\n"
          "CConstrainHprInterval(string name, float duration, const NodePath node, const NodePath target, bool wrt, const VBase3 hprOffset)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CConstrainHprInterval(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CConstrainHprInterval)
    {
        printf("CConstrainHprInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CConstrainHprInterval * local_this = (CConstrainHprInterval *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CConstrainHprInterval)
        return local_this;
    if(requested_type == &Dtool_CConstraintInterval)
        return ( CConstraintInterval *) local_this;
    if(requested_type == &Dtool_CInterval)
        return ( CInterval *)( CConstraintInterval *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( CInterval *)( CConstraintInterval *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( CInterval *)( CConstraintInterval *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( CInterval *)( CConstraintInterval *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CConstrainHprInterval(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CConstrainHprInterval)
        return from_this;
    if(from_type == &Dtool_CConstraintInterval)
    {
          CConstraintInterval* other_this = (CConstraintInterval*)from_this;
          return (CConstrainHprInterval*)other_this;
    }
    if(from_type == &Dtool_CInterval)
    {
          CInterval* other_this = (CInterval*)from_this;
          return (CConstrainHprInterval*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CConstrainHprInterval*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CConstrainHprInterval*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (CConstrainHprInterval*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CConstrainPosHprInterval 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline NodePath const &CConstrainPosHprInterval::get_node(void) const
 *******************************************************************/
static PyObject *Dtool_CConstrainPosHprInterval_get_node_63(PyObject *self, PyObject *args,PyObject *kwds) {
    CConstrainPosHprInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConstrainPosHprInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NodePath const &CConstrainPosHprInterval::get_node(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNode", key_word_list));
        else
            (PyArg_Parse(args, ":getNode"));
        if(!PyErr_Occurred())
        {
            NodePath const *return_value = &(((const CConstrainPosHprInterval*)local_this)->get_node());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNode(const CConstrainPosHprInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConstrainPosHprInterval_get_node_63_comment =
    "C++ Interface:\n"
    "getNode(const CConstrainPosHprInterval this)\n"
    "\n"
    "// Filename: cConstrainPosHprInterval.I\n"
    "// Created by:  pratt (10Mar08)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConstrainPosHprInterval::get_node\n"
    "//       Access: Published\n"
    "//  Description: Returns the \"source\" node.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConstrainPosHprInterval_get_node_63_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NodePath const &CConstrainPosHprInterval::get_target(void) const
 *******************************************************************/
static PyObject *Dtool_CConstrainPosHprInterval_get_target_64(PyObject *self, PyObject *args,PyObject *kwds) {
    CConstrainPosHprInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConstrainPosHprInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NodePath const &CConstrainPosHprInterval::get_target(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTarget", key_word_list));
        else
            (PyArg_Parse(args, ":getTarget"));
        if(!PyErr_Occurred())
        {
            NodePath const *return_value = &(((const CConstrainPosHprInterval*)local_this)->get_target());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTarget(const CConstrainPosHprInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConstrainPosHprInterval_get_target_64_comment =
    "C++ Interface:\n"
    "getTarget(const CConstrainPosHprInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConstrainPosHprInterval::get_target\n"
    "//       Access: Published\n"
    "//  Description: Returns the \"target\" node.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConstrainPosHprInterval_get_target_64_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CConstrainPosHprInterval::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CConstrainPosHprInterval_get_class_type_65(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CConstrainPosHprInterval::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CConstrainPosHprInterval::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConstrainPosHprInterval_get_class_type_65_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CConstrainPosHprInterval_get_class_type_65_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CConstrainPosHprInterval::CConstrainPosHprInterval(basic_string< char > const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3f const posOffset, LVecBase3f const hprOffset)
 * CConstrainPosHprInterval::CConstrainPosHprInterval(basic_string< char > const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3f const posOffset, LVecBase3f const hprOffset = ((zero())))
 * CConstrainPosHprInterval::CConstrainPosHprInterval(basic_string< char > const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3f const posOffset = ((zero())), LVecBase3f const hprOffset = ((zero())))
 *******************************************************************/
int  Dtool_Init_CConstrainPosHprInterval(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(5):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-CConstrainPosHprInterval::CConstrainPosHprInterval(basic_string< char > const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3f const posOffset = ((zero())), LVecBase3f const hprOffset = ((zero())))
                char *param0_str; int param0_len;
                double param1;
                PyObject *param2;
                PyObject *param3;
                PyObject *param4;
                static char * key_word_list[] = {(char *)"name", (char *)"duration", (char *)"node", (char *)"target", (char *)"wrt", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#dOOO:CConstrainPosHprInterval", key_word_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4))
                {
                    NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "CConstrainPosHprInterval.CConstrainPosHprInterval", 1, coerced_ptr, report_errors);
NodePath *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_NodePath, 3, "CConstrainPosHprInterval.CConstrainPosHprInterval", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)|| (param3_this == NULL)))
                    {
                        CConstrainPosHprInterval *return_value = new CConstrainPosHprInterval(basic_string<char>(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4)!=0));
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_CConstrainPosHprInterval,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-CConstrainPosHprInterval::CConstrainPosHprInterval(basic_string< char > const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3f const posOffset, LVecBase3f const hprOffset = ((zero())))
                char *param0_str; int param0_len;
                double param1;
                PyObject *param2;
                PyObject *param3;
                PyObject *param4;
                PyObject *param5;
                static char * key_word_list[] = {(char *)"name", (char *)"duration", (char *)"node", (char *)"target", (char *)"wrt", (char *)"posOffset", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#dOOOO:CConstrainPosHprInterval", key_word_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4, &param5))
                {
                    NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "CConstrainPosHprInterval.CConstrainPosHprInterval", 1, coerced_ptr, report_errors);
NodePath *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_NodePath, 3, "CConstrainPosHprInterval.CConstrainPosHprInterval", 1, coerced_ptr, report_errors);
LVecBase3f *param5_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_LVecBase3f, 5, "CConstrainPosHprInterval.CConstrainPosHprInterval", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)|| (param3_this == NULL)|| (param5_this == NULL)))
                    {
                        CConstrainPosHprInterval *return_value = new CConstrainPosHprInterval(basic_string<char>(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4)!=0), *param5_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_CConstrainPosHprInterval,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(7):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-CConstrainPosHprInterval::CConstrainPosHprInterval(basic_string< char > const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3f const posOffset, LVecBase3f const hprOffset)
                char *param0_str; int param0_len;
                double param1;
                PyObject *param2;
                PyObject *param3;
                PyObject *param4;
                PyObject *param5;
                PyObject *param6;
                static char * key_word_list[] = {(char *)"name", (char *)"duration", (char *)"node", (char *)"target", (char *)"wrt", (char *)"posOffset", (char *)"hprOffset", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#dOOOOO:CConstrainPosHprInterval", key_word_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4, &param5, &param6))
                {
                    NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "CConstrainPosHprInterval.CConstrainPosHprInterval", 1, coerced_ptr, report_errors);
NodePath *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_NodePath, 3, "CConstrainPosHprInterval.CConstrainPosHprInterval", 1, coerced_ptr, report_errors);
LVecBase3f *param5_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_LVecBase3f, 5, "CConstrainPosHprInterval.CConstrainPosHprInterval", 1, coerced_ptr, report_errors);
LVecBase3f *param6_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param6, &Dtool_LVecBase3f, 6, "CConstrainPosHprInterval.CConstrainPosHprInterval", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)|| (param3_this == NULL)|| (param5_this == NULL)|| (param6_this == NULL)))
                    {
                        CConstrainPosHprInterval *return_value = new CConstrainPosHprInterval(basic_string<char>(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4)!=0), *param5_this, *param6_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_CConstrainPosHprInterval,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "CConstrainPosHprInterval() takes 5, 6, or 7 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "CConstrainPosHprInterval(string name, float duration, const NodePath node, const NodePath target, bool wrt)\n"
          "CConstrainPosHprInterval(string name, float duration, const NodePath node, const NodePath target, bool wrt, const VBase3 posOffset)\n"
          "CConstrainPosHprInterval(string name, float duration, const NodePath node, const NodePath target, bool wrt, const VBase3 posOffset, const VBase3 hprOffset)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CConstrainPosHprInterval(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CConstrainPosHprInterval)
    {
        printf("CConstrainPosHprInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CConstrainPosHprInterval * local_this = (CConstrainPosHprInterval *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CConstrainPosHprInterval)
        return local_this;
    if(requested_type == &Dtool_CConstraintInterval)
        return ( CConstraintInterval *) local_this;
    if(requested_type == &Dtool_CInterval)
        return ( CInterval *)( CConstraintInterval *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( CInterval *)( CConstraintInterval *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( CInterval *)( CConstraintInterval *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( CInterval *)( CConstraintInterval *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CConstrainPosHprInterval(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CConstrainPosHprInterval)
        return from_this;
    if(from_type == &Dtool_CConstraintInterval)
    {
          CConstraintInterval* other_this = (CConstraintInterval*)from_this;
          return (CConstrainPosHprInterval*)other_this;
    }
    if(from_type == &Dtool_CInterval)
    {
          CInterval* other_this = (CInterval*)from_this;
          return (CConstrainPosHprInterval*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CConstrainPosHprInterval*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CConstrainPosHprInterval*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (CConstrainPosHprInterval*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CConstrainPosInterval 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline NodePath const &CConstrainPosInterval::get_node(void) const
 *******************************************************************/
static PyObject *Dtool_CConstrainPosInterval_get_node_69(PyObject *self, PyObject *args,PyObject *kwds) {
    CConstrainPosInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConstrainPosInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NodePath const &CConstrainPosInterval::get_node(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNode", key_word_list));
        else
            (PyArg_Parse(args, ":getNode"));
        if(!PyErr_Occurred())
        {
            NodePath const *return_value = &(((const CConstrainPosInterval*)local_this)->get_node());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNode(const CConstrainPosInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConstrainPosInterval_get_node_69_comment =
    "C++ Interface:\n"
    "getNode(const CConstrainPosInterval this)\n"
    "\n"
    "// Filename: cConstrainPosInterval.I\n"
    "// Created by:  pratt (29Sep06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConstrainPosInterval::get_node\n"
    "//       Access: Published\n"
    "//  Description: Returns the \"source\" node.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConstrainPosInterval_get_node_69_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NodePath const &CConstrainPosInterval::get_target(void) const
 *******************************************************************/
static PyObject *Dtool_CConstrainPosInterval_get_target_70(PyObject *self, PyObject *args,PyObject *kwds) {
    CConstrainPosInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConstrainPosInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NodePath const &CConstrainPosInterval::get_target(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTarget", key_word_list));
        else
            (PyArg_Parse(args, ":getTarget"));
        if(!PyErr_Occurred())
        {
            NodePath const *return_value = &(((const CConstrainPosInterval*)local_this)->get_target());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTarget(const CConstrainPosInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConstrainPosInterval_get_target_70_comment =
    "C++ Interface:\n"
    "getTarget(const CConstrainPosInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConstrainPosInterval::get_target\n"
    "//       Access: Published\n"
    "//  Description: Returns the \"target\" node.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConstrainPosInterval_get_target_70_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CConstrainPosInterval::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CConstrainPosInterval_get_class_type_71(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CConstrainPosInterval::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CConstrainPosInterval::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConstrainPosInterval_get_class_type_71_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CConstrainPosInterval_get_class_type_71_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CConstrainPosInterval::CConstrainPosInterval(basic_string< char > const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3f const posOffset)
 * CConstrainPosInterval::CConstrainPosInterval(basic_string< char > const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3f const posOffset = ((zero())))
 *******************************************************************/
int  Dtool_Init_CConstrainPosInterval(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(5):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-CConstrainPosInterval::CConstrainPosInterval(basic_string< char > const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3f const posOffset = ((zero())))
                char *param0_str; int param0_len;
                double param1;
                PyObject *param2;
                PyObject *param3;
                PyObject *param4;
                static char * key_word_list[] = {(char *)"name", (char *)"duration", (char *)"node", (char *)"target", (char *)"wrt", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#dOOO:CConstrainPosInterval", key_word_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4))
                {
                    NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "CConstrainPosInterval.CConstrainPosInterval", 1, coerced_ptr, report_errors);
NodePath *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_NodePath, 3, "CConstrainPosInterval.CConstrainPosInterval", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)|| (param3_this == NULL)))
                    {
                        CConstrainPosInterval *return_value = new CConstrainPosInterval(basic_string<char>(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4)!=0));
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_CConstrainPosInterval,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-CConstrainPosInterval::CConstrainPosInterval(basic_string< char > const &name, double duration, NodePath const &node, NodePath const &target, bool wrt, LVecBase3f const posOffset)
                char *param0_str; int param0_len;
                double param1;
                PyObject *param2;
                PyObject *param3;
                PyObject *param4;
                PyObject *param5;
                static char * key_word_list[] = {(char *)"name", (char *)"duration", (char *)"node", (char *)"target", (char *)"wrt", (char *)"posOffset", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#dOOOO:CConstrainPosInterval", key_word_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4, &param5))
                {
                    NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "CConstrainPosInterval.CConstrainPosInterval", 1, coerced_ptr, report_errors);
NodePath *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_NodePath, 3, "CConstrainPosInterval.CConstrainPosInterval", 1, coerced_ptr, report_errors);
LVecBase3f *param5_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_LVecBase3f, 5, "CConstrainPosInterval.CConstrainPosInterval", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)|| (param3_this == NULL)|| (param5_this == NULL)))
                    {
                        CConstrainPosInterval *return_value = new CConstrainPosInterval(basic_string<char>(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4)!=0), *param5_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_CConstrainPosInterval,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "CConstrainPosInterval() takes 5 or 6 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "CConstrainPosInterval(string name, float duration, const NodePath node, const NodePath target, bool wrt)\n"
          "CConstrainPosInterval(string name, float duration, const NodePath node, const NodePath target, bool wrt, const VBase3 posOffset)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CConstrainPosInterval(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CConstrainPosInterval)
    {
        printf("CConstrainPosInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CConstrainPosInterval * local_this = (CConstrainPosInterval *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CConstrainPosInterval)
        return local_this;
    if(requested_type == &Dtool_CConstraintInterval)
        return ( CConstraintInterval *) local_this;
    if(requested_type == &Dtool_CInterval)
        return ( CInterval *)( CConstraintInterval *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( CInterval *)( CConstraintInterval *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( CInterval *)( CConstraintInterval *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( CInterval *)( CConstraintInterval *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CConstrainPosInterval(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CConstrainPosInterval)
        return from_this;
    if(from_type == &Dtool_CConstraintInterval)
    {
          CConstraintInterval* other_this = (CConstraintInterval*)from_this;
          return (CConstrainPosInterval*)other_this;
    }
    if(from_type == &Dtool_CInterval)
    {
          CInterval* other_this = (CInterval*)from_this;
          return (CConstrainPosInterval*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CConstrainPosInterval*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CConstrainPosInterval*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (CConstrainPosInterval*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CConstrainTransformInterval 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline NodePath const &CConstrainTransformInterval::get_node(void) const
 *******************************************************************/
static PyObject *Dtool_CConstrainTransformInterval_get_node_75(PyObject *self, PyObject *args,PyObject *kwds) {
    CConstrainTransformInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConstrainTransformInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NodePath const &CConstrainTransformInterval::get_node(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNode", key_word_list));
        else
            (PyArg_Parse(args, ":getNode"));
        if(!PyErr_Occurred())
        {
            NodePath const *return_value = &(((const CConstrainTransformInterval*)local_this)->get_node());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNode(const CConstrainTransformInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConstrainTransformInterval_get_node_75_comment =
    "C++ Interface:\n"
    "getNode(const CConstrainTransformInterval this)\n"
    "\n"
    "// Filename: cConstrainTransformInterval.I\n"
    "// Created by:  pratt (29Sep06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConstrainTransformInterval::get_node\n"
    "//       Access: Published\n"
    "//  Description: Returns the \"source\" node.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConstrainTransformInterval_get_node_75_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NodePath const &CConstrainTransformInterval::get_target(void) const
 *******************************************************************/
static PyObject *Dtool_CConstrainTransformInterval_get_target_76(PyObject *self, PyObject *args,PyObject *kwds) {
    CConstrainTransformInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CConstrainTransformInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NodePath const &CConstrainTransformInterval::get_target(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTarget", key_word_list));
        else
            (PyArg_Parse(args, ":getTarget"));
        if(!PyErr_Occurred())
        {
            NodePath const *return_value = &(((const CConstrainTransformInterval*)local_this)->get_target());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTarget(const CConstrainTransformInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConstrainTransformInterval_get_target_76_comment =
    "C++ Interface:\n"
    "getTarget(const CConstrainTransformInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CConstrainTransformInterval::get_target\n"
    "//       Access: Published\n"
    "//  Description: Returns the \"target\" node.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CConstrainTransformInterval_get_target_76_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CConstrainTransformInterval::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CConstrainTransformInterval_get_class_type_77(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CConstrainTransformInterval::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CConstrainTransformInterval::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CConstrainTransformInterval_get_class_type_77_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CConstrainTransformInterval_get_class_type_77_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CConstrainTransformInterval::CConstrainTransformInterval(basic_string< char > const &name, double duration, NodePath const &node, NodePath const &target, bool wrt)
 *******************************************************************/
int  Dtool_Init_CConstrainTransformInterval(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-CConstrainTransformInterval::CConstrainTransformInterval(basic_string< char > const &name, double duration, NodePath const &node, NodePath const &target, bool wrt)
            char *param0_str; int param0_len;
            double param1;
            PyObject *param2;
            PyObject *param3;
            PyObject *param4;
            static char * key_word_list[] = {(char *)"name", (char *)"duration", (char *)"node", (char *)"target", (char *)"wrt", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#dOOO:CConstrainTransformInterval", key_word_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4))
            {
                NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "CConstrainTransformInterval.CConstrainTransformInterval", 1, coerced_ptr, report_errors);
NodePath *param3_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_NodePath, 3, "CConstrainTransformInterval.CConstrainTransformInterval", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)|| (param3_this == NULL)))
                {
                    CConstrainTransformInterval *return_value = new CConstrainTransformInterval(basic_string<char>(param0_str, param0_len), (double)param1, *param2_this, *param3_this, (PyObject_IsTrue(param4)!=0));
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_CConstrainTransformInterval,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "CConstrainTransformInterval(string name, float duration, const NodePath node, const NodePath target, bool wrt)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CConstrainTransformInterval(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CConstrainTransformInterval)
    {
        printf("CConstrainTransformInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CConstrainTransformInterval * local_this = (CConstrainTransformInterval *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CConstrainTransformInterval)
        return local_this;
    if(requested_type == &Dtool_CConstraintInterval)
        return ( CConstraintInterval *) local_this;
    if(requested_type == &Dtool_CInterval)
        return ( CInterval *)( CConstraintInterval *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( CInterval *)( CConstraintInterval *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( CInterval *)( CConstraintInterval *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( CInterval *)( CConstraintInterval *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CConstrainTransformInterval(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CConstrainTransformInterval)
        return from_this;
    if(from_type == &Dtool_CConstraintInterval)
    {
          CConstraintInterval* other_this = (CConstraintInterval*)from_this;
          return (CConstrainTransformInterval*)other_this;
    }
    if(from_type == &Dtool_CInterval)
    {
          CInterval* other_this = (CInterval*)from_this;
          return (CConstrainTransformInterval*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CConstrainTransformInterval*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CConstrainTransformInterval*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (CConstrainTransformInterval*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CIntervalManager 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void CIntervalManager::set_event_queue(EventQueue *event_queue)
 *******************************************************************/
static PyObject *Dtool_CIntervalManager_set_event_queue_82(PyObject *self, PyObject *args,PyObject *kwds) {
    CIntervalManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CIntervalManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CIntervalManager::set_event_queue(EventQueue *event_queue)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"event_queue", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setEventQueue", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setEventQueue", &param1));
            if(!PyErr_Occurred())
            {
                EventQueue *param1_this = (EventQueue *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_EventQueue, 1, "CIntervalManager.setEventQueue", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_event_queue(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CIntervalManager.setEventQueue() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEventQueue(non-const CIntervalManager this, non-const EventQueue event_queue)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CIntervalManager_set_event_queue_82_comment =
    "C++ Interface:\n"
    "setEventQueue(non-const CIntervalManager this, non-const EventQueue event_queue)\n"
    "\n"
    "// Filename: cIntervalManager.I\n"
    "// Created by:  drose (10Sep02)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CIntervalManager::set_event_queue\n"
    "//       Access: Published\n"
    "//  Description: Specifies a custom event queue to be used for\n"
    "//               throwing done events from intervals as they finish.\n"
    "//               If this is not specified, the global event queue is\n"
    "//               used.\n"
    "//\n"
    "//               The caller maintains ownership of the EventQueue\n"
    "//               object; it is the caller's responsibility to ensure\n"
    "//               that the supplied EventQueue does not destruct during\n"
    "//               the lifetime of the CIntervalManager.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CIntervalManager_set_event_queue_82_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline EventQueue *CIntervalManager::get_event_queue(void) const
 *******************************************************************/
static PyObject *Dtool_CIntervalManager_get_event_queue_83(PyObject *self, PyObject *args,PyObject *kwds) {
    CIntervalManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CIntervalManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline EventQueue *CIntervalManager::get_event_queue(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEventQueue", key_word_list));
        else
            (PyArg_Parse(args, ":getEventQueue"));
        if(!PyErr_Occurred())
        {
            EventQueue *return_value = ((const CIntervalManager*)local_this)->get_event_queue();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_EventQueue,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEventQueue(const CIntervalManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CIntervalManager_get_event_queue_83_comment =
    "C++ Interface:\n"
    "getEventQueue(const CIntervalManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CIntervalManager::get_event_queue\n"
    "//       Access: Published\n"
    "//  Description: Returns the custom event queue to be used for\n"
    "//               throwing done events from intervals as they finish.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CIntervalManager_get_event_queue_83_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int CIntervalManager::add_c_interval(CInterval *interval, bool external)
 *******************************************************************/
static PyObject *Dtool_CIntervalManager_add_c_interval_84(PyObject *self, PyObject *args,PyObject *kwds) {
    CIntervalManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CIntervalManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int CIntervalManager::add_c_interval(CInterval *interval, bool external)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"interval", (char *)"external", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:addCInterval", key_word_list, &param1, &param2))
            {
                CInterval *param1_this = (CInterval *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_CInterval, 1, "CIntervalManager.addCInterval", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = (local_this)->add_c_interval(param1_this, (PyObject_IsTrue(param2)!=0));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CIntervalManager.addCInterval() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addCInterval(non-const CIntervalManager this, non-const CInterval interval, bool external)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CIntervalManager_add_c_interval_84_comment =
    "C++ Interface:\n"
    "addCInterval(non-const CIntervalManager this, non-const CInterval interval, bool external)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CIntervalManager::add_c_interval\n"
    "//       Access: Published\n"
    "//  Description: Adds the interval to the manager, and returns a\n"
    "//               unique index for the interval.  This index will be\n"
    "//               unique among all the currently added intervals, but\n"
    "//               not unique across all intervals ever added to the\n"
    "//               manager.  The maximum index value will never exceed\n"
    "//               the maximum number of intervals added at any given\n"
    "//               time.\n"
    "//\n"
    "//               If the external flag is true, the interval is\n"
    "//               understood to also be stored in the scripting\n"
    "//               language data structures.  In this case, it will be\n"
    "//               available for information returned by\n"
    "//               get_next_event() and get_next_removal().  If external\n"
    "//               is false, the interval's index will never be returned\n"
    "//               by these two functions.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CIntervalManager_add_c_interval_84_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int CIntervalManager::find_c_interval(basic_string< char > const &name) const
 *******************************************************************/
static PyObject *Dtool_CIntervalManager_find_c_interval_85(PyObject *self, PyObject *args,PyObject *kwds) {
    CIntervalManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CIntervalManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int CIntervalManager::find_c_interval(basic_string< char > const &name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:findCInterval", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:findCInterval", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            int return_value = ((const CIntervalManager*)local_this)->find_c_interval(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findCInterval(const CIntervalManager this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CIntervalManager_find_c_interval_85_comment =
    "C++ Interface:\n"
    "findCInterval(const CIntervalManager this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CIntervalManager::find_c_interval\n"
    "//       Access: Published\n"
    "//  Description: Returns the index associated with the named interval,\n"
    "//               if there is such an interval, or -1 if there is not.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CIntervalManager_find_c_interval_85_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CInterval *CIntervalManager::get_c_interval(int index) const
 *******************************************************************/
static PyObject *Dtool_CIntervalManager_get_c_interval_86(PyObject *self, PyObject *args,PyObject *kwds) {
    CIntervalManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CIntervalManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-CInterval *CIntervalManager::get_c_interval(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getCInterval", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getCInterval", &param1));
        if(!PyErr_Occurred())
        {
            CInterval *return_value = ((const CIntervalManager*)local_this)->get_c_interval((int)param1);
            if (return_value != (CInterval *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_CInterval,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCInterval(const CIntervalManager this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CIntervalManager_get_c_interval_86_comment =
    "C++ Interface:\n"
    "getCInterval(const CIntervalManager this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CIntervalManager::get_c_interval\n"
    "//       Access: Published\n"
    "//  Description: Returns the interval associated with the given index.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CIntervalManager_get_c_interval_86_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CIntervalManager::remove_c_interval(int index)
 *******************************************************************/
static PyObject *Dtool_CIntervalManager_remove_c_interval_87(PyObject *self, PyObject *args,PyObject *kwds) {
    CIntervalManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CIntervalManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CIntervalManager::remove_c_interval(int index)
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:removeCInterval", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:removeCInterval", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->remove_c_interval((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CIntervalManager.removeCInterval() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeCInterval(non-const CIntervalManager this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CIntervalManager_remove_c_interval_87_comment =
    "C++ Interface:\n"
    "removeCInterval(non-const CIntervalManager this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CIntervalManager::remove_c_interval\n"
    "//       Access: Published\n"
    "//  Description: Removes the indicated interval from the queue\n"
    "//               immediately.  It will not be returned from\n"
    "//               get_next_removal(), and none of its pending events,\n"
    "//               if any, will be returned by get_next_event().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CIntervalManager_remove_c_interval_87_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int CIntervalManager::interrupt(void)
 *******************************************************************/
static PyObject *Dtool_CIntervalManager_interrupt_88(PyObject *self, PyObject *args,PyObject *kwds) {
    CIntervalManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CIntervalManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int CIntervalManager::interrupt(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":interrupt", key_word_list));
        else
            (PyArg_Parse(args, ":interrupt"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->interrupt();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CIntervalManager.interrupt() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "interrupt(non-const CIntervalManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CIntervalManager_interrupt_88_comment =
    "C++ Interface:\n"
    "interrupt(non-const CIntervalManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CIntervalManager::interrupt\n"
    "//       Access: Published\n"
    "//  Description: Pauses or finishes (removes from the active queue)\n"
    "//               all intervals tagged with auto_pause or auto_finish\n"
    "//               set to true.  These are intervals that someone fired\n"
    "//               up but won't necessarily expect to clean up; they can\n"
    "//               be interrupted at will when necessary.\n"
    "//\n"
    "//               Returns the number of intervals affected.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CIntervalManager_interrupt_88_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int CIntervalManager::get_num_intervals(void) const
 *******************************************************************/
static PyObject *Dtool_CIntervalManager_get_num_intervals_89(PyObject *self, PyObject *args,PyObject *kwds) {
    CIntervalManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CIntervalManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int CIntervalManager::get_num_intervals(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumIntervals", key_word_list));
        else
            (PyArg_Parse(args, ":getNumIntervals"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const CIntervalManager*)local_this)->get_num_intervals();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumIntervals(const CIntervalManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CIntervalManager_get_num_intervals_89_comment =
    "C++ Interface:\n"
    "getNumIntervals(const CIntervalManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CIntervalManager::get_num_intervals\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of currently active intervals.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CIntervalManager_get_num_intervals_89_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int CIntervalManager::get_max_index(void) const
 *******************************************************************/
static PyObject *Dtool_CIntervalManager_get_max_index_90(PyObject *self, PyObject *args,PyObject *kwds) {
    CIntervalManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CIntervalManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int CIntervalManager::get_max_index(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxIndex", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxIndex"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const CIntervalManager*)local_this)->get_max_index();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxIndex(const CIntervalManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CIntervalManager_get_max_index_90_comment =
    "C++ Interface:\n"
    "getMaxIndex(const CIntervalManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CIntervalManager::get_max_index\n"
    "//       Access: Published\n"
    "//  Description: Returns one more than the largest interval index\n"
    "//               number in the manager.  If you walk through all the\n"
    "//               values between (0, get_max_index()] and call\n"
    "//               get_c_interval() on each number, you will retrieve\n"
    "//               all of the managed intervals (and possibly a number\n"
    "//               of NULL pointers as well).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CIntervalManager_get_max_index_90_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CIntervalManager::step(void)
 *******************************************************************/
static PyObject *Dtool_CIntervalManager_step_91(PyObject *self, PyObject *args,PyObject *kwds) {
    CIntervalManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CIntervalManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CIntervalManager::step(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":step", key_word_list));
        else
            (PyArg_Parse(args, ":step"));
        if(!PyErr_Occurred())
        {
            (local_this)->step();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CIntervalManager.step() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "step(non-const CIntervalManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CIntervalManager_step_91_comment =
    "C++ Interface:\n"
    "step(non-const CIntervalManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CIntervalManager::step\n"
    "//       Access: Published\n"
    "//  Description: This should be called every frame to do the\n"
    "//               processing for all the active intervals.  It will\n"
    "//               call step_play() for each interval that has been\n"
    "//               added and that has not yet been removed.\n"
    "//\n"
    "//               After each call to step(), the scripting language\n"
    "//               should call get_next_event() and get_next_removal()\n"
    "//               repeatedly to process all the high-level\n"
    "//               (e.g. Python-interval-based) events and to manage the\n"
    "//               high-level list of intervals.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CIntervalManager_step_91_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int CIntervalManager::get_next_event(void)
 *******************************************************************/
static PyObject *Dtool_CIntervalManager_get_next_event_92(PyObject *self, PyObject *args,PyObject *kwds) {
    CIntervalManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CIntervalManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int CIntervalManager::get_next_event(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNextEvent", key_word_list));
        else
            (PyArg_Parse(args, ":getNextEvent"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_next_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CIntervalManager.getNextEvent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNextEvent(non-const CIntervalManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CIntervalManager_get_next_event_92_comment =
    "C++ Interface:\n"
    "getNextEvent(non-const CIntervalManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CIntervalManager::get_next_event\n"
    "//       Access: Published\n"
    "//  Description: This should be called by the scripting language after\n"
    "//               each call to step().  It returns the index number of\n"
    "//               the next interval that has events requiring servicing\n"
    "//               by the scripting language, or -1 if no more intervals\n"
    "//               have any events pending.\n"
    "//\n"
    "//               If this function returns something other than -1, it\n"
    "//               is the scripting language's responsibility to query\n"
    "//               the indicated interval for its next event via\n"
    "//               get_event_index(), and eventually pop_event().\n"
    "//\n"
    "//               Then get_next_event() should be called again until it\n"
    "//               returns -1.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CIntervalManager_get_next_event_92_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int CIntervalManager::get_next_removal(void)
 *******************************************************************/
static PyObject *Dtool_CIntervalManager_get_next_removal_93(PyObject *self, PyObject *args,PyObject *kwds) {
    CIntervalManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CIntervalManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int CIntervalManager::get_next_removal(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNextRemoval", key_word_list));
        else
            (PyArg_Parse(args, ":getNextRemoval"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_next_removal();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CIntervalManager.getNextRemoval() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNextRemoval(non-const CIntervalManager this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CIntervalManager_get_next_removal_93_comment =
    "C++ Interface:\n"
    "getNextRemoval(non-const CIntervalManager this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CIntervalManager::get_next_removal\n"
    "//       Access: Published\n"
    "//  Description: This should be called by the scripting language after\n"
    "//               each call to step().  It returns the index number of\n"
    "//               an interval that was recently removed, or -1 if no\n"
    "//               intervals were removed.\n"
    "//\n"
    "//               If this returns something other than -1, the\n"
    "//               scripting language should clean up its own data\n"
    "//               structures accordingly, and then call\n"
    "//               get_next_removal() again.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CIntervalManager_get_next_removal_93_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CIntervalManager::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_CIntervalManager_output_94(PyObject *self, PyObject *args,PyObject *kwds) {
    CIntervalManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CIntervalManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void CIntervalManager::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "CIntervalManager.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const CIntervalManager*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const CIntervalManager this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CIntervalManager_output_94_comment =
    "C++ Interface:\n"
    "output(const CIntervalManager this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CIntervalManager::output\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CIntervalManager_output_94_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CIntervalManager::write(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_CIntervalManager_write_95(PyObject *self, PyObject *args,PyObject *kwds) {
    CIntervalManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CIntervalManager,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void CIntervalManager::write(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:write", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "CIntervalManager.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const CIntervalManager*)local_this)->write(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const CIntervalManager this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CIntervalManager_write_95_comment =
    "C++ Interface:\n"
    "write(const CIntervalManager this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CIntervalManager::write\n"
    "//       Access: Published\n"
    "//  Description: \n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CIntervalManager_write_95_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static CIntervalManager *CIntervalManager::get_global_ptr(void)
 *******************************************************************/
static PyObject *Dtool_CIntervalManager_get_global_ptr_96(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static CIntervalManager *CIntervalManager::get_global_ptr(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getGlobalPtr", key_word_list))
        {
            CIntervalManager *return_value = CIntervalManager::get_global_ptr();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_CIntervalManager,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGlobalPtr()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CIntervalManager_get_global_ptr_96_comment =
    "C++ Interface:\n"
    "getGlobalPtr()\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CIntervalManager::get_global_ptr\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the pointer to the one global\n"
    "//               CIntervalManager object.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CIntervalManager_get_global_ptr_96_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CIntervalManager::CIntervalManager(void)
 *******************************************************************/
int  Dtool_Init_CIntervalManager(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-CIntervalManager::CIntervalManager(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":CIntervalManager", key_word_list))
        {
            CIntervalManager *return_value = new CIntervalManager();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_CIntervalManager,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "CIntervalManager()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CIntervalManager(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CIntervalManager)
    {
        printf("CIntervalManager ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CIntervalManager * local_this = (CIntervalManager *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CIntervalManager)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CIntervalManager(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CIntervalManager)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CLerpInterval 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline CLerpInterval::BlendType CLerpInterval::get_blend_type(void) const
 *******************************************************************/
static PyObject *Dtool_CLerpInterval_get_blend_type_99(PyObject *self, PyObject *args,PyObject *kwds) {
    CLerpInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CLerpInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline CLerpInterval::BlendType CLerpInterval::get_blend_type(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBlendType", key_word_list));
        else
            (PyArg_Parse(args, ":getBlendType"));
        if(!PyErr_Occurred())
        {
            CLerpInterval::BlendType return_value = ((const CLerpInterval*)local_this)->get_blend_type();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBlendType(const CLerpInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpInterval_get_blend_type_99_comment =
    "C++ Interface:\n"
    "getBlendType(const CLerpInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpInterval::get_blend_type\n"
    "//       Access: Published\n"
    "//  Description: Returns the blend type specified for the interval.\n"
    "//               This controls how the linear interpolation behaves\n"
    "//               near the beginning and end of the lerp period.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CLerpInterval_get_blend_type_99_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static CLerpInterval::BlendType CLerpInterval::string_blend_type(basic_string< char > const &blend_type)
 *******************************************************************/
static PyObject *Dtool_CLerpInterval_string_blend_type_100(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static CLerpInterval::BlendType CLerpInterval::string_blend_type(basic_string< char > const &blend_type)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"blend_type", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:stringBlendType", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:stringBlendType", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            CLerpInterval::BlendType return_value = CLerpInterval::string_blend_type(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "stringBlendType(string blend_type)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpInterval_string_blend_type_100_comment =
    "C++ Interface:\n"
    "stringBlendType(string blend_type)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpInterval::string_blend_type\n"
    "//       Access: Published, Static\n"
    "//  Description: Returns the BlendType enumerated value corresponding\n"
    "//               to the indicated string, or BT_invalid if the string\n"
    "//               doesn't match anything.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CLerpInterval_string_blend_type_100_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CLerpInterval::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CLerpInterval_get_class_type_101(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CLerpInterval::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CLerpInterval::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpInterval_get_class_type_101_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CLerpInterval_get_class_type_101_comment = NULL;
#endif

int  Dtool_Init_CLerpInterval(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (CLerpInterval)");
       return -1;
}
inline void  * Dtool_UpcastInterface_CLerpInterval(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CLerpInterval)
    {
        printf("CLerpInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CLerpInterval * local_this = (CLerpInterval *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CLerpInterval)
        return local_this;
    if(requested_type == &Dtool_CInterval)
        return ( CInterval *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( CInterval *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( CInterval *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( CInterval *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CLerpInterval(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CLerpInterval)
        return from_this;
    if(from_type == &Dtool_CInterval)
    {
          CInterval* other_this = (CInterval*)from_this;
          return (CLerpInterval*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CLerpInterval*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CLerpInterval*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (CLerpInterval*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CLerpAnimEffectInterval 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void CLerpAnimEffectInterval::add_control(AnimControl *control, basic_string< char > const &name, float begin_effect, float end_effect)
 *******************************************************************/
static PyObject *Dtool_CLerpAnimEffectInterval_add_control_105(PyObject *self, PyObject *args,PyObject *kwds) {
    CLerpAnimEffectInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CLerpAnimEffectInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CLerpAnimEffectInterval::add_control(AnimControl *control, basic_string< char > const &name, float begin_effect, float end_effect)
            PyObject *param1;
            char *param2_str; int param2_len;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"control", (char *)"name", (char *)"begin_effect", (char *)"end_effect", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#dd:addControl", key_word_list, &param1, &param2_str, &param2_len, &param3, &param4))
            {
                AnimControl *param1_this = (AnimControl *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_AnimControl, 1, "CLerpAnimEffectInterval.addControl", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_control(param1_this, basic_string<char>(param2_str, param2_len), (float)param3, (float)param4);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CLerpAnimEffectInterval.addControl() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addControl(non-const CLerpAnimEffectInterval this, non-const AnimControl control, string name, float begin_effect, float end_effect)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpAnimEffectInterval_add_control_105_comment =
    "C++ Interface:\n"
    "addControl(non-const CLerpAnimEffectInterval this, non-const AnimControl control, string name, float begin_effect, float end_effect)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpAnimEffectInterval::add_control\n"
    "//       Access: Published\n"
    "//  Description: Adds another AnimControl to the list of AnimControls\n"
    "//               affected by the lerp.  This control will be lerped\n"
    "//               from begin_effect to end_effect over the period of\n"
    "//               the lerp.\n"
    "//\n"
    "//               The AnimControl name parameter is only used when\n"
    "//               formatting the interval for output.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CLerpAnimEffectInterval_add_control_105_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CLerpAnimEffectInterval::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CLerpAnimEffectInterval_get_class_type_106(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CLerpAnimEffectInterval::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CLerpAnimEffectInterval::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpAnimEffectInterval_get_class_type_106_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CLerpAnimEffectInterval_get_class_type_106_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CLerpAnimEffectInterval::CLerpAnimEffectInterval(basic_string< char > const &name, double duration, CLerpInterval::BlendType blend_type)
 *******************************************************************/
int  Dtool_Init_CLerpAnimEffectInterval(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline CLerpAnimEffectInterval::CLerpAnimEffectInterval(basic_string< char > const &name, double duration, CLerpInterval::BlendType blend_type)
        char *param0_str; int param0_len;
        double param1;
        int param2;
        static char * key_word_list[] = {(char *)"name", (char *)"duration", (char *)"blend_type", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#di:CLerpAnimEffectInterval", key_word_list, &param0_str, &param0_len, &param1, &param2))
        {
            CLerpAnimEffectInterval *return_value = new CLerpAnimEffectInterval(basic_string<char>(param0_str, param0_len), (double)param1, (CLerpInterval::BlendType)param2);
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_CLerpAnimEffectInterval,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "CLerpAnimEffectInterval(string name, float duration, int blend_type)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CLerpAnimEffectInterval(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CLerpAnimEffectInterval)
    {
        printf("CLerpAnimEffectInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CLerpAnimEffectInterval * local_this = (CLerpAnimEffectInterval *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CLerpAnimEffectInterval)
        return local_this;
    if(requested_type == &Dtool_CInterval)
        return ( CInterval *)( CLerpInterval *) local_this;
    if(requested_type == &Dtool_CLerpInterval)
        return ( CLerpInterval *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( CInterval *)( CLerpInterval *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( CInterval *)( CLerpInterval *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( CInterval *)( CLerpInterval *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CLerpAnimEffectInterval(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CLerpAnimEffectInterval)
        return from_this;
    if(from_type == &Dtool_CInterval)
    {
          CInterval* other_this = (CInterval*)from_this;
          return (CLerpAnimEffectInterval*)other_this;
    }
    if(from_type == &Dtool_CLerpInterval)
    {
          CLerpInterval* other_this = (CLerpInterval*)from_this;
          return (CLerpAnimEffectInterval*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CLerpAnimEffectInterval*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CLerpAnimEffectInterval*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (CLerpAnimEffectInterval*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CLerpNodePathInterval 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline NodePath const &CLerpNodePathInterval::get_node(void) const
 *******************************************************************/
static PyObject *Dtool_CLerpNodePathInterval_get_node_110(PyObject *self, PyObject *args,PyObject *kwds) {
    CLerpNodePathInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CLerpNodePathInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NodePath const &CLerpNodePathInterval::get_node(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNode", key_word_list));
        else
            (PyArg_Parse(args, ":getNode"));
        if(!PyErr_Occurred())
        {
            NodePath const *return_value = &(((const CLerpNodePathInterval*)local_this)->get_node());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNode(const CLerpNodePathInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpNodePathInterval_get_node_110_comment =
    "C++ Interface:\n"
    "getNode(const CLerpNodePathInterval this)\n"
    "\n"
    "// Filename: cLerpNodePathInterval.I\n"
    "// Created by:  drose (27Aug02)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpNodePathInterval::get_node\n"
    "//       Access: Published\n"
    "//  Description: Returns the node being lerped.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CLerpNodePathInterval_get_node_110_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline NodePath const &CLerpNodePathInterval::get_other(void) const
 *******************************************************************/
static PyObject *Dtool_CLerpNodePathInterval_get_other_111(PyObject *self, PyObject *args,PyObject *kwds) {
    CLerpNodePathInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CLerpNodePathInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline NodePath const &CLerpNodePathInterval::get_other(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOther", key_word_list));
        else
            (PyArg_Parse(args, ":getOther"));
        if(!PyErr_Occurred())
        {
            NodePath const *return_value = &(((const CLerpNodePathInterval*)local_this)->get_other());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOther(const CLerpNodePathInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpNodePathInterval_get_other_111_comment =
    "C++ Interface:\n"
    "getOther(const CLerpNodePathInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpNodePathInterval::get_other\n"
    "//       Access: Published\n"
    "//  Description: Returns the \"other\" node, which the lerped node is\n"
    "//               being moved relative to.  If this is an empty node\n"
    "//               path, the lerped node is being moved in its own\n"
    "//               coordinate system.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CLerpNodePathInterval_get_other_111_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CLerpNodePathInterval::set_start_pos(LVecBase3f const &pos)
 *******************************************************************/
static PyObject *Dtool_CLerpNodePathInterval_set_start_pos_112(PyObject *self, PyObject *args,PyObject *kwds) {
    CLerpNodePathInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CLerpNodePathInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CLerpNodePathInterval::set_start_pos(LVecBase3f const &pos)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"pos", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setStartPos", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setStartPos", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "CLerpNodePathInterval.setStartPos", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_start_pos(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CLerpNodePathInterval.setStartPos() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setStartPos(non-const CLerpNodePathInterval this, const VBase3 pos)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpNodePathInterval_set_start_pos_112_comment =
    "C++ Interface:\n"
    "setStartPos(non-const CLerpNodePathInterval this, const VBase3 pos)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpNodePathInterval::set_start_pos\n"
    "//       Access: Published\n"
    "//  Description: Indicates the initial position of the lerped node.\n"
    "//               This is meaningful only if set_end_pos() is also\n"
    "//               called.  This parameter is optional; if unspecified,\n"
    "//               the value will be taken from the node's actual\n"
    "//               position at the time the lerp is performed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CLerpNodePathInterval_set_start_pos_112_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CLerpNodePathInterval::set_end_pos(LVecBase3f const &pos)
 *******************************************************************/
static PyObject *Dtool_CLerpNodePathInterval_set_end_pos_113(PyObject *self, PyObject *args,PyObject *kwds) {
    CLerpNodePathInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CLerpNodePathInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CLerpNodePathInterval::set_end_pos(LVecBase3f const &pos)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"pos", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setEndPos", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setEndPos", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "CLerpNodePathInterval.setEndPos", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_end_pos(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CLerpNodePathInterval.setEndPos() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEndPos(non-const CLerpNodePathInterval this, const VBase3 pos)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpNodePathInterval_set_end_pos_113_comment =
    "C++ Interface:\n"
    "setEndPos(non-const CLerpNodePathInterval this, const VBase3 pos)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpNodePathInterval::set_end_pos\n"
    "//       Access: Published\n"
    "//  Description: Indicates that the position of the node should be\n"
    "//               lerped, and specifies the final position of the node.\n"
    "//               This should be called before priv_initialize().  If this\n"
    "//               is not called, the node's position will not be\n"
    "//               affected by the lerp.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CLerpNodePathInterval_set_end_pos_113_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CLerpNodePathInterval::set_start_hpr(LVecBase3f const &hpr)
 *******************************************************************/
static PyObject *Dtool_CLerpNodePathInterval_set_start_hpr_114(PyObject *self, PyObject *args,PyObject *kwds) {
    CLerpNodePathInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CLerpNodePathInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CLerpNodePathInterval::set_start_hpr(LVecBase3f const &hpr)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"hpr", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setStartHpr", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setStartHpr", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "CLerpNodePathInterval.setStartHpr", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_start_hpr(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CLerpNodePathInterval.setStartHpr() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setStartHpr(non-const CLerpNodePathInterval this, const VBase3 hpr)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpNodePathInterval_set_start_hpr_114_comment =
    "C++ Interface:\n"
    "setStartHpr(non-const CLerpNodePathInterval this, const VBase3 hpr)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpNodePathInterval::set_start_hpr\n"
    "//       Access: Published\n"
    "//  Description: Indicates the initial rotation of the lerped node.\n"
    "//               This is meaningful only if either set_end_hpr() or\n"
    "//               set_end_quat() is also called.  This parameter is\n"
    "//               optional; if unspecified, the value will be taken\n"
    "//               from the node's actual rotation at the time the lerp\n"
    "//               is performed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CLerpNodePathInterval_set_start_hpr_114_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CLerpNodePathInterval::set_end_hpr(LQuaternionf const &quat)
 * inline void CLerpNodePathInterval::set_end_hpr(LVecBase3f const &hpr)
 *******************************************************************/
static PyObject *Dtool_CLerpNodePathInterval_set_end_hpr_115(PyObject *self, PyObject *args,PyObject *kwds) {
    CLerpNodePathInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CLerpNodePathInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline void CLerpNodePathInterval::set_end_hpr(LQuaternionf const &quat)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"quat", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setEndHpr", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setEndHpr", &param1));
            if(!PyErr_Occurred())
            {
                LQuaternionf *param1_this = (LQuaternionf *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LQuaternionf, 1, "CLerpNodePathInterval.setEndHpr", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_end_hpr(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline void CLerpNodePathInterval::set_end_hpr(LVecBase3f const &hpr)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"hpr", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setEndHpr", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setEndHpr", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "CLerpNodePathInterval.setEndHpr", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_end_hpr(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEndHpr(non-const CLerpNodePathInterval this, const Quat quat)\n"
          "setEndHpr(non-const CLerpNodePathInterval this, const VBase3 hpr)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpNodePathInterval_set_end_hpr_115_comment =
    "C++ Interface:\n"
    "setEndHpr(non-const CLerpNodePathInterval this, const Quat quat)\n"
    "setEndHpr(non-const CLerpNodePathInterval this, const VBase3 hpr)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpNodePathInterval::set_end_hpr\n"
    "//       Access: Published\n"
    "//  Description: Indicates that the rotation of the node should be\n"
    "//               lerped, and specifies the final rotation of the node.\n"
    "//               This should be called before priv_initialize().\n"
    "//\n"
    "//               This replaces a previous call to set_end_quat().  If\n"
    "//               neither set_end_hpr() nor set_end_quat() is called,\n"
    "//               the node's rotation will not be affected by the lerp.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpNodePathInterval::set_end_hpr\n"
    "//       Access: Published\n"
    "//  Description: Indicates that the rotation of the node should be\n"
    "//               lerped, and specifies the final rotation of the node.\n"
    "//               This should be called before priv_initialize().\n"
    "//\n"
    "//               This special function is overloaded to accept a\n"
    "//               quaternion, even though the function name is\n"
    "//               set_end_hpr().  The quaternion will be implicitly\n"
    "//               converted to a HPR trio, and the lerp will be\n"
    "//               performed in HPR space, componentwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CLerpNodePathInterval_set_end_hpr_115_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CLerpNodePathInterval::set_start_quat(LQuaternionf const &quat)
 *******************************************************************/
static PyObject *Dtool_CLerpNodePathInterval_set_start_quat_116(PyObject *self, PyObject *args,PyObject *kwds) {
    CLerpNodePathInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CLerpNodePathInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CLerpNodePathInterval::set_start_quat(LQuaternionf const &quat)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"quat", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setStartQuat", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setStartQuat", &param1));
            if(!PyErr_Occurred())
            {
                LQuaternionf *param1_this = (LQuaternionf *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LQuaternionf, 1, "CLerpNodePathInterval.setStartQuat", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_start_quat(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CLerpNodePathInterval.setStartQuat() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setStartQuat(non-const CLerpNodePathInterval this, const Quat quat)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpNodePathInterval_set_start_quat_116_comment =
    "C++ Interface:\n"
    "setStartQuat(non-const CLerpNodePathInterval this, const Quat quat)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpNodePathInterval::set_start_quat\n"
    "//       Access: Published\n"
    "//  Description: Indicates the initial rotation of the lerped node.\n"
    "//               This is meaningful only if either set_end_quat() or\n"
    "//               set_end_hpr() is also called.  This parameter is\n"
    "//               optional; if unspecified, the value will be taken\n"
    "//               from the node's actual rotation at the time the lerp\n"
    "//               is performed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CLerpNodePathInterval_set_start_quat_116_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CLerpNodePathInterval::set_end_quat(LQuaternionf const &quat)
 * inline void CLerpNodePathInterval::set_end_quat(LVecBase3f const &hpr)
 *******************************************************************/
static PyObject *Dtool_CLerpNodePathInterval_set_end_quat_117(PyObject *self, PyObject *args,PyObject *kwds) {
    CLerpNodePathInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CLerpNodePathInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline void CLerpNodePathInterval::set_end_quat(LVecBase3f const &hpr)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"hpr", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setEndQuat", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setEndQuat", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "CLerpNodePathInterval.setEndQuat", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_end_quat(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline void CLerpNodePathInterval::set_end_quat(LQuaternionf const &quat)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"quat", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setEndQuat", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setEndQuat", &param1));
            if(!PyErr_Occurred())
            {
                LQuaternionf *param1_this = (LQuaternionf *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LQuaternionf, 1, "CLerpNodePathInterval.setEndQuat", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_end_quat(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEndQuat(non-const CLerpNodePathInterval this, const VBase3 hpr)\n"
          "setEndQuat(non-const CLerpNodePathInterval this, const Quat quat)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpNodePathInterval_set_end_quat_117_comment =
    "C++ Interface:\n"
    "setEndQuat(non-const CLerpNodePathInterval this, const VBase3 hpr)\n"
    "setEndQuat(non-const CLerpNodePathInterval this, const Quat quat)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpNodePathInterval::set_end_quat\n"
    "//       Access: Published\n"
    "//  Description: Indicates that the rotation of the node should be\n"
    "//               lerped, and specifies the final rotation of the node.\n"
    "//               This should be called before priv_initialize().\n"
    "//\n"
    "//               This replaces a previous call to set_end_hpr().  If\n"
    "//               neither set_end_quat() nor set_end_hpr() is called,\n"
    "//               the node's rotation will not be affected by the lerp.\n"
    "//\n"
    "//               This special function is overloaded to accept a HPR\n"
    "//               trio, even though the function name is\n"
    "//               set_end_quat().  The HPR will be implicitly converted\n"
    "//               to a quaternion, and the lerp will be performed in\n"
    "//               quaternion space, as a spherical lerp.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpNodePathInterval::set_end_quat\n"
    "//       Access: Published\n"
    "//  Description: Indicates that the rotation of the node should be\n"
    "//               lerped, and specifies the final rotation of the node.\n"
    "//               This should be called before priv_initialize().\n"
    "//\n"
    "//               This replaces a previous call to set_end_hpr().  If\n"
    "//               neither set_end_quat() nor set_end_hpr() is called,\n"
    "//               the node's rotation will not be affected by the lerp.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CLerpNodePathInterval_set_end_quat_117_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CLerpNodePathInterval::set_start_scale(LVecBase3f const &scale)
 * inline void CLerpNodePathInterval::set_start_scale(float scale)
 *******************************************************************/
static PyObject *Dtool_CLerpNodePathInterval_set_start_scale_118(PyObject *self, PyObject *args,PyObject *kwds) {
    CLerpNodePathInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CLerpNodePathInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline void CLerpNodePathInterval::set_start_scale(LVecBase3f const &scale)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"scale", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setStartScale", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setStartScale", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "CLerpNodePathInterval.setStartScale", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_start_scale(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline void CLerpNodePathInterval::set_start_scale(float scale)
            double param1;
            static char * key_word_list[] = {(char *)"scale", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:setStartScale", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:setStartScale", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->set_start_scale((float)param1);
                Py_XDECREF(coerced);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setStartScale(non-const CLerpNodePathInterval this, const VBase3 scale)\n"
          "setStartScale(non-const CLerpNodePathInterval this, float scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpNodePathInterval_set_start_scale_118_comment =
    "C++ Interface:\n"
    "setStartScale(non-const CLerpNodePathInterval this, const VBase3 scale)\n"
    "setStartScale(non-const CLerpNodePathInterval this, float scale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpNodePathInterval::set_start_scale\n"
    "//       Access: Published\n"
    "//  Description: Indicates the initial scale of the lerped node.\n"
    "//               This is meaningful only if set_end_scale() is also\n"
    "//               called.  This parameter is optional; if unspecified,\n"
    "//               the value will be taken from the node's actual\n"
    "//               scale at the time the lerp is performed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpNodePathInterval::set_start_scale\n"
    "//       Access: Published\n"
    "//  Description: Indicates the initial scale of the lerped node.\n"
    "//               This is meaningful only if set_end_scale() is also\n"
    "//               called.  This parameter is optional; if unspecified,\n"
    "//               the value will be taken from the node's actual\n"
    "//               scale at the time the lerp is performed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CLerpNodePathInterval_set_start_scale_118_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CLerpNodePathInterval::set_end_scale(LVecBase3f const &scale)
 * inline void CLerpNodePathInterval::set_end_scale(float scale)
 *******************************************************************/
static PyObject *Dtool_CLerpNodePathInterval_set_end_scale_119(PyObject *self, PyObject *args,PyObject *kwds) {
    CLerpNodePathInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CLerpNodePathInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline void CLerpNodePathInterval::set_end_scale(LVecBase3f const &scale)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"scale", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setEndScale", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setEndScale", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "CLerpNodePathInterval.setEndScale", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_end_scale(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 inline void CLerpNodePathInterval::set_end_scale(float scale)
            double param1;
            static char * key_word_list[] = {(char *)"scale", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:setEndScale", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:setEndScale", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->set_end_scale((float)param1);
                Py_XDECREF(coerced);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEndScale(non-const CLerpNodePathInterval this, const VBase3 scale)\n"
          "setEndScale(non-const CLerpNodePathInterval this, float scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpNodePathInterval_set_end_scale_119_comment =
    "C++ Interface:\n"
    "setEndScale(non-const CLerpNodePathInterval this, const VBase3 scale)\n"
    "setEndScale(non-const CLerpNodePathInterval this, float scale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpNodePathInterval::set_end_scale\n"
    "//       Access: Published\n"
    "//  Description: Indicates that the scale of the node should be\n"
    "//               lerped, and specifies the final scale of the node.\n"
    "//               This should be called before priv_initialize().  If this\n"
    "//               is not called, the node's scale will not be\n"
    "//               affected by the lerp.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpNodePathInterval::set_end_scale\n"
    "//       Access: Published\n"
    "//  Description: Indicates that the scale of the node should be\n"
    "//               lerped, and specifies the final scale of the node.\n"
    "//               This should be called before priv_initialize().  If this\n"
    "//               is not called, the node's scale will not be\n"
    "//               affected by the lerp.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CLerpNodePathInterval_set_end_scale_119_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CLerpNodePathInterval::set_start_shear(LVecBase3f const &shear)
 *******************************************************************/
static PyObject *Dtool_CLerpNodePathInterval_set_start_shear_120(PyObject *self, PyObject *args,PyObject *kwds) {
    CLerpNodePathInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CLerpNodePathInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CLerpNodePathInterval::set_start_shear(LVecBase3f const &shear)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"shear", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setStartShear", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setStartShear", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "CLerpNodePathInterval.setStartShear", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_start_shear(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CLerpNodePathInterval.setStartShear() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setStartShear(non-const CLerpNodePathInterval this, const VBase3 shear)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpNodePathInterval_set_start_shear_120_comment =
    "C++ Interface:\n"
    "setStartShear(non-const CLerpNodePathInterval this, const VBase3 shear)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpNodePathInterval::set_start_shear\n"
    "//       Access: Published\n"
    "//  Description: Indicates the initial shear of the lerped node.\n"
    "//               This is meaningful only if set_end_shear() is also\n"
    "//               called.  This parameter is optional; if unspecified,\n"
    "//               the value will be taken from the node's actual\n"
    "//               shear at the time the lerp is performed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CLerpNodePathInterval_set_start_shear_120_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CLerpNodePathInterval::set_end_shear(LVecBase3f const &shear)
 *******************************************************************/
static PyObject *Dtool_CLerpNodePathInterval_set_end_shear_121(PyObject *self, PyObject *args,PyObject *kwds) {
    CLerpNodePathInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CLerpNodePathInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CLerpNodePathInterval::set_end_shear(LVecBase3f const &shear)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"shear", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setEndShear", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setEndShear", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "CLerpNodePathInterval.setEndShear", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_end_shear(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CLerpNodePathInterval.setEndShear() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEndShear(non-const CLerpNodePathInterval this, const VBase3 shear)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpNodePathInterval_set_end_shear_121_comment =
    "C++ Interface:\n"
    "setEndShear(non-const CLerpNodePathInterval this, const VBase3 shear)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpNodePathInterval::set_end_shear\n"
    "//       Access: Published\n"
    "//  Description: Indicates that the shear of the node should be\n"
    "//               lerped, and specifies the final shear of the node.\n"
    "//               This should be called before priv_initialize().  If this\n"
    "//               is not called, the node's shear will not be\n"
    "//               affected by the lerp.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CLerpNodePathInterval_set_end_shear_121_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CLerpNodePathInterval::set_start_color(LVecBase4f const &color)
 *******************************************************************/
static PyObject *Dtool_CLerpNodePathInterval_set_start_color_122(PyObject *self, PyObject *args,PyObject *kwds) {
    CLerpNodePathInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CLerpNodePathInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CLerpNodePathInterval::set_start_color(LVecBase4f const &color)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"color", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setStartColor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setStartColor", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "CLerpNodePathInterval.setStartColor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_start_color(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CLerpNodePathInterval.setStartColor() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setStartColor(non-const CLerpNodePathInterval this, const VBase4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpNodePathInterval_set_start_color_122_comment =
    "C++ Interface:\n"
    "setStartColor(non-const CLerpNodePathInterval this, const VBase4 color)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpNodePathInterval::set_start_color\n"
    "//       Access: Published\n"
    "//  Description: Indicates the initial color of the lerped node.\n"
    "//               This is meaningful only if set_end_color() is also\n"
    "//               called.  This parameter is optional; if unspecified,\n"
    "//               the value will be taken from the node's actual\n"
    "//               color at the time the lerp is performed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CLerpNodePathInterval_set_start_color_122_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CLerpNodePathInterval::set_end_color(LVecBase4f const &color)
 *******************************************************************/
static PyObject *Dtool_CLerpNodePathInterval_set_end_color_123(PyObject *self, PyObject *args,PyObject *kwds) {
    CLerpNodePathInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CLerpNodePathInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CLerpNodePathInterval::set_end_color(LVecBase4f const &color)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"color", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setEndColor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setEndColor", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "CLerpNodePathInterval.setEndColor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_end_color(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CLerpNodePathInterval.setEndColor() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEndColor(non-const CLerpNodePathInterval this, const VBase4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpNodePathInterval_set_end_color_123_comment =
    "C++ Interface:\n"
    "setEndColor(non-const CLerpNodePathInterval this, const VBase4 color)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpNodePathInterval::set_end_color\n"
    "//       Access: Published\n"
    "//  Description: Indicates that the color of the node should be\n"
    "//               lerped, and specifies the final color of the node.\n"
    "//               This should be called before priv_initialize().  If this\n"
    "//               is not called, the node's color will not be\n"
    "//               affected by the lerp.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CLerpNodePathInterval_set_end_color_123_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CLerpNodePathInterval::set_start_color_scale(LVecBase4f const &color_scale)
 *******************************************************************/
static PyObject *Dtool_CLerpNodePathInterval_set_start_color_scale_124(PyObject *self, PyObject *args,PyObject *kwds) {
    CLerpNodePathInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CLerpNodePathInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CLerpNodePathInterval::set_start_color_scale(LVecBase4f const &color_scale)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"color_scale", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setStartColorScale", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setStartColorScale", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "CLerpNodePathInterval.setStartColorScale", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_start_color_scale(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CLerpNodePathInterval.setStartColorScale() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setStartColorScale(non-const CLerpNodePathInterval this, const VBase4 color_scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpNodePathInterval_set_start_color_scale_124_comment =
    "C++ Interface:\n"
    "setStartColorScale(non-const CLerpNodePathInterval this, const VBase4 color_scale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpNodePathInterval::set_start_color_scale\n"
    "//       Access: Published\n"
    "//  Description: Indicates the initial color scale of the lerped node.\n"
    "//               This is meaningful only if set_end_color_scale() is also\n"
    "//               called.  This parameter is optional; if unspecified,\n"
    "//               the value will be taken from the node's actual\n"
    "//               color scale at the time the lerp is performed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CLerpNodePathInterval_set_start_color_scale_124_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CLerpNodePathInterval::set_end_color_scale(LVecBase4f const &color_scale)
 *******************************************************************/
static PyObject *Dtool_CLerpNodePathInterval_set_end_color_scale_125(PyObject *self, PyObject *args,PyObject *kwds) {
    CLerpNodePathInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CLerpNodePathInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CLerpNodePathInterval::set_end_color_scale(LVecBase4f const &color_scale)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"color_scale", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setEndColorScale", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setEndColorScale", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "CLerpNodePathInterval.setEndColorScale", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_end_color_scale(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CLerpNodePathInterval.setEndColorScale() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEndColorScale(non-const CLerpNodePathInterval this, const VBase4 color_scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpNodePathInterval_set_end_color_scale_125_comment =
    "C++ Interface:\n"
    "setEndColorScale(non-const CLerpNodePathInterval this, const VBase4 color_scale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpNodePathInterval::set_end_color_scale\n"
    "//       Access: Published\n"
    "//  Description: Indicates that the color scale of the node should be\n"
    "//               lerped, and specifies the final color scale of the node.\n"
    "//               This should be called before priv_initialize().  If this\n"
    "//               is not called, the node's color scale will not be\n"
    "//               affected by the lerp.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CLerpNodePathInterval_set_end_color_scale_125_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CLerpNodePathInterval::set_texture_stage(TextureStage *stage)
 *******************************************************************/
static PyObject *Dtool_CLerpNodePathInterval_set_texture_stage_126(PyObject *self, PyObject *args,PyObject *kwds) {
    CLerpNodePathInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CLerpNodePathInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CLerpNodePathInterval::set_texture_stage(TextureStage *stage)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"stage", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setTextureStage", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setTextureStage", &param1));
            if(!PyErr_Occurred())
            {
                TextureStage *param1_this = (TextureStage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TextureStage, 1, "CLerpNodePathInterval.setTextureStage", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_texture_stage(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CLerpNodePathInterval.setTextureStage() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTextureStage(non-const CLerpNodePathInterval this, non-const TextureStage stage)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpNodePathInterval_set_texture_stage_126_comment =
    "C++ Interface:\n"
    "setTextureStage(non-const CLerpNodePathInterval this, non-const TextureStage stage)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpNodePathInterval::set_texture_stage\n"
    "//       Access: Published\n"
    "//  Description: Indicates the texture stage that is adjusted by\n"
    "//               tex_offset, tex_rotate, and/or tex_scale.  If this is\n"
    "//               not set, the default is the default texture stage.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CLerpNodePathInterval_set_texture_stage_126_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CLerpNodePathInterval::set_start_tex_offset(LVecBase2f const &tex_offset)
 *******************************************************************/
static PyObject *Dtool_CLerpNodePathInterval_set_start_tex_offset_127(PyObject *self, PyObject *args,PyObject *kwds) {
    CLerpNodePathInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CLerpNodePathInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CLerpNodePathInterval::set_start_tex_offset(LVecBase2f const &tex_offset)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"tex_offset", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setStartTexOffset", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setStartTexOffset", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase2f *param1_this = (LVecBase2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase2f, 1, "CLerpNodePathInterval.setStartTexOffset", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_start_tex_offset(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CLerpNodePathInterval.setStartTexOffset() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setStartTexOffset(non-const CLerpNodePathInterval this, const VBase2 tex_offset)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpNodePathInterval_set_start_tex_offset_127_comment =
    "C++ Interface:\n"
    "setStartTexOffset(non-const CLerpNodePathInterval this, const VBase2 tex_offset)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpNodePathInterval::set_start_tex_offset\n"
    "//       Access: Published\n"
    "//  Description: Indicates the initial UV offset of the lerped node.\n"
    "//               This is meaningful only if set_end_tex_offset() is also\n"
    "//               called.  This parameter is optional; if unspecified,\n"
    "//               the value will be taken from the node's actual\n"
    "//               UV offset at the time the lerp is performed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CLerpNodePathInterval_set_start_tex_offset_127_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CLerpNodePathInterval::set_end_tex_offset(LVecBase2f const &tex_offset)
 *******************************************************************/
static PyObject *Dtool_CLerpNodePathInterval_set_end_tex_offset_128(PyObject *self, PyObject *args,PyObject *kwds) {
    CLerpNodePathInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CLerpNodePathInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CLerpNodePathInterval::set_end_tex_offset(LVecBase2f const &tex_offset)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"tex_offset", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setEndTexOffset", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setEndTexOffset", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase2f *param1_this = (LVecBase2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase2f, 1, "CLerpNodePathInterval.setEndTexOffset", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_end_tex_offset(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CLerpNodePathInterval.setEndTexOffset() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEndTexOffset(non-const CLerpNodePathInterval this, const VBase2 tex_offset)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpNodePathInterval_set_end_tex_offset_128_comment =
    "C++ Interface:\n"
    "setEndTexOffset(non-const CLerpNodePathInterval this, const VBase2 tex_offset)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpNodePathInterval::set_end_tex_offset\n"
    "//       Access: Published\n"
    "//  Description: Indicates that the UV offset of the node should be\n"
    "//               lerped, and specifies the final UV offset of the node.\n"
    "//               This should be called before priv_initialize().  If this\n"
    "//               is not called, the node's UV offset will not be\n"
    "//               affected by the lerp.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CLerpNodePathInterval_set_end_tex_offset_128_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CLerpNodePathInterval::set_start_tex_rotate(float tex_rotate)
 *******************************************************************/
static PyObject *Dtool_CLerpNodePathInterval_set_start_tex_rotate_129(PyObject *self, PyObject *args,PyObject *kwds) {
    CLerpNodePathInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CLerpNodePathInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CLerpNodePathInterval::set_start_tex_rotate(float tex_rotate)
        double param1;
        static char * key_word_list[] = {(char *)"tex_rotate", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setStartTexRotate", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setStartTexRotate", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_start_tex_rotate((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CLerpNodePathInterval.setStartTexRotate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setStartTexRotate(non-const CLerpNodePathInterval this, float tex_rotate)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpNodePathInterval_set_start_tex_rotate_129_comment =
    "C++ Interface:\n"
    "setStartTexRotate(non-const CLerpNodePathInterval this, float tex_rotate)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpNodePathInterval::set_start_tex_rotate\n"
    "//       Access: Published\n"
    "//  Description: Indicates the initial UV rotate of the lerped node.\n"
    "//               This is meaningful only if set_end_tex_rotate() is also\n"
    "//               called.  This parameter is optional; if unspecified,\n"
    "//               the value will be taken from the node's actual\n"
    "//               UV rotate at the time the lerp is performed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CLerpNodePathInterval_set_start_tex_rotate_129_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CLerpNodePathInterval::set_end_tex_rotate(float tex_rotate)
 *******************************************************************/
static PyObject *Dtool_CLerpNodePathInterval_set_end_tex_rotate_130(PyObject *self, PyObject *args,PyObject *kwds) {
    CLerpNodePathInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CLerpNodePathInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CLerpNodePathInterval::set_end_tex_rotate(float tex_rotate)
        double param1;
        static char * key_word_list[] = {(char *)"tex_rotate", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setEndTexRotate", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setEndTexRotate", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_end_tex_rotate((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CLerpNodePathInterval.setEndTexRotate() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEndTexRotate(non-const CLerpNodePathInterval this, float tex_rotate)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpNodePathInterval_set_end_tex_rotate_130_comment =
    "C++ Interface:\n"
    "setEndTexRotate(non-const CLerpNodePathInterval this, float tex_rotate)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpNodePathInterval::set_end_tex_rotate\n"
    "//       Access: Published\n"
    "//  Description: Indicates that the UV rotate of the node should be\n"
    "//               lerped, and specifies the final UV rotate of the node.\n"
    "//               This should be called before priv_initialize().  If this\n"
    "//               is not called, the node's UV rotate will not be\n"
    "//               affected by the lerp.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CLerpNodePathInterval_set_end_tex_rotate_130_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CLerpNodePathInterval::set_start_tex_scale(LVecBase2f const &tex_scale)
 *******************************************************************/
static PyObject *Dtool_CLerpNodePathInterval_set_start_tex_scale_131(PyObject *self, PyObject *args,PyObject *kwds) {
    CLerpNodePathInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CLerpNodePathInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CLerpNodePathInterval::set_start_tex_scale(LVecBase2f const &tex_scale)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"tex_scale", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setStartTexScale", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setStartTexScale", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase2f *param1_this = (LVecBase2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase2f, 1, "CLerpNodePathInterval.setStartTexScale", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_start_tex_scale(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CLerpNodePathInterval.setStartTexScale() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setStartTexScale(non-const CLerpNodePathInterval this, const VBase2 tex_scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpNodePathInterval_set_start_tex_scale_131_comment =
    "C++ Interface:\n"
    "setStartTexScale(non-const CLerpNodePathInterval this, const VBase2 tex_scale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpNodePathInterval::set_start_tex_scale\n"
    "//       Access: Published\n"
    "//  Description: Indicates the initial UV scale of the lerped node.\n"
    "//               This is meaningful only if set_end_tex_scale() is also\n"
    "//               called.  This parameter is optional; if unspecified,\n"
    "//               the value will be taken from the node's actual\n"
    "//               UV scale at the time the lerp is performed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CLerpNodePathInterval_set_start_tex_scale_131_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CLerpNodePathInterval::set_end_tex_scale(LVecBase2f const &tex_scale)
 *******************************************************************/
static PyObject *Dtool_CLerpNodePathInterval_set_end_tex_scale_132(PyObject *self, PyObject *args,PyObject *kwds) {
    CLerpNodePathInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CLerpNodePathInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void CLerpNodePathInterval::set_end_tex_scale(LVecBase2f const &tex_scale)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"tex_scale", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setEndTexScale", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setEndTexScale", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase2f *param1_this = (LVecBase2f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase2f, 1, "CLerpNodePathInterval.setEndTexScale", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_end_tex_scale(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CLerpNodePathInterval.setEndTexScale() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setEndTexScale(non-const CLerpNodePathInterval this, const VBase2 tex_scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpNodePathInterval_set_end_tex_scale_132_comment =
    "C++ Interface:\n"
    "setEndTexScale(non-const CLerpNodePathInterval this, const VBase2 tex_scale)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpNodePathInterval::set_end_tex_scale\n"
    "//       Access: Published\n"
    "//  Description: Indicates that the UV scale of the node should be\n"
    "//               lerped, and specifies the final UV scale of the node.\n"
    "//               This should be called before priv_initialize().  If this\n"
    "//               is not called, the node's UV scale will not be\n"
    "//               affected by the lerp.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CLerpNodePathInterval_set_end_tex_scale_132_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void CLerpNodePathInterval::set_override(int override)
 *******************************************************************/
static PyObject *Dtool_CLerpNodePathInterval_set_override_133(PyObject *self, PyObject *args,PyObject *kwds) {
    CLerpNodePathInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CLerpNodePathInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CLerpNodePathInterval::set_override(int override)
        int param1;
        static char * key_word_list[] = {(char *)"override", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setOverride", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setOverride", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_override((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CLerpNodePathInterval.setOverride() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setOverride(non-const CLerpNodePathInterval this, int override)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpNodePathInterval_set_override_133_comment =
    "C++ Interface:\n"
    "setOverride(non-const CLerpNodePathInterval this, int override)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpNodePathInterval::set_override\n"
    "//       Access: Published\n"
    "//  Description: Changes the override value that will be associated\n"
    "//               with any state changes applied by the lerp.  If this\n"
    "//               lerp is changing state (for instance, a color lerp or\n"
    "//               a tex matrix lerp), then the new attributes created\n"
    "//               by this lerp will be assigned the indicated override\n"
    "//               value when they are applied to the node.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CLerpNodePathInterval_set_override_133_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int CLerpNodePathInterval::get_override(void) const
 *******************************************************************/
static PyObject *Dtool_CLerpNodePathInterval_get_override_134(PyObject *self, PyObject *args,PyObject *kwds) {
    CLerpNodePathInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CLerpNodePathInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int CLerpNodePathInterval::get_override(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOverride", key_word_list));
        else
            (PyArg_Parse(args, ":getOverride"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const CLerpNodePathInterval*)local_this)->get_override();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOverride(const CLerpNodePathInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpNodePathInterval_get_override_134_comment =
    "C++ Interface:\n"
    "getOverride(const CLerpNodePathInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CLerpNodePathInterval::get_override\n"
    "//       Access: Published\n"
    "//  Description: Returns the override value that will be associated\n"
    "//               with any state changes applied by the lerp.  See\n"
    "//               set_override().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CLerpNodePathInterval_get_override_134_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CLerpNodePathInterval::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CLerpNodePathInterval_get_class_type_135(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CLerpNodePathInterval::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CLerpNodePathInterval::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CLerpNodePathInterval_get_class_type_135_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CLerpNodePathInterval_get_class_type_135_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CLerpNodePathInterval::CLerpNodePathInterval(basic_string< char > const &name, double duration, CLerpInterval::BlendType blend_type, bool bake_in_start, bool fluid, NodePath const &node, NodePath const &other)
 *******************************************************************/
int  Dtool_Init_CLerpNodePathInterval(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-CLerpNodePathInterval::CLerpNodePathInterval(basic_string< char > const &name, double duration, CLerpInterval::BlendType blend_type, bool bake_in_start, bool fluid, NodePath const &node, NodePath const &other)
            char *param0_str; int param0_len;
            double param1;
            int param2;
            PyObject *param3;
            PyObject *param4;
            PyObject *param5;
            PyObject *param6;
            static char * key_word_list[] = {(char *)"name", (char *)"duration", (char *)"blend_type", (char *)"bake_in_start", (char *)"fluid", (char *)"node", (char *)"other", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#diOOOO:CLerpNodePathInterval", key_word_list, &param0_str, &param0_len, &param1, &param2, &param3, &param4, &param5, &param6))
            {
                NodePath *param5_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_NodePath, 5, "CLerpNodePathInterval.CLerpNodePathInterval", 1, coerced_ptr, report_errors);
NodePath *param6_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param6, &Dtool_NodePath, 6, "CLerpNodePathInterval.CLerpNodePathInterval", 1, coerced_ptr, report_errors);

                if (!((param5_this == NULL)|| (param6_this == NULL)))
                {
                    CLerpNodePathInterval *return_value = new CLerpNodePathInterval(basic_string<char>(param0_str, param0_len), (double)param1, (CLerpInterval::BlendType)param2, (PyObject_IsTrue(param3)!=0), (PyObject_IsTrue(param4)!=0), *param5_this, *param6_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_CLerpNodePathInterval,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "CLerpNodePathInterval(string name, float duration, int blend_type, bool bake_in_start, bool fluid, const NodePath node, const NodePath other)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CLerpNodePathInterval(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CLerpNodePathInterval)
    {
        printf("CLerpNodePathInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CLerpNodePathInterval * local_this = (CLerpNodePathInterval *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CLerpNodePathInterval)
        return local_this;
    if(requested_type == &Dtool_CInterval)
        return ( CInterval *)( CLerpInterval *) local_this;
    if(requested_type == &Dtool_CLerpInterval)
        return ( CLerpInterval *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( CInterval *)( CLerpInterval *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( CInterval *)( CLerpInterval *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( CInterval *)( CLerpInterval *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CLerpNodePathInterval(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CLerpNodePathInterval)
        return from_this;
    if(from_type == &Dtool_CInterval)
    {
          CInterval* other_this = (CInterval*)from_this;
          return (CLerpNodePathInterval*)other_this;
    }
    if(from_type == &Dtool_CLerpInterval)
    {
          CLerpInterval* other_this = (CLerpInterval*)from_this;
          return (CLerpNodePathInterval*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CLerpNodePathInterval*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CLerpNodePathInterval*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (CLerpNodePathInterval*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. CMetaInterval 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void CMetaInterval::set_precision(double precision)
 *******************************************************************/
static PyObject *Dtool_CMetaInterval_set_precision_140(PyObject *self, PyObject *args,PyObject *kwds) {
    CMetaInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMetaInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void CMetaInterval::set_precision(double precision)
        double param1;
        static char * key_word_list[] = {(char *)"precision", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setPrecision", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setPrecision", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_precision((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CMetaInterval.setPrecision() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPrecision(non-const CMetaInterval this, float precision)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMetaInterval_set_precision_140_comment =
    "C++ Interface:\n"
    "setPrecision(non-const CMetaInterval this, float precision)\n"
    "\n"
    "// Filename: cMetaInterval.I\n"
    "// Created by:  drose (27Aug02)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMetaInterval::set_precision\n"
    "//       Access: Published\n"
    "//  Description: Indicates the precision with which time measurements\n"
    "//               are compared.  For numerical accuracy, all\n"
    "//               floating-point time values are converted to integer\n"
    "//               values internally by scaling by the precision factor.\n"
    "//               The larger the number given here, the smaller the\n"
    "//               delta of time that can be differentiated; the\n"
    "//               limit is the maximum integer that can be represented\n"
    "//               in the system.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMetaInterval_set_precision_140_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double CMetaInterval::get_precision(void) const
 *******************************************************************/
static PyObject *Dtool_CMetaInterval_get_precision_141(PyObject *self, PyObject *args,PyObject *kwds) {
    CMetaInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMetaInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double CMetaInterval::get_precision(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPrecision", key_word_list));
        else
            (PyArg_Parse(args, ":getPrecision"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const CMetaInterval*)local_this)->get_precision();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPrecision(const CMetaInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMetaInterval_get_precision_141_comment =
    "C++ Interface:\n"
    "getPrecision(const CMetaInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMetaInterval::get_precision\n"
    "//       Access: Published\n"
    "//  Description: Returns the precision with which time measurements\n"
    "//               are compared.  See set_precision().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMetaInterval_get_precision_141_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CMetaInterval::clear_intervals(void)
 *******************************************************************/
static PyObject *Dtool_CMetaInterval_clear_intervals_142(PyObject *self, PyObject *args,PyObject *kwds) {
    CMetaInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMetaInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CMetaInterval::clear_intervals(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearIntervals", key_word_list));
        else
            (PyArg_Parse(args, ":clearIntervals"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_intervals();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CMetaInterval.clearIntervals() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearIntervals(non-const CMetaInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMetaInterval_clear_intervals_142_comment =
    "C++ Interface:\n"
    "clearIntervals(non-const CMetaInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMetaInterval::clear_intervals\n"
    "//       Access: Published\n"
    "//  Description: Resets the list of intervals and prepares for\n"
    "//               receiving a new list.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMetaInterval_clear_intervals_142_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int CMetaInterval::push_level(basic_string< char > const &name, double rel_time, CMetaInterval::RelativeStart rel_to)
 *******************************************************************/
static PyObject *Dtool_CMetaInterval_push_level_143(PyObject *self, PyObject *args,PyObject *kwds) {
    CMetaInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMetaInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int CMetaInterval::push_level(basic_string< char > const &name, double rel_time, CMetaInterval::RelativeStart rel_to)
        char *param1_str; int param1_len;
        double param2;
        int param3;
        static char * key_word_list[] = {(char *)"name", (char *)"rel_time", (char *)"rel_to", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#di:pushLevel", key_word_list, &param1_str, &param1_len, &param2, &param3))
        {
            int return_value = (local_this)->push_level(basic_string<char>(param1_str, param1_len), (double)param2, (CMetaInterval::RelativeStart)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CMetaInterval.pushLevel() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "pushLevel(non-const CMetaInterval this, string name, float rel_time, int rel_to)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMetaInterval_push_level_143_comment =
    "C++ Interface:\n"
    "pushLevel(non-const CMetaInterval this, string name, float rel_time, int rel_to)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMetaInterval::push_level\n"
    "//       Access: Published\n"
    "//  Description: Marks the beginning of a nested level of child\n"
    "//               intervals.  Within the nested level, a RelativeStart\n"
    "//               time of RS_level_begin refers to the start of the\n"
    "//               level, and the first interval added within the level\n"
    "//               is always relative to the start of the level.\n"
    "//\n"
    "//               The return value is the index of the def entry\n"
    "//               created by this push.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMetaInterval_push_level_143_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int CMetaInterval::add_c_interval(CInterval *c_interval, double rel_time, CMetaInterval::RelativeStart rel_to)
 * int CMetaInterval::add_c_interval(CInterval *c_interval, double rel_time, CMetaInterval::RelativeStart rel_to = (RS_previous_end))
 * int CMetaInterval::add_c_interval(CInterval *c_interval, double rel_time = (0), CMetaInterval::RelativeStart rel_to = (RS_previous_end))
 *******************************************************************/
static PyObject *Dtool_CMetaInterval_add_c_interval_144(PyObject *self, PyObject *args,PyObject *kwds) {
    CMetaInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMetaInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-int CMetaInterval::add_c_interval(CInterval *c_interval, double rel_time = (0), CMetaInterval::RelativeStart rel_to = (RS_previous_end))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"c_interval", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:addCInterval", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:addCInterval", &param1));
                if(!PyErr_Occurred())
                {
                    CInterval *param1_this = (CInterval *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_CInterval, 1, "CMetaInterval.addCInterval", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        int return_value = (local_this)->add_c_interval(param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call CMetaInterval.addCInterval() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-int CMetaInterval::add_c_interval(CInterval *c_interval, double rel_time, CMetaInterval::RelativeStart rel_to = (RS_previous_end))
                PyObject *param1;
                double param2;
                static char * key_word_list[] = {(char *)"c_interval", (char *)"rel_time", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Od:addCInterval", key_word_list, &param1, &param2))
                {
                    CInterval *param1_this = (CInterval *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_CInterval, 1, "CMetaInterval.addCInterval", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        int return_value = (local_this)->add_c_interval(param1_this, (double)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call CMetaInterval.addCInterval() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-int CMetaInterval::add_c_interval(CInterval *c_interval, double rel_time, CMetaInterval::RelativeStart rel_to)
                PyObject *param1;
                double param2;
                int param3;
                static char * key_word_list[] = {(char *)"c_interval", (char *)"rel_time", (char *)"rel_to", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Odi:addCInterval", key_word_list, &param1, &param2, &param3))
                {
                    CInterval *param1_this = (CInterval *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_CInterval, 1, "CMetaInterval.addCInterval", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        int return_value = (local_this)->add_c_interval(param1_this, (double)param2, (CMetaInterval::RelativeStart)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call CMetaInterval.addCInterval() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "addCInterval() takes 2, 3, or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "addCInterval(non-const CMetaInterval this, non-const CInterval c_interval)\n"
          "addCInterval(non-const CMetaInterval this, non-const CInterval c_interval, float rel_time)\n"
          "addCInterval(non-const CMetaInterval this, non-const CInterval c_interval, float rel_time, int rel_to)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMetaInterval_add_c_interval_144_comment =
    "C++ Interface:\n"
    "addCInterval(non-const CMetaInterval this, non-const CInterval c_interval)\n"
    "addCInterval(non-const CMetaInterval this, non-const CInterval c_interval, float rel_time)\n"
    "addCInterval(non-const CMetaInterval this, non-const CInterval c_interval, float rel_time, int rel_to)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMetaInterval::add_c_interval\n"
    "//       Access: Published\n"
    "//  Description: Adds a new CInterval to the list.  The interval will\n"
    "//               be played when the indicated time (relative to the\n"
    "//               given point) has been reached.\n"
    "//\n"
    "//               The return value is the index of the def entry\n"
    "//               representing the new interval.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMetaInterval_add_c_interval_144_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int CMetaInterval::add_ext_index(int ext_index, basic_string< char > const &name, double duration, bool open_ended, double rel_time, CMetaInterval::RelativeStart rel_to)
 *******************************************************************/
static PyObject *Dtool_CMetaInterval_add_ext_index_145(PyObject *self, PyObject *args,PyObject *kwds) {
    CMetaInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMetaInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int CMetaInterval::add_ext_index(int ext_index, basic_string< char > const &name, double duration, bool open_ended, double rel_time, CMetaInterval::RelativeStart rel_to)
        int param1;
        char *param2_str; int param2_len;
        double param3;
        PyObject *param4;
        double param5;
        int param6;
        static char * key_word_list[] = {(char *)"ext_index", (char *)"name", (char *)"duration", (char *)"open_ended", (char *)"rel_time", (char *)"rel_to", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "is#dOdi:addExtIndex", key_word_list, &param1, &param2_str, &param2_len, &param3, &param4, &param5, &param6))
        {
            int return_value = (local_this)->add_ext_index((int)param1, basic_string<char>(param2_str, param2_len), (double)param3, (PyObject_IsTrue(param4)!=0), (double)param5, (CMetaInterval::RelativeStart)param6);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CMetaInterval.addExtIndex() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addExtIndex(non-const CMetaInterval this, int ext_index, string name, float duration, bool open_ended, float rel_time, int rel_to)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMetaInterval_add_ext_index_145_comment =
    "C++ Interface:\n"
    "addExtIndex(non-const CMetaInterval this, int ext_index, string name, float duration, bool open_ended, float rel_time, int rel_to)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMetaInterval::add_ext_index\n"
    "//       Access: Published\n"
    "//  Description: Adds a new external interval to the list.  This\n"
    "//               represents some object in the external scripting\n"
    "//               language that has properties similar to a CInterval\n"
    "//               (for instance, a Python Interval object).\n"
    "//\n"
    "//               The CMetaInterval object cannot play this external\n"
    "//               interval directly, but it records a placeholder for\n"
    "//               it and will ask the scripting language to play it\n"
    "//               when it is time, via is_event_ready() and related\n"
    "//               methods.\n"
    "//\n"
    "//               The ext_index number itself is simply a handle that\n"
    "//               the scripting language makes up and associates with\n"
    "//               its interval object somehow.  The CMetaInterval\n"
    "//               object does not attempt to interpret this value.\n"
    "//\n"
    "//               The return value is the index of the def entry\n"
    "//               representing the new interval.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMetaInterval_add_ext_index_145_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int CMetaInterval::pop_level(double duration)
 * int CMetaInterval::pop_level(double duration = (-1))
 *******************************************************************/
static PyObject *Dtool_CMetaInterval_pop_level_146(PyObject *self, PyObject *args,PyObject *kwds) {
    CMetaInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMetaInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int CMetaInterval::pop_level(double duration = (-1))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":popLevel", key_word_list));
            else
                (PyArg_Parse(args, ":popLevel"));
            if(!PyErr_Occurred())
            {
                int return_value = (local_this)->pop_level();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CMetaInterval.popLevel() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int CMetaInterval::pop_level(double duration)
            double param1;
            static char * key_word_list[] = {(char *)"duration", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:popLevel", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:popLevel", &param1));
            if(!PyErr_Occurred())
            {
                int return_value = (local_this)->pop_level((double)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CMetaInterval.popLevel() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "popLevel() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "popLevel(non-const CMetaInterval this)\n"
          "popLevel(non-const CMetaInterval this, float duration)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMetaInterval_pop_level_146_comment =
    "C++ Interface:\n"
    "popLevel(non-const CMetaInterval this)\n"
    "popLevel(non-const CMetaInterval this, float duration)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMetaInterval::pop_level\n"
    "//       Access: Published\n"
    "//  Description: Finishes a level marked by a previous call to\n"
    "//               push_level(), and returns to the previous level.\n"
    "//\n"
    "//               If the duration is not negative, it represents a\n"
    "//               phony duration to assign to the level, for the\n"
    "//               purposes of sequencing later intervals.  Otherwise,\n"
    "//               the level's duration is computed based on the\n"
    "//               intervals within the level.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMetaInterval_pop_level_146_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool CMetaInterval::set_interval_start_time(basic_string< char > const &name, double rel_time, CMetaInterval::RelativeStart rel_to)
 * bool CMetaInterval::set_interval_start_time(basic_string< char > const &name, double rel_time, CMetaInterval::RelativeStart rel_to = (RS_level_begin))
 *******************************************************************/
static PyObject *Dtool_CMetaInterval_set_interval_start_time_147(PyObject *self, PyObject *args,PyObject *kwds) {
    CMetaInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMetaInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool CMetaInterval::set_interval_start_time(basic_string< char > const &name, double rel_time, CMetaInterval::RelativeStart rel_to = (RS_level_begin))
            char *param1_str; int param1_len;
            double param2;
            static char * key_word_list[] = {(char *)"name", (char *)"rel_time", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#d:setIntervalStartTime", key_word_list, &param1_str, &param1_len, &param2))
            {
                bool return_value = (local_this)->set_interval_start_time(basic_string<char>(param1_str, param1_len), (double)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CMetaInterval.setIntervalStartTime() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool CMetaInterval::set_interval_start_time(basic_string< char > const &name, double rel_time, CMetaInterval::RelativeStart rel_to)
            char *param1_str; int param1_len;
            double param2;
            int param3;
            static char * key_word_list[] = {(char *)"name", (char *)"rel_time", (char *)"rel_to", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#di:setIntervalStartTime", key_word_list, &param1_str, &param1_len, &param2, &param3))
            {
                bool return_value = (local_this)->set_interval_start_time(basic_string<char>(param1_str, param1_len), (double)param2, (CMetaInterval::RelativeStart)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call CMetaInterval.setIntervalStartTime() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setIntervalStartTime() takes 3 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setIntervalStartTime(non-const CMetaInterval this, string name, float rel_time)\n"
          "setIntervalStartTime(non-const CMetaInterval this, string name, float rel_time, int rel_to)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMetaInterval_set_interval_start_time_147_comment =
    "C++ Interface:\n"
    "setIntervalStartTime(non-const CMetaInterval this, string name, float rel_time)\n"
    "setIntervalStartTime(non-const CMetaInterval this, string name, float rel_time, int rel_to)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMetaInterval::set_interval_start_time\n"
    "//       Access: Published\n"
    "//  Description: Adjusts the start time of the child interval with the\n"
    "//               given name, if found.  This may be either a C++\n"
    "//               interval added via add_c_interval(), or an external\n"
    "//               interval added via add_ext_index(); the name must\n"
    "//               match exactly.\n"
    "//\n"
    "//               If the interval is found, its start time is adjusted,\n"
    "//               and all subsequent intervals are adjusting\n"
    "//               accordingly, and true is returned.  If a matching\n"
    "//               interval is not found, nothing is changed and false\n"
    "//               is returned.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMetaInterval_set_interval_start_time_147_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * double CMetaInterval::get_interval_start_time(basic_string< char > const &name) const
 *******************************************************************/
static PyObject *Dtool_CMetaInterval_get_interval_start_time_148(PyObject *self, PyObject *args,PyObject *kwds) {
    CMetaInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMetaInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-double CMetaInterval::get_interval_start_time(basic_string< char > const &name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getIntervalStartTime", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:getIntervalStartTime", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            double return_value = ((const CMetaInterval*)local_this)->get_interval_start_time(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIntervalStartTime(const CMetaInterval this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMetaInterval_get_interval_start_time_148_comment =
    "C++ Interface:\n"
    "getIntervalStartTime(const CMetaInterval this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMetaInterval::get_interval_start_time\n"
    "//       Access: Published\n"
    "//  Description: Returns the actual start time, relative to the\n"
    "//               beginning of the interval, of the child interval with\n"
    "//               the given name, if found, or -1 if the interval is\n"
    "//               not found.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMetaInterval_get_interval_start_time_148_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * double CMetaInterval::get_interval_end_time(basic_string< char > const &name) const
 *******************************************************************/
static PyObject *Dtool_CMetaInterval_get_interval_end_time_149(PyObject *self, PyObject *args,PyObject *kwds) {
    CMetaInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMetaInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-double CMetaInterval::get_interval_end_time(basic_string< char > const &name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getIntervalEndTime", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:getIntervalEndTime", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            double return_value = ((const CMetaInterval*)local_this)->get_interval_end_time(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIntervalEndTime(const CMetaInterval this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMetaInterval_get_interval_end_time_149_comment =
    "C++ Interface:\n"
    "getIntervalEndTime(const CMetaInterval this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMetaInterval::get_interval_end_time\n"
    "//       Access: Published\n"
    "//  Description: Returns the actual end time, relative to the\n"
    "//               beginning of the interval, of the child interval with\n"
    "//               the given name, if found, or -1 if the interval is\n"
    "//               not found.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMetaInterval_get_interval_end_time_149_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int CMetaInterval::get_num_defs(void) const
 *******************************************************************/
static PyObject *Dtool_CMetaInterval_get_num_defs_151(PyObject *self, PyObject *args,PyObject *kwds) {
    CMetaInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMetaInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int CMetaInterval::get_num_defs(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumDefs", key_word_list));
        else
            (PyArg_Parse(args, ":getNumDefs"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const CMetaInterval*)local_this)->get_num_defs();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumDefs(const CMetaInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMetaInterval_get_num_defs_151_comment =
    "C++ Interface:\n"
    "getNumDefs(const CMetaInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMetaInterval::get_num_defs\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of interval and push/pop\n"
    "//               definitions that have been added to the meta\n"
    "//               interval.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMetaInterval_get_num_defs_151_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CMetaInterval::DefType CMetaInterval::get_def_type(int n) const
 *******************************************************************/
static PyObject *Dtool_CMetaInterval_get_def_type_152(PyObject *self, PyObject *args,PyObject *kwds) {
    CMetaInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMetaInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline CMetaInterval::DefType CMetaInterval::get_def_type(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getDefType", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getDefType", &param1));
        if(!PyErr_Occurred())
        {
            CMetaInterval::DefType return_value = ((const CMetaInterval*)local_this)->get_def_type((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDefType(const CMetaInterval this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMetaInterval_get_def_type_152_comment =
    "C++ Interface:\n"
    "getDefType(const CMetaInterval this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMetaInterval::get_def_type\n"
    "//       Access: Published\n"
    "//  Description: Returns the type of the nth interval definition that\n"
    "//               has been added.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMetaInterval_get_def_type_152_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CInterval *CMetaInterval::get_c_interval(int n) const
 *******************************************************************/
static PyObject *Dtool_CMetaInterval_get_c_interval_153(PyObject *self, PyObject *args,PyObject *kwds) {
    CMetaInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMetaInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline CInterval *CMetaInterval::get_c_interval(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getCInterval", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getCInterval", &param1));
        if(!PyErr_Occurred())
        {
            CInterval *return_value = ((const CMetaInterval*)local_this)->get_c_interval((int)param1);
            if (return_value != (CInterval *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_CInterval,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCInterval(const CMetaInterval this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMetaInterval_get_c_interval_153_comment =
    "C++ Interface:\n"
    "getCInterval(const CMetaInterval this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMetaInterval::get_c_interval\n"
    "//       Access: Published\n"
    "//  Description: Return the CInterval pointer associated with the nth\n"
    "//               interval definition.  It is only valid to call this\n"
    "//               if get_def_type(n) returns DT_c_interval.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMetaInterval_get_c_interval_153_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int CMetaInterval::get_ext_index(int n) const
 *******************************************************************/
static PyObject *Dtool_CMetaInterval_get_ext_index_154(PyObject *self, PyObject *args,PyObject *kwds) {
    CMetaInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMetaInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int CMetaInterval::get_ext_index(int n) const
        int param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getExtIndex", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getExtIndex", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const CMetaInterval*)local_this)->get_ext_index((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getExtIndex(const CMetaInterval this, int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMetaInterval_get_ext_index_154_comment =
    "C++ Interface:\n"
    "getExtIndex(const CMetaInterval this, int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMetaInterval::get_ext_index\n"
    "//       Access: Published\n"
    "//  Description: Return the external interval index number associated\n"
    "//               with the nth interval definition.  It is only valid\n"
    "//               to call this if get_def_type(n) returns DT_ext_index.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMetaInterval_get_ext_index_154_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool CMetaInterval::is_event_ready(void)
 *******************************************************************/
static PyObject *Dtool_CMetaInterval_is_event_ready_155(PyObject *self, PyObject *args,PyObject *kwds) {
    CMetaInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMetaInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool CMetaInterval::is_event_ready(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isEventReady", key_word_list));
        else
            (PyArg_Parse(args, ":isEventReady"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->is_event_ready();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CMetaInterval.isEventReady() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isEventReady(non-const CMetaInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMetaInterval_is_event_ready_155_comment =
    "C++ Interface:\n"
    "isEventReady(non-const CMetaInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMetaInterval::is_event_ready\n"
    "//       Access: Published\n"
    "//  Description: Returns true if a recent call to priv_initialize(),\n"
    "//               priv_step(), or priv_finalize() has left some external\n"
    "//               intervals ready to play.  If this returns true, call\n"
    "//               get_event_index(), get_event_t(), and pop_event() to\n"
    "//               retrieve the relevant information.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMetaInterval_is_event_ready_155_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int CMetaInterval::get_event_index(void) const
 *******************************************************************/
static PyObject *Dtool_CMetaInterval_get_event_index_156(PyObject *self, PyObject *args,PyObject *kwds) {
    CMetaInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMetaInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int CMetaInterval::get_event_index(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEventIndex", key_word_list));
        else
            (PyArg_Parse(args, ":getEventIndex"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const CMetaInterval*)local_this)->get_event_index();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEventIndex(const CMetaInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMetaInterval_get_event_index_156_comment =
    "C++ Interface:\n"
    "getEventIndex(const CMetaInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMetaInterval::get_event_index\n"
    "//       Access: Published\n"
    "//  Description: If a previous call to is_event_ready() returned\n"
    "//               true, this returns the index number (added via\n"
    "//               add_event_index()) of the external interval that needs\n"
    "//               to be played.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMetaInterval_get_event_index_156_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double CMetaInterval::get_event_t(void) const
 *******************************************************************/
static PyObject *Dtool_CMetaInterval_get_event_t_157(PyObject *self, PyObject *args,PyObject *kwds) {
    CMetaInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMetaInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline double CMetaInterval::get_event_t(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEventT", key_word_list));
        else
            (PyArg_Parse(args, ":getEventT"));
        if(!PyErr_Occurred())
        {
            double return_value = ((const CMetaInterval*)local_this)->get_event_t();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEventT(const CMetaInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMetaInterval_get_event_t_157_comment =
    "C++ Interface:\n"
    "getEventT(const CMetaInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMetaInterval::get_event_t\n"
    "//       Access: Published\n"
    "//  Description: If a previous call to is_event_ready() returned\n"
    "//               true, this returns the t value that should be fed to\n"
    "//               the given interval.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMetaInterval_get_event_t_157_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CInterval::EventType CMetaInterval::get_event_type(void) const
 *******************************************************************/
static PyObject *Dtool_CMetaInterval_get_event_type_158(PyObject *self, PyObject *args,PyObject *kwds) {
    CMetaInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMetaInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline CInterval::EventType CMetaInterval::get_event_type(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEventType", key_word_list));
        else
            (PyArg_Parse(args, ":getEventType"));
        if(!PyErr_Occurred())
        {
            CInterval::EventType return_value = ((const CMetaInterval*)local_this)->get_event_type();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEventType(const CMetaInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMetaInterval_get_event_type_158_comment =
    "C++ Interface:\n"
    "getEventType(const CMetaInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMetaInterval::get_event_type\n"
    "//       Access: Published\n"
    "//  Description: If a previous call to is_event_ready() returned\n"
    "//               true, this returns the type of the event (initialize,\n"
    "//               step, finalize, etc.) for the given interval.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMetaInterval_get_event_type_158_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CMetaInterval::pop_event(void)
 *******************************************************************/
static PyObject *Dtool_CMetaInterval_pop_event_159(PyObject *self, PyObject *args,PyObject *kwds) {
    CMetaInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMetaInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void CMetaInterval::pop_event(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":popEvent", key_word_list));
        else
            (PyArg_Parse(args, ":popEvent"));
        if(!PyErr_Occurred())
        {
            (local_this)->pop_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call CMetaInterval.popEvent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "popEvent(non-const CMetaInterval this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMetaInterval_pop_event_159_comment =
    "C++ Interface:\n"
    "popEvent(non-const CMetaInterval this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMetaInterval::pop_event\n"
    "//       Access: Published\n"
    "//  Description: Acknowledges that the external interval on the top of\n"
    "//               the queue has been extracted, and is about to be\n"
    "//               serviced by the scripting language.  This prepares\n"
    "//               the interval so the next call to is_event_ready()\n"
    "//               will return information about the next external\n"
    "//               interval on the queue, if any.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMetaInterval_pop_event_159_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void CMetaInterval::timeline(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_CMetaInterval_timeline_160(PyObject *self, PyObject *args,PyObject *kwds) {
    CMetaInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CMetaInterval,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void CMetaInterval::timeline(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:timeline", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:timeline", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "CMetaInterval.timeline", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const CMetaInterval*)local_this)->timeline(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "timeline(const CMetaInterval this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMetaInterval_timeline_160_comment =
    "C++ Interface:\n"
    "timeline(const CMetaInterval this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: CMetaInterval::timeline\n"
    "//       Access: Published\n"
    "//  Description: Outputs a list of all events in the order in which\n"
    "//               they occur.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_CMetaInterval_timeline_160_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle CMetaInterval::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_CMetaInterval_get_class_type_161(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle CMetaInterval::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = CMetaInterval::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_CMetaInterval_get_class_type_161_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_CMetaInterval_get_class_type_161_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * CMetaInterval::CMetaInterval(basic_string< char > const &name)
 *******************************************************************/
int  Dtool_Init_CMetaInterval(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-CMetaInterval::CMetaInterval(basic_string< char > const &name)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:CMetaInterval", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:CMetaInterval", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            CMetaInterval *return_value = new CMetaInterval(basic_string<char>(param0_str, param0_len));
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_CMetaInterval,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "CMetaInterval(string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_CMetaInterval(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_CMetaInterval)
    {
        printf("CMetaInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    CMetaInterval * local_this = (CMetaInterval *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_CMetaInterval)
        return local_this;
    if(requested_type == &Dtool_CInterval)
        return ( CInterval *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( CInterval *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( CInterval *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( CInterval *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_CMetaInterval(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_CMetaInterval)
        return from_this;
    if(from_type == &Dtool_CInterval)
    {
          CInterval* other_this = (CInterval*)from_this;
          return (CMetaInterval*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (CMetaInterval*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (CMetaInterval*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (CMetaInterval*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. HideInterval 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle HideInterval::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_HideInterval_get_class_type_164(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle HideInterval::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = HideInterval::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_HideInterval_get_class_type_164_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_HideInterval_get_class_type_164_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * HideInterval::HideInterval(NodePath const &node, basic_string< char > const &name)
 * HideInterval::HideInterval(NodePath const &node, basic_string< char > const &name = ((string())))
 *******************************************************************/
int  Dtool_Init_HideInterval(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-HideInterval::HideInterval(NodePath const &node, basic_string< char > const &name = ((string())))
                PyObject *param0;
                static char * key_word_list[] = {(char *)"node", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:HideInterval", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:HideInterval", &param0));
                if(!PyErr_Occurred())
                {
                    NodePath *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_NodePath, 0, "HideInterval.HideInterval", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        HideInterval *return_value = new HideInterval(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_HideInterval,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-HideInterval::HideInterval(NodePath const &node, basic_string< char > const &name)
                PyObject *param0;
                char *param1_str; int param1_len;
                static char * key_word_list[] = {(char *)"node", (char *)"name", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:HideInterval", key_word_list, &param0, &param1_str, &param1_len))
                {
                    NodePath *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_NodePath, 0, "HideInterval.HideInterval", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        HideInterval *return_value = new HideInterval(*param0_this, basic_string<char>(param1_str, param1_len));
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_HideInterval,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "HideInterval() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "HideInterval(const NodePath node)\n"
          "HideInterval(const NodePath node, string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_HideInterval(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_HideInterval)
    {
        printf("HideInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    HideInterval * local_this = (HideInterval *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_HideInterval)
        return local_this;
    if(requested_type == &Dtool_CInterval)
        return ( CInterval *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( CInterval *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( CInterval *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( CInterval *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_HideInterval(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_HideInterval)
        return from_this;
    if(from_type == &Dtool_CInterval)
    {
          CInterval* other_this = (CInterval*)from_this;
          return (HideInterval*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (HideInterval*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (HideInterval*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (HideInterval*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. ShowInterval 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle ShowInterval::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_ShowInterval_get_class_type_168(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle ShowInterval::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = ShowInterval::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_ShowInterval_get_class_type_168_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_ShowInterval_get_class_type_168_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * ShowInterval::ShowInterval(NodePath const &node, basic_string< char > const &name)
 * ShowInterval::ShowInterval(NodePath const &node, basic_string< char > const &name = ((string())))
 *******************************************************************/
int  Dtool_Init_ShowInterval(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-ShowInterval::ShowInterval(NodePath const &node, basic_string< char > const &name = ((string())))
                PyObject *param0;
                static char * key_word_list[] = {(char *)"node", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:ShowInterval", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:ShowInterval", &param0));
                if(!PyErr_Occurred())
                {
                    NodePath *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_NodePath, 0, "ShowInterval.ShowInterval", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        ShowInterval *return_value = new ShowInterval(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_ShowInterval,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-ShowInterval::ShowInterval(NodePath const &node, basic_string< char > const &name)
                PyObject *param0;
                char *param1_str; int param1_len;
                static char * key_word_list[] = {(char *)"node", (char *)"name", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:ShowInterval", key_word_list, &param0, &param1_str, &param1_len))
                {
                    NodePath *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_NodePath, 0, "ShowInterval.ShowInterval", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        ShowInterval *return_value = new ShowInterval(*param0_this, basic_string<char>(param1_str, param1_len));
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_ShowInterval,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "ShowInterval() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "ShowInterval(const NodePath node)\n"
          "ShowInterval(const NodePath node, string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_ShowInterval(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_ShowInterval)
    {
        printf("ShowInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    ShowInterval * local_this = (ShowInterval *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_ShowInterval)
        return local_this;
    if(requested_type == &Dtool_CInterval)
        return ( CInterval *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( CInterval *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( CInterval *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( CInterval *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_ShowInterval(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_ShowInterval)
        return from_this;
    if(from_type == &Dtool_CInterval)
    {
          CInterval* other_this = (CInterval*)from_this;
          return (ShowInterval*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (ShowInterval*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (ShowInterval*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (ShowInterval*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. WaitInterval 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle WaitInterval::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_WaitInterval_get_class_type_172(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle WaitInterval::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = WaitInterval::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_WaitInterval_get_class_type_172_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_WaitInterval_get_class_type_172_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline WaitInterval::WaitInterval(double duration)
 *******************************************************************/
int  Dtool_Init_WaitInterval(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-inline WaitInterval::WaitInterval(double duration)
        double param0;
        static char * key_word_list[] = {(char *)"duration", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:WaitInterval", key_word_list, &param0));
        else
            (PyArg_Parse(args, "d:WaitInterval", &param0));
        if(!PyErr_Occurred())
        {
            WaitInterval *return_value = new WaitInterval((double)param0);
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_WaitInterval,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "WaitInterval(float duration)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_WaitInterval(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_WaitInterval)
    {
        printf("WaitInterval ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    WaitInterval * local_this = (WaitInterval *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_WaitInterval)
        return local_this;
    if(requested_type == &Dtool_CInterval)
        return ( CInterval *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( CInterval *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( CInterval *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( CInterval *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_WaitInterval(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_WaitInterval)
        return from_this;
    if(from_type == &Dtool_CInterval)
    {
          CInterval* other_this = (CInterval*)from_this;
          return (WaitInterval*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (WaitInterval*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (WaitInterval*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (WaitInterval*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. CInterval | CInterval
//********************************************************************
PyMethodDef Dtool_Methods_CInterval[]= {
  { "getName",(PyCFunction ) &Dtool_CInterval_get_name_3, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_get_name_3_comment},
  { "getDuration",(PyCFunction ) &Dtool_CInterval_get_duration_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_get_duration_4_comment},
  { "getOpenEnded",(PyCFunction ) &Dtool_CInterval_get_open_ended_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_get_open_ended_5_comment},
  { "getState",(PyCFunction ) &Dtool_CInterval_get_state_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_get_state_8_comment},
  { "isStopped",(PyCFunction ) &Dtool_CInterval_is_stopped_9, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_is_stopped_9_comment},
  { "setDoneEvent",(PyCFunction ) &Dtool_CInterval_set_done_event_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_set_done_event_10_comment},
  { "getDoneEvent",(PyCFunction ) &Dtool_CInterval_get_done_event_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_get_done_event_11_comment},
  { "setT",(PyCFunction ) &Dtool_CInterval_set_t_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_set_t_12_comment},
  { "getT",(PyCFunction ) &Dtool_CInterval_get_t_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_get_t_13_comment},
  { "setAutoPause",(PyCFunction ) &Dtool_CInterval_set_auto_pause_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_set_auto_pause_14_comment},
  { "getAutoPause",(PyCFunction ) &Dtool_CInterval_get_auto_pause_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_get_auto_pause_15_comment},
  { "setAutoFinish",(PyCFunction ) &Dtool_CInterval_set_auto_finish_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_set_auto_finish_16_comment},
  { "getAutoFinish",(PyCFunction ) &Dtool_CInterval_get_auto_finish_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_get_auto_finish_17_comment},
  { "setWantsTCallback",(PyCFunction ) &Dtool_CInterval_set_wants_t_callback_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_set_wants_t_callback_18_comment},
  { "getWantsTCallback",(PyCFunction ) &Dtool_CInterval_get_wants_t_callback_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_get_wants_t_callback_19_comment},
  { "setManager",(PyCFunction ) &Dtool_CInterval_set_manager_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_set_manager_20_comment},
  { "getManager",(PyCFunction ) &Dtool_CInterval_get_manager_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_get_manager_21_comment},
  { "start",(PyCFunction ) &Dtool_CInterval_start_22, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_start_22_comment},
  { "loop",(PyCFunction ) &Dtool_CInterval_loop_23, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_loop_23_comment},
  { "pause",(PyCFunction ) &Dtool_CInterval_pause_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_pause_24_comment},
  { "resume",(PyCFunction ) &Dtool_CInterval_resume_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_resume_25_comment},
  { "resumeUntil",(PyCFunction ) &Dtool_CInterval_resume_until_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_resume_until_26_comment},
  { "finish",(PyCFunction ) &Dtool_CInterval_finish_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_finish_27_comment},
  { "clearToInitial",(PyCFunction ) &Dtool_CInterval_clear_to_initial_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_clear_to_initial_28_comment},
  { "isPlaying",(PyCFunction ) &Dtool_CInterval_is_playing_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_is_playing_29_comment},
  { "getPlayRate",(PyCFunction ) &Dtool_CInterval_get_play_rate_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_get_play_rate_30_comment},
  { "setPlayRate",(PyCFunction ) &Dtool_CInterval_set_play_rate_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_set_play_rate_31_comment},
  { "privDoEvent",(PyCFunction ) &Dtool_CInterval_priv_do_event_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_priv_do_event_32_comment},
  { "privInitialize",(PyCFunction ) &Dtool_CInterval_priv_initialize_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_priv_initialize_33_comment},
  { "privInstant",(PyCFunction ) &Dtool_CInterval_priv_instant_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_priv_instant_34_comment},
  { "privStep",(PyCFunction ) &Dtool_CInterval_priv_step_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_priv_step_35_comment},
  { "privFinalize",(PyCFunction ) &Dtool_CInterval_priv_finalize_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_priv_finalize_36_comment},
  { "privReverseInitialize",(PyCFunction ) &Dtool_CInterval_priv_reverse_initialize_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_priv_reverse_initialize_37_comment},
  { "privReverseInstant",(PyCFunction ) &Dtool_CInterval_priv_reverse_instant_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_priv_reverse_instant_38_comment},
  { "privReverseFinalize",(PyCFunction ) &Dtool_CInterval_priv_reverse_finalize_39, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_priv_reverse_finalize_39_comment},
  { "privInterrupt",(PyCFunction ) &Dtool_CInterval_priv_interrupt_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_priv_interrupt_40_comment},
  { "output",(PyCFunction ) &Dtool_CInterval_output_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_output_41_comment},
  { "write",(PyCFunction ) &Dtool_CInterval_write_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_write_42_comment},
  { "setupPlay",(PyCFunction ) &Dtool_CInterval_setup_play_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_setup_play_43_comment},
  { "setupResume",(PyCFunction ) &Dtool_CInterval_setup_resume_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_setup_resume_44_comment},
  { "setupResumeUntil",(PyCFunction ) &Dtool_CInterval_setup_resume_until_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_setup_resume_until_45_comment},
  { "stepPlay",(PyCFunction ) &Dtool_CInterval_step_play_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_step_play_46_comment},
  { "getClassType",(PyCFunction ) &Dtool_CInterval_get_class_type_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CInterval_get_class_type_47_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     CInterval
//////////////////
static PyObject *  Dtool_Repr_CInterval(PyObject * self)
{
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     CInterval
//////////////////
static PyObject *  Dtool_Str_CInterval(PyObject * self)
{
    CInterval * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CInterval,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os,0);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_CInterval(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CInterval.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CInterval\n"
          "// Description : The base class for timeline components.  A CInterval\n"
          "//               represents a single action, event, or collection of\n"
          "//               nested intervals that will be performed at some\n"
          "//               specific time or over a period of time.\n"
          "//\n"
          "//               This is essentially similar to the Python \"Interval\"\n"
          "//               class, but it is implemented in C++ (hence the name).\n"
          "//               Intervals that may be implemented in C++ will inherit\n"
          "//               from this class; Intervals that must be implemented\n"
          "//               in Python will inherit from the similar Python class.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_CInterval.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_CInterval.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CInterval.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CInterval.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_CInterval.As_PyTypeObject().tp_repr = & Dtool_Repr_CInterval;
        // __str__
        Dtool_CInterval.As_PyTypeObject().tp_str = & Dtool_Str_CInterval;
        // Enum  CInterval::EventType;
        PyDict_SetItemString(Dtool_CInterval.As_PyTypeObject().tp_dict,"ETInitialize",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_CInterval.As_PyTypeObject().tp_dict,"ETInstant",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_CInterval.As_PyTypeObject().tp_dict,"ETStep",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_CInterval.As_PyTypeObject().tp_dict,"ETFinalize",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_CInterval.As_PyTypeObject().tp_dict,"ETReverseInitialize",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_CInterval.As_PyTypeObject().tp_dict,"ETReverseInstant",PyInt_FromLong(5));
        PyDict_SetItemString(Dtool_CInterval.As_PyTypeObject().tp_dict,"ETReverseFinalize",PyInt_FromLong(6));
        PyDict_SetItemString(Dtool_CInterval.As_PyTypeObject().tp_dict,"ETInterrupt",PyInt_FromLong(7));
        // Enum  CInterval::State;
        PyDict_SetItemString(Dtool_CInterval.As_PyTypeObject().tp_dict,"SInitial",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_CInterval.As_PyTypeObject().tp_dict,"SStarted",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_CInterval.As_PyTypeObject().tp_dict,"SPaused",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_CInterval.As_PyTypeObject().tp_dict,"SFinal",PyInt_FromLong(3));
        if(PyType_Ready(&Dtool_CInterval.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CInterval)");
             printf(" Error In PyType_ReadyCInterval");
             return;
        }
        Py_INCREF(&Dtool_CInterval.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CInterval.As_PyTypeObject().tp_dict,"CInterval",&Dtool_CInterval.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CInterval.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CInterval[42],&Dtool_CInterval.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CInterval,CInterval::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CInterval.As_PyTypeObject());
        PyModule_AddObject(module, "CInterval",(PyObject *)&Dtool_CInterval.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CConstraintInterval | CConstraintInterval
//********************************************************************
PyMethodDef Dtool_Methods_CConstraintInterval[]= {
  { "getClassType",(PyCFunction ) &Dtool_CConstraintInterval_get_class_type_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConstraintInterval_get_class_type_53_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CConstraintInterval(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CConstraintInterval.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CConstraintInterval\n"
          "// Description : The base class for a family of intervals that\n"
          "//               constrain some property to a value over time.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CInterval._Dtool_ClassInit(NULL);
        Dtool_CConstraintInterval.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CInterval.As_PyTypeObject());
        Dtool_CConstraintInterval.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CConstraintInterval.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CConstraintInterval.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CConstraintInterval.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CConstraintInterval)");
             printf(" Error In PyType_ReadyCConstraintInterval");
             return;
        }
        Py_INCREF(&Dtool_CConstraintInterval.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CConstraintInterval.As_PyTypeObject().tp_dict,"CConstraintInterval",&Dtool_CConstraintInterval.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CConstraintInterval.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CConstraintInterval[0],&Dtool_CConstraintInterval.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CConstraintInterval,CConstraintInterval::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CConstraintInterval.As_PyTypeObject());
        PyModule_AddObject(module, "CConstraintInterval",(PyObject *)&Dtool_CConstraintInterval.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CConstrainHprInterval | CConstrainHprInterval
//********************************************************************
PyMethodDef Dtool_Methods_CConstrainHprInterval[]= {
  { "getNode",(PyCFunction ) &Dtool_CConstrainHprInterval_get_node_57, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConstrainHprInterval_get_node_57_comment},
  { "getTarget",(PyCFunction ) &Dtool_CConstrainHprInterval_get_target_58, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConstrainHprInterval_get_target_58_comment},
  { "getClassType",(PyCFunction ) &Dtool_CConstrainHprInterval_get_class_type_59, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConstrainHprInterval_get_class_type_59_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CConstrainHprInterval(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CConstrainHprInterval.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CConstrainHprInterval\n"
          "// Description : A constraint interval that will constrain the\n"
          "//               orientation of one node to the orientation of another.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CConstraintInterval._Dtool_ClassInit(NULL);
        Dtool_CConstrainHprInterval.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CConstraintInterval.As_PyTypeObject());
        Dtool_CConstrainHprInterval.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CConstrainHprInterval.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CConstrainHprInterval.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CConstrainHprInterval.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CConstrainHprInterval)");
             printf(" Error In PyType_ReadyCConstrainHprInterval");
             return;
        }
        Py_INCREF(&Dtool_CConstrainHprInterval.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CConstrainHprInterval.As_PyTypeObject().tp_dict,"CConstrainHprInterval",&Dtool_CConstrainHprInterval.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CConstrainHprInterval.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CConstrainHprInterval[2],&Dtool_CConstrainHprInterval.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CConstrainHprInterval,CConstrainHprInterval::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CConstrainHprInterval.As_PyTypeObject());
        PyModule_AddObject(module, "CConstrainHprInterval",(PyObject *)&Dtool_CConstrainHprInterval.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CConstrainPosHprInterval | CConstrainPosHprInterval
//********************************************************************
PyMethodDef Dtool_Methods_CConstrainPosHprInterval[]= {
  { "getNode",(PyCFunction ) &Dtool_CConstrainPosHprInterval_get_node_63, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConstrainPosHprInterval_get_node_63_comment},
  { "getTarget",(PyCFunction ) &Dtool_CConstrainPosHprInterval_get_target_64, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConstrainPosHprInterval_get_target_64_comment},
  { "getClassType",(PyCFunction ) &Dtool_CConstrainPosHprInterval_get_class_type_65, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConstrainPosHprInterval_get_class_type_65_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CConstrainPosHprInterval(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CConstrainPosHprInterval.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CConstrainPosHprInterval\n"
          "// Description : A constraint interval that will constrain the\n"
          "//               position and orientation of one node to the\n"
          "//               position and orientation of another.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CConstraintInterval._Dtool_ClassInit(NULL);
        Dtool_CConstrainPosHprInterval.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CConstraintInterval.As_PyTypeObject());
        Dtool_CConstrainPosHprInterval.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CConstrainPosHprInterval.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CConstrainPosHprInterval.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CConstrainPosHprInterval.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CConstrainPosHprInterval)");
             printf(" Error In PyType_ReadyCConstrainPosHprInterval");
             return;
        }
        Py_INCREF(&Dtool_CConstrainPosHprInterval.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CConstrainPosHprInterval.As_PyTypeObject().tp_dict,"CConstrainPosHprInterval",&Dtool_CConstrainPosHprInterval.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CConstrainPosHprInterval.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CConstrainPosHprInterval[2],&Dtool_CConstrainPosHprInterval.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CConstrainPosHprInterval,CConstrainPosHprInterval::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CConstrainPosHprInterval.As_PyTypeObject());
        PyModule_AddObject(module, "CConstrainPosHprInterval",(PyObject *)&Dtool_CConstrainPosHprInterval.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CConstrainPosInterval | CConstrainPosInterval
//********************************************************************
PyMethodDef Dtool_Methods_CConstrainPosInterval[]= {
  { "getNode",(PyCFunction ) &Dtool_CConstrainPosInterval_get_node_69, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConstrainPosInterval_get_node_69_comment},
  { "getTarget",(PyCFunction ) &Dtool_CConstrainPosInterval_get_target_70, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConstrainPosInterval_get_target_70_comment},
  { "getClassType",(PyCFunction ) &Dtool_CConstrainPosInterval_get_class_type_71, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConstrainPosInterval_get_class_type_71_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CConstrainPosInterval(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CConstrainPosInterval.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CConstrainPosInterval\n"
          "// Description : A constraint interval that will constrain the\n"
          "//               position of one node to the position of another.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CConstraintInterval._Dtool_ClassInit(NULL);
        Dtool_CConstrainPosInterval.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CConstraintInterval.As_PyTypeObject());
        Dtool_CConstrainPosInterval.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CConstrainPosInterval.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CConstrainPosInterval.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CConstrainPosInterval.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CConstrainPosInterval)");
             printf(" Error In PyType_ReadyCConstrainPosInterval");
             return;
        }
        Py_INCREF(&Dtool_CConstrainPosInterval.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CConstrainPosInterval.As_PyTypeObject().tp_dict,"CConstrainPosInterval",&Dtool_CConstrainPosInterval.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CConstrainPosInterval.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CConstrainPosInterval[2],&Dtool_CConstrainPosInterval.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CConstrainPosInterval,CConstrainPosInterval::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CConstrainPosInterval.As_PyTypeObject());
        PyModule_AddObject(module, "CConstrainPosInterval",(PyObject *)&Dtool_CConstrainPosInterval.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CConstrainTransformInterval | CConstrainTransformInterval
//********************************************************************
PyMethodDef Dtool_Methods_CConstrainTransformInterval[]= {
  { "getNode",(PyCFunction ) &Dtool_CConstrainTransformInterval_get_node_75, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConstrainTransformInterval_get_node_75_comment},
  { "getTarget",(PyCFunction ) &Dtool_CConstrainTransformInterval_get_target_76, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConstrainTransformInterval_get_target_76_comment},
  { "getClassType",(PyCFunction ) &Dtool_CConstrainTransformInterval_get_class_type_77, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CConstrainTransformInterval_get_class_type_77_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CConstrainTransformInterval(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CConstrainTransformInterval.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CConstrainTransformInterval\n"
          "// Description : A constraint interval that will constrain the\n"
          "//               transform of one node to the transform of another.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CConstraintInterval._Dtool_ClassInit(NULL);
        Dtool_CConstrainTransformInterval.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CConstraintInterval.As_PyTypeObject());
        Dtool_CConstrainTransformInterval.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CConstrainTransformInterval.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CConstrainTransformInterval.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CConstrainTransformInterval.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CConstrainTransformInterval)");
             printf(" Error In PyType_ReadyCConstrainTransformInterval");
             return;
        }
        Py_INCREF(&Dtool_CConstrainTransformInterval.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CConstrainTransformInterval.As_PyTypeObject().tp_dict,"CConstrainTransformInterval",&Dtool_CConstrainTransformInterval.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CConstrainTransformInterval.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CConstrainTransformInterval[2],&Dtool_CConstrainTransformInterval.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CConstrainTransformInterval,CConstrainTransformInterval::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CConstrainTransformInterval.As_PyTypeObject());
        PyModule_AddObject(module, "CConstrainTransformInterval",(PyObject *)&Dtool_CConstrainTransformInterval.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CIntervalManager | CIntervalManager
//********************************************************************
PyMethodDef Dtool_Methods_CIntervalManager[]= {
  { "setEventQueue",(PyCFunction ) &Dtool_CIntervalManager_set_event_queue_82, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CIntervalManager_set_event_queue_82_comment},
  { "getEventQueue",(PyCFunction ) &Dtool_CIntervalManager_get_event_queue_83, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CIntervalManager_get_event_queue_83_comment},
  { "addCInterval",(PyCFunction ) &Dtool_CIntervalManager_add_c_interval_84, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CIntervalManager_add_c_interval_84_comment},
  { "findCInterval",(PyCFunction ) &Dtool_CIntervalManager_find_c_interval_85, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CIntervalManager_find_c_interval_85_comment},
  { "getCInterval",(PyCFunction ) &Dtool_CIntervalManager_get_c_interval_86, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CIntervalManager_get_c_interval_86_comment},
  { "removeCInterval",(PyCFunction ) &Dtool_CIntervalManager_remove_c_interval_87, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CIntervalManager_remove_c_interval_87_comment},
  { "interrupt",(PyCFunction ) &Dtool_CIntervalManager_interrupt_88, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CIntervalManager_interrupt_88_comment},
  { "getNumIntervals",(PyCFunction ) &Dtool_CIntervalManager_get_num_intervals_89, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CIntervalManager_get_num_intervals_89_comment},
  { "getMaxIndex",(PyCFunction ) &Dtool_CIntervalManager_get_max_index_90, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CIntervalManager_get_max_index_90_comment},
  { "step",(PyCFunction ) &Dtool_CIntervalManager_step_91, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CIntervalManager_step_91_comment},
  { "getNextEvent",(PyCFunction ) &Dtool_CIntervalManager_get_next_event_92, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CIntervalManager_get_next_event_92_comment},
  { "getNextRemoval",(PyCFunction ) &Dtool_CIntervalManager_get_next_removal_93, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CIntervalManager_get_next_removal_93_comment},
  { "output",(PyCFunction ) &Dtool_CIntervalManager_output_94, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CIntervalManager_output_94_comment},
  { "write",(PyCFunction ) &Dtool_CIntervalManager_write_95, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CIntervalManager_write_95_comment},
  { "getGlobalPtr",(PyCFunction ) &Dtool_CIntervalManager_get_global_ptr_96, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CIntervalManager_get_global_ptr_96_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     CIntervalManager
//////////////////
static PyObject *  Dtool_Repr_CIntervalManager(PyObject * self)
{
    CIntervalManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CIntervalManager,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     CIntervalManager
//////////////////
static PyObject *  Dtool_Str_CIntervalManager(PyObject * self)
{
    CIntervalManager * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_CIntervalManager,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_CIntervalManager(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CIntervalManager.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CIntervalManager\n"
          "// Description : This object holds a number of currently-playing\n"
          "//               intervals and is responsible for advancing them each\n"
          "//               frame as needed.\n"
          "//\n"
          "//               There is normally only one IntervalManager object in\n"
          "//               the world, and it is the responsibility of the\n"
          "//               scripting language to call step() on this object once\n"
          "//               each frame, and to then process the events indicated by\n"
          "//               get_next_event().  \n"
          "//\n"
          "//               It is also possible to create multiple\n"
          "//               IntervalManager objects for special needs.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_CIntervalManager.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_CIntervalManager.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CIntervalManager.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CIntervalManager.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_CIntervalManager.As_PyTypeObject().tp_repr = & Dtool_Repr_CIntervalManager;
        // __str__
        Dtool_CIntervalManager.As_PyTypeObject().tp_str = & Dtool_Str_CIntervalManager;
        if(PyType_Ready(&Dtool_CIntervalManager.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CIntervalManager)");
             printf(" Error In PyType_ReadyCIntervalManager");
             return;
        }
        Py_INCREF(&Dtool_CIntervalManager.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CIntervalManager.As_PyTypeObject().tp_dict,"CIntervalManager",&Dtool_CIntervalManager.As_PyObject());
        //  Static Method getGlobalPtr
        PyDict_SetItemString(Dtool_CIntervalManager.As_PyTypeObject().tp_dict,"getGlobalPtr",PyCFunction_New(&Dtool_Methods_CIntervalManager[14],&Dtool_CIntervalManager.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CIntervalManager,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CIntervalManager.As_PyTypeObject());
        PyModule_AddObject(module, "CIntervalManager",(PyObject *)&Dtool_CIntervalManager.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CLerpInterval | CLerpInterval
//********************************************************************
PyMethodDef Dtool_Methods_CLerpInterval[]= {
  { "getBlendType",(PyCFunction ) &Dtool_CLerpInterval_get_blend_type_99, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpInterval_get_blend_type_99_comment},
  { "stringBlendType",(PyCFunction ) &Dtool_CLerpInterval_string_blend_type_100, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpInterval_string_blend_type_100_comment},
  { "getClassType",(PyCFunction ) &Dtool_CLerpInterval_get_class_type_101, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpInterval_get_class_type_101_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CLerpInterval(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CLerpInterval.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CLerpInterval\n"
          "// Description : The base class for a family of intervals that\n"
          "//               linearly interpolate one or more numeric values over\n"
          "//               time.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CInterval._Dtool_ClassInit(NULL);
        Dtool_CLerpInterval.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CInterval.As_PyTypeObject());
        Dtool_CLerpInterval.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CLerpInterval.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CLerpInterval.As_PyTypeObject().tp_dict);
        // Enum  CLerpInterval::BlendType;
        PyDict_SetItemString(Dtool_CLerpInterval.As_PyTypeObject().tp_dict,"BTNoBlend",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_CLerpInterval.As_PyTypeObject().tp_dict,"BTEaseIn",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_CLerpInterval.As_PyTypeObject().tp_dict,"BTEaseOut",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_CLerpInterval.As_PyTypeObject().tp_dict,"BTEaseInOut",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_CLerpInterval.As_PyTypeObject().tp_dict,"BTInvalid",PyInt_FromLong(4));
        if(PyType_Ready(&Dtool_CLerpInterval.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CLerpInterval)");
             printf(" Error In PyType_ReadyCLerpInterval");
             return;
        }
        Py_INCREF(&Dtool_CLerpInterval.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CLerpInterval.As_PyTypeObject().tp_dict,"CLerpInterval",&Dtool_CLerpInterval.As_PyObject());
        //  Static Method stringBlendType
        PyDict_SetItemString(Dtool_CLerpInterval.As_PyTypeObject().tp_dict,"stringBlendType",PyCFunction_New(&Dtool_Methods_CLerpInterval[1],&Dtool_CLerpInterval.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CLerpInterval.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CLerpInterval[2],&Dtool_CLerpInterval.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CLerpInterval,CLerpInterval::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CLerpInterval.As_PyTypeObject());
        PyModule_AddObject(module, "CLerpInterval",(PyObject *)&Dtool_CLerpInterval.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CLerpAnimEffectInterval | CLerpAnimEffectInterval
//********************************************************************
PyMethodDef Dtool_Methods_CLerpAnimEffectInterval[]= {
  { "addControl",(PyCFunction ) &Dtool_CLerpAnimEffectInterval_add_control_105, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpAnimEffectInterval_add_control_105_comment},
  { "getClassType",(PyCFunction ) &Dtool_CLerpAnimEffectInterval_get_class_type_106, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpAnimEffectInterval_get_class_type_106_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CLerpAnimEffectInterval(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CLerpAnimEffectInterval.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CLerpAnimEffectInterval\n"
          "// Description : This interval lerps between different amounts of\n"
          "//               control effects for various AnimControls that might\n"
          "//               be playing on an actor.  It's used to change the\n"
          "//               blending amount between multiple animations.\n"
          "//\n"
          "//               The idea is to start all the animations playing\n"
          "//               first, then use a CLerpAnimEffectInterval to adjust\n"
          "//               the degree to which each animation affects the actor.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CLerpInterval._Dtool_ClassInit(NULL);
        Dtool_CLerpAnimEffectInterval.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CLerpInterval.As_PyTypeObject());
        Dtool_CLerpAnimEffectInterval.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CLerpAnimEffectInterval.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CLerpAnimEffectInterval.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CLerpAnimEffectInterval.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CLerpAnimEffectInterval)");
             printf(" Error In PyType_ReadyCLerpAnimEffectInterval");
             return;
        }
        Py_INCREF(&Dtool_CLerpAnimEffectInterval.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CLerpAnimEffectInterval.As_PyTypeObject().tp_dict,"CLerpAnimEffectInterval",&Dtool_CLerpAnimEffectInterval.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CLerpAnimEffectInterval.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CLerpAnimEffectInterval[1],&Dtool_CLerpAnimEffectInterval.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CLerpAnimEffectInterval,CLerpAnimEffectInterval::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CLerpAnimEffectInterval.As_PyTypeObject());
        PyModule_AddObject(module, "CLerpAnimEffectInterval",(PyObject *)&Dtool_CLerpAnimEffectInterval.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CLerpNodePathInterval | CLerpNodePathInterval
//********************************************************************
PyMethodDef Dtool_Methods_CLerpNodePathInterval[]= {
  { "getNode",(PyCFunction ) &Dtool_CLerpNodePathInterval_get_node_110, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpNodePathInterval_get_node_110_comment},
  { "getOther",(PyCFunction ) &Dtool_CLerpNodePathInterval_get_other_111, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpNodePathInterval_get_other_111_comment},
  { "setStartPos",(PyCFunction ) &Dtool_CLerpNodePathInterval_set_start_pos_112, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpNodePathInterval_set_start_pos_112_comment},
  { "setEndPos",(PyCFunction ) &Dtool_CLerpNodePathInterval_set_end_pos_113, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpNodePathInterval_set_end_pos_113_comment},
  { "setStartHpr",(PyCFunction ) &Dtool_CLerpNodePathInterval_set_start_hpr_114, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpNodePathInterval_set_start_hpr_114_comment},
  { "setEndHpr",(PyCFunction ) &Dtool_CLerpNodePathInterval_set_end_hpr_115, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpNodePathInterval_set_end_hpr_115_comment},
  { "setStartQuat",(PyCFunction ) &Dtool_CLerpNodePathInterval_set_start_quat_116, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpNodePathInterval_set_start_quat_116_comment},
  { "setEndQuat",(PyCFunction ) &Dtool_CLerpNodePathInterval_set_end_quat_117, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpNodePathInterval_set_end_quat_117_comment},
  { "setStartScale",(PyCFunction ) &Dtool_CLerpNodePathInterval_set_start_scale_118, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpNodePathInterval_set_start_scale_118_comment},
  { "setEndScale",(PyCFunction ) &Dtool_CLerpNodePathInterval_set_end_scale_119, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpNodePathInterval_set_end_scale_119_comment},
  { "setStartShear",(PyCFunction ) &Dtool_CLerpNodePathInterval_set_start_shear_120, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpNodePathInterval_set_start_shear_120_comment},
  { "setEndShear",(PyCFunction ) &Dtool_CLerpNodePathInterval_set_end_shear_121, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpNodePathInterval_set_end_shear_121_comment},
  { "setStartColor",(PyCFunction ) &Dtool_CLerpNodePathInterval_set_start_color_122, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpNodePathInterval_set_start_color_122_comment},
  { "setEndColor",(PyCFunction ) &Dtool_CLerpNodePathInterval_set_end_color_123, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpNodePathInterval_set_end_color_123_comment},
  { "setStartColorScale",(PyCFunction ) &Dtool_CLerpNodePathInterval_set_start_color_scale_124, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpNodePathInterval_set_start_color_scale_124_comment},
  { "setEndColorScale",(PyCFunction ) &Dtool_CLerpNodePathInterval_set_end_color_scale_125, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpNodePathInterval_set_end_color_scale_125_comment},
  { "setTextureStage",(PyCFunction ) &Dtool_CLerpNodePathInterval_set_texture_stage_126, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpNodePathInterval_set_texture_stage_126_comment},
  { "setStartTexOffset",(PyCFunction ) &Dtool_CLerpNodePathInterval_set_start_tex_offset_127, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpNodePathInterval_set_start_tex_offset_127_comment},
  { "setEndTexOffset",(PyCFunction ) &Dtool_CLerpNodePathInterval_set_end_tex_offset_128, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpNodePathInterval_set_end_tex_offset_128_comment},
  { "setStartTexRotate",(PyCFunction ) &Dtool_CLerpNodePathInterval_set_start_tex_rotate_129, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpNodePathInterval_set_start_tex_rotate_129_comment},
  { "setEndTexRotate",(PyCFunction ) &Dtool_CLerpNodePathInterval_set_end_tex_rotate_130, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpNodePathInterval_set_end_tex_rotate_130_comment},
  { "setStartTexScale",(PyCFunction ) &Dtool_CLerpNodePathInterval_set_start_tex_scale_131, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpNodePathInterval_set_start_tex_scale_131_comment},
  { "setEndTexScale",(PyCFunction ) &Dtool_CLerpNodePathInterval_set_end_tex_scale_132, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpNodePathInterval_set_end_tex_scale_132_comment},
  { "setOverride",(PyCFunction ) &Dtool_CLerpNodePathInterval_set_override_133, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpNodePathInterval_set_override_133_comment},
  { "getOverride",(PyCFunction ) &Dtool_CLerpNodePathInterval_get_override_134, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpNodePathInterval_get_override_134_comment},
  { "getClassType",(PyCFunction ) &Dtool_CLerpNodePathInterval_get_class_type_135, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CLerpNodePathInterval_get_class_type_135_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CLerpNodePathInterval(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_CLerpNodePathInterval.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : CLerpNodePathInterval\n"
          "// Description : An interval that lerps one or more properties (like\n"
          "//               pos, hpr, etc.) on a NodePath over time.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CLerpInterval._Dtool_ClassInit(NULL);
        Dtool_CLerpNodePathInterval.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CLerpInterval.As_PyTypeObject());
        Dtool_CLerpNodePathInterval.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CLerpNodePathInterval.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CLerpNodePathInterval.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_CLerpNodePathInterval.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CLerpNodePathInterval)");
             printf(" Error In PyType_ReadyCLerpNodePathInterval");
             return;
        }
        Py_INCREF(&Dtool_CLerpNodePathInterval.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CLerpNodePathInterval.As_PyTypeObject().tp_dict,"CLerpNodePathInterval",&Dtool_CLerpNodePathInterval.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CLerpNodePathInterval.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CLerpNodePathInterval[25],&Dtool_CLerpNodePathInterval.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CLerpNodePathInterval,CLerpNodePathInterval::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CLerpNodePathInterval.As_PyTypeObject());
        PyModule_AddObject(module, "CLerpNodePathInterval",(PyObject *)&Dtool_CLerpNodePathInterval.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. CMetaInterval | CMetaInterval
//********************************************************************
PyMethodDef Dtool_Methods_CMetaInterval[]= {
  { "setPrecision",(PyCFunction ) &Dtool_CMetaInterval_set_precision_140, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMetaInterval_set_precision_140_comment},
  { "getPrecision",(PyCFunction ) &Dtool_CMetaInterval_get_precision_141, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMetaInterval_get_precision_141_comment},
  { "clearIntervals",(PyCFunction ) &Dtool_CMetaInterval_clear_intervals_142, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMetaInterval_clear_intervals_142_comment},
  { "pushLevel",(PyCFunction ) &Dtool_CMetaInterval_push_level_143, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMetaInterval_push_level_143_comment},
  { "addCInterval",(PyCFunction ) &Dtool_CMetaInterval_add_c_interval_144, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMetaInterval_add_c_interval_144_comment},
  { "addExtIndex",(PyCFunction ) &Dtool_CMetaInterval_add_ext_index_145, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMetaInterval_add_ext_index_145_comment},
  { "popLevel",(PyCFunction ) &Dtool_CMetaInterval_pop_level_146, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMetaInterval_pop_level_146_comment},
  { "setIntervalStartTime",(PyCFunction ) &Dtool_CMetaInterval_set_interval_start_time_147, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMetaInterval_set_interval_start_time_147_comment},
  { "getIntervalStartTime",(PyCFunction ) &Dtool_CMetaInterval_get_interval_start_time_148, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMetaInterval_get_interval_start_time_148_comment},
  { "getIntervalEndTime",(PyCFunction ) &Dtool_CMetaInterval_get_interval_end_time_149, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMetaInterval_get_interval_end_time_149_comment},
  { "getNumDefs",(PyCFunction ) &Dtool_CMetaInterval_get_num_defs_151, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMetaInterval_get_num_defs_151_comment},
  { "getDefType",(PyCFunction ) &Dtool_CMetaInterval_get_def_type_152, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMetaInterval_get_def_type_152_comment},
  { "getCInterval",(PyCFunction ) &Dtool_CMetaInterval_get_c_interval_153, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMetaInterval_get_c_interval_153_comment},
  { "getExtIndex",(PyCFunction ) &Dtool_CMetaInterval_get_ext_index_154, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMetaInterval_get_ext_index_154_comment},
  { "isEventReady",(PyCFunction ) &Dtool_CMetaInterval_is_event_ready_155, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMetaInterval_is_event_ready_155_comment},
  { "getEventIndex",(PyCFunction ) &Dtool_CMetaInterval_get_event_index_156, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMetaInterval_get_event_index_156_comment},
  { "getEventT",(PyCFunction ) &Dtool_CMetaInterval_get_event_t_157, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMetaInterval_get_event_t_157_comment},
  { "getEventType",(PyCFunction ) &Dtool_CMetaInterval_get_event_type_158, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMetaInterval_get_event_type_158_comment},
  { "popEvent",(PyCFunction ) &Dtool_CMetaInterval_pop_event_159, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMetaInterval_pop_event_159_comment},
  { "timeline",(PyCFunction ) &Dtool_CMetaInterval_timeline_160, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMetaInterval_timeline_160_comment},
  { "getClassType",(PyCFunction ) &Dtool_CMetaInterval_get_class_type_161, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_CMetaInterval_get_class_type_161_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_CMetaInterval(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_CInterval._Dtool_ClassInit(NULL);
        Dtool_CMetaInterval.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CInterval.As_PyTypeObject());
        Dtool_CMetaInterval.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_CMetaInterval.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_CMetaInterval.As_PyTypeObject().tp_dict);
        // Enum  CMetaInterval::RelativeStart;
        PyDict_SetItemString(Dtool_CMetaInterval.As_PyTypeObject().tp_dict,"RSPreviousEnd",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_CMetaInterval.As_PyTypeObject().tp_dict,"RSPreviousBegin",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_CMetaInterval.As_PyTypeObject().tp_dict,"RSLevelBegin",PyInt_FromLong(2));
        // Enum  CMetaInterval::DefType;
        PyDict_SetItemString(Dtool_CMetaInterval.As_PyTypeObject().tp_dict,"DTCInterval",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_CMetaInterval.As_PyTypeObject().tp_dict,"DTExtIndex",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_CMetaInterval.As_PyTypeObject().tp_dict,"DTPushLevel",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_CMetaInterval.As_PyTypeObject().tp_dict,"DTPopLevel",PyInt_FromLong(3));
        if(PyType_Ready(&Dtool_CMetaInterval.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(CMetaInterval)");
             printf(" Error In PyType_ReadyCMetaInterval");
             return;
        }
        Py_INCREF(&Dtool_CMetaInterval.As_PyTypeObject());
        PyDict_SetItemString(Dtool_CMetaInterval.As_PyTypeObject().tp_dict,"CMetaInterval",&Dtool_CMetaInterval.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_CMetaInterval.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_CMetaInterval[20],&Dtool_CMetaInterval.As_PyObject()));
        RegisterRuntimeClass(&Dtool_CMetaInterval,CMetaInterval::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_CMetaInterval.As_PyTypeObject());
        PyModule_AddObject(module, "CMetaInterval",(PyObject *)&Dtool_CMetaInterval.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. HideInterval | HideInterval
//********************************************************************
PyMethodDef Dtool_Methods_HideInterval[]= {
  { "getClassType",(PyCFunction ) &Dtool_HideInterval_get_class_type_164, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_HideInterval_get_class_type_164_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_HideInterval(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_HideInterval.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : HideInterval\n"
          "// Description : An interval that calls NodePath::hide().\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CInterval._Dtool_ClassInit(NULL);
        Dtool_HideInterval.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CInterval.As_PyTypeObject());
        Dtool_HideInterval.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_HideInterval.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_HideInterval.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_HideInterval.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(HideInterval)");
             printf(" Error In PyType_ReadyHideInterval");
             return;
        }
        Py_INCREF(&Dtool_HideInterval.As_PyTypeObject());
        PyDict_SetItemString(Dtool_HideInterval.As_PyTypeObject().tp_dict,"HideInterval",&Dtool_HideInterval.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_HideInterval.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_HideInterval[0],&Dtool_HideInterval.As_PyObject()));
        RegisterRuntimeClass(&Dtool_HideInterval,HideInterval::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_HideInterval.As_PyTypeObject());
        PyModule_AddObject(module, "HideInterval",(PyObject *)&Dtool_HideInterval.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. ShowInterval | ShowInterval
//********************************************************************
PyMethodDef Dtool_Methods_ShowInterval[]= {
  { "getClassType",(PyCFunction ) &Dtool_ShowInterval_get_class_type_168, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_ShowInterval_get_class_type_168_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_ShowInterval(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_ShowInterval.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : ShowInterval\n"
          "// Description : An interval that calls NodePath::show().\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CInterval._Dtool_ClassInit(NULL);
        Dtool_ShowInterval.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CInterval.As_PyTypeObject());
        Dtool_ShowInterval.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_ShowInterval.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_ShowInterval.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_ShowInterval.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(ShowInterval)");
             printf(" Error In PyType_ReadyShowInterval");
             return;
        }
        Py_INCREF(&Dtool_ShowInterval.As_PyTypeObject());
        PyDict_SetItemString(Dtool_ShowInterval.As_PyTypeObject().tp_dict,"ShowInterval",&Dtool_ShowInterval.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_ShowInterval.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_ShowInterval[0],&Dtool_ShowInterval.As_PyObject()));
        RegisterRuntimeClass(&Dtool_ShowInterval,ShowInterval::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_ShowInterval.As_PyTypeObject());
        PyModule_AddObject(module, "ShowInterval",(PyObject *)&Dtool_ShowInterval.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. WaitInterval | WaitInterval
//********************************************************************
PyMethodDef Dtool_Methods_WaitInterval[]= {
  { "getClassType",(PyCFunction ) &Dtool_WaitInterval_get_class_type_172, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_WaitInterval_get_class_type_172_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_WaitInterval(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_WaitInterval.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : WaitInterval\n"
          "// Description : This interval does absolutely nothing, and is mainly\n"
          "//               useful for marking time between other intervals\n"
          "//               within a sequence.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_CInterval._Dtool_ClassInit(NULL);
        Dtool_WaitInterval.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_CInterval.As_PyTypeObject());
        Dtool_WaitInterval.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_WaitInterval.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_WaitInterval.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_WaitInterval.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(WaitInterval)");
             printf(" Error In PyType_ReadyWaitInterval");
             return;
        }
        Py_INCREF(&Dtool_WaitInterval.As_PyTypeObject());
        PyDict_SetItemString(Dtool_WaitInterval.As_PyTypeObject().tp_dict,"WaitInterval",&Dtool_WaitInterval.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_WaitInterval.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_WaitInterval[0],&Dtool_WaitInterval.As_PyObject()));
        RegisterRuntimeClass(&Dtool_WaitInterval,WaitInterval::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_WaitInterval.As_PyTypeObject());
        PyModule_AddObject(module, "WaitInterval",(PyObject *)&Dtool_WaitInterval.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..CInterval
//********************************************************************
   Dtool_PyModuleClassInit_CInterval(module);
//********************************************************************
//*** Module Init Updcall ..CConstraintInterval
//********************************************************************
   Dtool_PyModuleClassInit_CConstraintInterval(module);
//********************************************************************
//*** Module Init Updcall ..CConstrainHprInterval
//********************************************************************
   Dtool_PyModuleClassInit_CConstrainHprInterval(module);
//********************************************************************
//*** Module Init Updcall ..CConstrainPosHprInterval
//********************************************************************
   Dtool_PyModuleClassInit_CConstrainPosHprInterval(module);
//********************************************************************
//*** Module Init Updcall ..CConstrainPosInterval
//********************************************************************
   Dtool_PyModuleClassInit_CConstrainPosInterval(module);
//********************************************************************
//*** Module Init Updcall ..CConstrainTransformInterval
//********************************************************************
   Dtool_PyModuleClassInit_CConstrainTransformInterval(module);
//********************************************************************
//*** Module Init Updcall ..CIntervalManager
//********************************************************************
   Dtool_PyModuleClassInit_CIntervalManager(module);
//********************************************************************
//*** Module Init Updcall ..CLerpInterval
//********************************************************************
   Dtool_PyModuleClassInit_CLerpInterval(module);
//********************************************************************
//*** Module Init Updcall ..CLerpAnimEffectInterval
//********************************************************************
   Dtool_PyModuleClassInit_CLerpAnimEffectInterval(module);
//********************************************************************
//*** Module Init Updcall ..CLerpNodePathInterval
//********************************************************************
   Dtool_PyModuleClassInit_CLerpNodePathInterval(module);
//********************************************************************
//*** Module Init Updcall ..CMetaInterval
//********************************************************************
   Dtool_PyModuleClassInit_CMetaInterval(module);
//********************************************************************
//*** Module Init Updcall ..HideInterval
//********************************************************************
   Dtool_PyModuleClassInit_HideInterval(module);
//********************************************************************
//*** Module Init Updcall ..ShowInterval
//********************************************************************
   Dtool_PyModuleClassInit_ShowInterval(module);
//********************************************************************
//*** Module Init Updcall ..WaitInterval
//********************************************************************
   Dtool_PyModuleClassInit_WaitInterval(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libinterval_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687213764,  /* file_identifier */
  "libinterval",  /* library_name */
  "SpsC",  /* library_hash_name */
  "p3direct",  /* module_name */
  "libinterval.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  399  /* next_index */
};

Configure(_in_configure_libinterval);
ConfigureFn(_in_configure_libinterval) {
  interrogate_request_module(&_in_module_def);
}

