/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir toontown/dna -Itoontown/dna -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libdna_igate.cxx -od built_Rocket/pandac/input/libdna.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Itoontown/dna -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_TOONTOWN -module toontown -library libdna config_dna.h dnaAnimBuilding.h dnaAnimProp.h dnaBattleCell.h dnaBuildings.h dnaConstants.h dnaCornice.h dnaData.h dnaDoor.h dnaGroup.h dnaInteractiveProp.h dnaLoader.h dnaLoader_composite1.cxx dnaLoader_composite2.cxx dnaNode.h dnaProp.h dnaSign.h dnaSignBaseline.h dnaSignGraphic.h dnaSignText.h dnaStorage.h dnaStreet.h dnaSuitEdge.h dnaSuitPath.h dnaSuitPoint.h dnaVisGroup.h dnaWindow.h lexerDefs.h load_dna_file.h loaderFileTypeDNA.h parserDefs.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libdna
#include "py_panda.h"  

#include "configVariableList.h"
#include "configVariableSearchPath.h"
#include "config_dna.h"
#include "coordinateSystem.h"
#include "dSearchPath.h"
#include "dconfig.h"
#include "dnaAnimBuilding.h"
#include "dnaAnimProp.h"
#include "dnaBattleCell.h"
#include "dnaBuildings.h"
#include "dnaConstants.h"
#include "dnaCornice.h"
#include "dnaData.h"
#include "dnaDoor.h"
#include "dnaGroup.h"
#include "dnaInteractiveProp.h"
#include "dnaLoader.h"
#include "dnaNode.h"
#include "dnaProp.h"
#include "dnaSign.h"
#include "dnaSignBaseline.h"
#include "dnaSignGraphic.h"
#include "dnaSignText.h"
#include "dnaStorage.h"
#include "dnaStreet.h"
#include "dnaSuitEdge.h"
#include "dnaSuitPath.h"
#include "dnaSuitPoint.h"
#include "dnaVisGroup.h"
#include "dnaWindow.h"
#include "filename.h"
#include "lexerDefs.h"
#include "load_dna_file.h"
#include "loaderFileTypeDNA.h"
#include "luse.h"
#include "nodePath.h"
#include "notifyCategoryProxy.h"
#include "pandaNode.h"
#include "parserDefs.h"
#include "pnotify.h"
#include "pvector.h"
#include <string>
#include "toontownbase.h"
#include "typedReferenceCount.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. DNAGroup
//********************************************************************
typedef  DNAGroup  DNAGroup_localtype;
Define_Module_ClassRef(toontown,DNAGroup,DNAGroup_localtype,DNAGroup);
//********************************************************************
//*** prototypes for .. DNASuitPoint
//********************************************************************
typedef  DNASuitPoint  DNASuitPoint_localtype;
Define_Module_ClassRef(toontown,DNASuitPoint,DNASuitPoint_localtype,DNASuitPoint);
//********************************************************************
//*** prototypes for .. DNASuitEdge
//********************************************************************
typedef  DNASuitEdge  DNASuitEdge_localtype;
Define_Module_ClassRef(toontown,DNASuitEdge,DNASuitEdge_localtype,DNASuitEdge);
//********************************************************************
//*** prototypes for .. DNABattleCell
//********************************************************************
typedef  DNABattleCell  DNABattleCell_localtype;
Define_Module_ClassRef(toontown,DNABattleCell,DNABattleCell_localtype,DNABattleCell);
//********************************************************************
//*** prototypes for .. DNAVisGroup
//********************************************************************
typedef  DNAVisGroup  DNAVisGroup_localtype;
Define_Module_ClassRef(toontown,DNAVisGroup,DNAVisGroup_localtype,DNAVisGroup);
//********************************************************************
//*** prototypes for .. DNASuitPath
//********************************************************************
typedef  DNASuitPath  DNASuitPath_localtype;
Define_Module_ClassRef(toontown,DNASuitPath,DNASuitPath_localtype,DNASuitPath);
//********************************************************************
//*** prototypes for .. PosHpr
//********************************************************************
typedef  PosHpr  PosHpr_localtype;
Define_Module_Class(toontown,PosHpr,PosHpr_localtype,PosHpr);
//********************************************************************
//*** prototypes for .. DNAStorage
//********************************************************************
typedef  DNAStorage  DNAStorage_localtype;
Define_Module_Class(toontown,DNAStorage,DNAStorage_localtype,DNAStorage);
//********************************************************************
//*** prototypes for .. DNANode
//********************************************************************
typedef  DNANode  DNANode_localtype;
Define_Module_ClassRef(toontown,DNANode,DNANode_localtype,DNANode);
//********************************************************************
//*** prototypes for .. DNAWall
//********************************************************************
typedef  DNAWall  DNAWall_localtype;
Define_Module_ClassRef(toontown,DNAWall,DNAWall_localtype,DNAWall);
//********************************************************************
//*** prototypes for .. DNAFlatBuilding
//********************************************************************
typedef  DNAFlatBuilding  DNAFlatBuilding_localtype;
Define_Module_ClassRef(toontown,DNAFlatBuilding,DNAFlatBuilding_localtype,DNAFlatBuilding);
//********************************************************************
//*** prototypes for .. DNALandmarkBuilding
//********************************************************************
typedef  DNALandmarkBuilding  DNALandmarkBuilding_localtype;
Define_Module_ClassRef(toontown,DNALandmarkBuilding,DNALandmarkBuilding_localtype,DNALandmarkBuilding);
//********************************************************************
//*** prototypes for .. DNAAnimBuilding
//********************************************************************
typedef  DNAAnimBuilding  DNAAnimBuilding_localtype;
Define_Module_ClassRef(toontown,DNAAnimBuilding,DNAAnimBuilding_localtype,DNAAnimBuilding);
//********************************************************************
//*** prototypes for .. DNAProp
//********************************************************************
typedef  DNAProp  DNAProp_localtype;
Define_Module_ClassRef(toontown,DNAProp,DNAProp_localtype,DNAProp);
//********************************************************************
//*** prototypes for .. DNAAnimProp
//********************************************************************
typedef  DNAAnimProp  DNAAnimProp_localtype;
Define_Module_ClassRef(toontown,DNAAnimProp,DNAAnimProp_localtype,DNAAnimProp);
//********************************************************************
//*** prototypes for .. DNACornice
//********************************************************************
typedef  DNACornice  DNACornice_localtype;
Define_Module_ClassRef(toontown,DNACornice,DNACornice_localtype,DNACornice);
//********************************************************************
//*** prototypes for .. DNAData
//********************************************************************
typedef  DNAData  DNAData_localtype;
Define_Module_ClassRef(toontown,DNAData,DNAData_localtype,DNAData);
//********************************************************************
//*** prototypes for .. DNADoor
//********************************************************************
typedef  DNADoor  DNADoor_localtype;
Define_Module_ClassRef(toontown,DNADoor,DNADoor_localtype,DNADoor);
//********************************************************************
//*** prototypes for .. DNAFlatDoor
//********************************************************************
typedef  DNAFlatDoor  DNAFlatDoor_localtype;
Define_Module_ClassRef(toontown,DNAFlatDoor,DNAFlatDoor_localtype,DNAFlatDoor);
//********************************************************************
//*** prototypes for .. DNAInteractiveProp
//********************************************************************
typedef  DNAInteractiveProp  DNAInteractiveProp_localtype;
Define_Module_ClassRef(toontown,DNAInteractiveProp,DNAInteractiveProp_localtype,DNAInteractiveProp);
//********************************************************************
//*** prototypes for .. DNALoader
//********************************************************************
typedef  DNALoader  DNALoader_localtype;
Define_Module_Class(toontown,DNALoader,DNALoader_localtype,DNALoader);
//********************************************************************
//*** prototypes for .. DNAWindows
//********************************************************************
typedef  DNAWindows  DNAWindows_localtype;
Define_Module_ClassRef(toontown,DNAWindows,DNAWindows_localtype,DNAWindows);
//********************************************************************
//*** prototypes for .. DNAStreet
//********************************************************************
typedef  DNAStreet  DNAStreet_localtype;
Define_Module_ClassRef(toontown,DNAStreet,DNAStreet_localtype,DNAStreet);
//********************************************************************
//*** prototypes for .. DNASign
//********************************************************************
typedef  DNASign  DNASign_localtype;
Define_Module_ClassRef(toontown,DNASign,DNASign_localtype,DNASign);
//********************************************************************
//*** prototypes for .. DNASignBaseline
//********************************************************************
typedef  DNASignBaseline  DNASignBaseline_localtype;
Define_Module_ClassRef(toontown,DNASignBaseline,DNASignBaseline_localtype,DNASignBaseline);
//********************************************************************
//*** prototypes for .. DNASignGraphic
//********************************************************************
typedef  DNASignGraphic  DNASignGraphic_localtype;
Define_Module_ClassRef(toontown,DNASignGraphic,DNASignGraphic_localtype,DNASignGraphic);
//********************************************************************
//*** prototypes for .. DNASignText
//********************************************************************
typedef  DNASignText  DNASignText_localtype;
Define_Module_ClassRef(toontown,DNASignText,DNASignText_localtype,DNASignText);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ConfigVariableSearchPath;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_DSearchPath;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Filename;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LMatrix4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LPoint3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVector3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVector4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Namable;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_NodePath;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PandaNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PointerTo_DNAData;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PointerTo_PandaNode;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TextFont;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Texture;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_istream;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * ConfigVariableSearchPath const &get_dna_path(void)
 *******************************************************************/
static PyObject *Dtool_get_dna_path_1(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-ConfigVariableSearchPath const &get_dna_path(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getDnaPath", key_word_list))
        {
            ConfigVariableSearchPath const *return_value = &(get_dna_path());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_ConfigVariableSearchPath,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDnaPath()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_get_dna_path_1_comment =
    "C++ Interface:\n"
    "getDnaPath()\n"
    "\n"
    "";
#else
static const char * Dtool_get_dna_path_1_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< PandaNode > load_DNA_file(DNAStorage *dna_store, basic_string< char > const &filename, CoordinateSystem cs, int editing)
 * PointerTo< PandaNode > load_DNA_file(DNAStorage *dna_store, basic_string< char > const &filename, CoordinateSystem cs, int editing = (0))
 * PointerTo< PandaNode > load_DNA_file(DNAStorage *dna_store, basic_string< char > const &filename, CoordinateSystem cs = (CS_default), int editing = (0))
 *******************************************************************/
static PyObject *Dtool_load_DNA_file_393(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-PointerTo< PandaNode > load_DNA_file(DNAStorage *dna_store, basic_string< char > const &filename, CoordinateSystem cs = (CS_default), int editing = (0))
                PyObject *param0;
                char *param1_str; int param1_len;
                static char * key_word_list[] = {(char *)"dna_store", (char *)"filename", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:loadDNAFile", key_word_list, &param0, &param1_str, &param1_len))
                {
                    DNAStorage *param0_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNAStorage, 0, "loadDNAFile", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PointerTo< PandaNode > return_value = load_DNA_file(param0_this, basic_string<char>(param1_str, param1_len));
                        if (return_value != (PandaNode *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_PandaNode,true, false, (return_value.p())->as_typed_object()->get_type_index());
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-PointerTo< PandaNode > load_DNA_file(DNAStorage *dna_store, basic_string< char > const &filename, CoordinateSystem cs, int editing = (0))
                PyObject *param0;
                char *param1_str; int param1_len;
                int param2;
                static char * key_word_list[] = {(char *)"dna_store", (char *)"filename", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#i:loadDNAFile", key_word_list, &param0, &param1_str, &param1_len, &param2))
                {
                    DNAStorage *param0_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNAStorage, 0, "loadDNAFile", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PointerTo< PandaNode > return_value = load_DNA_file(param0_this, basic_string<char>(param1_str, param1_len), (CoordinateSystem)param2);
                        if (return_value != (PandaNode *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_PandaNode,true, false, (return_value.p())->as_typed_object()->get_type_index());
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-PointerTo< PandaNode > load_DNA_file(DNAStorage *dna_store, basic_string< char > const &filename, CoordinateSystem cs, int editing)
                PyObject *param0;
                char *param1_str; int param1_len;
                int param2;
                int param3;
                static char * key_word_list[] = {(char *)"dna_store", (char *)"filename", (char *)"cs", (char *)"editing", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#ii:loadDNAFile", key_word_list, &param0, &param1_str, &param1_len, &param2, &param3))
                {
                    DNAStorage *param0_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNAStorage, 0, "loadDNAFile", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PointerTo< PandaNode > return_value = load_DNA_file(param0_this, basic_string<char>(param1_str, param1_len), (CoordinateSystem)param2, (int)param3);
                        if (return_value != (PandaNode *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_PandaNode,true, false, (return_value.p())->as_typed_object()->get_type_index());
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "loadDNAFile() takes 2, 3, or 4 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "loadDNAFile(non-const DNAStorage dna_store, string filename)\n"
          "loadDNAFile(non-const DNAStorage dna_store, string filename, int cs)\n"
          "loadDNAFile(non-const DNAStorage dna_store, string filename, int cs, int editing)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_load_DNA_file_393_comment =
    "C++ Interface:\n"
    "loadDNAFile(non-const DNAStorage dna_store, string filename)\n"
    "loadDNAFile(non-const DNAStorage dna_store, string filename, int cs)\n"
    "loadDNAFile(non-const DNAStorage dna_store, string filename, int cs, int editing)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: load_dna_file\n"
    "//  Description: A convenience function; the primary interface to this\n"
    "//               package.  Loads up the indicated dna file, and\n"
    "//               returns the root of a scene graph.  Returns NULL if\n"
    "//               the file cannot be read for some reason.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: load_dna_file\n"
    "//  Description: A convenience function.  Loads up the indicated dna\n"
    "//               file, and returns the root of a scene graph.  Returns\n"
    "//               NULL if the file cannot be read for some reason.\n"
    "//\n"
    "//               Unlike load_egg_file(), this function *does* search\n"
    "//               for the file along the model_path (as well as the\n"
    "//               dna_path) if it is not already fully qualified.\n"
    "//               Begin the filename with ./ to prevent this behavior.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_load_DNA_file_393_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< DNAData > load_DNA_file_AI(DNAStorage *dna_store, basic_string< char > const &filename, CoordinateSystem cs)
 * PointerTo< DNAData > load_DNA_file_AI(DNAStorage *dna_store, basic_string< char > const &filename, CoordinateSystem cs = (CS_default))
 *******************************************************************/
static PyObject *Dtool_load_DNA_file_AI_394(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-PointerTo< DNAData > load_DNA_file_AI(DNAStorage *dna_store, basic_string< char > const &filename, CoordinateSystem cs = (CS_default))
                PyObject *param0;
                char *param1_str; int param1_len;
                static char * key_word_list[] = {(char *)"dna_store", (char *)"filename", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:loadDNAFileAI", key_word_list, &param0, &param1_str, &param1_len))
                {
                    DNAStorage *param0_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNAStorage, 0, "loadDNAFileAI", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PointerTo< DNAData > return_value = load_DNA_file_AI(param0_this, basic_string<char>(param1_str, param1_len));
                        if (return_value != (DNAData *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_DNAData,true, false, (return_value.p())->as_typed_object()->get_type_index());
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-PointerTo< DNAData > load_DNA_file_AI(DNAStorage *dna_store, basic_string< char > const &filename, CoordinateSystem cs)
                PyObject *param0;
                char *param1_str; int param1_len;
                int param2;
                static char * key_word_list[] = {(char *)"dna_store", (char *)"filename", (char *)"cs", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#i:loadDNAFileAI", key_word_list, &param0, &param1_str, &param1_len, &param2))
                {
                    DNAStorage *param0_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNAStorage, 0, "loadDNAFileAI", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PointerTo< DNAData > return_value = load_DNA_file_AI(param0_this, basic_string<char>(param1_str, param1_len), (CoordinateSystem)param2);
                        if (return_value != (DNAData *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_DNAData,true, false, (return_value.p())->as_typed_object()->get_type_index());
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "loadDNAFileAI() takes 2 or 3 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "loadDNAFileAI(non-const DNAStorage dna_store, string filename)\n"
          "loadDNAFileAI(non-const DNAStorage dna_store, string filename, int cs)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_load_DNA_file_AI_394_comment =
    "C++ Interface:\n"
    "loadDNAFileAI(non-const DNAStorage dna_store, string filename)\n"
    "loadDNAFileAI(non-const DNAStorage dna_store, string filename, int cs)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: load_dna_file_ai\n"
    "//  Description: Loads up the indicated dna file but does not create\n"
    "//               any geometry from it. It simply creates the dna\n"
    "//               structures that can then be accessed via the dnaStorage\n"
    "//               Returns the DNAData object on success, or NULL if the\n"
    "//               file cannot be read for some reason.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: load_dna_file_AI\n"
    "//  Description: Loads up the indicated dna file but does not create\n"
    "//               geometry.  Returns the DNAData loaded, or NULL.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_load_DNA_file_AI_394_comment = NULL;
#endif

//********************************************************************
//*** Functions for .. DNAGroup 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * virtual NodePath DNAGroup::traverse(NodePath &parent, DNAStorage *store, int editing)
 * virtual NodePath DNAGroup::traverse(NodePath &parent, DNAStorage *store, int editing = (0))
 *******************************************************************/
static PyObject *Dtool_DNAGroup_traverse_10(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-virtual NodePath DNAGroup::traverse(NodePath &parent, DNAStorage *store, int editing = (0))
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"parent", (char *)"store", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:traverse", key_word_list, &param1, &param2))
                {
                    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "DNAGroup.traverse", 0, coerced_ptr, report_errors);
DNAStorage *param2_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DNAStorage, 2, "DNAGroup.traverse", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        NodePath result = (local_this)->traverse(*param1_this, param2_this);
                        NodePath *return_value = new NodePath(result);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call DNAGroup.traverse() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-virtual NodePath DNAGroup::traverse(NodePath &parent, DNAStorage *store, int editing)
                PyObject *param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"parent", (char *)"store", (char *)"editing", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:traverse", key_word_list, &param1, &param2, &param3))
                {
                    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "DNAGroup.traverse", 0, coerced_ptr, report_errors);
DNAStorage *param2_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DNAStorage, 2, "DNAGroup.traverse", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        NodePath result = (local_this)->traverse(*param1_this, param2_this, (int)param3);
                        NodePath *return_value = new NodePath(result);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call DNAGroup.traverse() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "traverse() takes 3 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "traverse(non-const DNAGroup this, non-const NodePath parent, non-const DNAStorage store)\n"
          "traverse(non-const DNAGroup this, non-const NodePath parent, non-const DNAStorage store, int editing)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAGroup_traverse_10_comment =
    "C++ Interface:\n"
    "traverse(non-const DNAGroup this, non-const NodePath parent, non-const DNAStorage store)\n"
    "traverse(non-const DNAGroup this, non-const NodePath parent, non-const DNAStorage store, int editing)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAGroup::traverse\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAGroup_traverse_10_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NodePath DNAGroup::top_level_traverse(NodePath &parent, DNAStorage *store, int editing)
 * NodePath DNAGroup::top_level_traverse(NodePath &parent, DNAStorage *store, int editing = (0))
 *******************************************************************/
static PyObject *Dtool_DNAGroup_top_level_traverse_11(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-NodePath DNAGroup::top_level_traverse(NodePath &parent, DNAStorage *store, int editing = (0))
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"parent", (char *)"store", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:topLevelTraverse", key_word_list, &param1, &param2))
                {
                    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "DNAGroup.topLevelTraverse", 0, coerced_ptr, report_errors);
DNAStorage *param2_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DNAStorage, 2, "DNAGroup.topLevelTraverse", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        NodePath result = (local_this)->top_level_traverse(*param1_this, param2_this);
                        NodePath *return_value = new NodePath(result);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call DNAGroup.topLevelTraverse() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-NodePath DNAGroup::top_level_traverse(NodePath &parent, DNAStorage *store, int editing)
                PyObject *param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"parent", (char *)"store", (char *)"editing", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:topLevelTraverse", key_word_list, &param1, &param2, &param3))
                {
                    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "DNAGroup.topLevelTraverse", 0, coerced_ptr, report_errors);
DNAStorage *param2_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DNAStorage, 2, "DNAGroup.topLevelTraverse", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        NodePath result = (local_this)->top_level_traverse(*param1_this, param2_this, (int)param3);
                        NodePath *return_value = new NodePath(result);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call DNAGroup.topLevelTraverse() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "topLevelTraverse() takes 3 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "topLevelTraverse(non-const DNAGroup this, non-const NodePath parent, non-const DNAStorage store)\n"
          "topLevelTraverse(non-const DNAGroup this, non-const NodePath parent, non-const DNAStorage store, int editing)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAGroup_top_level_traverse_11_comment =
    "C++ Interface:\n"
    "topLevelTraverse(non-const DNAGroup this, non-const NodePath parent, non-const DNAStorage store)\n"
    "topLevelTraverse(non-const DNAGroup this, non-const NodePath parent, non-const DNAStorage store, int editing)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAGroup::top_level_traverse\n"
    "//       Access: Public\n"
    "//  Description: The top level traverse does some special things\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAGroup_top_level_traverse_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAGroup::add(PointerTo< DNAGroup > group)
 *******************************************************************/
static PyObject *Dtool_DNAGroup_add_12(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DNAGroup::add(PointerTo< DNAGroup > group)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"group", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:add", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:add", &param1));
            if(!PyErr_Occurred())
            {
                DNAGroup *param1_this = (DNAGroup *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNAGroup, 1, "DNAGroup.add", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAGroup.add() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "add(non-const DNAGroup this, const DNAGroup group)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAGroup_add_12_comment =
    "C++ Interface:\n"
    "add(non-const DNAGroup this, const DNAGroup group)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAGroup::add\n"
    "//       Access: Public\n"
    "//  Description: add a DNAGroup to this vector of nodes\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAGroup_add_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAGroup::remove(PointerTo< DNAGroup > group)
 *******************************************************************/
static PyObject *Dtool_DNAGroup_remove_13(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DNAGroup::remove(PointerTo< DNAGroup > group)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"group", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:remove", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:remove", &param1));
            if(!PyErr_Occurred())
            {
                DNAGroup *param1_this = (DNAGroup *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNAGroup, 1, "DNAGroup.remove", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->remove(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAGroup.remove() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "remove(non-const DNAGroup this, const DNAGroup group)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAGroup_remove_13_comment =
    "C++ Interface:\n"
    "remove(non-const DNAGroup this, const DNAGroup group)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAGroup::remove\n"
    "//       Access: Public\n"
    "//  Description: Remove a group from this vector. Note, this is\n"
    "//               not really meant for heavy use, since we are using\n"
    "//               an STL vector which erases in linear time.\n"
    "//               Should be ok, since removal will be rare.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAGroup_remove_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PointerTo< DNAGroup > DNAGroup::at(unsigned int index)
 *******************************************************************/
static PyObject *Dtool_DNAGroup_at_14(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline PointerTo< DNAGroup > DNAGroup::at(unsigned int index)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:at", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:at", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                PointerTo< DNAGroup > return_value = (local_this)->at(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (return_value != (DNAGroup *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value.p() == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_DNAGroup,true, false, (return_value.p())->as_typed_object()->get_type_index());
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAGroup.at() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "at(non-const DNAGroup this, unsigned int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAGroup_at_14_comment =
    "C++ Interface:\n"
    "at(non-const DNAGroup this, unsigned int index)\n"
    "\n"
    "// Filename: dnaGroup.I\n"
    "// Created by:  shochet (24May00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAGroup::at\n"
    "//       Access: Public\n"
    "//  Description: Return the nth group in the vector\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAGroup_at_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PointerTo< DNAGroup > DNAGroup::current(void)
 *******************************************************************/
static PyObject *Dtool_DNAGroup_current_15(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline PointerTo< DNAGroup > DNAGroup::current(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":current", key_word_list));
        else
            (PyArg_Parse(args, ":current"));
        if(!PyErr_Occurred())
        {
            PointerTo< DNAGroup > return_value = (local_this)->current();
            if (return_value != (DNAGroup *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_DNAGroup,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAGroup.current() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "current(non-const DNAGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAGroup_current_15_comment =
    "C++ Interface:\n"
    "current(non-const DNAGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAGroup::current\n"
    "//       Access: Public\n"
    "//  Description: return the current group\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAGroup_current_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DNAGroup::get_num_children(void)
 *******************************************************************/
static PyObject *Dtool_DNAGroup_get_num_children_16(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int DNAGroup::get_num_children(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumChildren", key_word_list));
        else
            (PyArg_Parse(args, ":getNumChildren"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_num_children();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAGroup.getNumChildren() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumChildren(non-const DNAGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAGroup_get_num_children_16_comment =
    "C++ Interface:\n"
    "getNumChildren(non-const DNAGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAGroup::get_num_children\n"
    "//       Access: Public\n"
    "//  Description: how many groups do we have under us?\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAGroup_get_num_children_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PointerTo< DNAGroup > DNAGroup::get_parent(void) const
 *******************************************************************/
static PyObject *Dtool_DNAGroup_get_parent_17(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PointerTo< DNAGroup > DNAGroup::get_parent(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getParent", key_word_list));
        else
            (PyArg_Parse(args, ":getParent"));
        if(!PyErr_Occurred())
        {
            PointerTo< DNAGroup > return_value = ((const DNAGroup*)local_this)->get_parent();
            if (return_value != (DNAGroup *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_DNAGroup,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParent(const DNAGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAGroup_get_parent_17_comment =
    "C++ Interface:\n"
    "getParent(const DNAGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAGroup::get_parent\n"
    "//       Access: Public\n"
    "//  Description: Return the parent group\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAGroup_get_parent_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void DNAGroup::write(ostream &out, DNAStorage *store, int indent_level) const
 * virtual void DNAGroup::write(ostream &out, DNAStorage *store, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_DNAGroup_write_18(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void DNAGroup::write(ostream &out, DNAStorage *store, int indent_level = (0)) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"store", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DNAGroup.write", 0, coerced_ptr, report_errors);
DNAStorage *param2_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DNAStorage, 2, "DNAGroup.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        ((const DNAGroup*)local_this)->write(*param1_this, param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void DNAGroup::write(ostream &out, DNAStorage *store, int indent_level) const
                PyObject *param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"out", (char *)"store", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:write", key_word_list, &param1, &param2, &param3))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DNAGroup.write", 0, coerced_ptr, report_errors);
DNAStorage *param2_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DNAStorage, 2, "DNAGroup.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        ((const DNAGroup*)local_this)->write(*param1_this, param2_this, (int)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 3 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const DNAGroup this, non-const Ostream out, non-const DNAStorage store)\n"
          "write(const DNAGroup this, non-const Ostream out, non-const DNAStorage store, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAGroup_write_18_comment =
    "C++ Interface:\n"
    "write(const DNAGroup this, non-const Ostream out, non-const DNAStorage store)\n"
    "write(const DNAGroup this, non-const Ostream out, non-const DNAStorage store, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAGroup::write\n"
    "//       Access: Public\n"
    "//  Description: Writes the group and all children to output\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAGroup_write_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAGroup::ls(void) const
 *******************************************************************/
static PyObject *Dtool_DNAGroup_ls_19(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-void DNAGroup::ls(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":ls", key_word_list));
        else
            (PyArg_Parse(args, ":ls"));
        if(!PyErr_Occurred())
        {
            ((const DNAGroup*)local_this)->ls();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "ls(const DNAGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAGroup_ls_19_comment =
    "C++ Interface:\n"
    "ls(const DNAGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAGroup::ls\n"
    "//       Access: Public\n"
    "//  Description: Writes the group and all children to cout (for debugging)\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAGroup_ls_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNAGroup::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNAGroup_get_class_type_20(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DNAGroup::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DNAGroup::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAGroup_get_class_type_20_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DNAGroup_get_class_type_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * TypedReferenceCount *DNAGroup::upcast_to_TypedReferenceCount(void)
 *******************************************************************/
static PyObject *Dtool_DNAGroup_upcast_to_TypedReferenceCount_4(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-TypedReferenceCount *DNAGroup::upcast_to_TypedReferenceCount(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToTypedReferenceCount", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToTypedReferenceCount"));
        if(!PyErr_Occurred())
        {
            TypedReferenceCount *return_value = (TypedReferenceCount *)local_this;
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TypedReferenceCount,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAGroup.upcastToTypedReferenceCount() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToTypedReferenceCount(non-const DNAGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAGroup_upcast_to_TypedReferenceCount_4_comment =
    "C++ Interface:\n"
    "upcastToTypedReferenceCount(non-const DNAGroup this)\n"
    "\n"
    "upcast from DNAGroup to TypedReferenceCount\n"
    "";
#else
static const char * Dtool_DNAGroup_upcast_to_TypedReferenceCount_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Namable *DNAGroup::upcast_to_Namable(void)
 *******************************************************************/
static PyObject *Dtool_DNAGroup_upcast_to_Namable_7(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-Namable *DNAGroup::upcast_to_Namable(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":upcastToNamable", key_word_list));
        else
            (PyArg_Parse(args, ":upcastToNamable"));
        if(!PyErr_Occurred())
        {
            Namable *return_value = (Namable *)local_this;
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Namable,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAGroup.upcastToNamable() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "upcastToNamable(non-const DNAGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAGroup_upcast_to_Namable_7_comment =
    "C++ Interface:\n"
    "upcastToNamable(non-const DNAGroup this)\n"
    "\n"
    "upcast from DNAGroup to Namable\n"
    "";
#else
static const char * Dtool_DNAGroup_upcast_to_Namable_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAGroup::DNAGroup(DNAGroup const &group)
 * DNAGroup::DNAGroup(basic_string< char > const &initial_name)
 * DNAGroup::DNAGroup(basic_string< char > const &initial_name = (""))
 *******************************************************************/
int  Dtool_Init_DNAGroup(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-DNAGroup::DNAGroup(basic_string< char > const &initial_name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":DNAGroup", key_word_list))
            {
                DNAGroup *return_value = new DNAGroup();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAGroup,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 DNAGroup::DNAGroup(DNAGroup const &group)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"group", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DNAGroup", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DNAGroup", &param0));
                if(!PyErr_Occurred())
                {
                    DNAGroup *param0_this = (DNAGroup *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNAGroup, 0, "DNAGroup.DNAGroup", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        DNAGroup *return_value = new DNAGroup(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAGroup,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 DNAGroup::DNAGroup(basic_string< char > const &initial_name)
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"initial_name", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNAGroup", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:DNAGroup", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    DNAGroup *return_value = new DNAGroup(basic_string<char>(param0_str, param0_len));
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAGroup,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "DNAGroup() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "DNAGroup()\n"
          "DNAGroup(const DNAGroup group)\n"
          "DNAGroup(string initial_name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNAGroup(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNAGroup)
    {
        printf("DNAGroup ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNAGroup * local_this = (DNAGroup *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNAGroup)
        return local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNAGroup(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNAGroup)
        return from_this;
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (DNAGroup*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (DNAGroup*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DNAGroup*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (DNAGroup*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNASuitPoint 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DNASuitPoint::set_index(int index)
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_set_index_25(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitPoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitPoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNASuitPoint::set_index(int index)
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setIndex", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setIndex", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_index((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASuitPoint.setIndex() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setIndex(non-const DNASuitPoint this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitPoint_set_index_25_comment =
    "C++ Interface:\n"
    "setIndex(non-const DNASuitPoint this, int index)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitPoint_set_index_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DNASuitPoint::get_index(void) const
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_get_index_26(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitPoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitPoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DNASuitPoint::get_index(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getIndex", key_word_list));
        else
            (PyArg_Parse(args, ":getIndex"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DNASuitPoint*)local_this)->get_index();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIndex(const DNASuitPoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitPoint_get_index_26_comment =
    "C++ Interface:\n"
    "getIndex(const DNASuitPoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitPoint_get_index_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASuitPoint::set_point_type(DNASuitPoint::DNASuitPointType type)
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_set_point_type_27(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitPoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitPoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNASuitPoint::set_point_type(DNASuitPoint::DNASuitPointType type)
        int param1;
        static char * key_word_list[] = {(char *)"type", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setPointType", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setPointType", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_point_type((DNASuitPoint::DNASuitPointType)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASuitPoint.setPointType() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPointType(non-const DNASuitPoint this, int type)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitPoint_set_point_type_27_comment =
    "C++ Interface:\n"
    "setPointType(non-const DNASuitPoint this, int type)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitPoint_set_point_type_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DNASuitPoint::DNASuitPointType DNASuitPoint::get_point_type(void) const
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_get_point_type_28(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitPoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitPoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline DNASuitPoint::DNASuitPointType DNASuitPoint::get_point_type(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPointType", key_word_list));
        else
            (PyArg_Parse(args, ":getPointType"));
        if(!PyErr_Occurred())
        {
            DNASuitPoint::DNASuitPointType return_value = ((const DNASuitPoint*)local_this)->get_point_type();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPointType(const DNASuitPoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitPoint_get_point_type_28_comment =
    "C++ Interface:\n"
    "getPointType(const DNASuitPoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitPoint_get_point_type_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASuitPoint::set_pos(LPoint3f pos)
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_set_pos_29(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitPoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitPoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DNASuitPoint::set_pos(LPoint3f pos)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"pos", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setPos", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setPos", &param1));
            if(!PyErr_Occurred())
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "DNASuitPoint.setPos", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_pos(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNASuitPoint.setPos() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPos(non-const DNASuitPoint this, const Point3 pos)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitPoint_set_pos_29_comment =
    "C++ Interface:\n"
    "setPos(non-const DNASuitPoint this, const Point3 pos)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitPoint_set_pos_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f DNASuitPoint::get_pos(void) const
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_get_pos_30(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitPoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitPoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f DNASuitPoint::get_pos(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPos", key_word_list));
        else
            (PyArg_Parse(args, ":getPos"));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const DNASuitPoint*)local_this)->get_pos();
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPos(const DNASuitPoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitPoint_get_pos_30_comment =
    "C++ Interface:\n"
    "getPos(const DNASuitPoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitPoint_get_pos_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASuitPoint::set_graph_id(int graph_id)
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_set_graph_id_31(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitPoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitPoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNASuitPoint::set_graph_id(int graph_id)
        int param1;
        static char * key_word_list[] = {(char *)"graph_id", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setGraphId", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setGraphId", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_graph_id((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASuitPoint.setGraphId() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setGraphId(non-const DNASuitPoint this, int graph_id)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitPoint_set_graph_id_31_comment =
    "C++ Interface:\n"
    "setGraphId(non-const DNASuitPoint this, int graph_id)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitPoint_set_graph_id_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DNASuitPoint::get_graph_id(void) const
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_get_graph_id_32(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitPoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitPoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DNASuitPoint::get_graph_id(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getGraphId", key_word_list));
        else
            (PyArg_Parse(args, ":getGraphId"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DNASuitPoint*)local_this)->get_graph_id();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGraphId(const DNASuitPoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitPoint_get_graph_id_32_comment =
    "C++ Interface:\n"
    "getGraphId(const DNASuitPoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitPoint_get_graph_id_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASuitPoint::set_landmark_building_index(int lb_index)
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_set_landmark_building_index_33(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitPoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitPoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNASuitPoint::set_landmark_building_index(int lb_index)
        int param1;
        static char * key_word_list[] = {(char *)"lb_index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setLandmarkBuildingIndex", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setLandmarkBuildingIndex", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_landmark_building_index((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASuitPoint.setLandmarkBuildingIndex() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setLandmarkBuildingIndex(non-const DNASuitPoint this, int lb_index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitPoint_set_landmark_building_index_33_comment =
    "C++ Interface:\n"
    "setLandmarkBuildingIndex(non-const DNASuitPoint this, int lb_index)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitPoint_set_landmark_building_index_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DNASuitPoint::get_landmark_building_index(void) const
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_get_landmark_building_index_34(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitPoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitPoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DNASuitPoint::get_landmark_building_index(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLandmarkBuildingIndex", key_word_list));
        else
            (PyArg_Parse(args, ":getLandmarkBuildingIndex"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DNASuitPoint*)local_this)->get_landmark_building_index();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLandmarkBuildingIndex(const DNASuitPoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitPoint_get_landmark_building_index_34_comment =
    "C++ Interface:\n"
    "getLandmarkBuildingIndex(const DNASuitPoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitPoint_get_landmark_building_index_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool DNASuitPoint::is_terminal(void) const
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_is_terminal_35(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitPoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitPoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool DNASuitPoint::is_terminal(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isTerminal", key_word_list));
        else
            (PyArg_Parse(args, ":isTerminal"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const DNASuitPoint*)local_this)->is_terminal();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isTerminal(const DNASuitPoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitPoint_is_terminal_35_comment =
    "C++ Interface:\n"
    "isTerminal(const DNASuitPoint this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNASuitPoint::is_terminal\n"
    "//       Access: Published\n"
    "//  Description: Returns true if this point is the sort of point you\n"
    "//               find at the beginning or end of a suit path (like a\n"
    "//               FRONT_DOOR_POINT or SIDE_DOOR_POINT), or false if it\n"
    "//               is something you're more likely to find in the middle\n"
    "//               of a suit path (like a STREET_POINT).\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNASuitPoint_is_terminal_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNASuitPoint::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_output_36(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitPoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitPoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void DNASuitPoint::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DNASuitPoint.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const DNASuitPoint*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const DNASuitPoint this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitPoint_output_36_comment =
    "C++ Interface:\n"
    "output(const DNASuitPoint this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNASuitPoint::output\n"
    "//       Access: Public\n"
    "//  Description: Output all the properties to the stream\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNASuitPoint_output_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void DNASuitPoint::write(ostream &out, int indent_level) const
 * virtual void DNASuitPoint::write(ostream &out, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_write_37(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitPoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitPoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void DNASuitPoint::write(ostream &out, int indent_level = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DNASuitPoint.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const DNASuitPoint*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void DNASuitPoint::write(ostream &out, int indent_level) const
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DNASuitPoint.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const DNASuitPoint*)local_this)->write(*param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const DNASuitPoint this, non-const Ostream out)\n"
          "write(const DNASuitPoint this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitPoint_write_37_comment =
    "C++ Interface:\n"
    "write(const DNASuitPoint this, non-const Ostream out)\n"
    "write(const DNASuitPoint this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNASuitPoint::write\n"
    "//       Access: Public\n"
    "//  Description: write the suit point back out to the dna\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNASuitPoint_write_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNASuitPoint::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNASuitPoint_get_class_type_38(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DNASuitPoint::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DNASuitPoint::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitPoint_get_class_type_38_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitPoint_get_class_type_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNASuitPoint::DNASuitPoint(int index, DNASuitPoint::DNASuitPointType type, LPoint3f pos, int lb_index)
 * DNASuitPoint::DNASuitPoint(int index, DNASuitPoint::DNASuitPointType type, LPoint3f pos, int lb_index = (-1))
 *******************************************************************/
int  Dtool_Init_DNASuitPoint(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-DNASuitPoint::DNASuitPoint(int index, DNASuitPoint::DNASuitPointType type, LPoint3f pos, int lb_index = (-1))
                int param0;
                int param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"index", (char *)"type", (char *)"pos", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iiO:DNASuitPoint", key_word_list, &param0, &param1, &param2))
                {
                    LPoint3f *param2_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint3f, 2, "DNASuitPoint.DNASuitPoint", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        DNASuitPoint *return_value = new DNASuitPoint((int)param0, (DNASuitPoint::DNASuitPointType)param1, *param2_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DNASuitPoint,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-DNASuitPoint::DNASuitPoint(int index, DNASuitPoint::DNASuitPointType type, LPoint3f pos, int lb_index)
                int param0;
                int param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"index", (char *)"type", (char *)"pos", (char *)"lb_index", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iiOi:DNASuitPoint", key_word_list, &param0, &param1, &param2, &param3))
                {
                    LPoint3f *param2_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint3f, 2, "DNASuitPoint.DNASuitPoint", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        DNASuitPoint *return_value = new DNASuitPoint((int)param0, (DNASuitPoint::DNASuitPointType)param1, *param2_this, (int)param3);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DNASuitPoint,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "DNASuitPoint() takes 3 or 4 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "DNASuitPoint(int index, int type, const Point3 pos)\n"
          "DNASuitPoint(int index, int type, const Point3 pos, int lb_index)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNASuitPoint(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNASuitPoint)
    {
        printf("DNASuitPoint ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNASuitPoint * local_this = (DNASuitPoint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNASuitPoint)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNASuitPoint(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNASuitPoint)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (DNASuitPoint*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DNASuitPoint*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (DNASuitPoint*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNASuitEdge 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline bool DNASuitEdge::operator ==(DNASuitEdge const &other) const
 *******************************************************************/
static PyObject *Dtool_DNASuitEdge_operator_42(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitEdge * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitEdge,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool DNASuitEdge::operator ==(DNASuitEdge const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:eq", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:eq", &param1));
            if(!PyErr_Occurred())
            {
                DNASuitEdge *param1_this = (DNASuitEdge *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNASuitEdge, 1, "DNASuitEdge.eq", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const DNASuitEdge*)local_this)->operator ==(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "eq(const DNASuitEdge this, const DNASuitEdge other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitEdge_operator_42_comment =
    "C++ Interface:\n"
    "eq(const DNASuitEdge this, const DNASuitEdge other)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitEdge_operator_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PointerTo< DNASuitPoint > DNASuitEdge::get_start_point(void) const
 *******************************************************************/
static PyObject *Dtool_DNASuitEdge_get_start_point_43(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitEdge * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitEdge,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PointerTo< DNASuitPoint > DNASuitEdge::get_start_point(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStartPoint", key_word_list));
        else
            (PyArg_Parse(args, ":getStartPoint"));
        if(!PyErr_Occurred())
        {
            PointerTo< DNASuitPoint > return_value = ((const DNASuitEdge*)local_this)->get_start_point();
            if (return_value != (DNASuitPoint *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_DNASuitPoint,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStartPoint(const DNASuitEdge this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitEdge_get_start_point_43_comment =
    "C++ Interface:\n"
    "getStartPoint(const DNASuitEdge this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitEdge_get_start_point_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PointerTo< DNASuitPoint > DNASuitEdge::get_end_point(void) const
 *******************************************************************/
static PyObject *Dtool_DNASuitEdge_get_end_point_44(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitEdge * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitEdge,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PointerTo< DNASuitPoint > DNASuitEdge::get_end_point(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getEndPoint", key_word_list));
        else
            (PyArg_Parse(args, ":getEndPoint"));
        if(!PyErr_Occurred())
        {
            PointerTo< DNASuitPoint > return_value = ((const DNASuitEdge*)local_this)->get_end_point();
            if (return_value != (DNASuitPoint *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_DNASuitPoint,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getEndPoint(const DNASuitEdge this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitEdge_get_end_point_44_comment =
    "C++ Interface:\n"
    "getEndPoint(const DNASuitEdge this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitEdge_get_end_point_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNASuitEdge::get_zone_id(void) const
 *******************************************************************/
static PyObject *Dtool_DNASuitEdge_get_zone_id_45(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitEdge * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitEdge,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > DNASuitEdge::get_zone_id(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getZoneId", key_word_list));
        else
            (PyArg_Parse(args, ":getZoneId"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DNASuitEdge*)local_this)->get_zone_id();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getZoneId(const DNASuitEdge this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitEdge_get_zone_id_45_comment =
    "C++ Interface:\n"
    "getZoneId(const DNASuitEdge this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitEdge_get_zone_id_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASuitEdge::set_zone_id(basic_string< char > zone_id)
 *******************************************************************/
static PyObject *Dtool_DNASuitEdge_set_zone_id_46(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitEdge * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitEdge,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNASuitEdge::set_zone_id(basic_string< char > zone_id)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"zone_id", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setZoneId", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setZoneId", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_zone_id(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASuitEdge.setZoneId() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setZoneId(non-const DNASuitEdge this, string zone_id)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitEdge_set_zone_id_46_comment =
    "C++ Interface:\n"
    "setZoneId(non-const DNASuitEdge this, string zone_id)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitEdge_set_zone_id_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNASuitEdge::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_DNASuitEdge_output_47(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitEdge * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitEdge,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void DNASuitEdge::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DNASuitEdge.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const DNASuitEdge*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const DNASuitEdge this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitEdge_output_47_comment =
    "C++ Interface:\n"
    "output(const DNASuitEdge this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNASuitEdge::output\n"
    "//       Access: Public\n"
    "//  Description: Outputs all the properties to ostream\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNASuitEdge_output_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void DNASuitEdge::write(ostream &out, DNAStorage *store, int indent_level) const
 * virtual void DNASuitEdge::write(ostream &out, DNAStorage *store, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_DNASuitEdge_write_48(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitEdge * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitEdge,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void DNASuitEdge::write(ostream &out, DNAStorage *store, int indent_level = (0)) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"store", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DNASuitEdge.write", 0, coerced_ptr, report_errors);
DNAStorage *param2_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DNAStorage, 2, "DNASuitEdge.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        ((const DNASuitEdge*)local_this)->write(*param1_this, param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void DNASuitEdge::write(ostream &out, DNAStorage *store, int indent_level) const
                PyObject *param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"out", (char *)"store", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:write", key_word_list, &param1, &param2, &param3))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DNASuitEdge.write", 0, coerced_ptr, report_errors);
DNAStorage *param2_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DNAStorage, 2, "DNASuitEdge.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        ((const DNASuitEdge*)local_this)->write(*param1_this, param2_this, (int)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 3 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const DNASuitEdge this, non-const Ostream out, non-const DNAStorage store)\n"
          "write(const DNASuitEdge this, non-const Ostream out, non-const DNAStorage store, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitEdge_write_48_comment =
    "C++ Interface:\n"
    "write(const DNASuitEdge this, non-const Ostream out, non-const DNAStorage store)\n"
    "write(const DNASuitEdge this, non-const Ostream out, non-const DNAStorage store, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNASuitEdge::write\n"
    "//       Access: Public\n"
    "//  Description: Writes the edge and properties\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNASuitEdge_write_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNASuitEdge::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNASuitEdge_get_class_type_49(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DNASuitEdge::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DNASuitEdge::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitEdge_get_class_type_49_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitEdge_get_class_type_49_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNASuitEdge::DNASuitEdge(PointerTo< DNASuitPoint > start_point, PointerTo< DNASuitPoint > end_point, basic_string< char > zone_id)
 *******************************************************************/
int  Dtool_Init_DNASuitEdge(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-DNASuitEdge::DNASuitEdge(PointerTo< DNASuitPoint > start_point, PointerTo< DNASuitPoint > end_point, basic_string< char > zone_id)
            PyObject *param0;
            PyObject *param1;
            char *param2_str; int param2_len;
            static char * key_word_list[] = {(char *)"start_point", (char *)"end_point", (char *)"zone_id", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOs#:DNASuitEdge", key_word_list, &param0, &param1, &param2_str, &param2_len))
            {
                DNASuitPoint *param0_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNASuitPoint, 0, "DNASuitEdge.DNASuitEdge", 1, coerced_ptr, report_errors);
DNASuitPoint *param1_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNASuitPoint, 1, "DNASuitEdge.DNASuitEdge", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)|| (param1_this == NULL)))
                {
                    DNASuitEdge *return_value = new DNASuitEdge(param0_this, param1_this, basic_string<char>(param2_str, param2_len));
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_DNASuitEdge,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DNASuitEdge(const DNASuitPoint start_point, const DNASuitPoint end_point, string zone_id)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNASuitEdge(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNASuitEdge)
    {
        printf("DNASuitEdge ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNASuitEdge * local_this = (DNASuitEdge *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNASuitEdge)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNASuitEdge(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNASuitEdge)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (DNASuitEdge*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DNASuitEdge*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (DNASuitEdge*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNABattleCell 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DNABattleCell::set_width_height(float width, float height)
 *******************************************************************/
static PyObject *Dtool_DNABattleCell_set_width_height_53(PyObject *self, PyObject *args,PyObject *kwds) {
    DNABattleCell * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNABattleCell,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNABattleCell::set_width_height(float width, float height)
        double param1;
        double param2;
        static char * key_word_list[] = {(char *)"width", (char *)"height", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:setWidthHeight", key_word_list, &param1, &param2))
        {
            (local_this)->set_width_height((float)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNABattleCell.setWidthHeight() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWidthHeight(non-const DNABattleCell this, float width, float height)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNABattleCell_set_width_height_53_comment =
    "C++ Interface:\n"
    "setWidthHeight(non-const DNABattleCell this, float width, float height)\n"
    "\n"
    "// Filename: dnaBattleCell.I\n"
    "// Created by:\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNABattleCell_set_width_height_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DNABattleCell::get_width(void) const
 *******************************************************************/
static PyObject *Dtool_DNABattleCell_get_width_54(PyObject *self, PyObject *args,PyObject *kwds) {
    DNABattleCell * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNABattleCell,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DNABattleCell::get_width(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWidth", key_word_list));
        else
            (PyArg_Parse(args, ":getWidth"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DNABattleCell*)local_this)->get_width();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWidth(const DNABattleCell this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNABattleCell_get_width_54_comment =
    "C++ Interface:\n"
    "getWidth(const DNABattleCell this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNABattleCell::get_width\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNABattleCell_get_width_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DNABattleCell::get_height(void) const
 *******************************************************************/
static PyObject *Dtool_DNABattleCell_get_height_55(PyObject *self, PyObject *args,PyObject *kwds) {
    DNABattleCell * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNABattleCell,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DNABattleCell::get_height(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHeight", key_word_list));
        else
            (PyArg_Parse(args, ":getHeight"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DNABattleCell*)local_this)->get_height();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHeight(const DNABattleCell this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNABattleCell_get_height_55_comment =
    "C++ Interface:\n"
    "getHeight(const DNABattleCell this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNABattleCell::get_height\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNABattleCell_get_height_55_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNABattleCell::set_pos(LPoint3f pos)
 *******************************************************************/
static PyObject *Dtool_DNABattleCell_set_pos_56(PyObject *self, PyObject *args,PyObject *kwds) {
    DNABattleCell * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNABattleCell,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DNABattleCell::set_pos(LPoint3f pos)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"pos", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setPos", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setPos", &param1));
            if(!PyErr_Occurred())
            {
                LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "DNABattleCell.setPos", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_pos(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNABattleCell.setPos() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPos(non-const DNABattleCell this, const Point3 pos)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNABattleCell_set_pos_56_comment =
    "C++ Interface:\n"
    "setPos(non-const DNABattleCell this, const Point3 pos)\n"
    "\n"
    "";
#else
static const char * Dtool_DNABattleCell_set_pos_56_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f DNABattleCell::get_pos(void) const
 *******************************************************************/
static PyObject *Dtool_DNABattleCell_get_pos_57(PyObject *self, PyObject *args,PyObject *kwds) {
    DNABattleCell * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNABattleCell,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f DNABattleCell::get_pos(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPos", key_word_list));
        else
            (PyArg_Parse(args, ":getPos"));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const DNABattleCell*)local_this)->get_pos();
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPos(const DNABattleCell this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNABattleCell_get_pos_57_comment =
    "C++ Interface:\n"
    "getPos(const DNABattleCell this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNABattleCell_get_pos_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNABattleCell::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_DNABattleCell_output_58(PyObject *self, PyObject *args,PyObject *kwds) {
    DNABattleCell * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNABattleCell,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void DNABattleCell::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DNABattleCell.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const DNABattleCell*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const DNABattleCell this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNABattleCell_output_58_comment =
    "C++ Interface:\n"
    "output(const DNABattleCell this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNABattleCell::output\n"
    "//       Access: Public\n"
    "//  Description: Writes the cell properties to output\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNABattleCell_output_58_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual NodePath DNABattleCell::traverse(NodePath &parent, DNAStorage *store, int editing)
 * virtual NodePath DNABattleCell::traverse(NodePath &parent, DNAStorage *store, int editing = (0))
 *******************************************************************/
static PyObject *Dtool_DNABattleCell_traverse_59(PyObject *self, PyObject *args,PyObject *kwds) {
    DNABattleCell * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNABattleCell,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-virtual NodePath DNABattleCell::traverse(NodePath &parent, DNAStorage *store, int editing = (0))
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"parent", (char *)"store", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:traverse", key_word_list, &param1, &param2))
                {
                    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "DNABattleCell.traverse", 0, coerced_ptr, report_errors);
DNAStorage *param2_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DNAStorage, 2, "DNABattleCell.traverse", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        NodePath result = (local_this)->traverse(*param1_this, param2_this);
                        NodePath *return_value = new NodePath(result);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call DNABattleCell.traverse() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-virtual NodePath DNABattleCell::traverse(NodePath &parent, DNAStorage *store, int editing)
                PyObject *param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"parent", (char *)"store", (char *)"editing", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:traverse", key_word_list, &param1, &param2, &param3))
                {
                    NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "DNABattleCell.traverse", 0, coerced_ptr, report_errors);
DNAStorage *param2_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DNAStorage, 2, "DNABattleCell.traverse", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        NodePath result = (local_this)->traverse(*param1_this, param2_this, (int)param3);
                        NodePath *return_value = new NodePath(result);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call DNABattleCell.traverse() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "traverse() takes 3 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "traverse(non-const DNABattleCell this, non-const NodePath parent, non-const DNAStorage store)\n"
          "traverse(non-const DNABattleCell this, non-const NodePath parent, non-const DNAStorage store, int editing)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNABattleCell_traverse_59_comment =
    "C++ Interface:\n"
    "traverse(non-const DNABattleCell this, non-const NodePath parent, non-const DNAStorage store)\n"
    "traverse(non-const DNABattleCell this, non-const NodePath parent, non-const DNAStorage store, int editing)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNABattleCell::traverse\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNABattleCell_traverse_59_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void DNABattleCell::write(ostream &out, DNAStorage *store, int indent_level) const
 * virtual void DNABattleCell::write(ostream &out, DNAStorage *store, int indent_level = (0)) const
 *******************************************************************/
static PyObject *Dtool_DNABattleCell_write_60(PyObject *self, PyObject *args,PyObject *kwds) {
    DNABattleCell * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNABattleCell,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void DNABattleCell::write(ostream &out, DNAStorage *store, int indent_level = (0)) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"store", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DNABattleCell.write", 0, coerced_ptr, report_errors);
DNAStorage *param2_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DNAStorage, 2, "DNABattleCell.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        ((const DNABattleCell*)local_this)->write(*param1_this, param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void DNABattleCell::write(ostream &out, DNAStorage *store, int indent_level) const
                PyObject *param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"out", (char *)"store", (char *)"indent_level", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:write", key_word_list, &param1, &param2, &param3))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DNABattleCell.write", 0, coerced_ptr, report_errors);
DNAStorage *param2_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DNAStorage, 2, "DNABattleCell.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        ((const DNABattleCell*)local_this)->write(*param1_this, param2_this, (int)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 3 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const DNABattleCell this, non-const Ostream out, non-const DNAStorage store)\n"
          "write(const DNABattleCell this, non-const Ostream out, non-const DNAStorage store, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNABattleCell_write_60_comment =
    "C++ Interface:\n"
    "write(const DNABattleCell this, non-const Ostream out, non-const DNAStorage store)\n"
    "write(const DNABattleCell this, non-const Ostream out, non-const DNAStorage store, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNABattleCell::write\n"
    "//       Access: Public\n"
    "//  Description: Writes the group and all children to output\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNABattleCell_write_60_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNABattleCell::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNABattleCell_get_class_type_61(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DNABattleCell::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DNABattleCell::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNABattleCell_get_class_type_61_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DNABattleCell_get_class_type_61_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNABattleCell::DNABattleCell(float width, float height, LPoint3f pos)
 *******************************************************************/
int  Dtool_Init_DNABattleCell(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-DNABattleCell::DNABattleCell(float width, float height, LPoint3f pos)
            double param0;
            double param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"width", (char *)"height", (char *)"pos", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddO:DNABattleCell", key_word_list, &param0, &param1, &param2))
            {
                LPoint3f *param2_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint3f, 2, "DNABattleCell.DNABattleCell", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    DNABattleCell *return_value = new DNABattleCell((float)param0, (float)param1, *param2_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_DNABattleCell,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DNABattleCell(float width, float height, const Point3 pos)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNABattleCell(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNABattleCell)
    {
        printf("DNABattleCell ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNABattleCell * local_this = (DNABattleCell *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNABattleCell)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNABattleCell(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNABattleCell)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (DNABattleCell*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DNABattleCell*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (DNABattleCell*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNAVisGroup 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void DNAVisGroup::add_visible(basic_string< char > const &vis_group_name)
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_add_visible_65(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAVisGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAVisGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNAVisGroup::add_visible(basic_string< char > const &vis_group_name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"vis_group_name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:addVisible", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:addVisible", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->add_visible(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAVisGroup.addVisible() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addVisible(non-const DNAVisGroup this, string vis_group_name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAVisGroup_add_visible_65_comment =
    "C++ Interface:\n"
    "addVisible(non-const DNAVisGroup this, string vis_group_name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAVisGroup::add_visible\n"
    "//       Access: Public\n"
    "//  Description: Add a vis group name to this group's list\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAVisGroup_add_visible_65_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DNAVisGroup::remove_visible(basic_string< char > const &vis_group_name)
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_remove_visible_66(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAVisGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAVisGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DNAVisGroup::remove_visible(basic_string< char > const &vis_group_name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"vis_group_name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:removeVisible", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:removeVisible", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->remove_visible(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAVisGroup.removeVisible() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeVisible(non-const DNAVisGroup this, string vis_group_name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAVisGroup_remove_visible_66_comment =
    "C++ Interface:\n"
    "removeVisible(non-const DNAVisGroup this, string vis_group_name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAVisGroup::remove_vis_group\n"
    "//       Access: Public\n"
    "//  Description: Remove a vis group name to this group's list\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAVisGroup_remove_visible_66_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DNAVisGroup::get_num_visibles(void) const
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_get_num_visibles_67(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAVisGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAVisGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DNAVisGroup::get_num_visibles(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumVisibles", key_word_list));
        else
            (PyArg_Parse(args, ":getNumVisibles"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DNAVisGroup*)local_this)->get_num_visibles();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumVisibles(const DNAVisGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAVisGroup_get_num_visibles_67_comment =
    "C++ Interface:\n"
    "getNumVisibles(const DNAVisGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAVisGroup::get_num_visibles\n"
    "//       Access: Public\n"
    "//  Description: Ask how many visibles this vis group has\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAVisGroup_get_num_visibles_67_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DNAVisGroup::get_visible_name(unsigned int i) const
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_get_visible_name_68(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAVisGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAVisGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > DNAVisGroup::get_visible_name(unsigned int i) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"i", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getVisibleName", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getVisibleName", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                basic_string< char > return_value = ((const DNAVisGroup*)local_this)->get_visible_name(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVisibleName(const DNAVisGroup this, unsigned int i)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAVisGroup_get_visible_name_68_comment =
    "C++ Interface:\n"
    "getVisibleName(const DNAVisGroup this, unsigned int i)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAVisGroup::get_visible_name\n"
    "//       Access: Public\n"
    "//  Description: Return the string name of the ith visible\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAVisGroup_get_visible_name_68_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAVisGroup::add_suit_edge(PointerTo< DNASuitEdge > edge)
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_add_suit_edge_69(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAVisGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAVisGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DNAVisGroup::add_suit_edge(PointerTo< DNASuitEdge > edge)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"edge", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addSuitEdge", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addSuitEdge", &param1));
            if(!PyErr_Occurred())
            {
                DNASuitEdge *param1_this = (DNASuitEdge *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNASuitEdge, 1, "DNAVisGroup.addSuitEdge", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_suit_edge(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAVisGroup.addSuitEdge() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addSuitEdge(non-const DNAVisGroup this, const DNASuitEdge edge)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAVisGroup_add_suit_edge_69_comment =
    "C++ Interface:\n"
    "addSuitEdge(non-const DNAVisGroup this, const DNASuitEdge edge)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAVisGroup::add_suit_edge\n"
    "//       Access: Public\n"
    "//  Description: Adds a suit edge to this vis group\n"
    "//               This is only stored here so we can write it back out\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAVisGroup_add_suit_edge_69_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DNAVisGroup::remove_suit_edge(PointerTo< DNASuitEdge > edge)
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_remove_suit_edge_70(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAVisGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAVisGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int DNAVisGroup::remove_suit_edge(PointerTo< DNASuitEdge > edge)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"edge", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeSuitEdge", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeSuitEdge", &param1));
            if(!PyErr_Occurred())
            {
                DNASuitEdge *param1_this = (DNASuitEdge *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNASuitEdge, 1, "DNAVisGroup.removeSuitEdge", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = (local_this)->remove_suit_edge(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAVisGroup.removeSuitEdge() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeSuitEdge(non-const DNAVisGroup this, const DNASuitEdge edge)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAVisGroup_remove_suit_edge_70_comment =
    "C++ Interface:\n"
    "removeSuitEdge(non-const DNAVisGroup this, const DNASuitEdge edge)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAVisGroup::remove_suit_edge\n"
    "//       Access: Public\n"
    "//  Description: Remove this suit edge\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAVisGroup_remove_suit_edge_70_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DNAVisGroup::get_num_suit_edges(void) const
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_get_num_suit_edges_71(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAVisGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAVisGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DNAVisGroup::get_num_suit_edges(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumSuitEdges", key_word_list));
        else
            (PyArg_Parse(args, ":getNumSuitEdges"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DNAVisGroup*)local_this)->get_num_suit_edges();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumSuitEdges(const DNAVisGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAVisGroup_get_num_suit_edges_71_comment =
    "C++ Interface:\n"
    "getNumSuitEdges(const DNAVisGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAVisGroup::get_num_suit_edges\n"
    "//       Access: Public\n"
    "//  Description: Ask how many edges this vis group has\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAVisGroup_get_num_suit_edges_71_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< DNASuitEdge > DNAVisGroup::get_suit_edge(unsigned int i) const
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_get_suit_edge_72(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAVisGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAVisGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PointerTo< DNASuitEdge > DNAVisGroup::get_suit_edge(unsigned int i) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"i", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getSuitEdge", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getSuitEdge", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                PointerTo< DNASuitEdge > return_value = ((const DNAVisGroup*)local_this)->get_suit_edge(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (return_value != (DNASuitEdge *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value.p() == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_DNASuitEdge,true, false, (return_value.p())->as_typed_object()->get_type_index());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSuitEdge(const DNAVisGroup this, unsigned int i)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAVisGroup_get_suit_edge_72_comment =
    "C++ Interface:\n"
    "getSuitEdge(const DNAVisGroup this, unsigned int i)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAVisGroup::get_suit_edge\n"
    "//       Access: Public\n"
    "//  Description: Return the ith edge in the vector\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAVisGroup_get_suit_edge_72_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAVisGroup::add_battle_cell(PointerTo< DNABattleCell > cell)
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_add_battle_cell_73(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAVisGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAVisGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DNAVisGroup::add_battle_cell(PointerTo< DNABattleCell > cell)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"cell", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addBattleCell", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addBattleCell", &param1));
            if(!PyErr_Occurred())
            {
                DNABattleCell *param1_this = (DNABattleCell *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNABattleCell, 1, "DNAVisGroup.addBattleCell", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_battle_cell(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAVisGroup.addBattleCell() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addBattleCell(non-const DNAVisGroup this, const DNABattleCell cell)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAVisGroup_add_battle_cell_73_comment =
    "C++ Interface:\n"
    "addBattleCell(non-const DNAVisGroup this, const DNABattleCell cell)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAVisGroup::add_battle_cell\n"
    "//       Access: Public\n"
    "//  Description: Adds a battle_cell to this vis group\n"
    "//               This is only stored here so we can write it back out\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAVisGroup_add_battle_cell_73_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DNAVisGroup::remove_battle_cell(PointerTo< DNABattleCell > cell)
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_remove_battle_cell_74(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAVisGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAVisGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int DNAVisGroup::remove_battle_cell(PointerTo< DNABattleCell > cell)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"cell", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeBattleCell", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeBattleCell", &param1));
            if(!PyErr_Occurred())
            {
                DNABattleCell *param1_this = (DNABattleCell *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNABattleCell, 1, "DNAVisGroup.removeBattleCell", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = (local_this)->remove_battle_cell(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAVisGroup.removeBattleCell() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeBattleCell(non-const DNAVisGroup this, const DNABattleCell cell)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAVisGroup_remove_battle_cell_74_comment =
    "C++ Interface:\n"
    "removeBattleCell(non-const DNAVisGroup this, const DNABattleCell cell)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAVisGroup::remove_battle_cell\n"
    "//       Access: Public\n"
    "//  Description: Remove this battle cell\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAVisGroup_remove_battle_cell_74_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DNAVisGroup::get_num_battle_cells(void) const
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_get_num_battle_cells_75(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAVisGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAVisGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DNAVisGroup::get_num_battle_cells(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumBattleCells", key_word_list));
        else
            (PyArg_Parse(args, ":getNumBattleCells"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DNAVisGroup*)local_this)->get_num_battle_cells();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumBattleCells(const DNAVisGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAVisGroup_get_num_battle_cells_75_comment =
    "C++ Interface:\n"
    "getNumBattleCells(const DNAVisGroup this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAVisGroup::get_num_battle_cells\n"
    "//       Access: Public\n"
    "//  Description: Ask how many cells this vis group has\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAVisGroup_get_num_battle_cells_75_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< DNABattleCell > DNAVisGroup::get_battle_cell(unsigned int i) const
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_get_battle_cell_76(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAVisGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAVisGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PointerTo< DNABattleCell > DNAVisGroup::get_battle_cell(unsigned int i) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"i", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getBattleCell", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getBattleCell", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                PointerTo< DNABattleCell > return_value = ((const DNAVisGroup*)local_this)->get_battle_cell(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (return_value != (DNABattleCell *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value.p() == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_DNABattleCell,true, false, (return_value.p())->as_typed_object()->get_type_index());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBattleCell(const DNAVisGroup this, unsigned int i)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAVisGroup_get_battle_cell_76_comment =
    "C++ Interface:\n"
    "getBattleCell(const DNAVisGroup this, unsigned int i)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAVisGroup::get_battle_cell\n"
    "//       Access: Public\n"
    "//  Description: Return the ith cell in the vector\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAVisGroup_get_battle_cell_76_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNAVisGroup::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNAVisGroup_get_class_type_77(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DNAVisGroup::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DNAVisGroup::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAVisGroup_get_class_type_77_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DNAVisGroup_get_class_type_77_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAVisGroup::DNAVisGroup(DNAVisGroup const &group)
 * DNAVisGroup::DNAVisGroup(basic_string< char > const &initial_name)
 * DNAVisGroup::DNAVisGroup(basic_string< char > const &initial_name = (""))
 *******************************************************************/
int  Dtool_Init_DNAVisGroup(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-DNAVisGroup::DNAVisGroup(basic_string< char > const &initial_name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":DNAVisGroup", key_word_list))
            {
                DNAVisGroup *return_value = new DNAVisGroup();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAVisGroup,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 DNAVisGroup::DNAVisGroup(DNAVisGroup const &group)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"group", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DNAVisGroup", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DNAVisGroup", &param0));
                if(!PyErr_Occurred())
                {
                    DNAVisGroup *param0_this = (DNAVisGroup *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNAVisGroup, 0, "DNAVisGroup.DNAVisGroup", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        DNAVisGroup *return_value = new DNAVisGroup(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAVisGroup,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 DNAVisGroup::DNAVisGroup(basic_string< char > const &initial_name)
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"initial_name", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNAVisGroup", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:DNAVisGroup", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    DNAVisGroup *return_value = new DNAVisGroup(basic_string<char>(param0_str, param0_len));
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAVisGroup,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "DNAVisGroup() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "DNAVisGroup()\n"
          "DNAVisGroup(const DNAVisGroup group)\n"
          "DNAVisGroup(string initial_name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNAVisGroup(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNAVisGroup)
    {
        printf("DNAVisGroup ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNAVisGroup * local_this = (DNAVisGroup *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNAVisGroup)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( DNAGroup *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( DNAGroup *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( DNAGroup *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( DNAGroup *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNAVisGroup(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNAVisGroup)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNAVisGroup*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (DNAVisGroup*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (DNAVisGroup*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DNAVisGroup*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (DNAVisGroup*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNASuitPath 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline int DNASuitPath::get_num_points(void) const
 *******************************************************************/
static PyObject *Dtool_DNASuitPath_get_num_points_81(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DNASuitPath::get_num_points(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumPoints", key_word_list));
        else
            (PyArg_Parse(args, ":getNumPoints"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DNASuitPath*)local_this)->get_num_points();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumPoints(const DNASuitPath this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitPath_get_num_points_81_comment =
    "C++ Interface:\n"
    "getNumPoints(const DNASuitPath this)\n"
    "\n"
    "// Filename: dnaSuitPath.I\n"
    "// Created by:  shochet (28Jan01)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNASuitPath::get_num_points\n"
    "//       Access: Public\n"
    "//  Description: How many points are along this path, including the\n"
    "//               starting and ending points\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNASuitPath_get_num_points_81_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNASuitPath::copy(DNASuitPath const &path)
 *******************************************************************/
static PyObject *Dtool_DNASuitPath_copy_82(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DNASuitPath::copy(DNASuitPath const &path)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"path", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:copy", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:copy", &param1));
            if(!PyErr_Occurred())
            {
                DNASuitPath *param1_this = (DNASuitPath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNASuitPath, 1, "DNASuitPath.copy", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->copy(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNASuitPath.copy() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "copy(non-const DNASuitPath this, const DNASuitPath path)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitPath_copy_82_comment =
    "C++ Interface:\n"
    "copy(non-const DNASuitPath this, const DNASuitPath path)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNASuitPath::copy\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNASuitPath_copy_82_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DNASuitPath::get_point_index(int i) const
 *******************************************************************/
static PyObject *Dtool_DNASuitPath_get_point_index_83(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DNASuitPath::get_point_index(int i) const
        int param1;
        static char * key_word_list[] = {(char *)"i", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getPointIndex", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getPointIndex", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DNASuitPath*)local_this)->get_point_index((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPointIndex(const DNASuitPath this, int i)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitPath_get_point_index_83_comment =
    "C++ Interface:\n"
    "getPointIndex(const DNASuitPath this, int i)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNASuitPath::get_point_index\n"
    "//       Access: Public\n"
    "//  Description: Returns the point index at location i. This index\n"
    "//               can then be looked up in the dna storage to ask\n"
    "//               properties of the actual point\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNASuitPath_get_point_index_83_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNASuitPath::output(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_DNASuitPath_output_84(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASuitPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitPath,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void DNASuitPath::output(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:output", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:output", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DNASuitPath.output", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const DNASuitPath*)local_this)->output(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "output(const DNASuitPath this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitPath_output_84_comment =
    "C++ Interface:\n"
    "output(const DNASuitPath this, non-const Ostream out)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNASuitPath::output\n"
    "//       Access: Public\n"
    "//  Description: Output the path to the ostream\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNASuitPath_output_84_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNASuitPath::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNASuitPath_get_class_type_85(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DNASuitPath::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DNASuitPath::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASuitPath_get_class_type_85_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DNASuitPath_get_class_type_85_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNASuitPath::DNASuitPath(void)
 * DNASuitPath::DNASuitPath(DNASuitPath const &path)
 * DNASuitPath::DNASuitPath(int reserve_length)
 *******************************************************************/
int  Dtool_Init_DNASuitPath(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-DNASuitPath::DNASuitPath(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":DNASuitPath", key_word_list))
            {
                DNASuitPath *return_value = new DNASuitPath();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DNASuitPath,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 DNASuitPath::DNASuitPath(DNASuitPath const &path)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"path", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DNASuitPath", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DNASuitPath", &param0));
                if(!PyErr_Occurred())
                {
                    DNASuitPath *param0_this = (DNASuitPath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNASuitPath, 0, "DNASuitPath.DNASuitPath", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        DNASuitPath *return_value = new DNASuitPath(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DNASuitPath,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 DNASuitPath::DNASuitPath(int reserve_length)
                int param0;
                static char * key_word_list[] = {(char *)"reserve_length", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "i:DNASuitPath", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "i:DNASuitPath", &param0));
                if(!PyErr_Occurred())
                {
                    DNASuitPath *return_value = new DNASuitPath((int)param0);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_DNASuitPath,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "DNASuitPath() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "DNASuitPath()\n"
          "DNASuitPath(const DNASuitPath path)\n"
          "DNASuitPath(int reserve_length)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNASuitPath(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNASuitPath)
    {
        printf("DNASuitPath ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNASuitPath * local_this = (DNASuitPath *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNASuitPath)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNASuitPath(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNASuitPath)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (DNASuitPath*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DNASuitPath*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (DNASuitPath*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PosHpr 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * LPoint3f const &PosHpr::get_pos(void) const
 *******************************************************************/
static PyObject *Dtool_PosHpr_get_pos_89(PyObject *self, PyObject *args,PyObject *kwds) {
    PosHpr * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PosHpr,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-LPoint3f const &PosHpr::get_pos(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPos", key_word_list));
        else
            (PyArg_Parse(args, ":getPos"));
        if(!PyErr_Occurred())
        {
            LPoint3f const *return_value = &(((const PosHpr*)local_this)->get_pos());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPos(const PosHpr this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PosHpr_get_pos_89_comment =
    "C++ Interface:\n"
    "getPos(const PosHpr this)\n"
    "\n"
    "";
#else
static const char * Dtool_PosHpr_get_pos_89_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LPoint3f const &PosHpr::get_hpr(void) const
 *******************************************************************/
static PyObject *Dtool_PosHpr_get_hpr_90(PyObject *self, PyObject *args,PyObject *kwds) {
    PosHpr * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PosHpr,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-LPoint3f const &PosHpr::get_hpr(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHpr", key_word_list));
        else
            (PyArg_Parse(args, ":getHpr"));
        if(!PyErr_Occurred())
        {
            LPoint3f const *return_value = &(((const PosHpr*)local_this)->get_hpr());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHpr(const PosHpr this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PosHpr_get_hpr_90_comment =
    "C++ Interface:\n"
    "getHpr(const PosHpr this)\n"
    "\n"
    "";
#else
static const char * Dtool_PosHpr_get_hpr_90_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PosHpr::PosHpr(LPoint3f const &pos, LPoint3f const &hpr)
 * PosHpr::PosHpr(LPoint3f const &pos, LPoint3f const &hpr = ((Vertexf(0))))
 * PosHpr::PosHpr(LPoint3f const &pos = ((Vertexf(0))), LPoint3f const &hpr = ((Vertexf(0))))
 *******************************************************************/
int  Dtool_Init_PosHpr(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-PosHpr::PosHpr(LPoint3f const &pos = ((Vertexf(0))), LPoint3f const &hpr = ((Vertexf(0))))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":PosHpr", key_word_list))
            {
                PosHpr *return_value = new PosHpr();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PosHpr,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-PosHpr::PosHpr(LPoint3f const &pos, LPoint3f const &hpr = ((Vertexf(0))))
                PyObject *param0;
                static char * key_word_list[] = {(char *)"pos", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PosHpr", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PosHpr", &param0));
                if(!PyErr_Occurred())
                {
                    LPoint3f *param0_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LPoint3f, 0, "PosHpr.PosHpr", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PosHpr *return_value = new PosHpr(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PosHpr,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-PosHpr::PosHpr(LPoint3f const &pos, LPoint3f const &hpr)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"pos", (char *)"hpr", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:PosHpr", key_word_list, &param0, &param1))
                {
                    LPoint3f *param0_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LPoint3f, 0, "PosHpr.PosHpr", 1, coerced_ptr, report_errors);
LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "PosHpr.PosHpr", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        PosHpr *return_value = new PosHpr(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PosHpr,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PosHpr() takes 0, 1, or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PosHpr()\n"
          "PosHpr(const Point3 pos)\n"
          "PosHpr(const Point3 pos, const Point3 hpr)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PosHpr(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PosHpr)
    {
        printf("PosHpr ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PosHpr * local_this = (PosHpr *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PosHpr)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PosHpr(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PosHpr)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNAStorage 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::print_node_storage(void) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_print_node_storage_94(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-void DNAStorage::print_node_storage(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":printNodeStorage", key_word_list));
        else
            (PyArg_Parse(args, ":printNodeStorage"));
        if(!PyErr_Occurred())
        {
            ((const DNAStorage*)local_this)->print_node_storage();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "printNodeStorage(const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_print_node_storage_94_comment =
    "C++ Interface:\n"
    "printNodeStorage(const DNAStorage this)\n"
    "\n"
    "// Storage functions\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: print_node_storage\n"
    "//       Access: Public\n"
    "//  Description: Print out the key/pointer pairs\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_print_node_storage_94_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::print_texture_storage(void) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_print_texture_storage_95(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-void DNAStorage::print_texture_storage(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":printTextureStorage", key_word_list));
        else
            (PyArg_Parse(args, ":printTextureStorage"));
        if(!PyErr_Occurred())
        {
            ((const DNAStorage*)local_this)->print_texture_storage();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "printTextureStorage(const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_print_texture_storage_95_comment =
    "C++ Interface:\n"
    "printTextureStorage(const DNAStorage this)\n"
    "\n"
    "// Storage functions\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: print_texture_storage\n"
    "//       Access: Public\n"
    "//  Description: Print out the key/pointer pairs\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_print_texture_storage_95_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::print_font_storage(void) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_print_font_storage_96(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-void DNAStorage::print_font_storage(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":printFontStorage", key_word_list));
        else
            (PyArg_Parse(args, ":printFontStorage"));
        if(!PyErr_Occurred())
        {
            ((const DNAStorage*)local_this)->print_font_storage();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "printFontStorage(const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_print_font_storage_96_comment =
    "C++ Interface:\n"
    "printFontStorage(const DNAStorage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: print_font_storage\n"
    "//       Access: Public\n"
    "//  Description: Print out the key/pointer pairs\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_print_font_storage_96_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::print_suit_point_storage(void) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_print_suit_point_storage_97(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-void DNAStorage::print_suit_point_storage(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":printSuitPointStorage", key_word_list));
        else
            (PyArg_Parse(args, ":printSuitPointStorage"));
        if(!PyErr_Occurred())
        {
            ((const DNAStorage*)local_this)->print_suit_point_storage();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "printSuitPointStorage(const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_print_suit_point_storage_97_comment =
    "C++ Interface:\n"
    "printSuitPointStorage(const DNAStorage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: print_suit_point_storage\n"
    "//       Access: Public\n"
    "//  Description: Print out the key/pointer pairs\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_print_suit_point_storage_97_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::print_battle_cell_storage(void) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_print_battle_cell_storage_98(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-void DNAStorage::print_battle_cell_storage(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":printBattleCellStorage", key_word_list));
        else
            (PyArg_Parse(args, ":printBattleCellStorage"));
        if(!PyErr_Occurred())
        {
            ((const DNAStorage*)local_this)->print_battle_cell_storage();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "printBattleCellStorage(const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_print_battle_cell_storage_98_comment =
    "C++ Interface:\n"
    "printBattleCellStorage(const DNAStorage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: print_battle_cell_storage\n"
    "//       Access: Public\n"
    "//  Description: Print out the battle cells\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_print_battle_cell_storage_98_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_texture(basic_string< char > const &code_string, PointerTo< Texture > texture)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_texture_99(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DNAStorage::store_texture(basic_string< char > const &code_string, PointerTo< Texture > texture)
            char *param1_str; int param1_len;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"code_string", (char *)"texture", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:storeTexture", key_word_list, &param1_str, &param1_len, &param2))
            {
                Texture *param2_this = (Texture *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_Texture, 2, "DNAStorage.storeTexture", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->store_texture(basic_string<char>(param1_str, param1_len), param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAStorage.storeTexture() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "storeTexture(non-const DNAStorage this, string code_string, const Texture texture)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_store_texture_99_comment =
    "C++ Interface:\n"
    "storeTexture(non-const DNAStorage this, string code_string, const Texture texture)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: store_texture\n"
    "//       Access: Public\n"
    "//  Description: Store a texture pointer in the texture map\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_store_texture_99_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_font(basic_string< char > const &code_string, PointerTo< TextFont > font)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_font_100(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DNAStorage::store_font(basic_string< char > const &code_string, PointerTo< TextFont > font)
            char *param1_str; int param1_len;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"code_string", (char *)"font", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:storeFont", key_word_list, &param1_str, &param1_len, &param2))
            {
                TextFont *param2_this = (TextFont *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_TextFont, 2, "DNAStorage.storeFont", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->store_font(basic_string<char>(param1_str, param1_len), param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAStorage.storeFont() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "storeFont(non-const DNAStorage this, string code_string, const TextFont font)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_store_font_100_comment =
    "C++ Interface:\n"
    "storeFont(non-const DNAStorage this, string code_string, const TextFont font)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: store_font\n"
    "//       Access: Public\n"
    "//  Description: Store a font pointer in the font map\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_store_font_100_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStorage::store_node(basic_string< char > const &code_string, NodePath node, basic_string< char > const &code_category)
 * inline void DNAStorage::store_node(basic_string< char > const &code_string, NodePath node, basic_string< char > const &code_category = (""))
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_node_101(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void DNAStorage::store_node(basic_string< char > const &code_string, NodePath node, basic_string< char > const &code_category = (""))
                char *param1_str; int param1_len;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"code_string", (char *)"node", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:storeNode", key_word_list, &param1_str, &param1_len, &param2))
                {
                    NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "DNAStorage.storeNode", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        (local_this)->store_node(basic_string<char>(param1_str, param1_len), *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call DNAStorage.storeNode() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void DNAStorage::store_node(basic_string< char > const &code_string, NodePath node, basic_string< char > const &code_category)
                char *param1_str; int param1_len;
                PyObject *param2;
                char *param3_str; int param3_len;
                static char * key_word_list[] = {(char *)"code_string", (char *)"node", (char *)"code_category", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#Os#:storeNode", key_word_list, &param1_str, &param1_len, &param2, &param3_str, &param3_len))
                {
                    NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "DNAStorage.storeNode", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        (local_this)->store_node(basic_string<char>(param1_str, param1_len), *param2_this, basic_string<char>(param3_str, param3_len));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call DNAStorage.storeNode() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "storeNode() takes 3 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "storeNode(non-const DNAStorage this, string code_string, const NodePath node)\n"
          "storeNode(non-const DNAStorage this, string code_string, const NodePath node, string code_category)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_store_node_101_comment =
    "C++ Interface:\n"
    "storeNode(non-const DNAStorage this, string code_string, const NodePath node)\n"
    "storeNode(non-const DNAStorage this, string code_string, const NodePath node, string code_category)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: store_node\n"
    "//       Access: Public\n"
    "//  Description: Store a node pointer in the node map\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_store_node_101_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStorage::store_hood_node(basic_string< char > const &code_string, NodePath node, basic_string< char > const &code_category)
 * inline void DNAStorage::store_hood_node(basic_string< char > const &code_string, NodePath node, basic_string< char > const &code_category = (""))
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_hood_node_102(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void DNAStorage::store_hood_node(basic_string< char > const &code_string, NodePath node, basic_string< char > const &code_category = (""))
                char *param1_str; int param1_len;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"code_string", (char *)"node", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:storeHoodNode", key_word_list, &param1_str, &param1_len, &param2))
                {
                    NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "DNAStorage.storeHoodNode", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        (local_this)->store_hood_node(basic_string<char>(param1_str, param1_len), *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call DNAStorage.storeHoodNode() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void DNAStorage::store_hood_node(basic_string< char > const &code_string, NodePath node, basic_string< char > const &code_category)
                char *param1_str; int param1_len;
                PyObject *param2;
                char *param3_str; int param3_len;
                static char * key_word_list[] = {(char *)"code_string", (char *)"node", (char *)"code_category", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#Os#:storeHoodNode", key_word_list, &param1_str, &param1_len, &param2, &param3_str, &param3_len))
                {
                    NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "DNAStorage.storeHoodNode", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        (local_this)->store_hood_node(basic_string<char>(param1_str, param1_len), *param2_this, basic_string<char>(param3_str, param3_len));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call DNAStorage.storeHoodNode() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "storeHoodNode() takes 3 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "storeHoodNode(non-const DNAStorage this, string code_string, const NodePath node)\n"
          "storeHoodNode(non-const DNAStorage this, string code_string, const NodePath node, string code_category)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_store_hood_node_102_comment =
    "C++ Interface:\n"
    "storeHoodNode(non-const DNAStorage this, string code_string, const NodePath node)\n"
    "storeHoodNode(non-const DNAStorage this, string code_string, const NodePath node, string code_category)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: store_hood_node\n"
    "//       Access: Public\n"
    "//  Description: Store a neighborhood specific node pointer in the\n"
    "//               hood node map\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_store_hood_node_102_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStorage::store_place_node(basic_string< char > const &code_string, NodePath node, basic_string< char > const &code_category)
 * inline void DNAStorage::store_place_node(basic_string< char > const &code_string, NodePath node, basic_string< char > const &code_category = (""))
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_place_node_103(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void DNAStorage::store_place_node(basic_string< char > const &code_string, NodePath node, basic_string< char > const &code_category = (""))
                char *param1_str; int param1_len;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"code_string", (char *)"node", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:storePlaceNode", key_word_list, &param1_str, &param1_len, &param2))
                {
                    NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "DNAStorage.storePlaceNode", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        (local_this)->store_place_node(basic_string<char>(param1_str, param1_len), *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call DNAStorage.storePlaceNode() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void DNAStorage::store_place_node(basic_string< char > const &code_string, NodePath node, basic_string< char > const &code_category)
                char *param1_str; int param1_len;
                PyObject *param2;
                char *param3_str; int param3_len;
                static char * key_word_list[] = {(char *)"code_string", (char *)"node", (char *)"code_category", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#Os#:storePlaceNode", key_word_list, &param1_str, &param1_len, &param2, &param3_str, &param3_len))
                {
                    NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "DNAStorage.storePlaceNode", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        (local_this)->store_place_node(basic_string<char>(param1_str, param1_len), *param2_this, basic_string<char>(param3_str, param3_len));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call DNAStorage.storePlaceNode() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "storePlaceNode() takes 3 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "storePlaceNode(non-const DNAStorage this, string code_string, const NodePath node)\n"
          "storePlaceNode(non-const DNAStorage this, string code_string, const NodePath node, string code_category)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_store_place_node_103_comment =
    "C++ Interface:\n"
    "storePlaceNode(non-const DNAStorage this, string code_string, const NodePath node)\n"
    "storePlaceNode(non-const DNAStorage this, string code_string, const NodePath node, string code_category)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: store_place_node\n"
    "//       Access: Public\n"
    "//  Description: Store a neighborhood specific node pointer in the\n"
    "//               place node map\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_store_place_node_103_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< DNASuitPoint > DNAStorage::store_suit_point(DNASuitPoint::DNASuitPointType type, LPoint3f pos)
 * int DNAStorage::store_suit_point(PointerTo< DNASuitPoint > )
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_suit_point_104(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-int DNAStorage::store_suit_point(PointerTo< DNASuitPoint > )
                PyObject *param1;
                static char * key_word_list[] = {(char *)"param0", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:storeSuitPoint", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:storeSuitPoint", &param1));
                if(!PyErr_Occurred())
                {
                    DNASuitPoint *param1_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNASuitPoint, 1, "DNAStorage.storeSuitPoint", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        int return_value = (local_this)->store_suit_point(param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call DNAStorage.storeSuitPoint() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-PointerTo< DNASuitPoint > DNAStorage::store_suit_point(DNASuitPoint::DNASuitPointType type, LPoint3f pos)
                int param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"type", (char *)"pos", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:storeSuitPoint", key_word_list, &param1, &param2))
                {
                    LPoint3f *param2_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint3f, 2, "DNAStorage.storeSuitPoint", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        PointerTo< DNASuitPoint > return_value = (local_this)->store_suit_point((DNASuitPoint::DNASuitPointType)param1, *param2_this);
                        if (return_value != (DNASuitPoint *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_DNASuitPoint,true, false, (return_value.p())->as_typed_object()->get_type_index());
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call DNAStorage.storeSuitPoint() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "storeSuitPoint() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "storeSuitPoint(non-const DNAStorage this, const DNASuitPoint)\n"
          "storeSuitPoint(non-const DNAStorage this, int type, const Point3 pos)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_store_suit_point_104_comment =
    "C++ Interface:\n"
    "storeSuitPoint(non-const DNAStorage this, const DNASuitPoint)\n"
    "storeSuitPoint(non-const DNAStorage this, int type, const Point3 pos)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: store_suit_point\n"
    "//       Access: Public\n"
    "//  Description: Store a point in the suit point map. If that pos\n"
    "//               already exists, return the existing point, otherwise\n"
    "//               create a new point and store that.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: store_suit_point\n"
    "//       Access: Public\n"
    "//  Description: Store a suit point in the suit point map\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_store_suit_point_104_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DNAStorage::get_highest_suit_point_index(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_highest_suit_point_index_105(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DNAStorage::get_highest_suit_point_index(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHighestSuitPointIndex", key_word_list));
        else
            (PyArg_Parse(args, ":getHighestSuitPointIndex"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_highest_suit_point_index();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.getHighestSuitPointIndex() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHighestSuitPointIndex(non-const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_highest_suit_point_index_105_comment =
    "C++ Interface:\n"
    "getHighestSuitPointIndex(non-const DNAStorage this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAStorage_get_highest_suit_point_index_105_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DNAStorage::remove_suit_point(PointerTo< DNASuitPoint > )
 *******************************************************************/
static PyObject *Dtool_DNAStorage_remove_suit_point_106(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int DNAStorage::remove_suit_point(PointerTo< DNASuitPoint > )
            PyObject *param1;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeSuitPoint", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeSuitPoint", &param1));
            if(!PyErr_Occurred())
            {
                DNASuitPoint *param1_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNASuitPoint, 1, "DNAStorage.removeSuitPoint", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = (local_this)->remove_suit_point(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAStorage.removeSuitPoint() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeSuitPoint(non-const DNAStorage this, const DNASuitPoint)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_remove_suit_point_106_comment =
    "C++ Interface:\n"
    "removeSuitPoint(non-const DNAStorage this, const DNASuitPoint)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: remove_suit_point\n"
    "//       Access: Public\n"
    "//  Description: Remove a suit point from the suit point map\n"
    "//               Returns the number of points removed (0 or 1)\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_remove_suit_point_106_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_block_number(basic_string< char > const &block, basic_string< char > const &zone_id)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_block_number_107(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNAStorage::store_block_number(basic_string< char > const &block, basic_string< char > const &zone_id)
        char *param1_str; int param1_len;
        char *param2_str; int param2_len;
        static char * key_word_list[] = {(char *)"block", (char *)"zone_id", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:storeBlockNumber", key_word_list, &param1_str, &param1_len, &param2_str, &param2_len))
        {
            (local_this)->store_block_number(basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.storeBlockNumber() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "storeBlockNumber(non-const DNAStorage this, string block, string zone_id)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_store_block_number_107_comment =
    "C++ Interface:\n"
    "storeBlockNumber(non-const DNAStorage this, string block, string zone_id)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: store_block_number\n"
    "//       Access: Public\n"
    "//  Description: Store a block and zone\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_store_block_number_107_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_block_door_pos_hpr(basic_string< char > const &block, LPoint3f const &pos, LPoint3f const &hpr)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_block_door_pos_hpr_108(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DNAStorage::store_block_door_pos_hpr(basic_string< char > const &block, LPoint3f const &pos, LPoint3f const &hpr)
            char *param1_str; int param1_len;
            PyObject *param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"block", (char *)"pos", (char *)"hpr", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#OO:storeBlockDoorPosHpr", key_word_list, &param1_str, &param1_len, &param2, &param3))
            {
                LPoint3f *param2_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint3f, 2, "DNAStorage.storeBlockDoorPosHpr", 1, coerced_ptr, report_errors);
LPoint3f *param3_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LPoint3f, 3, "DNAStorage.storeBlockDoorPosHpr", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)|| (param3_this == NULL)))
                {
                    (local_this)->store_block_door_pos_hpr(basic_string<char>(param1_str, param1_len), *param2_this, *param3_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAStorage.storeBlockDoorPosHpr() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "storeBlockDoorPosHpr(non-const DNAStorage this, string block, const Point3 pos, const Point3 hpr)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_store_block_door_pos_hpr_108_comment =
    "C++ Interface:\n"
    "storeBlockDoorPosHpr(non-const DNAStorage this, string block, const Point3 pos, const Point3 hpr)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: store_block_door_pos_hpr\n"
    "//       Access: Public\n"
    "//  Description: Store a block and zone\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_store_block_door_pos_hpr_108_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_block_sign_transform(basic_string< char > const &block, LMatrix4f const &mat)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_block_sign_transform_109(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DNAStorage::store_block_sign_transform(basic_string< char > const &block, LMatrix4f const &mat)
            char *param1_str; int param1_len;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"block", (char *)"mat", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:storeBlockSignTransform", key_word_list, &param1_str, &param1_len, &param2))
            {
                LMatrix4f *param2_this = (LMatrix4f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LMatrix4f, 2, "DNAStorage.storeBlockSignTransform", 1, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->store_block_sign_transform(basic_string<char>(param1_str, param1_len), *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAStorage.storeBlockSignTransform() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "storeBlockSignTransform(non-const DNAStorage this, string block, const Mat4 mat)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_store_block_sign_transform_109_comment =
    "C++ Interface:\n"
    "storeBlockSignTransform(non-const DNAStorage this, string block, const Mat4 mat)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: store_block_sign_transform\n"
    "//       Access: Public\n"
    "//  Description: Store a block and zone\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_store_block_sign_transform_109_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_block_title(basic_string< char > const &block, basic_string< char > const &title)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_block_title_110(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNAStorage::store_block_title(basic_string< char > const &block, basic_string< char > const &title)
        char *param1_str; int param1_len;
        char *param2_str; int param2_len;
        static char * key_word_list[] = {(char *)"block", (char *)"title", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:storeBlockTitle", key_word_list, &param1_str, &param1_len, &param2_str, &param2_len))
        {
            (local_this)->store_block_title(basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.storeBlockTitle() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "storeBlockTitle(non-const DNAStorage this, string block, string title)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_store_block_title_110_comment =
    "C++ Interface:\n"
    "storeBlockTitle(non-const DNAStorage this, string block, string title)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: store_block_title\n"
    "//       Access: Public\n"
    "//  Description: Store a block and zone\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_store_block_title_110_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_block_article(basic_string< char > const &block, basic_string< char > const &article)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_block_article_111(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNAStorage::store_block_article(basic_string< char > const &block, basic_string< char > const &article)
        char *param1_str; int param1_len;
        char *param2_str; int param2_len;
        static char * key_word_list[] = {(char *)"block", (char *)"article", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:storeBlockArticle", key_word_list, &param1_str, &param1_len, &param2_str, &param2_len))
        {
            (local_this)->store_block_article(basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.storeBlockArticle() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "storeBlockArticle(non-const DNAStorage this, string block, string article)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_store_block_article_111_comment =
    "C++ Interface:\n"
    "storeBlockArticle(non-const DNAStorage this, string block, string article)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: store_block_article\n"
    "//       Access: Public\n"
    "//  Description: Store a block and zone\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_store_block_article_111_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_battle_cell(PointerTo< DNABattleCell > )
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_battle_cell_112(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DNAStorage::store_battle_cell(PointerTo< DNABattleCell > )
            PyObject *param1;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:storeBattleCell", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:storeBattleCell", &param1));
            if(!PyErr_Occurred())
            {
                DNABattleCell *param1_this = (DNABattleCell *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNABattleCell, 1, "DNAStorage.storeBattleCell", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->store_battle_cell(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAStorage.storeBattleCell() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "storeBattleCell(non-const DNAStorage this, const DNABattleCell)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_store_battle_cell_112_comment =
    "C++ Interface:\n"
    "storeBattleCell(non-const DNAStorage this, const DNABattleCell)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: store_battle_cell\n"
    "//       Access: Public\n"
    "//  Description: Store a battle cell in the battle cell vector\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_store_battle_cell_112_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DNAStorage::remove_battle_cell(PointerTo< DNABattleCell > )
 *******************************************************************/
static PyObject *Dtool_DNAStorage_remove_battle_cell_113(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int DNAStorage::remove_battle_cell(PointerTo< DNABattleCell > )
            PyObject *param1;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeBattleCell", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeBattleCell", &param1));
            if(!PyErr_Occurred())
            {
                DNABattleCell *param1_this = (DNABattleCell *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNABattleCell, 1, "DNAStorage.removeBattleCell", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = (local_this)->remove_battle_cell(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAStorage.removeBattleCell() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeBattleCell(non-const DNAStorage this, const DNABattleCell)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_remove_battle_cell_113_comment =
    "C++ Interface:\n"
    "removeBattleCell(non-const DNAStorage this, const DNABattleCell)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: remove_battle_cell\n"
    "//       Access: Public\n"
    "//  Description: Remove a battle cell from the battle cell vector\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_remove_battle_cell_113_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< DNASuitEdge > DNAStorage::store_suit_edge(PointerTo< DNASuitEdge > )
 * PointerTo< DNASuitEdge > DNAStorage::store_suit_edge(int start_index, int end_index, basic_string< char > zone_id)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_suit_edge_114(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-PointerTo< DNASuitEdge > DNAStorage::store_suit_edge(PointerTo< DNASuitEdge > )
                PyObject *param1;
                static char * key_word_list[] = {(char *)"param0", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:storeSuitEdge", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:storeSuitEdge", &param1));
                if(!PyErr_Occurred())
                {
                    DNASuitEdge *param1_this = (DNASuitEdge *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNASuitEdge, 1, "DNAStorage.storeSuitEdge", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        PointerTo< DNASuitEdge > return_value = (local_this)->store_suit_edge(param1_this);
                        if (return_value != (DNASuitEdge *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_DNASuitEdge,true, false, (return_value.p())->as_typed_object()->get_type_index());
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call DNAStorage.storeSuitEdge() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-PointerTo< DNASuitEdge > DNAStorage::store_suit_edge(int start_index, int end_index, basic_string< char > zone_id)
            int param1;
            int param2;
            char *param3_str; int param3_len;
            static char * key_word_list[] = {(char *)"start_index", (char *)"end_index", (char *)"zone_id", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iis#:storeSuitEdge", key_word_list, &param1, &param2, &param3_str, &param3_len))
            {
                PointerTo< DNASuitEdge > return_value = (local_this)->store_suit_edge((int)param1, (int)param2, basic_string<char>(param3_str, param3_len));
                if (return_value != (DNASuitEdge *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value.p() == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_DNASuitEdge,true, false, (return_value.p())->as_typed_object()->get_type_index());
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAStorage.storeSuitEdge() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "storeSuitEdge() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "storeSuitEdge(non-const DNAStorage this, const DNASuitEdge)\n"
          "storeSuitEdge(non-const DNAStorage this, int start_index, int end_index, string zone_id)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_store_suit_edge_114_comment =
    "C++ Interface:\n"
    "storeSuitEdge(non-const DNAStorage this, const DNASuitEdge)\n"
    "storeSuitEdge(non-const DNAStorage this, int start_index, int end_index, string zone_id)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: store_suit_edge\n"
    "//       Access: Public\n"
    "//  Description: Store a suit edge represented by the start and end\n"
    "//               indexes in the suit start point map. These indexes\n"
    "//               better be stored in the suit_point_vector already\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: store_suit_edge\n"
    "//       Access: Public\n"
    "//  Description: Store a suit edge in the suit start point map,\n"
    "//               listed under the index of the start point\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_store_suit_edge_114_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DNAStorage::remove_suit_edge(PointerTo< DNASuitEdge > )
 *******************************************************************/
static PyObject *Dtool_DNAStorage_remove_suit_edge_115(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int DNAStorage::remove_suit_edge(PointerTo< DNASuitEdge > )
            PyObject *param1;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeSuitEdge", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeSuitEdge", &param1));
            if(!PyErr_Occurred())
            {
                DNASuitEdge *param1_this = (DNASuitEdge *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNASuitEdge, 1, "DNAStorage.removeSuitEdge", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = (local_this)->remove_suit_edge(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAStorage.removeSuitEdge() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeSuitEdge(non-const DNAStorage this, const DNASuitEdge)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_remove_suit_edge_115_comment =
    "C++ Interface:\n"
    "removeSuitEdge(non-const DNAStorage this, const DNASuitEdge)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: remove_suit_edge\n"
    "//       Access: Public\n"
    "//  Description: Removes a suit edge from the map\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_remove_suit_edge_115_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DNAStorage::delete_unused_suit_points(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_delete_unused_suit_points_116(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DNAStorage::delete_unused_suit_points(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":deleteUnusedSuitPoints", key_word_list));
        else
            (PyArg_Parse(args, ":deleteUnusedSuitPoints"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->delete_unused_suit_points();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.deleteUnusedSuitPoints() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "deleteUnusedSuitPoints(non-const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_delete_unused_suit_points_116_comment =
    "C++ Interface:\n"
    "deleteUnusedSuitPoints(non-const DNAStorage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: delete_unused_suit_points\n"
    "//       Access: Public\n"
    "//  Description: Runs through the list of suit points deleting\n"
    "//               any points that are not on any edges.\n"
    "//               This is computationally expensive, but it is only run\n"
    "//               when we save the dna in the editor, not at run time.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_delete_unused_suit_points_116_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DNAStorage::fix_coincident_suit_points(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_fix_coincident_suit_points_117(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DNAStorage::fix_coincident_suit_points(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":fixCoincidentSuitPoints", key_word_list));
        else
            (PyArg_Parse(args, ":fixCoincidentSuitPoints"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->fix_coincident_suit_points();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.fixCoincidentSuitPoints() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "fixCoincidentSuitPoints(non-const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_fix_coincident_suit_points_117_comment =
    "C++ Interface:\n"
    "fixCoincidentSuitPoints(non-const DNAStorage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: fix_coincident_suit_points\n"
    "//       Access: Public\n"
    "//  Description: Runs through the list of suit points fixing\n"
    "//               any points that are coincident by deleting the\n"
    "//               duplicates and patching up the effected edges\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_fix_coincident_suit_points_117_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStorage::reset_nodes(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_nodes_118(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNAStorage::reset_nodes(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":resetNodes", key_word_list));
        else
            (PyArg_Parse(args, ":resetNodes"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_nodes();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.resetNodes() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetNodes(non-const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_reset_nodes_118_comment =
    "C++ Interface:\n"
    "resetNodes(non-const DNAStorage this)\n"
    "\n"
    "// Reset functions\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: reset_nodes\n"
    "//       Access: Public\n"
    "//  Description: clear out the map of shared nodes\n"
    "//               so the ref counter will delete them\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_reset_nodes_118_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStorage::reset_textures(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_textures_119(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNAStorage::reset_textures(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":resetTextures", key_word_list));
        else
            (PyArg_Parse(args, ":resetTextures"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_textures();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.resetTextures() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetTextures(non-const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_reset_textures_119_comment =
    "C++ Interface:\n"
    "resetTextures(non-const DNAStorage this)\n"
    "\n"
    "// Reset functions\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: reset_textures\n"
    "//       Access: Public\n"
    "//  Description: clear out the map of shared textures\n"
    "//               so the ref counter will delete them\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_reset_textures_119_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStorage::reset_hood(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_hood_120(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNAStorage::reset_hood(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":resetHood", key_word_list));
        else
            (PyArg_Parse(args, ":resetHood"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_hood();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.resetHood() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetHood(non-const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_reset_hood_120_comment =
    "C++ Interface:\n"
    "resetHood(non-const DNAStorage this)\n"
    "\n"
    "// Reset everything associated with this hood\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: reset_hood\n"
    "//       Access: Public\n"
    "//  Description: clear out everything associated with the current hood\n"
    "//               this is called in Python whenever we leave a hood. It\n"
    "//               is easier to add things here than to have to keep\n"
    "//               updating the showcode.\n"
    "//               Reseting the hood also resets the place nodes.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_reset_hood_120_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStorage::reset_hood_nodes(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_hood_nodes_121(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNAStorage::reset_hood_nodes(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":resetHoodNodes", key_word_list));
        else
            (PyArg_Parse(args, ":resetHoodNodes"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_hood_nodes();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.resetHoodNodes() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetHoodNodes(non-const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_reset_hood_nodes_121_comment =
    "C++ Interface:\n"
    "resetHoodNodes(non-const DNAStorage this)\n"
    "\n"
    "// These all get called by reset hood\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: reset_hood_nodes\n"
    "//       Access: Public\n"
    "//  Description: clear out the map of neighborhood specific nodes\n"
    "//               so the ref counter will delete them\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_reset_hood_nodes_121_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStorage::reset_place_nodes(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_place_nodes_122(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNAStorage::reset_place_nodes(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":resetPlaceNodes", key_word_list));
        else
            (PyArg_Parse(args, ":resetPlaceNodes"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_place_nodes();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.resetPlaceNodes() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetPlaceNodes(non-const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_reset_place_nodes_122_comment =
    "C++ Interface:\n"
    "resetPlaceNodes(non-const DNAStorage this)\n"
    "\n"
    "// These all get called by reset hood\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: reset_place_nodes\n"
    "//       Access: Public\n"
    "//  Description: clear out the map of town and sz specific nodes\n"
    "//               so the ref counter will delete them\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_reset_place_nodes_122_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStorage::reset_suit_points(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_suit_points_123(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNAStorage::reset_suit_points(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":resetSuitPoints", key_word_list));
        else
            (PyArg_Parse(args, ":resetSuitPoints"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_suit_points();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.resetSuitPoints() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetSuitPoints(non-const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_reset_suit_points_123_comment =
    "C++ Interface:\n"
    "resetSuitPoints(non-const DNAStorage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: reset_suit_points\n"
    "//       Access: Public\n"
    "//  Description: clear out all maps relating to suit points\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_reset_suit_points_123_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStorage::reset_battle_cells(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_battle_cells_124(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNAStorage::reset_battle_cells(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":resetBattleCells", key_word_list));
        else
            (PyArg_Parse(args, ":resetBattleCells"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_battle_cells();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.resetBattleCells() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetBattleCells(non-const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_reset_battle_cells_124_comment =
    "C++ Interface:\n"
    "resetBattleCells(non-const DNAStorage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: reset_battle_cells\n"
    "//       Access: Public\n"
    "//  Description: clear out all battle cells\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_reset_battle_cells_124_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStorage::reset_block_numbers(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_block_numbers_125(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNAStorage::reset_block_numbers(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":resetBlockNumbers", key_word_list));
        else
            (PyArg_Parse(args, ":resetBlockNumbers"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_block_numbers();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.resetBlockNumbers() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetBlockNumbers(non-const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_reset_block_numbers_125_comment =
    "C++ Interface:\n"
    "resetBlockNumbers(non-const DNAStorage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: reset_block_number\n"
    "//       Access: Public\n"
    "//  Description: clear out the map\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_reset_block_numbers_125_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStorage::reset_block_door_pos_hprs(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_block_door_pos_hprs_126(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNAStorage::reset_block_door_pos_hprs(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":resetBlockDoorPosHprs", key_word_list));
        else
            (PyArg_Parse(args, ":resetBlockDoorPosHprs"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_block_door_pos_hprs();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.resetBlockDoorPosHprs() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetBlockDoorPosHprs(non-const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_reset_block_door_pos_hprs_126_comment =
    "C++ Interface:\n"
    "resetBlockDoorPosHprs(non-const DNAStorage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: reset_block_door_pos_hpr\n"
    "//       Access: Public\n"
    "//  Description: clear out the map\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_reset_block_door_pos_hprs_126_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStorage::reset_block_sign_transforms(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_block_sign_transforms_127(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNAStorage::reset_block_sign_transforms(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":resetBlockSignTransforms", key_word_list));
        else
            (PyArg_Parse(args, ":resetBlockSignTransforms"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_block_sign_transforms();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.resetBlockSignTransforms() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetBlockSignTransforms(non-const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_reset_block_sign_transforms_127_comment =
    "C++ Interface:\n"
    "resetBlockSignTransforms(non-const DNAStorage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: reset_block_sign_transform\n"
    "//       Access: Public\n"
    "//  Description: clear out the map\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_reset_block_sign_transforms_127_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStorage::reset_block_title(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_block_title_128(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNAStorage::reset_block_title(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":resetBlockTitle", key_word_list));
        else
            (PyArg_Parse(args, ":resetBlockTitle"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_block_title();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.resetBlockTitle() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetBlockTitle(non-const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_reset_block_title_128_comment =
    "C++ Interface:\n"
    "resetBlockTitle(non-const DNAStorage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: reset_block_title\n"
    "//       Access: Public\n"
    "//  Description: clear out the map\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_reset_block_title_128_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStorage::reset_block_article(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_block_article_129(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNAStorage::reset_block_article(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":resetBlockArticle", key_word_list));
        else
            (PyArg_Parse(args, ":resetBlockArticle"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_block_article();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.resetBlockArticle() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetBlockArticle(non-const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_reset_block_article_129_comment =
    "C++ Interface:\n"
    "resetBlockArticle(non-const DNAStorage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: reset_block_article\n"
    "//       Access: Public\n"
    "//  Description: clear out the map\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_reset_block_article_129_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< Texture > DNAStorage::find_texture(basic_string< char > const &dna_string) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_find_texture_130(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PointerTo< Texture > DNAStorage::find_texture(basic_string< char > const &dna_string) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"dna_string", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:findTexture", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:findTexture", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            PointerTo< Texture > return_value = ((const DNAStorage*)local_this)->find_texture(basic_string<char>(param1_str, param1_len));
            if (return_value != (Texture *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_Texture,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findTexture(const DNAStorage this, string dna_string)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_find_texture_130_comment =
    "C++ Interface:\n"
    "findTexture(const DNAStorage this, string dna_string)\n"
    "\n"
    "// Searching functions\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: find_texture\n"
    "//       Access: Public\n"
    "//  Description: A convenient interface if you only know the codes\n"
    "//               by name, not by number\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_find_texture_130_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * NodePath DNAStorage::find_node(basic_string< char > const &dna_string) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_find_node_131(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-NodePath DNAStorage::find_node(basic_string< char > const &dna_string) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"dna_string", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:findNode", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:findNode", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            NodePath result = ((const DNAStorage*)local_this)->find_node(basic_string<char>(param1_str, param1_len));
            NodePath *return_value = new NodePath(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_NodePath,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findNode(const DNAStorage this, string dna_string)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_find_node_131_comment =
    "C++ Interface:\n"
    "findNode(const DNAStorage this, string dna_string)\n"
    "\n"
    "// Searching functions\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: find_node\n"
    "//       Access: Public\n"
    "//  Description: A convenient interface if you only know the codes\n"
    "//               by name, not by number\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_find_node_131_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< TextFont > DNAStorage::find_font(basic_string< char > const &dna_string) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_find_font_132(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PointerTo< TextFont > DNAStorage::find_font(basic_string< char > const &dna_string) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"dna_string", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:findFont", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:findFont", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            PointerTo< TextFont > return_value = ((const DNAStorage*)local_this)->find_font(basic_string<char>(param1_str, param1_len));
            if (return_value != (TextFont *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_TextFont,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findFont(const DNAStorage this, string dna_string)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_find_font_132_comment =
    "C++ Interface:\n"
    "findFont(const DNAStorage this, string dna_string)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: find_node\n"
    "//       Access: Public\n"
    "//  Description: A convenient interface if you only know the codes\n"
    "//               by name, not by number\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_find_font_132_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DNAStorage::get_num_catalog_codes(basic_string< char > const &catalog_string) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_num_catalog_codes_133(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DNAStorage::get_num_catalog_codes(basic_string< char > const &catalog_string) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"catalog_string", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getNumCatalogCodes", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:getNumCatalogCodes", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DNAStorage*)local_this)->get_num_catalog_codes(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumCatalogCodes(const DNAStorage this, string catalog_string)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_num_catalog_codes_133_comment =
    "C++ Interface:\n"
    "getNumCatalogCodes(const DNAStorage this, string catalog_string)\n"
    "\n"
    "// Catalog functions\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_num_catalog_codes\n"
    "//       Access: Public\n"
    "//  Description: Return the number of entries in this catalog\n"
    "//               Return -1 if the catalog is not found\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_num_catalog_codes_133_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DNAStorage::get_catalog_code(basic_string< char > const &catalog_string, int i) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_catalog_code_134(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > DNAStorage::get_catalog_code(basic_string< char > const &catalog_string, int i) const
        char *param1_str; int param1_len;
        int param2;
        static char * key_word_list[] = {(char *)"catalog_string", (char *)"i", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#i:getCatalogCode", key_word_list, &param1_str, &param1_len, &param2))
        {
            basic_string< char > return_value = ((const DNAStorage*)local_this)->get_catalog_code(basic_string<char>(param1_str, param1_len), (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCatalogCode(const DNAStorage this, string catalog_string, int i)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_catalog_code_134_comment =
    "C++ Interface:\n"
    "getCatalogCode(const DNAStorage this, string catalog_string, int i)\n"
    "\n"
    "// Catalog functions\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_catalog_code\n"
    "//       Access: Public\n"
    "//  Description: Return the number of entries in this catalog\n"
    "//               Return empty string if the catalog is not found\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_catalog_code_134_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_catalog_string(basic_string< char > const &catalog_string, basic_string< char > const &dna_string)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_catalog_string_135(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNAStorage::store_catalog_string(basic_string< char > const &catalog_string, basic_string< char > const &dna_string)
        char *param1_str; int param1_len;
        char *param2_str; int param2_len;
        static char * key_word_list[] = {(char *)"catalog_string", (char *)"dna_string", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:storeCatalogString", key_word_list, &param1_str, &param1_len, &param2_str, &param2_len))
        {
            (local_this)->store_catalog_string(basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.storeCatalogString() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "storeCatalogString(non-const DNAStorage this, string catalog_string, string dna_string)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_store_catalog_string_135_comment =
    "C++ Interface:\n"
    "storeCatalogString(non-const DNAStorage this, string catalog_string, string dna_string)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: store_catalog_string\n"
    "//       Access: Public\n"
    "//  Description: Add a string\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_store_catalog_string_135_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::print_catalog(void) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_print_catalog_136(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-void DNAStorage::print_catalog(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":printCatalog", key_word_list));
        else
            (PyArg_Parse(args, ":printCatalog"));
        if(!PyErr_Occurred())
        {
            ((const DNAStorage*)local_this)->print_catalog();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "printCatalog(const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_print_catalog_136_comment =
    "C++ Interface:\n"
    "printCatalog(const DNAStorage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: print_catalog\n"
    "//       Access: Public\n"
    "//  Description: print the catalog\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_print_catalog_136_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_DNAGroup(PointerTo< PandaNode > , PointerTo< DNAGroup > )
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_DNAGroup_137(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DNAStorage::store_DNAGroup(PointerTo< PandaNode > , PointerTo< DNAGroup > )
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"param0", (char *)"param1", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:storeDNAGroup", key_word_list, &param1, &param2))
            {
                PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PandaNode, 1, "DNAStorage.storeDNAGroup", 1, coerced_ptr, report_errors);
DNAGroup *param2_this = (DNAGroup *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DNAGroup, 2, "DNAStorage.storeDNAGroup", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    (local_this)->store_DNAGroup(param1_this, param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAStorage.storeDNAGroup() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "storeDNAGroup(non-const DNAStorage this, const PandaNode, const DNAGroup)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_store_DNAGroup_137_comment =
    "C++ Interface:\n"
    "storeDNAGroup(non-const DNAStorage this, const PandaNode, const DNAGroup)\n"
    "\n"
    "// DNAGroup functions\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: store_DNAGroup\n"
    "//       Access: Public\n"
    "//  Description: store a DNAGroup at the node path pointer\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_store_DNAGroup_137_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DNAStorage::remove_DNAGroup(PointerTo< DNAGroup > )
 * int DNAStorage::remove_DNAGroup(PointerTo< PandaNode > )
 *******************************************************************/
static PyObject *Dtool_DNAStorage_remove_DNAGroup_138(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 int DNAStorage::remove_DNAGroup(PointerTo< DNAGroup > )
            PyObject *param1;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeDNAGroup", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeDNAGroup", &param1));
            if(!PyErr_Occurred())
            {
                DNAGroup *param1_this = (DNAGroup *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNAGroup, 1, "DNAStorage.removeDNAGroup", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = (local_this)->remove_DNAGroup(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 int DNAStorage::remove_DNAGroup(PointerTo< PandaNode > )
            PyObject *param1;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeDNAGroup", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeDNAGroup", &param1));
            if(!PyErr_Occurred())
            {
                PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PandaNode, 1, "DNAStorage.removeDNAGroup", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = (local_this)->remove_DNAGroup(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeDNAGroup(non-const DNAStorage this, const DNAGroup)\n"
          "removeDNAGroup(non-const DNAStorage this, const PandaNode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_remove_DNAGroup_138_comment =
    "C++ Interface:\n"
    "removeDNAGroup(non-const DNAStorage this, const DNAGroup)\n"
    "removeDNAGroup(non-const DNAStorage this, const PandaNode)\n"
    "\n"
    "// DNAGroup functions\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: remove_DNAGroup\n"
    "//       Access: Public\n"
    "//  Description: remove the DNAGroup pointed to by rr from the map\n"
    "//               It also removes all children of the dnaGroup.\n"
    "//               Returns the total number of DNAGroups removed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: remove_DNAGroup\n"
    "//       Access: Public\n"
    "//  Description: remove the DNAGroup from the map\n"
    "//               It also removes all children of the dnaGroup.\n"
    "//               Returns the total number of DNAGroups removed.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_remove_DNAGroup_138_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< DNAGroup > DNAStorage::find_DNAGroup(PointerTo< PandaNode > ) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_find_DNAGroup_139(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-PointerTo< DNAGroup > DNAStorage::find_DNAGroup(PointerTo< PandaNode > ) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:findDNAGroup", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:findDNAGroup", &param1));
            if(!PyErr_Occurred())
            {
                PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PandaNode, 1, "DNAStorage.findDNAGroup", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    PointerTo< DNAGroup > return_value = ((const DNAStorage*)local_this)->find_DNAGroup(param1_this);
                    if (return_value != (DNAGroup *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value.p() == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_DNAGroup,true, false, (return_value.p())->as_typed_object()->get_type_index());
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findDNAGroup(const DNAStorage this, const PandaNode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_find_DNAGroup_139_comment =
    "C++ Interface:\n"
    "findDNAGroup(const DNAStorage this, const PandaNode)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: find_DNAGroup\n"
    "//       Access: Public\n"
    "//  Description: find a DNAGroup at the node path pointer\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_find_DNAGroup_139_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< PandaNode > DNAStorage::find_PandaNode(PointerTo< DNAGroup > ) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_find_PandaNode_140(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-PointerTo< PandaNode > DNAStorage::find_PandaNode(PointerTo< DNAGroup > ) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:findPandaNode", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:findPandaNode", &param1));
            if(!PyErr_Occurred())
            {
                DNAGroup *param1_this = (DNAGroup *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNAGroup, 1, "DNAStorage.findPandaNode", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    PointerTo< PandaNode > return_value = ((const DNAStorage*)local_this)->find_PandaNode(param1_this);
                    if (return_value != (PandaNode *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value.p() == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_PandaNode,true, false, (return_value.p())->as_typed_object()->get_type_index());
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findPandaNode(const DNAStorage this, const DNAGroup)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_find_PandaNode_140_comment =
    "C++ Interface:\n"
    "findPandaNode(const DNAStorage this, const DNAGroup)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: find_PandaNode\n"
    "//       Access: Public\n"
    "//  Description: find a PandaNode at the DNAGroup\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_find_PandaNode_140_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DNAStorage::get_zone_from_block_number(int block_number) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_zone_from_block_number_141(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DNAStorage::get_zone_from_block_number(int block_number) const
        int param1;
        static char * key_word_list[] = {(char *)"block_number", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getZoneFromBlockNumber", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getZoneFromBlockNumber", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DNAStorage*)local_this)->get_zone_from_block_number((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getZoneFromBlockNumber(const DNAStorage this, int block_number)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_zone_from_block_number_141_comment =
    "C++ Interface:\n"
    "getZoneFromBlockNumber(const DNAStorage this, int block_number)\n"
    "\n"
    "// Block number functions\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_zone_from_block_number\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_zone_from_block_number_141_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DNAStorage::get_block_number_at(unsigned int index) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_block_number_at_142(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DNAStorage::get_block_number_at(unsigned int index) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getBlockNumberAt", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getBlockNumberAt", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                int return_value = ((const DNAStorage*)local_this)->get_block_number_at(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBlockNumberAt(const DNAStorage this, unsigned int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_block_number_at_142_comment =
    "C++ Interface:\n"
    "getBlockNumberAt(const DNAStorage this, unsigned int index)\n"
    "\n"
    "// Block number functions\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_block_number_at\n"
    "//       Access: Public\n"
    "//  Description: Get key at index\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_block_number_at_142_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DNAStorage::get_num_block_numbers(void) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_num_block_numbers_143(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DNAStorage::get_num_block_numbers(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumBlockNumbers", key_word_list));
        else
            (PyArg_Parse(args, ":getNumBlockNumbers"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DNAStorage*)local_this)->get_num_block_numbers();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumBlockNumbers(const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_num_block_numbers_143_comment =
    "C++ Interface:\n"
    "getNumBlockNumbers(const DNAStorage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_num_block_number\n"
    "//       Access: Public\n"
    "//  Description: Ask how many block numbers\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_num_block_numbers_143_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PosHpr const &DNAStorage::get_door_pos_hpr_from_block_number(int block_number) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_door_pos_hpr_from_block_number_144(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PosHpr const &DNAStorage::get_door_pos_hpr_from_block_number(int block_number) const
        int param1;
        static char * key_word_list[] = {(char *)"block_number", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getDoorPosHprFromBlockNumber", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getDoorPosHprFromBlockNumber", &param1));
        if(!PyErr_Occurred())
        {
            PosHpr const *return_value = &(((const DNAStorage*)local_this)->get_door_pos_hpr_from_block_number((int)param1));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_PosHpr,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDoorPosHprFromBlockNumber(const DNAStorage this, int block_number)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_door_pos_hpr_from_block_number_144_comment =
    "C++ Interface:\n"
    "getDoorPosHprFromBlockNumber(const DNAStorage this, int block_number)\n"
    "\n"
    "// Block door pos hpr functions\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_door_pos_hpr_from_block_number\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_door_pos_hpr_from_block_number_144_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DNAStorage::get_door_pos_hpr_block_at(unsigned int index) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_door_pos_hpr_block_at_145(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DNAStorage::get_door_pos_hpr_block_at(unsigned int index) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getDoorPosHprBlockAt", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getDoorPosHprBlockAt", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                int return_value = ((const DNAStorage*)local_this)->get_door_pos_hpr_block_at(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDoorPosHprBlockAt(const DNAStorage this, unsigned int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_door_pos_hpr_block_at_145_comment =
    "C++ Interface:\n"
    "getDoorPosHprBlockAt(const DNAStorage this, unsigned int index)\n"
    "\n"
    "// Block door pos hpr functions\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_door_pos_hpr_block_at\n"
    "//       Access: Public\n"
    "//  Description: Get key at index\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_door_pos_hpr_block_at_145_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DNAStorage::get_num_block_door_pos_hprs(void) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_num_block_door_pos_hprs_146(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DNAStorage::get_num_block_door_pos_hprs(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumBlockDoorPosHprs", key_word_list));
        else
            (PyArg_Parse(args, ":getNumBlockDoorPosHprs"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DNAStorage*)local_this)->get_num_block_door_pos_hprs();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumBlockDoorPosHprs(const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_num_block_door_pos_hprs_146_comment =
    "C++ Interface:\n"
    "getNumBlockDoorPosHprs(const DNAStorage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_num_block_door_pos_hprs\n"
    "//       Access: Public\n"
    "//  Description: Ask how many block numbers\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_num_block_door_pos_hprs_146_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LMatrix4f const &DNAStorage::get_sign_transform_from_block_number(int block_number) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_sign_transform_from_block_number_147(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-LMatrix4f const &DNAStorage::get_sign_transform_from_block_number(int block_number) const
        int param1;
        static char * key_word_list[] = {(char *)"block_number", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getSignTransformFromBlockNumber", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getSignTransformFromBlockNumber", &param1));
        if(!PyErr_Occurred())
        {
            LMatrix4f const *return_value = &(((const DNAStorage*)local_this)->get_sign_transform_from_block_number((int)param1));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LMatrix4f,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSignTransformFromBlockNumber(const DNAStorage this, int block_number)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_sign_transform_from_block_number_147_comment =
    "C++ Interface:\n"
    "getSignTransformFromBlockNumber(const DNAStorage this, int block_number)\n"
    "\n"
    "// Block sign pos hpr functions\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_sign_transform_from_block_number\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_sign_transform_from_block_number_147_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DNAStorage::get_sign_transform_block_at(unsigned int index) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_sign_transform_block_at_148(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DNAStorage::get_sign_transform_block_at(unsigned int index) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getSignTransformBlockAt", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getSignTransformBlockAt", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                int return_value = ((const DNAStorage*)local_this)->get_sign_transform_block_at(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSignTransformBlockAt(const DNAStorage this, unsigned int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_sign_transform_block_at_148_comment =
    "C++ Interface:\n"
    "getSignTransformBlockAt(const DNAStorage this, unsigned int index)\n"
    "\n"
    "// Block sign pos hpr functions\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_sign_transform_block_at\n"
    "//       Access: Public\n"
    "//  Description: Get key at index\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_sign_transform_block_at_148_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DNAStorage::get_num_block_sign_transforms(void) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_num_block_sign_transforms_149(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DNAStorage::get_num_block_sign_transforms(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumBlockSignTransforms", key_word_list));
        else
            (PyArg_Parse(args, ":getNumBlockSignTransforms"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DNAStorage*)local_this)->get_num_block_sign_transforms();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumBlockSignTransforms(const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_num_block_sign_transforms_149_comment =
    "C++ Interface:\n"
    "getNumBlockSignTransforms(const DNAStorage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_num_block_sign_transforms\n"
    "//       Access: Public\n"
    "//  Description: Ask how many block numbers\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_num_block_sign_transforms_149_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStorage::reset_DNAGroups(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_DNAGroups_150(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNAStorage::reset_DNAGroups(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":resetDNAGroups", key_word_list));
        else
            (PyArg_Parse(args, ":resetDNAGroups"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_DNAGroups();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.resetDNAGroups() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetDNAGroups(non-const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_reset_DNAGroups_150_comment =
    "C++ Interface:\n"
    "resetDNAGroups(non-const DNAStorage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: reset_DNAGroups\n"
    "//       Access: Public\n"
    "//  Description: clear out the map of DNAGroups\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_reset_DNAGroups_150_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DNAStorage::get_title_from_block_number(int block_number) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_title_from_block_number_151(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > DNAStorage::get_title_from_block_number(int block_number) const
        int param1;
        static char * key_word_list[] = {(char *)"block_number", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getTitleFromBlockNumber", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getTitleFromBlockNumber", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DNAStorage*)local_this)->get_title_from_block_number((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTitleFromBlockNumber(const DNAStorage this, int block_number)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_title_from_block_number_151_comment =
    "C++ Interface:\n"
    "getTitleFromBlockNumber(const DNAStorage this, int block_number)\n"
    "\n"
    "// Block title functions\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_title_from_block_number\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_title_from_block_number_151_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DNAStorage::get_title_block_at(unsigned int index) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_title_block_at_152(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DNAStorage::get_title_block_at(unsigned int index) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getTitleBlockAt", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getTitleBlockAt", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                int return_value = ((const DNAStorage*)local_this)->get_title_block_at(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTitleBlockAt(const DNAStorage this, unsigned int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_title_block_at_152_comment =
    "C++ Interface:\n"
    "getTitleBlockAt(const DNAStorage this, unsigned int index)\n"
    "\n"
    "// Block title functions\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_title_block_at\n"
    "//       Access: Public\n"
    "//  Description: Get key at index\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_title_block_at_152_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DNAStorage::get_num_block_titles(void) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_num_block_titles_153(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DNAStorage::get_num_block_titles(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumBlockTitles", key_word_list));
        else
            (PyArg_Parse(args, ":getNumBlockTitles"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DNAStorage*)local_this)->get_num_block_titles();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumBlockTitles(const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_num_block_titles_153_comment =
    "C++ Interface:\n"
    "getNumBlockTitles(const DNAStorage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_num_block_titles\n"
    "//       Access: Public\n"
    "//  Description: Ask how many block numbers\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_num_block_titles_153_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DNAStorage::get_article_from_block_number(int block_number) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_article_from_block_number_154(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > DNAStorage::get_article_from_block_number(int block_number) const
        int param1;
        static char * key_word_list[] = {(char *)"block_number", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getArticleFromBlockNumber", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getArticleFromBlockNumber", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DNAStorage*)local_this)->get_article_from_block_number((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getArticleFromBlockNumber(const DNAStorage this, int block_number)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_article_from_block_number_154_comment =
    "C++ Interface:\n"
    "getArticleFromBlockNumber(const DNAStorage this, int block_number)\n"
    "\n"
    "// Block article functions\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_article_from_block_number\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_article_from_block_number_154_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_block_building_type(basic_string< char > const &block, basic_string< char > const &type)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_block_building_type_155(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNAStorage::store_block_building_type(basic_string< char > const &block, basic_string< char > const &type)
        char *param1_str; int param1_len;
        char *param2_str; int param2_len;
        static char * key_word_list[] = {(char *)"block", (char *)"type", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "s#s#:storeBlockBuildingType", key_word_list, &param1_str, &param1_len, &param2_str, &param2_len))
        {
            (local_this)->store_block_building_type(basic_string<char>(param1_str, param1_len), basic_string<char>(param2_str, param2_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.storeBlockBuildingType() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "storeBlockBuildingType(non-const DNAStorage this, string block, string type)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_store_block_building_type_155_comment =
    "C++ Interface:\n"
    "storeBlockBuildingType(non-const DNAStorage this, string block, string type)\n"
    "\n"
    "// Block building type functions\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: store_block_building_type\n"
    "//       Access: Public\n"
    "//  Description: Store a block and zone\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_store_block_building_type_155_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DNAStorage::get_block_building_type(int block_number) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_block_building_type_156(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > DNAStorage::get_block_building_type(int block_number) const
        int param1;
        static char * key_word_list[] = {(char *)"block_number", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getBlockBuildingType", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getBlockBuildingType", &param1));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DNAStorage*)local_this)->get_block_building_type((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBlockBuildingType(const DNAStorage this, int block_number)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_block_building_type_156_comment =
    "C++ Interface:\n"
    "getBlockBuildingType(const DNAStorage this, int block_number)\n"
    "\n"
    "// Block building type functions\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_block_building_type\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_block_building_type_156_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStorage::store_DNAVisGroup(PointerTo< PandaNode > , PointerTo< DNAVisGroup > )
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_DNAVisGroup_157(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DNAStorage::store_DNAVisGroup(PointerTo< PandaNode > , PointerTo< DNAVisGroup > )
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"param0", (char *)"param1", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:storeDNAVisGroup", key_word_list, &param1, &param2))
            {
                PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PandaNode, 1, "DNAStorage.storeDNAVisGroup", 1, coerced_ptr, report_errors);
DNAVisGroup *param2_this = (DNAVisGroup *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DNAVisGroup, 2, "DNAStorage.storeDNAVisGroup", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    (local_this)->store_DNAVisGroup(param1_this, param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAStorage.storeDNAVisGroup() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "storeDNAVisGroup(non-const DNAStorage this, const PandaNode, const DNAVisGroup)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_store_DNAVisGroup_157_comment =
    "C++ Interface:\n"
    "storeDNAVisGroup(non-const DNAStorage this, const PandaNode, const DNAVisGroup)\n"
    "\n"
    "// VisGroup functions\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: store_DNAVisGroup\n"
    "//       Access: Public\n"
    "//  Description: store a DNAVisGroup at the node path pointer\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_store_DNAVisGroup_157_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DNAStorage::remove_DNAVisGroup(PointerTo< PandaNode > )
 *******************************************************************/
static PyObject *Dtool_DNAStorage_remove_DNAVisGroup_158(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline int DNAStorage::remove_DNAVisGroup(PointerTo< PandaNode > )
            PyObject *param1;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeDNAVisGroup", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeDNAVisGroup", &param1));
            if(!PyErr_Occurred())
            {
                PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PandaNode, 1, "DNAStorage.removeDNAVisGroup", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = (local_this)->remove_DNAVisGroup(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAStorage.removeDNAVisGroup() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeDNAVisGroup(non-const DNAStorage this, const PandaNode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_remove_DNAVisGroup_158_comment =
    "C++ Interface:\n"
    "removeDNAVisGroup(non-const DNAStorage this, const PandaNode)\n"
    "\n"
    "// VisGroup functions\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: remove_DNAVisGroup\n"
    "//       Access: Public\n"
    "//  Description: remove the DNAVisGroup pointed to by rr from the map\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_remove_DNAVisGroup_158_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< DNAVisGroup > DNAStorage::find_DNAVisGroup(PointerTo< PandaNode > ) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_find_DNAVisGroup_159(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-PointerTo< DNAVisGroup > DNAStorage::find_DNAVisGroup(PointerTo< PandaNode > ) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:findDNAVisGroup", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:findDNAVisGroup", &param1));
            if(!PyErr_Occurred())
            {
                PandaNode *param1_this = (PandaNode *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PandaNode, 1, "DNAStorage.findDNAVisGroup", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    PointerTo< DNAVisGroup > return_value = ((const DNAStorage*)local_this)->find_DNAVisGroup(param1_this);
                    if (return_value != (DNAVisGroup *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value.p() == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_DNAVisGroup,true, false, (return_value.p())->as_typed_object()->get_type_index());
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "findDNAVisGroup(const DNAStorage this, const PandaNode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_find_DNAVisGroup_159_comment =
    "C++ Interface:\n"
    "findDNAVisGroup(const DNAStorage this, const PandaNode)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: find_DNAVisGroup\n"
    "//       Access: Public\n"
    "//  Description: find a DNAVisGroup at the node path pointer\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_find_DNAVisGroup_159_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStorage::reset_DNAVisGroups(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_DNAVisGroups_160(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNAStorage::reset_DNAVisGroups(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":resetDNAVisGroups", key_word_list));
        else
            (PyArg_Parse(args, ":resetDNAVisGroups"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_DNAVisGroups();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.resetDNAVisGroups() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetDNAVisGroups(non-const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_reset_DNAVisGroups_160_comment =
    "C++ Interface:\n"
    "resetDNAVisGroups(non-const DNAStorage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: reset_DNAVisGroups\n"
    "//       Access: Public\n"
    "//  Description: clear out the map of DNAVisGroups\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_reset_DNAVisGroups_160_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DNAStorage::get_num_DNAVisGroups(void) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_num_DNAVisGroups_161(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DNAStorage::get_num_DNAVisGroups(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumDNAVisGroups", key_word_list));
        else
            (PyArg_Parse(args, ":getNumDNAVisGroups"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DNAStorage*)local_this)->get_num_DNAVisGroups();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumDNAVisGroups(const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_num_DNAVisGroups_161_comment =
    "C++ Interface:\n"
    "getNumDNAVisGroups(const DNAStorage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_num_DNAVisGroups\n"
    "//       Access: Public\n"
    "//  Description: Ask how many vis groups this dna store knows about\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_num_DNAVisGroups_161_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< DNAVisGroup > DNAStorage::get_DNAVisGroup(unsigned int i) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_DNAVisGroup_162(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PointerTo< DNAVisGroup > DNAStorage::get_DNAVisGroup(unsigned int i) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"i", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getDNAVisGroup", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getDNAVisGroup", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                PointerTo< DNAVisGroup > return_value = ((const DNAStorage*)local_this)->get_DNAVisGroup(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (return_value != (DNAVisGroup *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value.p() == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_DNAVisGroup,true, false, (return_value.p())->as_typed_object()->get_type_index());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDNAVisGroup(const DNAStorage this, unsigned int i)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_DNAVisGroup_162_comment =
    "C++ Interface:\n"
    "getDNAVisGroup(const DNAStorage this, unsigned int i)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_DNAVisGroup\n"
    "//       Access: Public\n"
    "//  Description: Return the ith vis group in our storage\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_DNAVisGroup_162_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DNAStorage::get_num_visibles_in_DNAVisGroup(unsigned int i) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_num_visibles_in_DNAVisGroup_163(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int DNAStorage::get_num_visibles_in_DNAVisGroup(unsigned int i) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"i", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getNumVisiblesInDNAVisGroup", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getNumVisiblesInDNAVisGroup", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                int return_value = ((const DNAStorage*)local_this)->get_num_visibles_in_DNAVisGroup(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumVisiblesInDNAVisGroup(const DNAStorage this, unsigned int i)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_num_visibles_in_DNAVisGroup_163_comment =
    "C++ Interface:\n"
    "getNumVisiblesInDNAVisGroup(const DNAStorage this, unsigned int i)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_num_visibles_in_DNAVisGroup\n"
    "//       Access: Public\n"
    "//  Description: Ask how many visibles there are in this visgroup\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_num_visibles_in_DNAVisGroup_163_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DNAStorage::get_DNAVisGroup_name(unsigned int i) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_DNAVisGroup_name_164(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > DNAStorage::get_DNAVisGroup_name(unsigned int i) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"i", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getDNAVisGroupName", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getDNAVisGroupName", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                basic_string< char > return_value = ((const DNAStorage*)local_this)->get_DNAVisGroup_name(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDNAVisGroupName(const DNAStorage this, unsigned int i)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_DNAVisGroup_name_164_comment =
    "C++ Interface:\n"
    "getDNAVisGroupName(const DNAStorage this, unsigned int i)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_DNAVisGroup_name\n"
    "//       Access: Public\n"
    "//  Description: Ask for the name of the nth DNAVisGroup in the map\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_DNAVisGroup_name_164_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DNAStorage::get_visible_name(unsigned int visgroup_index, unsigned int visible_index) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_visible_name_165(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > DNAStorage::get_visible_name(unsigned int visgroup_index, unsigned int visible_index) const
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"visgroup_index", (char *)"visible_index", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getVisibleName", key_word_list, &param1, &param2))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                basic_string< char > return_value = ((const DNAStorage*)local_this)->get_visible_name(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint));
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getVisibleName(const DNAStorage this, unsigned int visgroup_index, unsigned int visible_index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_visible_name_165_comment =
    "C++ Interface:\n"
    "getVisibleName(const DNAStorage this, unsigned int visgroup_index, unsigned int visible_index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_visible_name\n"
    "//       Access: Public\n"
    "//  Description: Ask for the name of the nth visible in the nth DNAVisGroup\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_visible_name_165_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::store_DNAVisGroupAI(PointerTo< DNAVisGroup > )
 *******************************************************************/
static PyObject *Dtool_DNAStorage_store_DNAVisGroupAI_166(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DNAStorage::store_DNAVisGroupAI(PointerTo< DNAVisGroup > )
            PyObject *param1;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:storeDNAVisGroupAI", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:storeDNAVisGroupAI", &param1));
            if(!PyErr_Occurred())
            {
                DNAVisGroup *param1_this = (DNAVisGroup *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNAVisGroup, 1, "DNAStorage.storeDNAVisGroupAI", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->store_DNAVisGroupAI(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAStorage.storeDNAVisGroupAI() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "storeDNAVisGroupAI(non-const DNAStorage this, const DNAVisGroup)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_store_DNAVisGroupAI_166_comment =
    "C++ Interface:\n"
    "storeDNAVisGroupAI(non-const DNAStorage this, const DNAVisGroup)\n"
    "\n"
    "// For the AI, he does not traverse but still needs vis groups\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: store_DNAVisGroupAI\n"
    "//       Access: Public\n"
    "//  Description: store a DNAVisGroup in a vector so the AI can\n"
    "//               retrieve it without traversing the DNA\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_store_DNAVisGroupAI_166_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DNAStorage::get_num_DNAVisGroupsAI(void) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_num_DNAVisGroupsAI_167(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DNAStorage::get_num_DNAVisGroupsAI(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumDNAVisGroupsAI", key_word_list));
        else
            (PyArg_Parse(args, ":getNumDNAVisGroupsAI"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DNAStorage*)local_this)->get_num_DNAVisGroupsAI();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumDNAVisGroupsAI(const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_num_DNAVisGroupsAI_167_comment =
    "C++ Interface:\n"
    "getNumDNAVisGroupsAI(const DNAStorage this)\n"
    "\n"
    "// For the AI, he does not traverse but still needs vis groups\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_num_DNAVisGroupsAI\n"
    "//       Access: Public\n"
    "//  Description: Ask how many vis groups this dna store knows about\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_num_DNAVisGroupsAI_167_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PointerTo< DNAVisGroup > DNAStorage::get_DNAVisGroupAI(unsigned int i) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_DNAVisGroupAI_168(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PointerTo< DNAVisGroup > DNAStorage::get_DNAVisGroupAI(unsigned int i) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"i", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getDNAVisGroupAI", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getDNAVisGroupAI", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                PointerTo< DNAVisGroup > return_value = ((const DNAStorage*)local_this)->get_DNAVisGroupAI(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (return_value != (DNAVisGroup *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value.p() == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_DNAVisGroup,true, false, (return_value.p())->as_typed_object()->get_type_index());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDNAVisGroupAI(const DNAStorage this, unsigned int i)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_DNAVisGroupAI_168_comment =
    "C++ Interface:\n"
    "getDNAVisGroupAI(const DNAStorage this, unsigned int i)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_DNAVisGroupAI\n"
    "//       Access: Public\n"
    "//  Description: Return the ith vis group in our storage\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_DNAVisGroupAI_168_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStorage::reset_DNAVisGroupsAI(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_reset_DNAVisGroupsAI_169(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNAStorage::reset_DNAVisGroupsAI(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":resetDNAVisGroupsAI", key_word_list));
        else
            (PyArg_Parse(args, ":resetDNAVisGroupsAI"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_DNAVisGroupsAI();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.resetDNAVisGroupsAI() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetDNAVisGroupsAI(non-const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_reset_DNAVisGroupsAI_169_comment =
    "C++ Interface:\n"
    "resetDNAVisGroupsAI(non-const DNAStorage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: reset_DNAVisGroupsAI\n"
    "//       Access: Public\n"
    "//  Description: clear out the vector of DNAVisGroups\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_reset_DNAVisGroupsAI_169_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DNAStorage::get_num_PandaNodes(void) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_num_PandaNodes_170(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DNAStorage::get_num_PandaNodes(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumPandaNodes", key_word_list));
        else
            (PyArg_Parse(args, ":getNumPandaNodes"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DNAStorage*)local_this)->get_num_PandaNodes();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumPandaNodes(const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_num_PandaNodes_170_comment =
    "C++ Interface:\n"
    "getNumPandaNodes(const DNAStorage this)\n"
    "\n"
    "// Node relation functions\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_num_PandaNodes\n"
    "//       Access: Public\n"
    "//  Description: how many node paths do we have in our map\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_num_PandaNodes_170_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< PandaNode > DNAStorage::get_PandaNode_at(unsigned int i) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_PandaNode_at_171(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-PointerTo< PandaNode > DNAStorage::get_PandaNode_at(unsigned int i) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"i", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getPandaNodeAt", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getPandaNodeAt", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                PointerTo< PandaNode > return_value = ((const DNAStorage*)local_this)->get_PandaNode_at(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (return_value != (PandaNode *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value.p() == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_PandaNode,true, false, (return_value.p())->as_typed_object()->get_type_index());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPandaNodeAt(const DNAStorage this, unsigned int i)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_PandaNode_at_171_comment =
    "C++ Interface:\n"
    "getPandaNodeAt(const DNAStorage this, unsigned int i)\n"
    "\n"
    "// Node relation functions\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_PandaNode_at\n"
    "//       Access: Public\n"
    "//  Description: return the ith NodePath\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_PandaNode_at_171_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::print_PandaNodes(void) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_print_PandaNodes_172(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-void DNAStorage::print_PandaNodes(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":printPandaNodes", key_word_list));
        else
            (PyArg_Parse(args, ":printPandaNodes"));
        if(!PyErr_Occurred())
        {
            ((const DNAStorage*)local_this)->print_PandaNodes();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "printPandaNodes(const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_print_PandaNodes_172_comment =
    "C++ Interface:\n"
    "printPandaNodes(const DNAStorage this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNAStorage_print_PandaNodes_172_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DNAStorage::get_suit_edge_zone(int start_index, int end_index) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_suit_edge_zone_173(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > DNAStorage::get_suit_edge_zone(int start_index, int end_index) const
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"start_index", (char *)"end_index", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getSuitEdgeZone", key_word_list, &param1, &param2))
        {
            basic_string< char > return_value = ((const DNAStorage*)local_this)->get_suit_edge_zone((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSuitEdgeZone(const DNAStorage this, int start_index, int end_index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_suit_edge_zone_173_comment =
    "C++ Interface:\n"
    "getSuitEdgeZone(const DNAStorage this, int start_index, int end_index)\n"
    "\n"
    "// Suit point functions\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_suit_edge_zone\n"
    "//       Access: Public\n"
    "//  Description: Ask for the zone that this edge is in\n"
    "//               Returns -1 if there is no edge between these points\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_suit_edge_zone_173_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float DNAStorage::get_suit_edge_travel_time(int start_index, int end_index, float rate) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_suit_edge_travel_time_174(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-float DNAStorage::get_suit_edge_travel_time(int start_index, int end_index, float rate) const
        int param1;
        int param2;
        double param3;
        static char * key_word_list[] = {(char *)"start_index", (char *)"end_index", (char *)"rate", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "iid:getSuitEdgeTravelTime", key_word_list, &param1, &param2, &param3))
        {
            float return_value = ((const DNAStorage*)local_this)->get_suit_edge_travel_time((int)param1, (int)param2, (float)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSuitEdgeTravelTime(const DNAStorage this, int start_index, int end_index, float rate)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_suit_edge_travel_time_174_comment =
    "C++ Interface:\n"
    "getSuitEdgeTravelTime(const DNAStorage this, int start_index, int end_index, float rate)\n"
    "\n"
    "// Suit point functions\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_suit_travel_time\n"
    "//       Access: Public\n"
    "//  Description: Ask how long in seconds it will take a suit to walk\n"
    "//               from the start point to the end point if he is\n"
    "//               walking this constant rate in units/second\n"
    "//               If there is not connection, return -1.0\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_suit_edge_travel_time_174_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DNAStorage::get_num_suit_points(void) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_num_suit_points_175(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DNAStorage::get_num_suit_points(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumSuitPoints", key_word_list));
        else
            (PyArg_Parse(args, ":getNumSuitPoints"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DNAStorage*)local_this)->get_num_suit_points();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumSuitPoints(const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_num_suit_points_175_comment =
    "C++ Interface:\n"
    "getNumSuitPoints(const DNAStorage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_num_suit_points\n"
    "//       Access: Public\n"
    "//  Description: How many suit points are in the map now?\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_num_suit_points_175_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PointerTo< DNASuitPoint > DNAStorage::get_suit_point_at_index(int index) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_suit_point_at_index_176(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PointerTo< DNASuitPoint > DNAStorage::get_suit_point_at_index(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getSuitPointAtIndex", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getSuitPointAtIndex", &param1));
        if(!PyErr_Occurred())
        {
            PointerTo< DNASuitPoint > return_value = ((const DNAStorage*)local_this)->get_suit_point_at_index((int)param1);
            if (return_value != (DNASuitPoint *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_DNASuitPoint,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSuitPointAtIndex(const DNAStorage this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_suit_point_at_index_176_comment =
    "C++ Interface:\n"
    "getSuitPointAtIndex(const DNAStorage this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_suit_point_at_index\n"
    "//       Access: Private\n"
    "//  Description: Convient way to return the point at index internally\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_suit_point_at_index_176_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PointerTo< DNASuitPoint > DNAStorage::get_suit_point_with_index(int index) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_suit_point_with_index_177(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PointerTo< DNASuitPoint > DNAStorage::get_suit_point_with_index(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getSuitPointWithIndex", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getSuitPointWithIndex", &param1));
        if(!PyErr_Occurred())
        {
            PointerTo< DNASuitPoint > return_value = ((const DNAStorage*)local_this)->get_suit_point_with_index((int)param1);
            if (return_value != (DNASuitPoint *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_DNASuitPoint,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSuitPointWithIndex(const DNAStorage this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_suit_point_with_index_177_comment =
    "C++ Interface:\n"
    "getSuitPointWithIndex(const DNAStorage this, int index)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_suit_point_with_index\n"
    "//       Access: Private\n"
    "//  Description: Convient way to return the point at index internally\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_suit_point_with_index_177_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< DNASuitPath > DNAStorage::get_suit_path(DNASuitPoint const *start_point, DNASuitPoint const *end_point, int min_length, int max_length) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_suit_path_178(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-PointerTo< DNASuitPath > DNAStorage::get_suit_path(DNASuitPoint const *start_point, DNASuitPoint const *end_point, int min_length, int max_length) const
            PyObject *param1;
            PyObject *param2;
            int param3;
            int param4;
            static char * key_word_list[] = {(char *)"start_point", (char *)"end_point", (char *)"min_length", (char *)"max_length", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOii:getSuitPath", key_word_list, &param1, &param2, &param3, &param4))
            {
                DNASuitPoint *param1_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNASuitPoint, 1, "DNAStorage.getSuitPath", 1, coerced_ptr, report_errors);
DNASuitPoint *param2_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_DNASuitPoint, 2, "DNAStorage.getSuitPath", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    PointerTo< DNASuitPath > return_value = ((const DNAStorage*)local_this)->get_suit_path(param1_this, param2_this, (int)param3, (int)param4);
                    if (return_value != (DNASuitPath *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value.p() == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_DNASuitPath,true, false, (return_value.p())->as_typed_object()->get_type_index());
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSuitPath(const DNAStorage this, const DNASuitPoint start_point, const DNASuitPoint end_point, int min_length, int max_length)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_suit_path_178_comment =
    "C++ Interface:\n"
    "getSuitPath(const DNAStorage this, const DNASuitPoint start_point, const DNASuitPoint end_point, int min_length, int max_length)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_suit_path\n"
    "//       Access: Public\n"
    "//  Description: Find a valid path from start to end for a suit to\n"
    "//               walk on given all the points and edges that are\n"
    "//               loaded in the current branch\n"
    "//               To make this easy, the SuitStartPointMap is organized\n"
    "//               as a map of points to edge lists that that point starts\n"
    "//               {\n"
    "//                 start_point1 { edge1 edge2 edge3 }\n"
    "//                 start_point2 { edge4 edge5 }\n"
    "//                 start_point3 { edge6 edge7 edge8 }\n"
    "//               }\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_suit_path_178_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< DNASuitPath > DNAStorage::get_adjacent_points(PointerTo< DNASuitPoint > start_point) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_adjacent_points_179(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-PointerTo< DNASuitPath > DNAStorage::get_adjacent_points(PointerTo< DNASuitPoint > start_point) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"start_point", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getAdjacentPoints", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getAdjacentPoints", &param1));
            if(!PyErr_Occurred())
            {
                DNASuitPoint *param1_this = (DNASuitPoint *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNASuitPoint, 1, "DNAStorage.getAdjacentPoints", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    PointerTo< DNASuitPath > return_value = ((const DNAStorage*)local_this)->get_adjacent_points(param1_this);
                    if (return_value != (DNASuitPath *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value.p() == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_DNASuitPath,true, false, (return_value.p())->as_typed_object()->get_type_index());
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAdjacentPoints(const DNAStorage this, const DNASuitPoint start_point)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_adjacent_points_179_comment =
    "C++ Interface:\n"
    "getAdjacentPoints(const DNAStorage this, const DNASuitPoint start_point)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_adjacent_points\n"
    "//       Access: Public\n"
    "//  Description: Returns all of the points adjacent to the indicated\n"
    "//               point.  The result is returned as a DNASuitPath, even\n"
    "//               though it's not actually a path; it's just a set of\n"
    "//               points.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_adjacent_points_179_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int DNAStorage::discover_continuity(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_discover_continuity_180(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int DNAStorage::discover_continuity(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":discoverContinuity", key_word_list));
        else
            (PyArg_Parse(args, ":discoverContinuity"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->discover_continuity();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.discoverContinuity() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "discoverContinuity(non-const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_discover_continuity_180_comment =
    "C++ Interface:\n"
    "discoverContinuity(non-const DNAStorage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: discover_continuity\n"
    "//       Access: Public\n"
    "//  Description: This should be called once the DNA file has been read\n"
    "//               and the set of suit points is complete.  It walks\n"
    "//               through the points and discovers which points are\n"
    "//               connected to each other and which are not.  Each\n"
    "//               group of suit points that can be reached from each\n"
    "//               other are assigned a unique graph_id number, which\n"
    "//               has no other meaning.  The return value is the number\n"
    "//               of disconnected graphs we have.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_discover_continuity_180_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DNAStorage::get_block(basic_string< char > const &name) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_get_block_181(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > DNAStorage::get_block(basic_string< char > const &name) const
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:getBlock", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:getBlock", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DNAStorage*)local_this)->get_block(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBlock(const DNAStorage this, string name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_get_block_181_comment =
    "C++ Interface:\n"
    "getBlock(const DNAStorage this, string name)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: get_block\n"
    "//       Access: Public\n"
    "//  Description: Get the block number as a string from the building\n"
    "//               name.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_get_block_181_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::fixup(void)
 *******************************************************************/
static PyObject *Dtool_DNAStorage_fixup_182(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNAStorage::fixup(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":fixup", key_word_list));
        else
            (PyArg_Parse(args, ":fixup"));
        if(!PyErr_Occurred())
        {
            (local_this)->fixup();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStorage.fixup() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "fixup(non-const DNAStorage this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_fixup_182_comment =
    "C++ Interface:\n"
    "fixup(non-const DNAStorage this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: fixup\n"
    "//       Access: Public\n"
    "//  Description: Do any processing here before we write the file\n"
    "//               to cleanup or fixup the dna storage\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_fixup_182_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAStorage::write(ostream &out, int indent_level) const
 *******************************************************************/
static PyObject *Dtool_DNAStorage_write_183(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void DNAStorage::write(ostream &out, int indent_level) const
            PyObject *param1;
            int param2;
            static char * key_word_list[] = {(char *)"out", (char *)"indent_level", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:write", key_word_list, &param1, &param2))
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DNAStorage.write", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const DNAStorage*)local_this)->write(*param1_this, (int)param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "write(const DNAStorage this, non-const Ostream out, int indent_level)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStorage_write_183_comment =
    "C++ Interface:\n"
    "write(const DNAStorage this, non-const Ostream out, int indent_level)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: write\n"
    "//       Access: Public\n"
    "//  Description: Write out to the dna file whatever the storage\n"
    "//               feels it needs to. For instance, the suit points.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStorage_write_183_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAStorage::DNAStorage(void)
 *******************************************************************/
int  Dtool_Init_DNAStorage(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-DNAStorage::DNAStorage(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":DNAStorage", key_word_list))
        {
            DNAStorage *return_value = new DNAStorage();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAStorage,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DNAStorage()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNAStorage(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNAStorage)
    {
        printf("DNAStorage ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNAStorage * local_this = (DNAStorage *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNAStorage)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNAStorage(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNAStorage)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNANode 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DNANode::set_pos(LVecBase3f const &pos)
 *******************************************************************/
static PyObject *Dtool_DNANode_set_pos_187(PyObject *self, PyObject *args,PyObject *kwds) {
    DNANode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNANode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DNANode::set_pos(LVecBase3f const &pos)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"pos", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setPos", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setPos", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "DNANode.setPos", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_pos(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNANode.setPos() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPos(non-const DNANode this, const VBase3 pos)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNANode_set_pos_187_comment =
    "C++ Interface:\n"
    "setPos(non-const DNANode this, const VBase3 pos)\n"
    "\n"
    "";
#else
static const char * Dtool_DNANode_set_pos_187_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f DNANode::get_pos(void) const
 *******************************************************************/
static PyObject *Dtool_DNANode_get_pos_188(PyObject *self, PyObject *args,PyObject *kwds) {
    DNANode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNANode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f DNANode::get_pos(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPos", key_word_list));
        else
            (PyArg_Parse(args, ":getPos"));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const DNANode*)local_this)->get_pos();
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPos(const DNANode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNANode_get_pos_188_comment =
    "C++ Interface:\n"
    "getPos(const DNANode this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNANode_get_pos_188_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNANode::set_hpr(LVecBase3f const &hpr)
 *******************************************************************/
static PyObject *Dtool_DNANode_set_hpr_189(PyObject *self, PyObject *args,PyObject *kwds) {
    DNANode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNANode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DNANode::set_hpr(LVecBase3f const &hpr)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"hpr", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setHpr", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setHpr", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "DNANode.setHpr", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_hpr(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNANode.setHpr() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setHpr(non-const DNANode this, const VBase3 hpr)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNANode_set_hpr_189_comment =
    "C++ Interface:\n"
    "setHpr(non-const DNANode this, const VBase3 hpr)\n"
    "\n"
    "";
#else
static const char * Dtool_DNANode_set_hpr_189_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f DNANode::get_hpr(void) const
 *******************************************************************/
static PyObject *Dtool_DNANode_get_hpr_190(PyObject *self, PyObject *args,PyObject *kwds) {
    DNANode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNANode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f DNANode::get_hpr(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHpr", key_word_list));
        else
            (PyArg_Parse(args, ":getHpr"));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const DNANode*)local_this)->get_hpr();
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHpr(const DNANode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNANode_get_hpr_190_comment =
    "C++ Interface:\n"
    "getHpr(const DNANode this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNANode_get_hpr_190_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNANode::set_scale(LVecBase3f const &scale)
 *******************************************************************/
static PyObject *Dtool_DNANode_set_scale_191(PyObject *self, PyObject *args,PyObject *kwds) {
    DNANode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNANode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DNANode::set_scale(LVecBase3f const &scale)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"scale", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setScale", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setScale", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "DNANode.setScale", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_scale(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNANode.setScale() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setScale(non-const DNANode this, const VBase3 scale)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNANode_set_scale_191_comment =
    "C++ Interface:\n"
    "setScale(non-const DNANode this, const VBase3 scale)\n"
    "\n"
    "";
#else
static const char * Dtool_DNANode_set_scale_191_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f DNANode::get_scale(void) const
 *******************************************************************/
static PyObject *Dtool_DNANode_get_scale_192(PyObject *self, PyObject *args,PyObject *kwds) {
    DNANode * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNANode,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f DNANode::get_scale(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getScale", key_word_list));
        else
            (PyArg_Parse(args, ":getScale"));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const DNANode*)local_this)->get_scale();
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getScale(const DNANode this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNANode_get_scale_192_comment =
    "C++ Interface:\n"
    "getScale(const DNANode this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNANode_get_scale_192_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNANode::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNANode_get_class_type_193(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DNANode::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DNANode::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNANode_get_class_type_193_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DNANode_get_class_type_193_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNANode::DNANode(DNANode const &node)
 * DNANode::DNANode(basic_string< char > const &initial_name)
 *******************************************************************/
int  Dtool_Init_DNANode(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 DNANode::DNANode(DNANode const &node)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"node", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:DNANode", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:DNANode", &param0));
            if(!PyErr_Occurred())
            {
                DNANode *param0_this = (DNANode *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNANode, 0, "DNANode.DNANode", 1, NULL, true);

                if (!((param0_this == NULL)))
                {
                    DNANode *return_value = new DNANode(*param0_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_DNANode,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 DNANode::DNANode(basic_string< char > const &initial_name)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"initial_name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNANode", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:DNANode", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                DNANode *return_value = new DNANode(basic_string<char>(param0_str, param0_len));
                return_value->ref();
                Py_XDECREF(coerced);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DNANode,true,false);
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DNANode(const DNANode node)\n"
          "DNANode(string initial_name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNANode(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNANode)
    {
        printf("DNANode ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNANode * local_this = (DNANode *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNANode)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( DNAGroup *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( DNAGroup *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( DNAGroup *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( DNAGroup *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNANode(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNANode)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNANode*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (DNANode*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (DNANode*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DNANode*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (DNANode*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNAWall 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DNAWall::set_code(basic_string< char > code)
 *******************************************************************/
static PyObject *Dtool_DNAWall_set_code_197(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAWall * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAWall,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNAWall::set_code(basic_string< char > code)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"code", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setCode", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setCode", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_code(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAWall.setCode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCode(non-const DNAWall this, string code)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAWall_set_code_197_comment =
    "C++ Interface:\n"
    "setCode(non-const DNAWall this, string code)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAWall::set_code\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAWall_set_code_197_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNAWall::get_code(void) const
 *******************************************************************/
static PyObject *Dtool_DNAWall_get_code_198(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAWall * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAWall,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > DNAWall::get_code(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCode", key_word_list));
        else
            (PyArg_Parse(args, ":getCode"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DNAWall*)local_this)->get_code();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCode(const DNAWall this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAWall_get_code_198_comment =
    "C++ Interface:\n"
    "getCode(const DNAWall this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAWall::get_code\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAWall_get_code_198_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAWall::set_height(float height)
 *******************************************************************/
static PyObject *Dtool_DNAWall_set_height_199(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAWall * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAWall,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNAWall::set_height(float height)
        double param1;
        static char * key_word_list[] = {(char *)"height", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setHeight", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setHeight", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_height((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAWall.setHeight() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setHeight(non-const DNAWall this, float height)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAWall_set_height_199_comment =
    "C++ Interface:\n"
    "setHeight(non-const DNAWall this, float height)\n"
    "\n"
    "// Filename: dnaBuildings.I\n"
    "// Created by:  shochet (28Mar00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAWall::set_height\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAWall_set_height_199_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DNAWall::get_height(void) const
 *******************************************************************/
static PyObject *Dtool_DNAWall_get_height_200(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAWall * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAWall,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DNAWall::get_height(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHeight", key_word_list));
        else
            (PyArg_Parse(args, ":getHeight"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DNAWall*)local_this)->get_height();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHeight(const DNAWall this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAWall_get_height_200_comment =
    "C++ Interface:\n"
    "getHeight(const DNAWall this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAWall::get_height\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAWall_get_height_200_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAWall::set_color(LVecBase4f const &color)
 *******************************************************************/
static PyObject *Dtool_DNAWall_set_color_201(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAWall * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAWall,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DNAWall::set_color(LVecBase4f const &color)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"color", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setColor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setColor", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "DNAWall.setColor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_color(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAWall.setColor() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setColor(non-const DNAWall this, const VBase4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAWall_set_color_201_comment =
    "C++ Interface:\n"
    "setColor(non-const DNAWall this, const VBase4 color)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAWall::set_color\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAWall_set_color_201_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f DNAWall::get_color(void) const
 *******************************************************************/
static PyObject *Dtool_DNAWall_get_color_202(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAWall * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAWall,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f DNAWall::get_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getColor", key_word_list));
        else
            (PyArg_Parse(args, ":getColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = ((const DNAWall*)local_this)->get_color();
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getColor(const DNAWall this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAWall_get_color_202_comment =
    "C++ Interface:\n"
    "getColor(const DNAWall this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAWall::get_color\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAWall_get_color_202_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNAWall::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNAWall_get_class_type_203(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DNAWall::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DNAWall::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAWall_get_class_type_203_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DNAWall_get_class_type_203_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAWall::DNAWall(DNAWall const &wall)
 * DNAWall::DNAWall(basic_string< char > const &initial_name)
 * DNAWall::DNAWall(basic_string< char > const &initial_name = (""))
 *******************************************************************/
int  Dtool_Init_DNAWall(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-DNAWall::DNAWall(basic_string< char > const &initial_name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":DNAWall", key_word_list))
            {
                DNAWall *return_value = new DNAWall();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAWall,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 DNAWall::DNAWall(DNAWall const &wall)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"wall", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DNAWall", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DNAWall", &param0));
                if(!PyErr_Occurred())
                {
                    DNAWall *param0_this = (DNAWall *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNAWall, 0, "DNAWall.DNAWall", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        DNAWall *return_value = new DNAWall(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAWall,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 DNAWall::DNAWall(basic_string< char > const &initial_name)
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"initial_name", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNAWall", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:DNAWall", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    DNAWall *return_value = new DNAWall(basic_string<char>(param0_str, param0_len));
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAWall,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "DNAWall() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "DNAWall()\n"
          "DNAWall(const DNAWall wall)\n"
          "DNAWall(string initial_name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNAWall(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNAWall)
    {
        printf("DNAWall ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNAWall * local_this = (DNAWall *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNAWall)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_DNANode)
        return ( DNANode *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( DNAGroup *)( DNANode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNAWall(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNAWall)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNAWall*)other_this;
    }
    if(from_type == &Dtool_DNANode)
    {
          DNANode* other_this = (DNANode*)from_this;
          return (DNAWall*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (DNAWall*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (DNAWall*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DNAWall*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (DNAWall*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNAFlatBuilding 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DNAFlatBuilding::set_width(float width)
 *******************************************************************/
static PyObject *Dtool_DNAFlatBuilding_set_width_207(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAFlatBuilding * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAFlatBuilding,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNAFlatBuilding::set_width(float width)
        double param1;
        static char * key_word_list[] = {(char *)"width", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setWidth", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setWidth", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_width((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAFlatBuilding.setWidth() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWidth(non-const DNAFlatBuilding this, float width)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAFlatBuilding_set_width_207_comment =
    "C++ Interface:\n"
    "setWidth(non-const DNAFlatBuilding this, float width)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAFlatBuilding::set_width\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAFlatBuilding_set_width_207_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DNAFlatBuilding::get_width(void) const
 *******************************************************************/
static PyObject *Dtool_DNAFlatBuilding_get_width_208(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAFlatBuilding * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAFlatBuilding,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DNAFlatBuilding::get_width(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWidth", key_word_list));
        else
            (PyArg_Parse(args, ":getWidth"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DNAFlatBuilding*)local_this)->get_width();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWidth(const DNAFlatBuilding this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAFlatBuilding_get_width_208_comment =
    "C++ Interface:\n"
    "getWidth(const DNAFlatBuilding this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAFlatBuilding::get_width\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAFlatBuilding_get_width_208_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DNAFlatBuilding::get_current_wall_height(void)
 *******************************************************************/
static PyObject *Dtool_DNAFlatBuilding_get_current_wall_height_209(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAFlatBuilding * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAFlatBuilding,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline float DNAFlatBuilding::get_current_wall_height(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCurrentWallHeight", key_word_list));
        else
            (PyArg_Parse(args, ":getCurrentWallHeight"));
        if(!PyErr_Occurred())
        {
            float return_value = (local_this)->get_current_wall_height();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAFlatBuilding.getCurrentWallHeight() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCurrentWallHeight(non-const DNAFlatBuilding this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAFlatBuilding_get_current_wall_height_209_comment =
    "C++ Interface:\n"
    "getCurrentWallHeight(non-const DNAFlatBuilding this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAFlatBuilding::get_current_wall_height\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAFlatBuilding_get_current_wall_height_209_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNAFlatBuilding::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNAFlatBuilding_get_class_type_210(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DNAFlatBuilding::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DNAFlatBuilding::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAFlatBuilding_get_class_type_210_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DNAFlatBuilding_get_class_type_210_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAFlatBuilding::DNAFlatBuilding(DNAFlatBuilding const &building)
 * DNAFlatBuilding::DNAFlatBuilding(basic_string< char > const &initial_name)
 * DNAFlatBuilding::DNAFlatBuilding(basic_string< char > const &initial_name = (""))
 *******************************************************************/
int  Dtool_Init_DNAFlatBuilding(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-DNAFlatBuilding::DNAFlatBuilding(basic_string< char > const &initial_name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":DNAFlatBuilding", key_word_list))
            {
                DNAFlatBuilding *return_value = new DNAFlatBuilding();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAFlatBuilding,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 DNAFlatBuilding::DNAFlatBuilding(DNAFlatBuilding const &building)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"building", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DNAFlatBuilding", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DNAFlatBuilding", &param0));
                if(!PyErr_Occurred())
                {
                    DNAFlatBuilding *param0_this = (DNAFlatBuilding *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNAFlatBuilding, 0, "DNAFlatBuilding.DNAFlatBuilding", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        DNAFlatBuilding *return_value = new DNAFlatBuilding(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAFlatBuilding,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 DNAFlatBuilding::DNAFlatBuilding(basic_string< char > const &initial_name)
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"initial_name", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNAFlatBuilding", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:DNAFlatBuilding", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    DNAFlatBuilding *return_value = new DNAFlatBuilding(basic_string<char>(param0_str, param0_len));
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAFlatBuilding,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "DNAFlatBuilding() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "DNAFlatBuilding()\n"
          "DNAFlatBuilding(const DNAFlatBuilding building)\n"
          "DNAFlatBuilding(string initial_name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNAFlatBuilding(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNAFlatBuilding)
    {
        printf("DNAFlatBuilding ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNAFlatBuilding * local_this = (DNAFlatBuilding *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNAFlatBuilding)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_DNANode)
        return ( DNANode *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( DNAGroup *)( DNANode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNAFlatBuilding(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNAFlatBuilding)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNAFlatBuilding*)other_this;
    }
    if(from_type == &Dtool_DNANode)
    {
          DNANode* other_this = (DNANode*)from_this;
          return (DNAFlatBuilding*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (DNAFlatBuilding*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (DNAFlatBuilding*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DNAFlatBuilding*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (DNAFlatBuilding*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNALandmarkBuilding 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DNALandmarkBuilding::set_title(basic_string< char > const &title)
 *******************************************************************/
static PyObject *Dtool_DNALandmarkBuilding_set_title_214(PyObject *self, PyObject *args,PyObject *kwds) {
    DNALandmarkBuilding * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNALandmarkBuilding,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNALandmarkBuilding::set_title(basic_string< char > const &title)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"title", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setTitle", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setTitle", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_title(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNALandmarkBuilding.setTitle() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTitle(non-const DNALandmarkBuilding this, string title)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNALandmarkBuilding_set_title_214_comment =
    "C++ Interface:\n"
    "setTitle(non-const DNALandmarkBuilding this, string title)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNALandmarkBuilding::set_title\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNALandmarkBuilding_set_title_214_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNALandmarkBuilding::get_title(void) const
 *******************************************************************/
static PyObject *Dtool_DNALandmarkBuilding_get_title_215(PyObject *self, PyObject *args,PyObject *kwds) {
    DNALandmarkBuilding * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNALandmarkBuilding,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > DNALandmarkBuilding::get_title(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTitle", key_word_list));
        else
            (PyArg_Parse(args, ":getTitle"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DNALandmarkBuilding*)local_this)->get_title();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTitle(const DNALandmarkBuilding this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNALandmarkBuilding_get_title_215_comment =
    "C++ Interface:\n"
    "getTitle(const DNALandmarkBuilding this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNALandmarkBuilding::get_title\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNALandmarkBuilding_get_title_215_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNALandmarkBuilding::set_article(basic_string< char > const &article)
 *******************************************************************/
static PyObject *Dtool_DNALandmarkBuilding_set_article_216(PyObject *self, PyObject *args,PyObject *kwds) {
    DNALandmarkBuilding * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNALandmarkBuilding,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNALandmarkBuilding::set_article(basic_string< char > const &article)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"article", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setArticle", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setArticle", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_article(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNALandmarkBuilding.setArticle() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setArticle(non-const DNALandmarkBuilding this, string article)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNALandmarkBuilding_set_article_216_comment =
    "C++ Interface:\n"
    "setArticle(non-const DNALandmarkBuilding this, string article)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNALandmarkBuilding::set_article\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNALandmarkBuilding_set_article_216_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNALandmarkBuilding::get_article(void) const
 *******************************************************************/
static PyObject *Dtool_DNALandmarkBuilding_get_article_217(PyObject *self, PyObject *args,PyObject *kwds) {
    DNALandmarkBuilding * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNALandmarkBuilding,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > DNALandmarkBuilding::get_article(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getArticle", key_word_list));
        else
            (PyArg_Parse(args, ":getArticle"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DNALandmarkBuilding*)local_this)->get_article();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getArticle(const DNALandmarkBuilding this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNALandmarkBuilding_get_article_217_comment =
    "C++ Interface:\n"
    "getArticle(const DNALandmarkBuilding this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNALandmarkBuilding::get_article\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNALandmarkBuilding_get_article_217_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNALandmarkBuilding::set_code(basic_string< char > code)
 *******************************************************************/
static PyObject *Dtool_DNALandmarkBuilding_set_code_218(PyObject *self, PyObject *args,PyObject *kwds) {
    DNALandmarkBuilding * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNALandmarkBuilding,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNALandmarkBuilding::set_code(basic_string< char > code)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"code", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setCode", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setCode", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_code(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNALandmarkBuilding.setCode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCode(non-const DNALandmarkBuilding this, string code)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNALandmarkBuilding_set_code_218_comment =
    "C++ Interface:\n"
    "setCode(non-const DNALandmarkBuilding this, string code)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNALandmarkBuilding::set_code\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNALandmarkBuilding_set_code_218_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNALandmarkBuilding::get_code(void) const
 *******************************************************************/
static PyObject *Dtool_DNALandmarkBuilding_get_code_219(PyObject *self, PyObject *args,PyObject *kwds) {
    DNALandmarkBuilding * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNALandmarkBuilding,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > DNALandmarkBuilding::get_code(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCode", key_word_list));
        else
            (PyArg_Parse(args, ":getCode"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DNALandmarkBuilding*)local_this)->get_code();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCode(const DNALandmarkBuilding this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNALandmarkBuilding_get_code_219_comment =
    "C++ Interface:\n"
    "getCode(const DNALandmarkBuilding this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNALandmarkBuilding::get_code\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNALandmarkBuilding_get_code_219_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNALandmarkBuilding::set_wall_color(LVecBase4f const &color)
 *******************************************************************/
static PyObject *Dtool_DNALandmarkBuilding_set_wall_color_220(PyObject *self, PyObject *args,PyObject *kwds) {
    DNALandmarkBuilding * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNALandmarkBuilding,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DNALandmarkBuilding::set_wall_color(LVecBase4f const &color)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"color", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setWallColor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setWallColor", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "DNALandmarkBuilding.setWallColor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_wall_color(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNALandmarkBuilding.setWallColor() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWallColor(non-const DNALandmarkBuilding this, const VBase4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNALandmarkBuilding_set_wall_color_220_comment =
    "C++ Interface:\n"
    "setWallColor(non-const DNALandmarkBuilding this, const VBase4 color)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNALandmarkBuilding::set_wall_color\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNALandmarkBuilding_set_wall_color_220_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f DNALandmarkBuilding::get_wall_color(void) const
 *******************************************************************/
static PyObject *Dtool_DNALandmarkBuilding_get_wall_color_221(PyObject *self, PyObject *args,PyObject *kwds) {
    DNALandmarkBuilding * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNALandmarkBuilding,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f DNALandmarkBuilding::get_wall_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWallColor", key_word_list));
        else
            (PyArg_Parse(args, ":getWallColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = ((const DNALandmarkBuilding*)local_this)->get_wall_color();
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWallColor(const DNALandmarkBuilding this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNALandmarkBuilding_get_wall_color_221_comment =
    "C++ Interface:\n"
    "getWallColor(const DNALandmarkBuilding this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNALandmarkBuilding::get_wall_color\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNALandmarkBuilding_get_wall_color_221_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNALandmarkBuilding::set_building_type(basic_string< char > const &type)
 *******************************************************************/
static PyObject *Dtool_DNALandmarkBuilding_set_building_type_222(PyObject *self, PyObject *args,PyObject *kwds) {
    DNALandmarkBuilding * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNALandmarkBuilding,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNALandmarkBuilding::set_building_type(basic_string< char > const &type)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"type", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setBuildingType", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setBuildingType", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_building_type(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNALandmarkBuilding.setBuildingType() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBuildingType(non-const DNALandmarkBuilding this, string type)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNALandmarkBuilding_set_building_type_222_comment =
    "C++ Interface:\n"
    "setBuildingType(non-const DNALandmarkBuilding this, string type)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNALandmarkBuilding::set_building_type\n"
    "//       Access: Public\n"
    "//  Description: Set the flag for Toon Headquarters\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNALandmarkBuilding_set_building_type_222_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNALandmarkBuilding::get_building_type(void) const
 *******************************************************************/
static PyObject *Dtool_DNALandmarkBuilding_get_building_type_223(PyObject *self, PyObject *args,PyObject *kwds) {
    DNALandmarkBuilding * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNALandmarkBuilding,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > DNALandmarkBuilding::get_building_type(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBuildingType", key_word_list));
        else
            (PyArg_Parse(args, ":getBuildingType"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DNALandmarkBuilding*)local_this)->get_building_type();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBuildingType(const DNALandmarkBuilding this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNALandmarkBuilding_get_building_type_223_comment =
    "C++ Interface:\n"
    "getBuildingType(const DNALandmarkBuilding this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNALandmarkBuilding::get_building_type\n"
    "//       Access: Public\n"
    "//  Description: Is this a Headquarters building?\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNALandmarkBuilding_get_building_type_223_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNALandmarkBuilding::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNALandmarkBuilding_get_class_type_224(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DNALandmarkBuilding::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DNALandmarkBuilding::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNALandmarkBuilding_get_class_type_224_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DNALandmarkBuilding_get_class_type_224_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNALandmarkBuilding::DNALandmarkBuilding(DNALandmarkBuilding const &building)
 * DNALandmarkBuilding::DNALandmarkBuilding(basic_string< char > const &initial_name)
 * DNALandmarkBuilding::DNALandmarkBuilding(basic_string< char > const &initial_name = (""))
 *******************************************************************/
int  Dtool_Init_DNALandmarkBuilding(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-DNALandmarkBuilding::DNALandmarkBuilding(basic_string< char > const &initial_name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":DNALandmarkBuilding", key_word_list))
            {
                DNALandmarkBuilding *return_value = new DNALandmarkBuilding();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DNALandmarkBuilding,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 DNALandmarkBuilding::DNALandmarkBuilding(DNALandmarkBuilding const &building)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"building", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DNALandmarkBuilding", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DNALandmarkBuilding", &param0));
                if(!PyErr_Occurred())
                {
                    DNALandmarkBuilding *param0_this = (DNALandmarkBuilding *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNALandmarkBuilding, 0, "DNALandmarkBuilding.DNALandmarkBuilding", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        DNALandmarkBuilding *return_value = new DNALandmarkBuilding(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DNALandmarkBuilding,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 DNALandmarkBuilding::DNALandmarkBuilding(basic_string< char > const &initial_name)
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"initial_name", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNALandmarkBuilding", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:DNALandmarkBuilding", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    DNALandmarkBuilding *return_value = new DNALandmarkBuilding(basic_string<char>(param0_str, param0_len));
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_DNALandmarkBuilding,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "DNALandmarkBuilding() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "DNALandmarkBuilding()\n"
          "DNALandmarkBuilding(const DNALandmarkBuilding building)\n"
          "DNALandmarkBuilding(string initial_name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNALandmarkBuilding(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNALandmarkBuilding)
    {
        printf("DNALandmarkBuilding ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNALandmarkBuilding * local_this = (DNALandmarkBuilding *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNALandmarkBuilding)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_DNANode)
        return ( DNANode *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( DNAGroup *)( DNANode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNALandmarkBuilding(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNALandmarkBuilding)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNALandmarkBuilding*)other_this;
    }
    if(from_type == &Dtool_DNANode)
    {
          DNANode* other_this = (DNANode*)from_this;
          return (DNALandmarkBuilding*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (DNALandmarkBuilding*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (DNALandmarkBuilding*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DNALandmarkBuilding*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (DNALandmarkBuilding*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNAAnimBuilding 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DNAAnimBuilding::set_anim(basic_string< char > anim)
 *******************************************************************/
static PyObject *Dtool_DNAAnimBuilding_set_anim_228(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAAnimBuilding * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAAnimBuilding,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNAAnimBuilding::set_anim(basic_string< char > anim)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"anim", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setAnim", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setAnim", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_anim(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAAnimBuilding.setAnim() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAnim(non-const DNAAnimBuilding this, string anim)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAAnimBuilding_set_anim_228_comment =
    "C++ Interface:\n"
    "setAnim(non-const DNAAnimBuilding this, string anim)\n"
    "\n"
    "// Filename: dnaAnimBuilding.I\n"
    "// Created by:  gjeon (12Nov09)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAAnimBuilding::set_anim\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAAnimBuilding_set_anim_228_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNAAnimBuilding::get_anim(void) const
 *******************************************************************/
static PyObject *Dtool_DNAAnimBuilding_get_anim_229(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAAnimBuilding * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAAnimBuilding,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > DNAAnimBuilding::get_anim(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAnim", key_word_list));
        else
            (PyArg_Parse(args, ":getAnim"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DNAAnimBuilding*)local_this)->get_anim();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAnim(const DNAAnimBuilding this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAAnimBuilding_get_anim_229_comment =
    "C++ Interface:\n"
    "getAnim(const DNAAnimBuilding this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAAnimBuilding::get_anim\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAAnimBuilding_get_anim_229_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNAAnimBuilding::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNAAnimBuilding_get_class_type_230(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DNAAnimBuilding::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DNAAnimBuilding::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAAnimBuilding_get_class_type_230_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DNAAnimBuilding_get_class_type_230_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAAnimBuilding::DNAAnimBuilding(DNAAnimBuilding const &anim_building)
 * DNAAnimBuilding::DNAAnimBuilding(basic_string< char > const &initial_name)
 * DNAAnimBuilding::DNAAnimBuilding(basic_string< char > const &initial_name = (""))
 *******************************************************************/
int  Dtool_Init_DNAAnimBuilding(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-DNAAnimBuilding::DNAAnimBuilding(basic_string< char > const &initial_name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":DNAAnimBuilding", key_word_list))
            {
                DNAAnimBuilding *return_value = new DNAAnimBuilding();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAAnimBuilding,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 DNAAnimBuilding::DNAAnimBuilding(DNAAnimBuilding const &anim_building)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"anim_building", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DNAAnimBuilding", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DNAAnimBuilding", &param0));
                if(!PyErr_Occurred())
                {
                    DNAAnimBuilding *param0_this = (DNAAnimBuilding *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNAAnimBuilding, 0, "DNAAnimBuilding.DNAAnimBuilding", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        DNAAnimBuilding *return_value = new DNAAnimBuilding(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAAnimBuilding,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 DNAAnimBuilding::DNAAnimBuilding(basic_string< char > const &initial_name)
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"initial_name", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNAAnimBuilding", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:DNAAnimBuilding", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    DNAAnimBuilding *return_value = new DNAAnimBuilding(basic_string<char>(param0_str, param0_len));
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAAnimBuilding,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "DNAAnimBuilding() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "DNAAnimBuilding()\n"
          "DNAAnimBuilding(const DNAAnimBuilding anim_building)\n"
          "DNAAnimBuilding(string initial_name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNAAnimBuilding(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNAAnimBuilding)
    {
        printf("DNAAnimBuilding ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNAAnimBuilding * local_this = (DNAAnimBuilding *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNAAnimBuilding)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *)( DNANode *)( DNALandmarkBuilding *) local_this;
    if(requested_type == &Dtool_DNALandmarkBuilding)
        return ( DNALandmarkBuilding *) local_this;
    if(requested_type == &Dtool_DNANode)
        return ( DNANode *)( DNALandmarkBuilding *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( DNAGroup *)( DNANode *)( DNALandmarkBuilding *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( DNAGroup *)( DNANode *)( DNALandmarkBuilding *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( DNAGroup *)( DNANode *)( DNALandmarkBuilding *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( DNAGroup *)( DNANode *)( DNALandmarkBuilding *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNAAnimBuilding(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNAAnimBuilding)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNAAnimBuilding*)other_this;
    }
    if(from_type == &Dtool_DNALandmarkBuilding)
    {
          DNALandmarkBuilding* other_this = (DNALandmarkBuilding*)from_this;
          return (DNAAnimBuilding*)other_this;
    }
    if(from_type == &Dtool_DNANode)
    {
          DNANode* other_this = (DNANode*)from_this;
          return (DNAAnimBuilding*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (DNAAnimBuilding*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (DNAAnimBuilding*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DNAAnimBuilding*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (DNAAnimBuilding*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNAProp 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DNAProp::set_code(basic_string< char > code)
 *******************************************************************/
static PyObject *Dtool_DNAProp_set_code_234(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAProp * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAProp,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNAProp::set_code(basic_string< char > code)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"code", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setCode", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setCode", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_code(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAProp.setCode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCode(non-const DNAProp this, string code)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAProp_set_code_234_comment =
    "C++ Interface:\n"
    "setCode(non-const DNAProp this, string code)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAProp::set_code\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAProp_set_code_234_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNAProp::get_code(void) const
 *******************************************************************/
static PyObject *Dtool_DNAProp_get_code_235(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAProp * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAProp,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > DNAProp::get_code(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCode", key_word_list));
        else
            (PyArg_Parse(args, ":getCode"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DNAProp*)local_this)->get_code();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCode(const DNAProp this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAProp_get_code_235_comment =
    "C++ Interface:\n"
    "getCode(const DNAProp this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAProp::get_code\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAProp_get_code_235_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAProp::set_color(LVecBase4f const &color)
 *******************************************************************/
static PyObject *Dtool_DNAProp_set_color_236(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAProp * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAProp,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DNAProp::set_color(LVecBase4f const &color)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"color", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setColor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setColor", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "DNAProp.setColor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_color(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAProp.setColor() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setColor(non-const DNAProp this, const VBase4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAProp_set_color_236_comment =
    "C++ Interface:\n"
    "setColor(non-const DNAProp this, const VBase4 color)\n"
    "\n"
    "// Filename: dnaProp.I\n"
    "// Created by:  shochet (28Mar00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAProp::set_color\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAProp_set_color_236_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f DNAProp::get_color(void) const
 *******************************************************************/
static PyObject *Dtool_DNAProp_get_color_237(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAProp * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAProp,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f DNAProp::get_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getColor", key_word_list));
        else
            (PyArg_Parse(args, ":getColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = ((const DNAProp*)local_this)->get_color();
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getColor(const DNAProp this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAProp_get_color_237_comment =
    "C++ Interface:\n"
    "getColor(const DNAProp this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAProp::get_color\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAProp_get_color_237_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNAProp::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNAProp_get_class_type_238(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DNAProp::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DNAProp::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAProp_get_class_type_238_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DNAProp_get_class_type_238_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAProp::DNAProp(DNAProp const &prop)
 * DNAProp::DNAProp(basic_string< char > const &initial_name)
 * DNAProp::DNAProp(basic_string< char > const &initial_name = (""))
 *******************************************************************/
int  Dtool_Init_DNAProp(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-DNAProp::DNAProp(basic_string< char > const &initial_name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":DNAProp", key_word_list))
            {
                DNAProp *return_value = new DNAProp();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAProp,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 DNAProp::DNAProp(DNAProp const &prop)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"prop", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DNAProp", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DNAProp", &param0));
                if(!PyErr_Occurred())
                {
                    DNAProp *param0_this = (DNAProp *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNAProp, 0, "DNAProp.DNAProp", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        DNAProp *return_value = new DNAProp(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAProp,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 DNAProp::DNAProp(basic_string< char > const &initial_name)
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"initial_name", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNAProp", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:DNAProp", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    DNAProp *return_value = new DNAProp(basic_string<char>(param0_str, param0_len));
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAProp,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "DNAProp() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "DNAProp()\n"
          "DNAProp(const DNAProp prop)\n"
          "DNAProp(string initial_name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNAProp(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNAProp)
    {
        printf("DNAProp ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNAProp * local_this = (DNAProp *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNAProp)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_DNANode)
        return ( DNANode *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( DNAGroup *)( DNANode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNAProp(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNAProp)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNAProp*)other_this;
    }
    if(from_type == &Dtool_DNANode)
    {
          DNANode* other_this = (DNANode*)from_this;
          return (DNAProp*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (DNAProp*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (DNAProp*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DNAProp*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (DNAProp*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNAAnimProp 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DNAAnimProp::set_anim(basic_string< char > anim)
 *******************************************************************/
static PyObject *Dtool_DNAAnimProp_set_anim_242(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAAnimProp * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAAnimProp,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNAAnimProp::set_anim(basic_string< char > anim)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"anim", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setAnim", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setAnim", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_anim(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAAnimProp.setAnim() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAnim(non-const DNAAnimProp this, string anim)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAAnimProp_set_anim_242_comment =
    "C++ Interface:\n"
    "setAnim(non-const DNAAnimProp this, string anim)\n"
    "\n"
    "// Filename: dnaAnimProp.I\n"
    "// Created by:  gjeon (18Sep09)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAAnimProp::set_anim\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAAnimProp_set_anim_242_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNAAnimProp::get_anim(void) const
 *******************************************************************/
static PyObject *Dtool_DNAAnimProp_get_anim_243(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAAnimProp * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAAnimProp,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > DNAAnimProp::get_anim(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAnim", key_word_list));
        else
            (PyArg_Parse(args, ":getAnim"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DNAAnimProp*)local_this)->get_anim();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAnim(const DNAAnimProp this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAAnimProp_get_anim_243_comment =
    "C++ Interface:\n"
    "getAnim(const DNAAnimProp this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAAnimProp::get_anim\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAAnimProp_get_anim_243_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNAAnimProp::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNAAnimProp_get_class_type_244(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DNAAnimProp::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DNAAnimProp::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAAnimProp_get_class_type_244_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DNAAnimProp_get_class_type_244_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAAnimProp::DNAAnimProp(DNAAnimProp const &anim_prop)
 * DNAAnimProp::DNAAnimProp(basic_string< char > const &initial_name)
 * DNAAnimProp::DNAAnimProp(basic_string< char > const &initial_name = (""))
 *******************************************************************/
int  Dtool_Init_DNAAnimProp(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-DNAAnimProp::DNAAnimProp(basic_string< char > const &initial_name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":DNAAnimProp", key_word_list))
            {
                DNAAnimProp *return_value = new DNAAnimProp();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAAnimProp,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 DNAAnimProp::DNAAnimProp(DNAAnimProp const &anim_prop)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"anim_prop", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DNAAnimProp", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DNAAnimProp", &param0));
                if(!PyErr_Occurred())
                {
                    DNAAnimProp *param0_this = (DNAAnimProp *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNAAnimProp, 0, "DNAAnimProp.DNAAnimProp", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        DNAAnimProp *return_value = new DNAAnimProp(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAAnimProp,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 DNAAnimProp::DNAAnimProp(basic_string< char > const &initial_name)
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"initial_name", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNAAnimProp", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:DNAAnimProp", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    DNAAnimProp *return_value = new DNAAnimProp(basic_string<char>(param0_str, param0_len));
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAAnimProp,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "DNAAnimProp() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "DNAAnimProp()\n"
          "DNAAnimProp(const DNAAnimProp anim_prop)\n"
          "DNAAnimProp(string initial_name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNAAnimProp(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNAAnimProp)
    {
        printf("DNAAnimProp ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNAAnimProp * local_this = (DNAAnimProp *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNAAnimProp)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *)( DNANode *)( DNAProp *) local_this;
    if(requested_type == &Dtool_DNANode)
        return ( DNANode *)( DNAProp *) local_this;
    if(requested_type == &Dtool_DNAProp)
        return ( DNAProp *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( DNAGroup *)( DNANode *)( DNAProp *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( DNAGroup *)( DNANode *)( DNAProp *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( DNAGroup *)( DNANode *)( DNAProp *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( DNAGroup *)( DNANode *)( DNAProp *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNAAnimProp(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNAAnimProp)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNAAnimProp*)other_this;
    }
    if(from_type == &Dtool_DNANode)
    {
          DNANode* other_this = (DNANode*)from_this;
          return (DNAAnimProp*)other_this;
    }
    if(from_type == &Dtool_DNAProp)
    {
          DNAProp* other_this = (DNAProp*)from_this;
          return (DNAAnimProp*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (DNAAnimProp*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (DNAAnimProp*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DNAAnimProp*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (DNAAnimProp*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNACornice 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void DNACornice::set_code(basic_string< char > code)
 *******************************************************************/
static PyObject *Dtool_DNACornice_set_code_248(PyObject *self, PyObject *args,PyObject *kwds) {
    DNACornice * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNACornice,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNACornice::set_code(basic_string< char > code)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"code", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setCode", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setCode", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_code(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNACornice.setCode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCode(non-const DNACornice this, string code)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNACornice_set_code_248_comment =
    "C++ Interface:\n"
    "setCode(non-const DNACornice this, string code)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNACornice::set_code\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNACornice_set_code_248_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DNACornice::get_code(void) const
 *******************************************************************/
static PyObject *Dtool_DNACornice_get_code_249(PyObject *self, PyObject *args,PyObject *kwds) {
    DNACornice * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNACornice,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > DNACornice::get_code(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCode", key_word_list));
        else
            (PyArg_Parse(args, ":getCode"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DNACornice*)local_this)->get_code();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCode(const DNACornice this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNACornice_get_code_249_comment =
    "C++ Interface:\n"
    "getCode(const DNACornice this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNACornice::get_code\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNACornice_get_code_249_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNACornice::set_color(LVecBase4f const &color)
 *******************************************************************/
static PyObject *Dtool_DNACornice_set_color_250(PyObject *self, PyObject *args,PyObject *kwds) {
    DNACornice * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNACornice,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DNACornice::set_color(LVecBase4f const &color)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"color", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setColor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setColor", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "DNACornice.setColor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_color(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNACornice.setColor() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setColor(non-const DNACornice this, const VBase4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNACornice_set_color_250_comment =
    "C++ Interface:\n"
    "setColor(non-const DNACornice this, const VBase4 color)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNACornice::set_color\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNACornice_set_color_250_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LVecBase4f DNACornice::get_color(void) const
 *******************************************************************/
static PyObject *Dtool_DNACornice_get_color_251(PyObject *self, PyObject *args,PyObject *kwds) {
    DNACornice * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNACornice,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-LVecBase4f DNACornice::get_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getColor", key_word_list));
        else
            (PyArg_Parse(args, ":getColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = ((const DNACornice*)local_this)->get_color();
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getColor(const DNACornice this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNACornice_get_color_251_comment =
    "C++ Interface:\n"
    "getColor(const DNACornice this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNACornice::get_color\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNACornice_get_color_251_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNACornice::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNACornice_get_class_type_252(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DNACornice::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DNACornice::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNACornice_get_class_type_252_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DNACornice_get_class_type_252_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNACornice::DNACornice(DNACornice const &cornice)
 * DNACornice::DNACornice(basic_string< char > const &initial_name)
 * DNACornice::DNACornice(basic_string< char > const &initial_name = (""))
 *******************************************************************/
int  Dtool_Init_DNACornice(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-DNACornice::DNACornice(basic_string< char > const &initial_name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":DNACornice", key_word_list))
            {
                DNACornice *return_value = new DNACornice();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DNACornice,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 DNACornice::DNACornice(DNACornice const &cornice)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"cornice", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DNACornice", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DNACornice", &param0));
                if(!PyErr_Occurred())
                {
                    DNACornice *param0_this = (DNACornice *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNACornice, 0, "DNACornice.DNACornice", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        DNACornice *return_value = new DNACornice(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DNACornice,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 DNACornice::DNACornice(basic_string< char > const &initial_name)
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"initial_name", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNACornice", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:DNACornice", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    DNACornice *return_value = new DNACornice(basic_string<char>(param0_str, param0_len));
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_DNACornice,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "DNACornice() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "DNACornice()\n"
          "DNACornice(const DNACornice cornice)\n"
          "DNACornice(string initial_name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNACornice(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNACornice)
    {
        printf("DNACornice ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNACornice * local_this = (DNACornice *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNACornice)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( DNAGroup *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( DNAGroup *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( DNAGroup *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( DNAGroup *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNACornice(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNACornice)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNACornice*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (DNACornice*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (DNACornice*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DNACornice*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (DNACornice*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNAData 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline DNAData &DNAData::operator =(DNAData const &copy)
 *******************************************************************/
static PyObject *Dtool_DNAData_operator_256(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline DNAData &DNAData::operator =(DNAData const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                DNAData *param1_this = (DNAData *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNAData, 1, "DNAData.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    DNAData *return_value = local_this;
                    if (return_value != (DNAData *)0) {
                      return_value->ref();
                    }
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_DNAData,true, false, (return_value)->as_typed_object()->get_type_index());
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAData.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const DNAData this, const DNAData copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAData_operator_256_comment =
    "C++ Interface:\n"
    "assign(non-const DNAData this, const DNAData copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAData::Copy assignment operator\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAData_operator_256_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DNAData::read(Filename filename, ostream &error)
 * bool DNAData::read(Filename filename, ostream &error = ((out())))
 * bool DNAData::read(istream &in, ostream &error)
 * bool DNAData::read(istream &in, ostream &error = ((out())))
 *******************************************************************/
static PyObject *Dtool_DNAData_read_257(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool DNAData::read(istream &in, ostream &error = ((out())))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"in", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:read", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:read", &param1));
                if(!PyErr_Occurred())
                {
                    istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_istream, 1, "DNAData.read", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = (local_this)->read(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool DNAData::read(Filename filename, ostream &error = ((out())))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"filename", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:read", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:read", &param1));
                if(!PyErr_Occurred())
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "DNAData.read", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = (local_this)->read(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool DNAData::read(Filename filename, ostream &error)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"filename", (char *)"error", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:read", key_word_list, &param1, &param2))
                {
                    Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "DNAData.read", 1, coerced_ptr, report_errors);
ostream *param2_this = (ostream *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_ostream, 2, "DNAData.read", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        bool return_value = (local_this)->read(*param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 bool DNAData::read(istream &in, ostream &error)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"in", (char *)"error", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:read", key_word_list, &param1, &param2))
                {
                    istream *param1_this = (istream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_istream, 1, "DNAData.read", 0, coerced_ptr, report_errors);
ostream *param2_this = (ostream *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_ostream, 2, "DNAData.read", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        bool return_value = (local_this)->read(*param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "read() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "read(non-const DNAData this, non-const Istream in)\n"
          "read(non-const DNAData this, const Filename filename)\n"
          "read(non-const DNAData this, const Filename filename, non-const Ostream error)\n"
          "read(non-const DNAData this, non-const Istream in, non-const Ostream error)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAData_read_257_comment =
    "C++ Interface:\n"
    "read(non-const DNAData this, non-const Istream in)\n"
    "read(non-const DNAData this, const Filename filename)\n"
    "read(non-const DNAData this, const Filename filename, non-const Ostream error)\n"
    "read(non-const DNAData this, non-const Istream in, non-const Ostream error)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAData::read\n"
    "//       Access: Public\n"
    "//  Description: Opens the indicated filename and reads the DNA data\n"
    "//               contents from it.  Returns true if the file was\n"
    "//               successfully opened and read, false if there were\n"
    "//               some errors, in which case the data may be partially\n"
    "//               read.\n"
    "//\n"
    "//               error is the output stream to which to write error\n"
    "//               messages.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAData::read\n"
    "//       Access: Public\n"
    "//  Description: Parses the DNA syntax contained in the indicated\n"
    "//               input stream.  Returns true if the stream was a\n"
    "//               completely valid DNA file, false if there were some\n"
    "//               errors, in which case the data may be partially read.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAData_read_257_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static bool DNAData::resolve_dna_filename(Filename &dna_filename, DSearchPath const &searchpath)
 * static bool DNAData::resolve_dna_filename(Filename &dna_filename, DSearchPath const &searchpath = ((())))
 *******************************************************************/
static PyObject *Dtool_DNAData_resolve_dna_filename_258(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-static bool DNAData::resolve_dna_filename(Filename &dna_filename, DSearchPath const &searchpath = ((())))
                PyObject *param0;
                static char * key_word_list[] = {(char *)"dna_filename", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:resolveDnaFilename", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:resolveDnaFilename", &param0));
                if(!PyErr_Occurred())
                {
                    Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Filename, 0, "DNAData.resolveDnaFilename", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        bool return_value = DNAData::resolve_dna_filename(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-static bool DNAData::resolve_dna_filename(Filename &dna_filename, DSearchPath const &searchpath)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"dna_filename", (char *)"searchpath", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:resolveDnaFilename", key_word_list, &param0, &param1))
                {
                    Filename *param0_this = (Filename *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Filename, 0, "DNAData.resolveDnaFilename", 0, coerced_ptr, report_errors);
DSearchPath *param1_this = (DSearchPath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DSearchPath, 1, "DNAData.resolveDnaFilename", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        bool return_value = DNAData::resolve_dna_filename(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "resolveDnaFilename() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "resolveDnaFilename(non-const Filename dna_filename)\n"
          "resolveDnaFilename(non-const Filename dna_filename, const DSearchPath searchpath)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAData_resolve_dna_filename_258_comment =
    "C++ Interface:\n"
    "resolveDnaFilename(non-const Filename dna_filename)\n"
    "resolveDnaFilename(non-const Filename dna_filename, const DSearchPath searchpath)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DnaData::resolve_dna_filename\n"
    "//       Access: Public, Static\n"
    "//  Description: Looks for the indicated filename, first along the\n"
    "//               indicated searchpath, and then along the dna_path and\n"
    "//               finally along the model_path.  If found, updates the\n"
    "//               filename to the full path and returns true;\n"
    "//               otherwise, returns false.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAData_resolve_dna_filename_258_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DNAData::resolve_externals(basic_string< char > const &searchpath, ostream &error)
 * bool DNAData::resolve_externals(basic_string< char > const &searchpath, ostream &error = ((out())))
 *******************************************************************/
static PyObject *Dtool_DNAData_resolve_externals_259(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool DNAData::resolve_externals(basic_string< char > const &searchpath, ostream &error = ((out())))
            char *param1_str; int param1_len;
            static char * key_word_list[] = {(char *)"searchpath", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:resolveExternals", key_word_list, &param1_str, &param1_len));
            else
                (PyArg_Parse(args, "s#:resolveExternals", &param1_str, &param1_len));
            if(!PyErr_Occurred())
            {
                bool return_value = (local_this)->resolve_externals(basic_string<char>(param1_str, param1_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAData.resolveExternals() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-bool DNAData::resolve_externals(basic_string< char > const &searchpath, ostream &error)
                char *param1_str; int param1_len;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"searchpath", (char *)"error", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:resolveExternals", key_word_list, &param1_str, &param1_len, &param2))
                {
                    ostream *param2_this = (ostream *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_ostream, 2, "DNAData.resolveExternals", 0, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        bool return_value = (local_this)->resolve_externals(basic_string<char>(param1_str, param1_len), *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call DNAData.resolveExternals() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "resolveExternals() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "resolveExternals(non-const DNAData this, string searchpath)\n"
          "resolveExternals(non-const DNAData this, string searchpath, non-const Ostream error)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAData_resolve_externals_259_comment =
    "C++ Interface:\n"
    "resolveExternals(non-const DNAData this, string searchpath)\n"
    "resolveExternals(non-const DNAData this, string searchpath, non-const Ostream error)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAData::resolve_externals\n"
    "//       Access: Public\n"
    "//  Description: Loads up all the dna files referenced by <File>\n"
    "//               entries within the dna structure, and inserts their\n"
    "//               contents in place of the <File> entries.  Searches\n"
    "//               for files in the searchpath, if not found directly,\n"
    "//               and writes error messages to the indicated output\n"
    "//               stream.  Returns true if all externals were loaded\n"
    "//               successfully, false otherwise.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAData_resolve_externals_259_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DNAData::write_dna(Filename filename, ostream &error, DNAStorage *store)
 * bool DNAData::write_dna(ostream &out, ostream &error, DNAStorage *store)
 *******************************************************************/
static PyObject *Dtool_DNAData_write_dna_260(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 bool DNAData::write_dna(Filename filename, ostream &error, DNAStorage *store)
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"filename", (char *)"error", (char *)"store", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:writeDna", key_word_list, &param1, &param2, &param3))
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "DNAData.writeDna", 1, coerced_ptr, report_errors);
ostream *param2_this = (ostream *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_ostream, 2, "DNAData.writeDna", 0, coerced_ptr, report_errors);
DNAStorage *param3_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_DNAStorage, 3, "DNAData.writeDna", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)))
                {
                    bool return_value = (local_this)->write_dna(*param1_this, *param2_this, param3_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 bool DNAData::write_dna(ostream &out, ostream &error, DNAStorage *store)
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"out", (char *)"error", (char *)"store", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:writeDna", key_word_list, &param1, &param2, &param3))
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "DNAData.writeDna", 0, coerced_ptr, report_errors);
ostream *param2_this = (ostream *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_ostream, 2, "DNAData.writeDna", 0, coerced_ptr, report_errors);
DNAStorage *param3_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_DNAStorage, 3, "DNAData.writeDna", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)))
                {
                    bool return_value = (local_this)->write_dna(*param1_this, *param2_this, param3_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "writeDna(non-const DNAData this, const Filename filename, non-const Ostream error, non-const DNAStorage store)\n"
          "writeDna(non-const DNAData this, non-const Ostream out, non-const Ostream error, non-const DNAStorage store)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAData_write_dna_260_comment =
    "C++ Interface:\n"
    "writeDna(non-const DNAData this, const Filename filename, non-const Ostream error, non-const DNAStorage store)\n"
    "writeDna(non-const DNAData this, non-const Ostream out, non-const Ostream error, non-const DNAStorage store)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAData::write_dna\n"
    "//       Access: Public\n"
    "//  Description: The main interface for writing complete dna files.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAData::write_dna\n"
    "//       Access: Public\n"
    "//  Description: The main interface for writing complete dna files.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAData_write_dna_260_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNAData::set_coordinate_system(CoordinateSystem coordsys)
 *******************************************************************/
static PyObject *Dtool_DNAData_set_coordinate_system_261(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNAData::set_coordinate_system(CoordinateSystem coordsys)
        int param1;
        static char * key_word_list[] = {(char *)"coordsys", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setCoordinateSystem", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setCoordinateSystem", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_coordinate_system((CoordinateSystem)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAData.setCoordinateSystem() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCoordinateSystem(non-const DNAData this, int coordsys)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAData_set_coordinate_system_261_comment =
    "C++ Interface:\n"
    "setCoordinateSystem(non-const DNAData this, int coordsys)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAData::set_coordinate_system\n"
    "//       Access: Public\n"
    "//  Description: Changes the coordinate system of the DNAData.  If the\n"
    "//               coordinate system was previously different, this may\n"
    "//               result in a conversion of the data.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAData_set_coordinate_system_261_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline CoordinateSystem DNAData::get_coordinate_system(void) const
 *******************************************************************/
static PyObject *Dtool_DNAData_get_coordinate_system_262(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline CoordinateSystem DNAData::get_coordinate_system(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCoordinateSystem", key_word_list));
        else
            (PyArg_Parse(args, ":getCoordinateSystem"));
        if(!PyErr_Occurred())
        {
            CoordinateSystem return_value = ((const DNAData*)local_this)->get_coordinate_system();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCoordinateSystem(const DNAData this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAData_get_coordinate_system_262_comment =
    "C++ Interface:\n"
    "getCoordinateSystem(const DNAData this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAData::get_coordinate_system\n"
    "//       Access: Public\n"
    "//  Description: Returns the coordinate system in which the dna file\n"
    "//               is defined.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAData_get_coordinate_system_262_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAData::set_dna_filename(Filename const &directory)
 *******************************************************************/
static PyObject *Dtool_DNAData_set_dna_filename_263(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DNAData::set_dna_filename(Filename const &directory)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"directory", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setDnaFilename", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setDnaFilename", &param1));
            if(!PyErr_Occurred())
            {
                Filename *param1_this = (Filename *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_Filename, 1, "DNAData.setDnaFilename", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_dna_filename(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAData.setDnaFilename() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDnaFilename(non-const DNAData this, const Filename directory)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAData_set_dna_filename_263_comment =
    "C++ Interface:\n"
    "setDnaFilename(non-const DNAData this, const Filename directory)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAData::set_dna_filename\n"
    "//       Access: Public\n"
    "//  Description: Sets the directory in which the dna file is\n"
    "//               considered to reside.  This is also implicitly set by\n"
    "//               read().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAData_set_dna_filename_263_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline Filename const &DNAData::get_dna_filename(void) const
 *******************************************************************/
static PyObject *Dtool_DNAData_get_dna_filename_264(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline Filename const &DNAData::get_dna_filename(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDnaFilename", key_word_list));
        else
            (PyArg_Parse(args, ":getDnaFilename"));
        if(!PyErr_Occurred())
        {
            Filename const *return_value = &(((const DNAData*)local_this)->get_dna_filename());
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_Filename,false, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDnaFilename(const DNAData this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAData_get_dna_filename_264_comment =
    "C++ Interface:\n"
    "getDnaFilename(const DNAData this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAData::get_dna_filename\n"
    "//       Access: Public\n"
    "//  Description: Returns the directory in which the dna file is\n"
    "//               considered to reside.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAData_get_dna_filename_264_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAData::set_dna_storage(DNAStorage *store)
 *******************************************************************/
static PyObject *Dtool_DNAData_set_dna_storage_265(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DNAData::set_dna_storage(DNAStorage *store)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"store", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setDnaStorage", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setDnaStorage", &param1));
            if(!PyErr_Occurred())
            {
                DNAStorage *param1_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNAStorage, 1, "DNAData.setDnaStorage", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_dna_storage(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAData.setDnaStorage() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDnaStorage(non-const DNAData this, non-const DNAStorage store)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAData_set_dna_storage_265_comment =
    "C++ Interface:\n"
    "setDnaStorage(non-const DNAData this, non-const DNAStorage store)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAData::set_dna_storage\n"
    "//       Access: Public\n"
    "//  Description: Sets the current dna storage facility\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAData_set_dna_storage_265_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DNAStorage *DNAData::get_dna_storage(void)
 *******************************************************************/
static PyObject *Dtool_DNAData_get_dna_storage_266(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline DNAStorage *DNAData::get_dna_storage(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDnaStorage", key_word_list));
        else
            (PyArg_Parse(args, ":getDnaStorage"));
        if(!PyErr_Occurred())
        {
            DNAStorage *return_value = (local_this)->get_dna_storage();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_DNAStorage,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAData.getDnaStorage() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDnaStorage(non-const DNAData this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAData_get_dna_storage_266_comment =
    "C++ Interface:\n"
    "getDnaStorage(non-const DNAData this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAData::get_dna_storage\n"
    "//       Access: Public\n"
    "//  Description: Returns the current dna storage facility\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAData_get_dna_storage_266_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNAData::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNAData_get_class_type_267(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DNAData::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DNAData::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAData_get_class_type_267_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DNAData_get_class_type_267_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline DNAData::DNAData(DNAData const &copy)
 * inline DNAData::DNAData(basic_string< char > const &initial_name)
 * inline DNAData::DNAData(basic_string< char > const &initial_name = (""))
 *******************************************************************/
int  Dtool_Init_DNAData(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-inline DNAData::DNAData(basic_string< char > const &initial_name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":DNAData", key_word_list))
            {
                DNAData *return_value = new DNAData();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAData,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline DNAData::DNAData(DNAData const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DNAData", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DNAData", &param0));
                if(!PyErr_Occurred())
                {
                    DNAData *param0_this = (DNAData *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNAData, 0, "DNAData.DNAData", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        DNAData *return_value = new DNAData(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAData,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline DNAData::DNAData(basic_string< char > const &initial_name)
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"initial_name", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNAData", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:DNAData", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    DNAData *return_value = new DNAData(basic_string<char>(param0_str, param0_len));
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAData,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "DNAData() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "DNAData()\n"
          "DNAData(const DNAData copy)\n"
          "DNAData(string initial_name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNAData(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNAData)
    {
        printf("DNAData ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNAData * local_this = (DNAData *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNAData)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( DNAGroup *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( DNAGroup *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( DNAGroup *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( DNAGroup *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNAData(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNAData)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNAData*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (DNAData*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (DNAData*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DNAData*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (DNAData*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNADoor 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void DNADoor::set_code(basic_string< char > code)
 *******************************************************************/
static PyObject *Dtool_DNADoor_set_code_271(PyObject *self, PyObject *args,PyObject *kwds) {
    DNADoor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNADoor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNADoor::set_code(basic_string< char > code)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"code", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setCode", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setCode", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_code(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNADoor.setCode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCode(non-const DNADoor this, string code)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNADoor_set_code_271_comment =
    "C++ Interface:\n"
    "setCode(non-const DNADoor this, string code)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNADoor::set_code\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNADoor_set_code_271_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DNADoor::get_code(void) const
 *******************************************************************/
static PyObject *Dtool_DNADoor_get_code_272(PyObject *self, PyObject *args,PyObject *kwds) {
    DNADoor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNADoor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > DNADoor::get_code(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCode", key_word_list));
        else
            (PyArg_Parse(args, ":getCode"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DNADoor*)local_this)->get_code();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCode(const DNADoor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNADoor_get_code_272_comment =
    "C++ Interface:\n"
    "getCode(const DNADoor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNADoor::get_code\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNADoor_get_code_272_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNADoor::set_color(LVecBase4f const &color)
 *******************************************************************/
static PyObject *Dtool_DNADoor_set_color_273(PyObject *self, PyObject *args,PyObject *kwds) {
    DNADoor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNADoor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DNADoor::set_color(LVecBase4f const &color)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"color", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setColor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setColor", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "DNADoor.setColor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_color(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNADoor.setColor() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setColor(non-const DNADoor this, const VBase4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNADoor_set_color_273_comment =
    "C++ Interface:\n"
    "setColor(non-const DNADoor this, const VBase4 color)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNADoor::set_color\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNADoor_set_color_273_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LVecBase4f DNADoor::get_color(void) const
 *******************************************************************/
static PyObject *Dtool_DNADoor_get_color_274(PyObject *self, PyObject *args,PyObject *kwds) {
    DNADoor * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNADoor,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-LVecBase4f DNADoor::get_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getColor", key_word_list));
        else
            (PyArg_Parse(args, ":getColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = ((const DNADoor*)local_this)->get_color();
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getColor(const DNADoor this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNADoor_get_color_274_comment =
    "C++ Interface:\n"
    "getColor(const DNADoor this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNADoor::get_color\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNADoor_get_color_274_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static void DNADoor::setup_door(NodePath &door_node_path, NodePath &parent, NodePath &door_origin, DNAStorage *store, basic_string< char > const &block, LVector4f const &color)
 *******************************************************************/
static PyObject *Dtool_DNADoor_setup_door_275(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static void DNADoor::setup_door(NodePath &door_node_path, NodePath &parent, NodePath &door_origin, DNAStorage *store, basic_string< char > const &block, LVector4f const &color)
            PyObject *param0;
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            char *param4_str; int param4_len;
            PyObject *param5;
            static char * key_word_list[] = {(char *)"door_node_path", (char *)"parent", (char *)"door_origin", (char *)"store", (char *)"block", (char *)"color", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOOs#O:setupDoor", key_word_list, &param0, &param1, &param2, &param3, &param4_str, &param4_len, &param5))
            {
                NodePath *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_NodePath, 0, "DNADoor.setupDoor", 0, coerced_ptr, report_errors);
NodePath *param1_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_NodePath, 1, "DNADoor.setupDoor", 0, coerced_ptr, report_errors);
NodePath *param2_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_NodePath, 2, "DNADoor.setupDoor", 0, coerced_ptr, report_errors);
DNAStorage *param3_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_DNAStorage, 3, "DNADoor.setupDoor", 0, coerced_ptr, report_errors);
LVector4f *param5_this = (LVector4f *)DTOOL_Call_GetPointerThisClass(param5, &Dtool_LVector4f, 5, "DNADoor.setupDoor", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)|| (param5_this == NULL)))
                {
                    DNADoor::setup_door(*param0_this, *param1_this, *param2_this, param3_this, basic_string<char>(param4_str, param4_len), *param5_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setupDoor(non-const NodePath door_node_path, non-const NodePath parent, non-const NodePath door_origin, non-const DNAStorage store, string block, const Vec4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNADoor_setup_door_275_comment =
    "C++ Interface:\n"
    "setupDoor(non-const NodePath door_node_path, non-const NodePath parent, non-const NodePath door_origin, non-const DNAStorage store, string block, const Vec4 color)\n"
    "\n"
    "";
#else
static const char * Dtool_DNADoor_setup_door_275_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNADoor::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNADoor_get_class_type_276(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DNADoor::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DNADoor::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNADoor_get_class_type_276_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DNADoor_get_class_type_276_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNADoor::DNADoor(DNADoor const &door)
 * DNADoor::DNADoor(basic_string< char > const &initial_name)
 * DNADoor::DNADoor(basic_string< char > const &initial_name = (""))
 *******************************************************************/
int  Dtool_Init_DNADoor(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-DNADoor::DNADoor(basic_string< char > const &initial_name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":DNADoor", key_word_list))
            {
                DNADoor *return_value = new DNADoor();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DNADoor,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 DNADoor::DNADoor(DNADoor const &door)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"door", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DNADoor", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DNADoor", &param0));
                if(!PyErr_Occurred())
                {
                    DNADoor *param0_this = (DNADoor *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNADoor, 0, "DNADoor.DNADoor", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        DNADoor *return_value = new DNADoor(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DNADoor,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 DNADoor::DNADoor(basic_string< char > const &initial_name)
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"initial_name", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNADoor", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:DNADoor", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    DNADoor *return_value = new DNADoor(basic_string<char>(param0_str, param0_len));
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_DNADoor,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "DNADoor() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "DNADoor()\n"
          "DNADoor(const DNADoor door)\n"
          "DNADoor(string initial_name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNADoor(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNADoor)
    {
        printf("DNADoor ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNADoor * local_this = (DNADoor *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNADoor)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( DNAGroup *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( DNAGroup *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( DNAGroup *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( DNAGroup *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNADoor(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNADoor)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNADoor*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (DNADoor*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (DNADoor*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DNADoor*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (DNADoor*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNAFlatDoor 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNAFlatDoor::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNAFlatDoor_get_class_type_280(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DNAFlatDoor::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DNAFlatDoor::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAFlatDoor_get_class_type_280_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DNAFlatDoor_get_class_type_280_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAFlatDoor::DNAFlatDoor(DNAFlatDoor const &door)
 * DNAFlatDoor::DNAFlatDoor(basic_string< char > const &initial_name)
 * DNAFlatDoor::DNAFlatDoor(basic_string< char > const &initial_name = (""))
 *******************************************************************/
int  Dtool_Init_DNAFlatDoor(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-DNAFlatDoor::DNAFlatDoor(basic_string< char > const &initial_name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":DNAFlatDoor", key_word_list))
            {
                DNAFlatDoor *return_value = new DNAFlatDoor();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAFlatDoor,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 DNAFlatDoor::DNAFlatDoor(DNAFlatDoor const &door)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"door", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DNAFlatDoor", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DNAFlatDoor", &param0));
                if(!PyErr_Occurred())
                {
                    DNAFlatDoor *param0_this = (DNAFlatDoor *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNAFlatDoor, 0, "DNAFlatDoor.DNAFlatDoor", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        DNAFlatDoor *return_value = new DNAFlatDoor(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAFlatDoor,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 DNAFlatDoor::DNAFlatDoor(basic_string< char > const &initial_name)
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"initial_name", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNAFlatDoor", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:DNAFlatDoor", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    DNAFlatDoor *return_value = new DNAFlatDoor(basic_string<char>(param0_str, param0_len));
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAFlatDoor,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "DNAFlatDoor() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "DNAFlatDoor()\n"
          "DNAFlatDoor(const DNAFlatDoor door)\n"
          "DNAFlatDoor(string initial_name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNAFlatDoor(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNAFlatDoor)
    {
        printf("DNAFlatDoor ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNAFlatDoor * local_this = (DNAFlatDoor *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNAFlatDoor)
        return local_this;
    if(requested_type == &Dtool_DNADoor)
        return ( DNADoor *) local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *)( DNADoor *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( DNAGroup *)( DNADoor *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( DNAGroup *)( DNADoor *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( DNAGroup *)( DNADoor *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( DNAGroup *)( DNADoor *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNAFlatDoor(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNAFlatDoor)
        return from_this;
    if(from_type == &Dtool_DNADoor)
    {
          DNADoor* other_this = (DNADoor*)from_this;
          return (DNAFlatDoor*)other_this;
    }
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNAFlatDoor*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (DNAFlatDoor*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (DNAFlatDoor*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DNAFlatDoor*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (DNAFlatDoor*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNAInteractiveProp 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DNAInteractiveProp::set_cell_id(int cell_id)
 *******************************************************************/
static PyObject *Dtool_DNAInteractiveProp_set_cell_id_284(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAInteractiveProp * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAInteractiveProp,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNAInteractiveProp::set_cell_id(int cell_id)
        int param1;
        static char * key_word_list[] = {(char *)"cell_id", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setCellId", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setCellId", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_cell_id((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAInteractiveProp.setCellId() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCellId(non-const DNAInteractiveProp this, int cell_id)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAInteractiveProp_set_cell_id_284_comment =
    "C++ Interface:\n"
    "setCellId(non-const DNAInteractiveProp this, int cell_id)\n"
    "\n"
    "// Filename: dnaInteractiveProp.I\n"
    "// Created by:  gjeon (02Oct09)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAInteractiveProp::set_cell_id\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAInteractiveProp_set_cell_id_284_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DNAInteractiveProp::get_cell_id(void) const
 *******************************************************************/
static PyObject *Dtool_DNAInteractiveProp_get_cell_id_285(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAInteractiveProp * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAInteractiveProp,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DNAInteractiveProp::get_cell_id(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCellId", key_word_list));
        else
            (PyArg_Parse(args, ":getCellId"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DNAInteractiveProp*)local_this)->get_cell_id();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCellId(const DNAInteractiveProp this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAInteractiveProp_get_cell_id_285_comment =
    "C++ Interface:\n"
    "getCellId(const DNAInteractiveProp this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAInteractiveProp::get_cell_id\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAInteractiveProp_get_cell_id_285_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNAInteractiveProp::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNAInteractiveProp_get_class_type_286(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DNAInteractiveProp::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DNAInteractiveProp::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAInteractiveProp_get_class_type_286_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DNAInteractiveProp_get_class_type_286_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAInteractiveProp::DNAInteractiveProp(DNAInteractiveProp const &interactive_prop)
 * DNAInteractiveProp::DNAInteractiveProp(basic_string< char > const &initial_name)
 * DNAInteractiveProp::DNAInteractiveProp(basic_string< char > const &initial_name = (""))
 *******************************************************************/
int  Dtool_Init_DNAInteractiveProp(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-DNAInteractiveProp::DNAInteractiveProp(basic_string< char > const &initial_name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":DNAInteractiveProp", key_word_list))
            {
                DNAInteractiveProp *return_value = new DNAInteractiveProp();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAInteractiveProp,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 DNAInteractiveProp::DNAInteractiveProp(DNAInteractiveProp const &interactive_prop)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"interactive_prop", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DNAInteractiveProp", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DNAInteractiveProp", &param0));
                if(!PyErr_Occurred())
                {
                    DNAInteractiveProp *param0_this = (DNAInteractiveProp *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNAInteractiveProp, 0, "DNAInteractiveProp.DNAInteractiveProp", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        DNAInteractiveProp *return_value = new DNAInteractiveProp(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAInteractiveProp,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 DNAInteractiveProp::DNAInteractiveProp(basic_string< char > const &initial_name)
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"initial_name", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNAInteractiveProp", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:DNAInteractiveProp", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    DNAInteractiveProp *return_value = new DNAInteractiveProp(basic_string<char>(param0_str, param0_len));
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAInteractiveProp,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "DNAInteractiveProp() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "DNAInteractiveProp()\n"
          "DNAInteractiveProp(const DNAInteractiveProp interactive_prop)\n"
          "DNAInteractiveProp(string initial_name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNAInteractiveProp(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNAInteractiveProp)
    {
        printf("DNAInteractiveProp ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNAInteractiveProp * local_this = (DNAInteractiveProp *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNAInteractiveProp)
        return local_this;
    if(requested_type == &Dtool_DNAAnimProp)
        return ( DNAAnimProp *) local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *)( DNANode *)( DNAProp *)( DNAAnimProp *) local_this;
    if(requested_type == &Dtool_DNANode)
        return ( DNANode *)( DNAProp *)( DNAAnimProp *) local_this;
    if(requested_type == &Dtool_DNAProp)
        return ( DNAProp *)( DNAAnimProp *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( DNAGroup *)( DNANode *)( DNAProp *)( DNAAnimProp *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( DNAGroup *)( DNANode *)( DNAProp *)( DNAAnimProp *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( DNAGroup *)( DNANode *)( DNAProp *)( DNAAnimProp *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( DNAGroup *)( DNANode *)( DNAProp *)( DNAAnimProp *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNAInteractiveProp(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNAInteractiveProp)
        return from_this;
    if(from_type == &Dtool_DNAAnimProp)
    {
          DNAAnimProp* other_this = (DNAAnimProp*)from_this;
          return (DNAInteractiveProp*)other_this;
    }
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNAInteractiveProp*)other_this;
    }
    if(from_type == &Dtool_DNANode)
    {
          DNANode* other_this = (DNANode*)from_this;
          return (DNAInteractiveProp*)other_this;
    }
    if(from_type == &Dtool_DNAProp)
    {
          DNAProp* other_this = (DNAProp*)from_this;
          return (DNAInteractiveProp*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (DNAInteractiveProp*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (DNAInteractiveProp*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DNAInteractiveProp*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (DNAInteractiveProp*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNALoader 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * PointerTo< PandaNode > DNALoader::build_graph(DNAStorage *dna_store, int editing)
 * PointerTo< PandaNode > DNALoader::build_graph(DNAStorage *dna_store, int editing = (0))
 *******************************************************************/
static PyObject *Dtool_DNALoader_build_graph_290(PyObject *self, PyObject *args,PyObject *kwds) {
    DNALoader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNALoader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-PointerTo< PandaNode > DNALoader::build_graph(DNAStorage *dna_store, int editing = (0))
                PyObject *param1;
                static char * key_word_list[] = {(char *)"dna_store", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:buildGraph", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:buildGraph", &param1));
                if(!PyErr_Occurred())
                {
                    DNAStorage *param1_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNAStorage, 1, "DNALoader.buildGraph", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        PointerTo< PandaNode > return_value = (local_this)->build_graph(param1_this);
                        if (return_value != (PandaNode *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_PandaNode,true, false, (return_value.p())->as_typed_object()->get_type_index());
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call DNALoader.buildGraph() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-PointerTo< PandaNode > DNALoader::build_graph(DNAStorage *dna_store, int editing)
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"dna_store", (char *)"editing", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:buildGraph", key_word_list, &param1, &param2))
                {
                    DNAStorage *param1_this = (DNAStorage *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_DNAStorage, 1, "DNALoader.buildGraph", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        PointerTo< PandaNode > return_value = (local_this)->build_graph(param1_this, (int)param2);
                        if (return_value != (PandaNode *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_PandaNode,true, false, (return_value.p())->as_typed_object()->get_type_index());
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call DNALoader.buildGraph() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "buildGraph() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "buildGraph(non-const DNALoader this, non-const DNAStorage dna_store)\n"
          "buildGraph(non-const DNALoader this, non-const DNAStorage dna_store, int editing)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNALoader_build_graph_290_comment =
    "C++ Interface:\n"
    "buildGraph(non-const DNALoader this, non-const DNAStorage dna_store)\n"
    "buildGraph(non-const DNALoader this, non-const DNAStorage dna_store, int editing)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNALoader::build_graph\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNALoader_build_graph_290_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * PointerTo< DNAData > DNALoader::get_data(void)
 *******************************************************************/
static PyObject *Dtool_DNALoader_get_data_291(PyObject *self, PyObject *args,PyObject *kwds) {
    DNALoader * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNALoader,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-PointerTo< DNAData > DNALoader::get_data(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getData", key_word_list));
        else
            (PyArg_Parse(args, ":getData"));
        if(!PyErr_Occurred())
        {
            PointerTo< DNAData > return_value = (local_this)->get_data();
            if (return_value != (DNAData *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_DNAData,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNALoader.getData() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getData(non-const DNALoader this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNALoader_get_data_291_comment =
    "C++ Interface:\n"
    "getData(non-const DNALoader this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNALoader_get_data_291_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNALoader::DNALoader(void)
 *******************************************************************/
int  Dtool_Init_DNALoader(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-DNALoader::DNALoader(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":DNALoader", key_word_list))
        {
            DNALoader *return_value = new DNALoader();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_DNALoader,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DNALoader()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNALoader(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNALoader)
    {
        printf("DNALoader ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNALoader * local_this = (DNALoader *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNALoader)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNALoader(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNALoader)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNAWindows 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DNAWindows::set_code(basic_string< char > code)
 *******************************************************************/
static PyObject *Dtool_DNAWindows_set_code_303(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAWindows * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAWindows,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNAWindows::set_code(basic_string< char > code)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"code", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setCode", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setCode", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_code(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAWindows.setCode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCode(non-const DNAWindows this, string code)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAWindows_set_code_303_comment =
    "C++ Interface:\n"
    "setCode(non-const DNAWindows this, string code)\n"
    "\n"
    "// Filename: dnaWindow.I\n"
    "// Created by:  shochet (11Jun00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAWindows::set_code\n"
    "//       Access: Public\n"
    "//  Description: sets the code of the windows node\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAWindows_set_code_303_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNAWindows::get_code(void) const
 *******************************************************************/
static PyObject *Dtool_DNAWindows_get_code_304(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAWindows * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAWindows,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > DNAWindows::get_code(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCode", key_word_list));
        else
            (PyArg_Parse(args, ":getCode"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DNAWindows*)local_this)->get_code();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCode(const DNAWindows this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAWindows_get_code_304_comment =
    "C++ Interface:\n"
    "getCode(const DNAWindows this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAWindows::get_code\n"
    "//       Access: Public\n"
    "//  Description: returns the code of the windows node\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAWindows_get_code_304_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAWindows::set_window_count(int count)
 *******************************************************************/
static PyObject *Dtool_DNAWindows_set_window_count_305(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAWindows * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAWindows,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNAWindows::set_window_count(int count)
        int param1;
        static char * key_word_list[] = {(char *)"count", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setWindowCount", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setWindowCount", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_window_count((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAWindows.setWindowCount() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWindowCount(non-const DNAWindows this, int count)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAWindows_set_window_count_305_comment =
    "C++ Interface:\n"
    "setWindowCount(non-const DNAWindows this, int count)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAWindows::set_window_count\n"
    "//       Access: Public\n"
    "//  Description: sets the number of windows\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAWindows_set_window_count_305_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int DNAWindows::get_window_count(void) const
 *******************************************************************/
static PyObject *Dtool_DNAWindows_get_window_count_306(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAWindows * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAWindows,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int DNAWindows::get_window_count(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWindowCount", key_word_list));
        else
            (PyArg_Parse(args, ":getWindowCount"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const DNAWindows*)local_this)->get_window_count();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWindowCount(const DNAWindows this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAWindows_get_window_count_306_comment =
    "C++ Interface:\n"
    "getWindowCount(const DNAWindows this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAWindows::get_window_count\n"
    "//       Access: Public\n"
    "//  Description: returns the count of windows\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAWindows_get_window_count_306_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAWindows::set_color(LVecBase4f const &color)
 *******************************************************************/
static PyObject *Dtool_DNAWindows_set_color_307(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAWindows * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAWindows,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DNAWindows::set_color(LVecBase4f const &color)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"color", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setColor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setColor", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "DNAWindows.setColor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_color(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAWindows.setColor() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setColor(non-const DNAWindows this, const VBase4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAWindows_set_color_307_comment =
    "C++ Interface:\n"
    "setColor(non-const DNAWindows this, const VBase4 color)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAWindows::set_color\n"
    "//       Access: Public\n"
    "//  Description: sets the color of the windows node\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAWindows_set_color_307_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f DNAWindows::get_color(void) const
 *******************************************************************/
static PyObject *Dtool_DNAWindows_get_color_308(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAWindows * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAWindows,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f DNAWindows::get_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getColor", key_word_list));
        else
            (PyArg_Parse(args, ":getColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = ((const DNAWindows*)local_this)->get_color();
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getColor(const DNAWindows this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAWindows_get_color_308_comment =
    "C++ Interface:\n"
    "getColor(const DNAWindows this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAWindows::get_color\n"
    "//       Access: Public\n"
    "//  Description: returns the color of the windows node\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAWindows_get_color_308_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNAWindows::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNAWindows_get_class_type_309(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DNAWindows::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DNAWindows::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAWindows_get_class_type_309_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DNAWindows_get_class_type_309_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAWindows::DNAWindows(DNAWindows const &window)
 * DNAWindows::DNAWindows(basic_string< char > const &initial_name)
 * DNAWindows::DNAWindows(basic_string< char > const &initial_name = (""))
 *******************************************************************/
int  Dtool_Init_DNAWindows(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-DNAWindows::DNAWindows(basic_string< char > const &initial_name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":DNAWindows", key_word_list))
            {
                DNAWindows *return_value = new DNAWindows();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAWindows,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 DNAWindows::DNAWindows(DNAWindows const &window)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"window", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DNAWindows", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DNAWindows", &param0));
                if(!PyErr_Occurred())
                {
                    DNAWindows *param0_this = (DNAWindows *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNAWindows, 0, "DNAWindows.DNAWindows", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        DNAWindows *return_value = new DNAWindows(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAWindows,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 DNAWindows::DNAWindows(basic_string< char > const &initial_name)
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"initial_name", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNAWindows", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:DNAWindows", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    DNAWindows *return_value = new DNAWindows(basic_string<char>(param0_str, param0_len));
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAWindows,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "DNAWindows() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "DNAWindows()\n"
          "DNAWindows(const DNAWindows window)\n"
          "DNAWindows(string initial_name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNAWindows(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNAWindows)
    {
        printf("DNAWindows ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNAWindows * local_this = (DNAWindows *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNAWindows)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( DNAGroup *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( DNAGroup *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( DNAGroup *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( DNAGroup *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNAWindows(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNAWindows)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNAWindows*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (DNAWindows*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (DNAWindows*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DNAWindows*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (DNAWindows*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNAStreet 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DNAStreet::set_code(basic_string< char > code)
 *******************************************************************/
static PyObject *Dtool_DNAStreet_set_code_313(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStreet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStreet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNAStreet::set_code(basic_string< char > code)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"code", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setCode", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setCode", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_code(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStreet.setCode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCode(non-const DNAStreet this, string code)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStreet_set_code_313_comment =
    "C++ Interface:\n"
    "setCode(non-const DNAStreet this, string code)\n"
    "\n"
    "// Filename: dnaStreet.I\n"
    "// Created by:  shochet (28Mar00)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAStreet::set_code\n"
    "//       Access: Public\n"
    "//  Description: sets the code of the street node\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStreet_set_code_313_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNAStreet::get_code(void) const
 *******************************************************************/
static PyObject *Dtool_DNAStreet_get_code_314(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStreet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStreet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > DNAStreet::get_code(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCode", key_word_list));
        else
            (PyArg_Parse(args, ":getCode"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DNAStreet*)local_this)->get_code();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCode(const DNAStreet this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStreet_get_code_314_comment =
    "C++ Interface:\n"
    "getCode(const DNAStreet this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAStreet::get_code\n"
    "//       Access: Public\n"
    "//  Description: returns the code of the street node\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStreet_get_code_314_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStreet::set_street_texture(basic_string< char > street_texture)
 *******************************************************************/
static PyObject *Dtool_DNAStreet_set_street_texture_315(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStreet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStreet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNAStreet::set_street_texture(basic_string< char > street_texture)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"street_texture", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setStreetTexture", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setStreetTexture", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_street_texture(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStreet.setStreetTexture() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setStreetTexture(non-const DNAStreet this, string street_texture)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStreet_set_street_texture_315_comment =
    "C++ Interface:\n"
    "setStreetTexture(non-const DNAStreet this, string street_texture)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAStreet::set_street_texture\n"
    "//       Access: Public\n"
    "//  Description: sets the texture of the street node\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStreet_set_street_texture_315_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNAStreet::get_street_texture(void) const
 *******************************************************************/
static PyObject *Dtool_DNAStreet_get_street_texture_316(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStreet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStreet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > DNAStreet::get_street_texture(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStreetTexture", key_word_list));
        else
            (PyArg_Parse(args, ":getStreetTexture"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DNAStreet*)local_this)->get_street_texture();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStreetTexture(const DNAStreet this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStreet_get_street_texture_316_comment =
    "C++ Interface:\n"
    "getStreetTexture(const DNAStreet this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAStreet::get_street_texture\n"
    "//       Access: Public\n"
    "//  Description: returns the texture of the street node\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStreet_get_street_texture_316_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStreet::set_sidewalk_texture(basic_string< char > sidewalk_texture)
 *******************************************************************/
static PyObject *Dtool_DNAStreet_set_sidewalk_texture_317(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStreet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStreet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNAStreet::set_sidewalk_texture(basic_string< char > sidewalk_texture)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"sidewalk_texture", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setSidewalkTexture", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setSidewalkTexture", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_sidewalk_texture(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStreet.setSidewalkTexture() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSidewalkTexture(non-const DNAStreet this, string sidewalk_texture)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStreet_set_sidewalk_texture_317_comment =
    "C++ Interface:\n"
    "setSidewalkTexture(non-const DNAStreet this, string sidewalk_texture)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAStreet::set_sidewalk_texture\n"
    "//       Access: Public\n"
    "//  Description: sets the texture of the sidewalk node\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStreet_set_sidewalk_texture_317_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNAStreet::get_sidewalk_texture(void) const
 *******************************************************************/
static PyObject *Dtool_DNAStreet_get_sidewalk_texture_318(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStreet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStreet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > DNAStreet::get_sidewalk_texture(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSidewalkTexture", key_word_list));
        else
            (PyArg_Parse(args, ":getSidewalkTexture"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DNAStreet*)local_this)->get_sidewalk_texture();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSidewalkTexture(const DNAStreet this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStreet_get_sidewalk_texture_318_comment =
    "C++ Interface:\n"
    "getSidewalkTexture(const DNAStreet this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAStreet::get_sidewalk_texture\n"
    "//       Access: Public\n"
    "//  Description: returns the texture of the sidewalk node\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStreet_get_sidewalk_texture_318_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStreet::set_curb_texture(basic_string< char > curb_texture)
 *******************************************************************/
static PyObject *Dtool_DNAStreet_set_curb_texture_319(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStreet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStreet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNAStreet::set_curb_texture(basic_string< char > curb_texture)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"curb_texture", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setCurbTexture", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setCurbTexture", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_curb_texture(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNAStreet.setCurbTexture() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCurbTexture(non-const DNAStreet this, string curb_texture)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStreet_set_curb_texture_319_comment =
    "C++ Interface:\n"
    "setCurbTexture(non-const DNAStreet this, string curb_texture)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAStreet::set_curb_texture\n"
    "//       Access: Public\n"
    "//  Description: sets the texture of the curb node\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStreet_set_curb_texture_319_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNAStreet::get_curb_texture(void) const
 *******************************************************************/
static PyObject *Dtool_DNAStreet_get_curb_texture_320(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStreet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStreet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > DNAStreet::get_curb_texture(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCurbTexture", key_word_list));
        else
            (PyArg_Parse(args, ":getCurbTexture"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DNAStreet*)local_this)->get_curb_texture();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCurbTexture(const DNAStreet this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStreet_get_curb_texture_320_comment =
    "C++ Interface:\n"
    "getCurbTexture(const DNAStreet this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAStreet::get_curb_texture\n"
    "//       Access: Public\n"
    "//  Description: returns the texture of the curb node\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStreet_get_curb_texture_320_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStreet::set_street_color(LVecBase4f const &color)
 *******************************************************************/
static PyObject *Dtool_DNAStreet_set_street_color_321(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStreet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStreet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DNAStreet::set_street_color(LVecBase4f const &color)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"color", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setStreetColor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setStreetColor", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "DNAStreet.setStreetColor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_street_color(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAStreet.setStreetColor() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setStreetColor(non-const DNAStreet this, const VBase4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStreet_set_street_color_321_comment =
    "C++ Interface:\n"
    "setStreetColor(non-const DNAStreet this, const VBase4 color)\n"
    "\n"
    "// For now we no longer support color on streets to allow vertex color\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAStreet::set_street_color\n"
    "//       Access: Public\n"
    "//  Description: sets the color of the street node\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStreet_set_street_color_321_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f DNAStreet::get_street_color(void) const
 *******************************************************************/
static PyObject *Dtool_DNAStreet_get_street_color_322(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStreet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStreet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f DNAStreet::get_street_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStreetColor", key_word_list));
        else
            (PyArg_Parse(args, ":getStreetColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = ((const DNAStreet*)local_this)->get_street_color();
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStreetColor(const DNAStreet this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStreet_get_street_color_322_comment =
    "C++ Interface:\n"
    "getStreetColor(const DNAStreet this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAStreet::get_street_color\n"
    "//       Access: Public\n"
    "//  Description: returns the color of the street node\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStreet_get_street_color_322_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStreet::set_sidewalk_color(LVecBase4f const &color)
 *******************************************************************/
static PyObject *Dtool_DNAStreet_set_sidewalk_color_323(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStreet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStreet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DNAStreet::set_sidewalk_color(LVecBase4f const &color)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"color", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setSidewalkColor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setSidewalkColor", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "DNAStreet.setSidewalkColor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_sidewalk_color(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAStreet.setSidewalkColor() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSidewalkColor(non-const DNAStreet this, const VBase4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStreet_set_sidewalk_color_323_comment =
    "C++ Interface:\n"
    "setSidewalkColor(non-const DNAStreet this, const VBase4 color)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAStreet::set_sidewalk_color\n"
    "//       Access: Public\n"
    "//  Description: sets the color of the sidewalk node\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStreet_set_sidewalk_color_323_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f DNAStreet::get_sidewalk_color(void) const
 *******************************************************************/
static PyObject *Dtool_DNAStreet_get_sidewalk_color_324(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStreet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStreet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f DNAStreet::get_sidewalk_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSidewalkColor", key_word_list));
        else
            (PyArg_Parse(args, ":getSidewalkColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = ((const DNAStreet*)local_this)->get_sidewalk_color();
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSidewalkColor(const DNAStreet this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStreet_get_sidewalk_color_324_comment =
    "C++ Interface:\n"
    "getSidewalkColor(const DNAStreet this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAStreet::get_sidewalk_color\n"
    "//       Access: Public\n"
    "//  Description: returns the color of the sidewalk node\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStreet_get_sidewalk_color_324_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNAStreet::set_curb_color(LVecBase4f const &color)
 *******************************************************************/
static PyObject *Dtool_DNAStreet_set_curb_color_325(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStreet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStreet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DNAStreet::set_curb_color(LVecBase4f const &color)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"color", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCurbColor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setCurbColor", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "DNAStreet.setCurbColor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_curb_color(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNAStreet.setCurbColor() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCurbColor(non-const DNAStreet this, const VBase4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStreet_set_curb_color_325_comment =
    "C++ Interface:\n"
    "setCurbColor(non-const DNAStreet this, const VBase4 color)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAStreet::set_curb_color\n"
    "//       Access: Public\n"
    "//  Description: sets the color of the sidewalk node\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStreet_set_curb_color_325_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f DNAStreet::get_curb_color(void) const
 *******************************************************************/
static PyObject *Dtool_DNAStreet_get_curb_color_326(PyObject *self, PyObject *args,PyObject *kwds) {
    DNAStreet * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStreet,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f DNAStreet::get_curb_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCurbColor", key_word_list));
        else
            (PyArg_Parse(args, ":getCurbColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = ((const DNAStreet*)local_this)->get_curb_color();
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCurbColor(const DNAStreet this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStreet_get_curb_color_326_comment =
    "C++ Interface:\n"
    "getCurbColor(const DNAStreet this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNAStreet::get_curb_color\n"
    "//       Access: Public\n"
    "//  Description: returns the color of the curb node\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNAStreet_get_curb_color_326_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNAStreet::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNAStreet_get_class_type_327(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DNAStreet::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DNAStreet::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNAStreet_get_class_type_327_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DNAStreet_get_class_type_327_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNAStreet::DNAStreet(DNAStreet const &street)
 * DNAStreet::DNAStreet(basic_string< char > const &initial_name)
 *******************************************************************/
int  Dtool_Init_DNAStreet(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 DNAStreet::DNAStreet(DNAStreet const &street)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"street", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:DNAStreet", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:DNAStreet", &param0));
            if(!PyErr_Occurred())
            {
                DNAStreet *param0_this = (DNAStreet *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNAStreet, 0, "DNAStreet.DNAStreet", 1, NULL, true);

                if (!((param0_this == NULL)))
                {
                    DNAStreet *return_value = new DNAStreet(*param0_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAStreet,true,false);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 DNAStreet::DNAStreet(basic_string< char > const &initial_name)
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"initial_name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNAStreet", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:DNAStreet", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                DNAStreet *return_value = new DNAStreet(basic_string<char>(param0_str, param0_len));
                return_value->ref();
                Py_XDECREF(coerced);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DNAStreet,true,false);
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "DNAStreet(const DNAStreet street)\n"
          "DNAStreet(string initial_name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNAStreet(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNAStreet)
    {
        printf("DNAStreet ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNAStreet * local_this = (DNAStreet *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNAStreet)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_DNANode)
        return ( DNANode *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( DNAGroup *)( DNANode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNAStreet(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNAStreet)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNAStreet*)other_this;
    }
    if(from_type == &Dtool_DNANode)
    {
          DNANode* other_this = (DNANode*)from_this;
          return (DNAStreet*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (DNAStreet*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (DNAStreet*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DNAStreet*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (DNAStreet*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNASign 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void DNASign::set_code(basic_string< char > code)
 *******************************************************************/
static PyObject *Dtool_DNASign_set_code_331(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASign * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASign,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNASign::set_code(basic_string< char > code)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"code", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setCode", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setCode", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_code(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASign.setCode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCode(non-const DNASign this, string code)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASign_set_code_331_comment =
    "C++ Interface:\n"
    "setCode(non-const DNASign this, string code)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASign_set_code_331_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DNASign::get_code(void) const
 *******************************************************************/
static PyObject *Dtool_DNASign_get_code_332(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASign * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASign,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > DNASign::get_code(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCode", key_word_list));
        else
            (PyArg_Parse(args, ":getCode"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DNASign*)local_this)->get_code();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCode(const DNASign this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASign_get_code_332_comment =
    "C++ Interface:\n"
    "getCode(const DNASign this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASign_get_code_332_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNASign::set_color(LVecBase4f const &color)
 *******************************************************************/
static PyObject *Dtool_DNASign_set_color_333(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASign * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASign,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DNASign::set_color(LVecBase4f const &color)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"color", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setColor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setColor", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "DNASign.setColor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_color(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNASign.setColor() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setColor(non-const DNASign this, const VBase4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASign_set_color_333_comment =
    "C++ Interface:\n"
    "setColor(non-const DNASign this, const VBase4 color)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASign_set_color_333_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LVecBase4f DNASign::get_color(void) const
 *******************************************************************/
static PyObject *Dtool_DNASign_get_color_334(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASign * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASign,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-LVecBase4f DNASign::get_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getColor", key_word_list));
        else
            (PyArg_Parse(args, ":getColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = ((const DNASign*)local_this)->get_color();
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getColor(const DNASign this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASign_get_color_334_comment =
    "C++ Interface:\n"
    "getColor(const DNASign this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASign_get_color_334_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNASign::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNASign_get_class_type_335(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DNASign::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DNASign::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASign_get_class_type_335_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DNASign_get_class_type_335_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNASign::DNASign(DNASign const &Sign)
 * DNASign::DNASign(basic_string< char > const &initial_name)
 * DNASign::DNASign(basic_string< char > const &initial_name = (""))
 *******************************************************************/
int  Dtool_Init_DNASign(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-DNASign::DNASign(basic_string< char > const &initial_name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":DNASign", key_word_list))
            {
                DNASign *return_value = new DNASign();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DNASign,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 DNASign::DNASign(DNASign const &Sign)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"Sign", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DNASign", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DNASign", &param0));
                if(!PyErr_Occurred())
                {
                    DNASign *param0_this = (DNASign *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNASign, 0, "DNASign.DNASign", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        DNASign *return_value = new DNASign(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DNASign,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 DNASign::DNASign(basic_string< char > const &initial_name)
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"initial_name", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNASign", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:DNASign", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    DNASign *return_value = new DNASign(basic_string<char>(param0_str, param0_len));
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_DNASign,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "DNASign() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "DNASign()\n"
          "DNASign(const DNASign Sign)\n"
          "DNASign(string initial_name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNASign(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNASign)
    {
        printf("DNASign ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNASign * local_this = (DNASign *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNASign)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_DNANode)
        return ( DNANode *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( DNAGroup *)( DNANode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNASign(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNASign)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNASign*)other_this;
    }
    if(from_type == &Dtool_DNANode)
    {
          DNANode* other_this = (DNANode*)from_this;
          return (DNASign*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (DNASign*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (DNASign*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DNASign*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (DNASign*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNASignBaseline 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DNASignBaseline::set_code(basic_string< char > code)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_set_code_339(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignBaseline * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignBaseline,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNASignBaseline::set_code(basic_string< char > code)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"code", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setCode", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setCode", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_code(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASignBaseline.setCode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCode(non-const DNASignBaseline this, string code)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_set_code_339_comment =
    "C++ Interface:\n"
    "setCode(non-const DNASignBaseline this, string code)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignBaseline_set_code_339_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNASignBaseline::get_code(void) const
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_get_code_340(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignBaseline * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignBaseline,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > DNASignBaseline::get_code(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCode", key_word_list));
        else
            (PyArg_Parse(args, ":getCode"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DNASignBaseline*)local_this)->get_code();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCode(const DNASignBaseline this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_get_code_340_comment =
    "C++ Interface:\n"
    "getCode(const DNASignBaseline this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignBaseline_get_code_340_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASignBaseline::set_color(LVecBase4f const &color)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_set_color_341(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignBaseline * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignBaseline,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DNASignBaseline::set_color(LVecBase4f const &color)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"color", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setColor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setColor", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "DNASignBaseline.setColor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_color(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNASignBaseline.setColor() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setColor(non-const DNASignBaseline this, const VBase4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_set_color_341_comment =
    "C++ Interface:\n"
    "setColor(non-const DNASignBaseline this, const VBase4 color)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignBaseline_set_color_341_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f DNASignBaseline::get_color(void) const
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_get_color_342(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignBaseline * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignBaseline,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f DNASignBaseline::get_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getColor", key_word_list));
        else
            (PyArg_Parse(args, ":getColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = ((const DNASignBaseline*)local_this)->get_color();
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getColor(const DNASignBaseline this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_get_color_342_comment =
    "C++ Interface:\n"
    "getColor(const DNASignBaseline this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignBaseline_get_color_342_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASignBaseline::set_font(TextFont *font)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_set_font_343(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignBaseline * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignBaseline,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DNASignBaseline::set_font(TextFont *font)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"font", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFont", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setFont", &param1));
            if(!PyErr_Occurred())
            {
                TextFont *param1_this = (TextFont *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_TextFont, 1, "DNASignBaseline.setFont", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_font(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNASignBaseline.setFont() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFont(non-const DNASignBaseline this, non-const TextFont font)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_set_font_343_comment =
    "C++ Interface:\n"
    "setFont(non-const DNASignBaseline this, non-const TextFont font)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignBaseline_set_font_343_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline TextFont *DNASignBaseline::get_font(void) const
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_get_font_344(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignBaseline * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignBaseline,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline TextFont *DNASignBaseline::get_font(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFont", key_word_list));
        else
            (PyArg_Parse(args, ":getFont"));
        if(!PyErr_Occurred())
        {
            TextFont *return_value = ((const DNASignBaseline*)local_this)->get_font();
            if (return_value != (TextFont *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_TextFont,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFont(const DNASignBaseline this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_get_font_344_comment =
    "C++ Interface:\n"
    "getFont(const DNASignBaseline this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignBaseline_get_font_344_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASignBaseline::set_indent(float indent)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_set_indent_345(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignBaseline * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignBaseline,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNASignBaseline::set_indent(float indent)
        double param1;
        static char * key_word_list[] = {(char *)"indent", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setIndent", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setIndent", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_indent((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASignBaseline.setIndent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setIndent(non-const DNASignBaseline this, float indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_set_indent_345_comment =
    "C++ Interface:\n"
    "setIndent(non-const DNASignBaseline this, float indent)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignBaseline_set_indent_345_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DNASignBaseline::get_indent(void) const
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_get_indent_346(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignBaseline * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignBaseline,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DNASignBaseline::get_indent(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getIndent", key_word_list));
        else
            (PyArg_Parse(args, ":getIndent"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DNASignBaseline*)local_this)->get_indent();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIndent(const DNASignBaseline this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_get_indent_346_comment =
    "C++ Interface:\n"
    "getIndent(const DNASignBaseline this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignBaseline_get_indent_346_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASignBaseline::set_kern(float kern)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_set_kern_347(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignBaseline * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignBaseline,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNASignBaseline::set_kern(float kern)
        double param1;
        static char * key_word_list[] = {(char *)"kern", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setKern", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setKern", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_kern((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASignBaseline.setKern() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setKern(non-const DNASignBaseline this, float kern)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_set_kern_347_comment =
    "C++ Interface:\n"
    "setKern(non-const DNASignBaseline this, float kern)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignBaseline_set_kern_347_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DNASignBaseline::get_kern(void) const
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_get_kern_348(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignBaseline * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignBaseline,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DNASignBaseline::get_kern(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getKern", key_word_list));
        else
            (PyArg_Parse(args, ":getKern"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DNASignBaseline*)local_this)->get_kern();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getKern(const DNASignBaseline this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_get_kern_348_comment =
    "C++ Interface:\n"
    "getKern(const DNASignBaseline this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignBaseline_get_kern_348_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DNASignBaseline::get_current_kern(void)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_get_current_kern_349(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignBaseline * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignBaseline,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline float DNASignBaseline::get_current_kern(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCurrentKern", key_word_list));
        else
            (PyArg_Parse(args, ":getCurrentKern"));
        if(!PyErr_Occurred())
        {
            float return_value = (local_this)->get_current_kern();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASignBaseline.getCurrentKern() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCurrentKern(non-const DNASignBaseline this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_get_current_kern_349_comment =
    "C++ Interface:\n"
    "getCurrentKern(non-const DNASignBaseline this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignBaseline_get_current_kern_349_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASignBaseline::set_wiggle(float wiggle)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_set_wiggle_350(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignBaseline * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignBaseline,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNASignBaseline::set_wiggle(float wiggle)
        double param1;
        static char * key_word_list[] = {(char *)"wiggle", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setWiggle", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setWiggle", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_wiggle((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASignBaseline.setWiggle() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWiggle(non-const DNASignBaseline this, float wiggle)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_set_wiggle_350_comment =
    "C++ Interface:\n"
    "setWiggle(non-const DNASignBaseline this, float wiggle)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignBaseline_set_wiggle_350_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DNASignBaseline::get_wiggle(void) const
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_get_wiggle_351(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignBaseline * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignBaseline,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DNASignBaseline::get_wiggle(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWiggle", key_word_list));
        else
            (PyArg_Parse(args, ":getWiggle"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DNASignBaseline*)local_this)->get_wiggle();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWiggle(const DNASignBaseline this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_get_wiggle_351_comment =
    "C++ Interface:\n"
    "getWiggle(const DNASignBaseline this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignBaseline_get_wiggle_351_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DNASignBaseline::get_current_wiggle(void)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_get_current_wiggle_352(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignBaseline * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignBaseline,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline float DNASignBaseline::get_current_wiggle(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCurrentWiggle", key_word_list));
        else
            (PyArg_Parse(args, ":getCurrentWiggle"));
        if(!PyErr_Occurred())
        {
            float return_value = (local_this)->get_current_wiggle();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASignBaseline.getCurrentWiggle() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCurrentWiggle(non-const DNASignBaseline this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_get_current_wiggle_352_comment =
    "C++ Interface:\n"
    "getCurrentWiggle(non-const DNASignBaseline this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignBaseline_get_current_wiggle_352_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASignBaseline::set_stumble(float stumble)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_set_stumble_353(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignBaseline * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignBaseline,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNASignBaseline::set_stumble(float stumble)
        double param1;
        static char * key_word_list[] = {(char *)"stumble", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setStumble", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setStumble", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_stumble((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASignBaseline.setStumble() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setStumble(non-const DNASignBaseline this, float stumble)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_set_stumble_353_comment =
    "C++ Interface:\n"
    "setStumble(non-const DNASignBaseline this, float stumble)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignBaseline_set_stumble_353_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DNASignBaseline::get_stumble(void) const
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_get_stumble_354(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignBaseline * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignBaseline,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DNASignBaseline::get_stumble(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStumble", key_word_list));
        else
            (PyArg_Parse(args, ":getStumble"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DNASignBaseline*)local_this)->get_stumble();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStumble(const DNASignBaseline this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_get_stumble_354_comment =
    "C++ Interface:\n"
    "getStumble(const DNASignBaseline this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignBaseline_get_stumble_354_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DNASignBaseline::get_current_stumble(void)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_get_current_stumble_355(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignBaseline * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignBaseline,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline float DNASignBaseline::get_current_stumble(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCurrentStumble", key_word_list));
        else
            (PyArg_Parse(args, ":getCurrentStumble"));
        if(!PyErr_Occurred())
        {
            float return_value = (local_this)->get_current_stumble();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASignBaseline.getCurrentStumble() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCurrentStumble(non-const DNASignBaseline this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_get_current_stumble_355_comment =
    "C++ Interface:\n"
    "getCurrentStumble(non-const DNASignBaseline this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignBaseline_get_current_stumble_355_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASignBaseline::set_stomp(float stomp)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_set_stomp_356(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignBaseline * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignBaseline,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNASignBaseline::set_stomp(float stomp)
        double param1;
        static char * key_word_list[] = {(char *)"stomp", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setStomp", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setStomp", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_stomp((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASignBaseline.setStomp() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setStomp(non-const DNASignBaseline this, float stomp)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_set_stomp_356_comment =
    "C++ Interface:\n"
    "setStomp(non-const DNASignBaseline this, float stomp)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignBaseline_set_stomp_356_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DNASignBaseline::get_stomp(void) const
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_get_stomp_357(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignBaseline * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignBaseline,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DNASignBaseline::get_stomp(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStomp", key_word_list));
        else
            (PyArg_Parse(args, ":getStomp"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DNASignBaseline*)local_this)->get_stomp();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStomp(const DNASignBaseline this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_get_stomp_357_comment =
    "C++ Interface:\n"
    "getStomp(const DNASignBaseline this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignBaseline_get_stomp_357_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DNASignBaseline::get_current_stomp(void)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_get_current_stomp_358(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignBaseline * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignBaseline,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline float DNASignBaseline::get_current_stomp(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCurrentStomp", key_word_list));
        else
            (PyArg_Parse(args, ":getCurrentStomp"));
        if(!PyErr_Occurred())
        {
            float return_value = (local_this)->get_current_stomp();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASignBaseline.getCurrentStomp() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCurrentStomp(non-const DNASignBaseline this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_get_current_stomp_358_comment =
    "C++ Interface:\n"
    "getCurrentStomp(non-const DNASignBaseline this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignBaseline_get_current_stomp_358_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASignBaseline::set_width(float width)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_set_width_359(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignBaseline * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignBaseline,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNASignBaseline::set_width(float width)
        double param1;
        static char * key_word_list[] = {(char *)"width", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setWidth", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setWidth", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_width((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASignBaseline.setWidth() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWidth(non-const DNASignBaseline this, float width)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_set_width_359_comment =
    "C++ Interface:\n"
    "setWidth(non-const DNASignBaseline this, float width)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignBaseline_set_width_359_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DNASignBaseline::get_width(void) const
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_get_width_360(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignBaseline * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignBaseline,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DNASignBaseline::get_width(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWidth", key_word_list));
        else
            (PyArg_Parse(args, ":getWidth"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DNASignBaseline*)local_this)->get_width();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWidth(const DNASignBaseline this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_get_width_360_comment =
    "C++ Interface:\n"
    "getWidth(const DNASignBaseline this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignBaseline_get_width_360_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASignBaseline::set_height(float height)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_set_height_361(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignBaseline * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignBaseline,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNASignBaseline::set_height(float height)
        double param1;
        static char * key_word_list[] = {(char *)"height", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setHeight", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setHeight", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_height((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASignBaseline.setHeight() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setHeight(non-const DNASignBaseline this, float height)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_set_height_361_comment =
    "C++ Interface:\n"
    "setHeight(non-const DNASignBaseline this, float height)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignBaseline_set_height_361_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float DNASignBaseline::get_height(void) const
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_get_height_362(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignBaseline * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignBaseline,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float DNASignBaseline::get_height(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHeight", key_word_list));
        else
            (PyArg_Parse(args, ":getHeight"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DNASignBaseline*)local_this)->get_height();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHeight(const DNASignBaseline this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_get_height_362_comment =
    "C++ Interface:\n"
    "getHeight(const DNASignBaseline this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignBaseline_get_height_362_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASignBaseline::set_flags(basic_string< char > flags)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_set_flags_363(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignBaseline * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignBaseline,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNASignBaseline::set_flags(basic_string< char > flags)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"flags", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setFlags", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setFlags", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_flags(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASignBaseline.setFlags() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFlags(non-const DNASignBaseline this, string flags)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_set_flags_363_comment =
    "C++ Interface:\n"
    "setFlags(non-const DNASignBaseline this, string flags)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignBaseline_set_flags_363_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNASignBaseline::get_flags(void) const
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_get_flags_364(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignBaseline * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignBaseline,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > DNASignBaseline::get_flags(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFlags", key_word_list));
        else
            (PyArg_Parse(args, ":getFlags"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DNASignBaseline*)local_this)->get_flags();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFlags(const DNASignBaseline this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_get_flags_364_comment =
    "C++ Interface:\n"
    "getFlags(const DNASignBaseline this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignBaseline_get_flags_364_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool DNASignBaseline::isFirstLetterOfWord(basic_string< char > letter)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_isFirstLetterOfWord_365(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignBaseline * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignBaseline,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-bool DNASignBaseline::isFirstLetterOfWord(basic_string< char > letter)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"letter", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:isFirstLetterOfWord", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:isFirstLetterOfWord", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->isFirstLetterOfWord(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASignBaseline.isFirstLetterOfWord() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isFirstLetterOfWord(non-const DNASignBaseline this, string letter)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_isFirstLetterOfWord_365_comment =
    "C++ Interface:\n"
    "isFirstLetterOfWord(non-const DNASignBaseline this, string letter)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNASignBaseline::isFirstLetterOfWord\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNASignBaseline_isFirstLetterOfWord_365_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNASignBaseline::reset_counter(void)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_reset_counter_366(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignBaseline * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignBaseline,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNASignBaseline::reset_counter(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":resetCounter", key_word_list));
        else
            (PyArg_Parse(args, ":resetCounter"));
        if(!PyErr_Occurred())
        {
            (local_this)->reset_counter();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASignBaseline.resetCounter() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resetCounter(non-const DNASignBaseline this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_reset_counter_366_comment =
    "C++ Interface:\n"
    "resetCounter(non-const DNASignBaseline this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignBaseline_reset_counter_366_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNASignBaseline::inc_counter(void)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_inc_counter_367(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignBaseline * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignBaseline,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNASignBaseline::inc_counter(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":incCounter", key_word_list));
        else
            (PyArg_Parse(args, ":incCounter"));
        if(!PyErr_Occurred())
        {
            (local_this)->inc_counter();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASignBaseline.incCounter() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "incCounter(non-const DNASignBaseline this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_inc_counter_367_comment =
    "C++ Interface:\n"
    "incCounter(non-const DNASignBaseline this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignBaseline_inc_counter_367_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void DNASignBaseline::baseline_next_pos_hpr_scale(LVector3f &pos, LVector3f &hpr, LVector3f &scale, LVector3f const &size)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_baseline_next_pos_hpr_scale_368(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignBaseline * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignBaseline,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-virtual void DNASignBaseline::baseline_next_pos_hpr_scale(LVector3f &pos, LVector3f &hpr, LVector3f &scale, LVector3f const &size)
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            PyObject *param4;
            static char * key_word_list[] = {(char *)"pos", (char *)"hpr", (char *)"scale", (char *)"size", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOO:baselineNextPosHprScale", key_word_list, &param1, &param2, &param3, &param4))
            {
                LVector3f *param1_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVector3f, 1, "DNASignBaseline.baselineNextPosHprScale", 0, coerced_ptr, report_errors);
LVector3f *param2_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVector3f, 2, "DNASignBaseline.baselineNextPosHprScale", 0, coerced_ptr, report_errors);
LVector3f *param3_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVector3f, 3, "DNASignBaseline.baselineNextPosHprScale", 0, coerced_ptr, report_errors);
LVector3f *param4_this = (LVector3f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LVector3f, 4, "DNASignBaseline.baselineNextPosHprScale", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)|| (param3_this == NULL)|| (param4_this == NULL)))
                {
                    (local_this)->baseline_next_pos_hpr_scale(*param1_this, *param2_this, *param3_this, *param4_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNASignBaseline.baselineNextPosHprScale() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "baselineNextPosHprScale(non-const DNASignBaseline this, non-const Vec3 pos, non-const Vec3 hpr, non-const Vec3 scale, const Vec3 size)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_baseline_next_pos_hpr_scale_368_comment =
    "C++ Interface:\n"
    "baselineNextPosHprScale(non-const DNASignBaseline this, non-const Vec3 pos, non-const Vec3 hpr, non-const Vec3 scale, const Vec3 size)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: DNASignBaseline::baseline_pos_hpr_scale\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_DNASignBaseline_baseline_next_pos_hpr_scale_368_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNASignBaseline::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNASignBaseline_get_class_type_369(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DNASignBaseline::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DNASignBaseline::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignBaseline_get_class_type_369_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignBaseline_get_class_type_369_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNASignBaseline::DNASignBaseline(DNASignBaseline const &Sign)
 * DNASignBaseline::DNASignBaseline(basic_string< char > const &initial_name)
 * DNASignBaseline::DNASignBaseline(basic_string< char > const &initial_name = (""))
 *******************************************************************/
int  Dtool_Init_DNASignBaseline(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-DNASignBaseline::DNASignBaseline(basic_string< char > const &initial_name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":DNASignBaseline", key_word_list))
            {
                DNASignBaseline *return_value = new DNASignBaseline();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DNASignBaseline,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 DNASignBaseline::DNASignBaseline(DNASignBaseline const &Sign)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"Sign", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DNASignBaseline", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DNASignBaseline", &param0));
                if(!PyErr_Occurred())
                {
                    DNASignBaseline *param0_this = (DNASignBaseline *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNASignBaseline, 0, "DNASignBaseline.DNASignBaseline", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        DNASignBaseline *return_value = new DNASignBaseline(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DNASignBaseline,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 DNASignBaseline::DNASignBaseline(basic_string< char > const &initial_name)
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"initial_name", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNASignBaseline", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:DNASignBaseline", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    DNASignBaseline *return_value = new DNASignBaseline(basic_string<char>(param0_str, param0_len));
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_DNASignBaseline,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "DNASignBaseline() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "DNASignBaseline()\n"
          "DNASignBaseline(const DNASignBaseline Sign)\n"
          "DNASignBaseline(string initial_name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNASignBaseline(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNASignBaseline)
    {
        printf("DNASignBaseline ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNASignBaseline * local_this = (DNASignBaseline *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNASignBaseline)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_DNANode)
        return ( DNANode *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( DNAGroup *)( DNANode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNASignBaseline(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNASignBaseline)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNASignBaseline*)other_this;
    }
    if(from_type == &Dtool_DNANode)
    {
          DNANode* other_this = (DNANode*)from_this;
          return (DNASignBaseline*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (DNASignBaseline*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (DNASignBaseline*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DNASignBaseline*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (DNASignBaseline*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNASignGraphic 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void DNASignGraphic::set_code(basic_string< char > code)
 *******************************************************************/
static PyObject *Dtool_DNASignGraphic_set_code_373(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignGraphic * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignGraphic,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNASignGraphic::set_code(basic_string< char > code)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"code", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setCode", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setCode", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_code(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASignGraphic.setCode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCode(non-const DNASignGraphic this, string code)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignGraphic_set_code_373_comment =
    "C++ Interface:\n"
    "setCode(non-const DNASignGraphic this, string code)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignGraphic_set_code_373_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * basic_string< char > DNASignGraphic::get_code(void) const
 *******************************************************************/
static PyObject *Dtool_DNASignGraphic_get_code_374(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignGraphic * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignGraphic,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-basic_string< char > DNASignGraphic::get_code(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCode", key_word_list));
        else
            (PyArg_Parse(args, ":getCode"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DNASignGraphic*)local_this)->get_code();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCode(const DNASignGraphic this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignGraphic_get_code_374_comment =
    "C++ Interface:\n"
    "getCode(const DNASignGraphic this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignGraphic_get_code_374_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNASignGraphic::set_color(LVecBase4f const &color)
 *******************************************************************/
static PyObject *Dtool_DNASignGraphic_set_color_375(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignGraphic * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignGraphic,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void DNASignGraphic::set_color(LVecBase4f const &color)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"color", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setColor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setColor", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "DNASignGraphic.setColor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_color(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNASignGraphic.setColor() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setColor(non-const DNASignGraphic this, const VBase4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignGraphic_set_color_375_comment =
    "C++ Interface:\n"
    "setColor(non-const DNASignGraphic this, const VBase4 color)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignGraphic_set_color_375_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * LVecBase4f DNASignGraphic::get_color(void) const
 *******************************************************************/
static PyObject *Dtool_DNASignGraphic_get_color_376(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignGraphic * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignGraphic,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-LVecBase4f DNASignGraphic::get_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getColor", key_word_list));
        else
            (PyArg_Parse(args, ":getColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = ((const DNASignGraphic*)local_this)->get_color();
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getColor(const DNASignGraphic this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignGraphic_get_color_376_comment =
    "C++ Interface:\n"
    "getColor(const DNASignGraphic this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignGraphic_get_color_376_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNASignGraphic::set_width(float width)
 *******************************************************************/
static PyObject *Dtool_DNASignGraphic_set_width_377(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignGraphic * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignGraphic,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNASignGraphic::set_width(float width)
        double param1;
        static char * key_word_list[] = {(char *)"width", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setWidth", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setWidth", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_width((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASignGraphic.setWidth() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setWidth(non-const DNASignGraphic this, float width)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignGraphic_set_width_377_comment =
    "C++ Interface:\n"
    "setWidth(non-const DNASignGraphic this, float width)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignGraphic_set_width_377_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float DNASignGraphic::get_width(void) const
 *******************************************************************/
static PyObject *Dtool_DNASignGraphic_get_width_378(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignGraphic * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignGraphic,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-float DNASignGraphic::get_width(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getWidth", key_word_list));
        else
            (PyArg_Parse(args, ":getWidth"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DNASignGraphic*)local_this)->get_width();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getWidth(const DNASignGraphic this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignGraphic_get_width_378_comment =
    "C++ Interface:\n"
    "getWidth(const DNASignGraphic this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignGraphic_get_width_378_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void DNASignGraphic::set_height(float height)
 *******************************************************************/
static PyObject *Dtool_DNASignGraphic_set_height_379(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignGraphic * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignGraphic,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void DNASignGraphic::set_height(float height)
        double param1;
        static char * key_word_list[] = {(char *)"height", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setHeight", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setHeight", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_height((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASignGraphic.setHeight() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setHeight(non-const DNASignGraphic this, float height)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignGraphic_set_height_379_comment =
    "C++ Interface:\n"
    "setHeight(non-const DNASignGraphic this, float height)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignGraphic_set_height_379_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float DNASignGraphic::get_height(void) const
 *******************************************************************/
static PyObject *Dtool_DNASignGraphic_get_height_380(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignGraphic * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignGraphic,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-float DNASignGraphic::get_height(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getHeight", key_word_list));
        else
            (PyArg_Parse(args, ":getHeight"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const DNASignGraphic*)local_this)->get_height();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getHeight(const DNASignGraphic this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignGraphic_get_height_380_comment =
    "C++ Interface:\n"
    "getHeight(const DNASignGraphic this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignGraphic_get_height_380_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNASignGraphic::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNASignGraphic_get_class_type_381(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DNASignGraphic::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DNASignGraphic::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignGraphic_get_class_type_381_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignGraphic_get_class_type_381_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNASignGraphic::DNASignGraphic(DNASignGraphic const &graphic)
 * DNASignGraphic::DNASignGraphic(basic_string< char > const &initial_name)
 * DNASignGraphic::DNASignGraphic(basic_string< char > const &initial_name = (""))
 *******************************************************************/
int  Dtool_Init_DNASignGraphic(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-DNASignGraphic::DNASignGraphic(basic_string< char > const &initial_name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":DNASignGraphic", key_word_list))
            {
                DNASignGraphic *return_value = new DNASignGraphic();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DNASignGraphic,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 DNASignGraphic::DNASignGraphic(DNASignGraphic const &graphic)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"graphic", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DNASignGraphic", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DNASignGraphic", &param0));
                if(!PyErr_Occurred())
                {
                    DNASignGraphic *param0_this = (DNASignGraphic *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNASignGraphic, 0, "DNASignGraphic.DNASignGraphic", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        DNASignGraphic *return_value = new DNASignGraphic(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DNASignGraphic,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 DNASignGraphic::DNASignGraphic(basic_string< char > const &initial_name)
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"initial_name", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNASignGraphic", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:DNASignGraphic", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    DNASignGraphic *return_value = new DNASignGraphic(basic_string<char>(param0_str, param0_len));
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_DNASignGraphic,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "DNASignGraphic() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "DNASignGraphic()\n"
          "DNASignGraphic(const DNASignGraphic graphic)\n"
          "DNASignGraphic(string initial_name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNASignGraphic(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNASignGraphic)
    {
        printf("DNASignGraphic ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNASignGraphic * local_this = (DNASignGraphic *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNASignGraphic)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_DNANode)
        return ( DNANode *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( DNAGroup *)( DNANode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNASignGraphic(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNASignGraphic)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNASignGraphic*)other_this;
    }
    if(from_type == &Dtool_DNANode)
    {
          DNANode* other_this = (DNANode*)from_this;
          return (DNASignGraphic*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (DNASignGraphic*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (DNASignGraphic*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DNASignGraphic*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (DNASignGraphic*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. DNASignText 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void DNASignText::set_code(basic_string< char > code)
 *******************************************************************/
static PyObject *Dtool_DNASignText_set_code_385(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignText * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignText,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNASignText::set_code(basic_string< char > code)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"code", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setCode", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setCode", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_code(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASignText.setCode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCode(non-const DNASignText this, string code)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignText_set_code_385_comment =
    "C++ Interface:\n"
    "setCode(non-const DNASignText this, string code)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignText_set_code_385_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNASignText::get_code(void) const
 *******************************************************************/
static PyObject *Dtool_DNASignText_get_code_386(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignText * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignText,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > DNASignText::get_code(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCode", key_word_list));
        else
            (PyArg_Parse(args, ":getCode"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DNASignText*)local_this)->get_code();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCode(const DNASignText this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignText_get_code_386_comment =
    "C++ Interface:\n"
    "getCode(const DNASignText this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignText_get_code_386_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASignText::set_color(LVecBase4f const &color)
 *******************************************************************/
static PyObject *Dtool_DNASignText_set_color_387(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignText * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignText,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void DNASignText::set_color(LVecBase4f const &color)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"color", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setColor", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setColor", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "DNASignText.setColor", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_color(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call DNASignText.setColor() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setColor(non-const DNASignText this, const VBase4 color)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignText_set_color_387_comment =
    "C++ Interface:\n"
    "setColor(non-const DNASignText this, const VBase4 color)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignText_set_color_387_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f DNASignText::get_color(void) const
 *******************************************************************/
static PyObject *Dtool_DNASignText_get_color_388(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignText * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignText,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f DNASignText::get_color(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getColor", key_word_list));
        else
            (PyArg_Parse(args, ":getColor"));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = ((const DNASignText*)local_this)->get_color();
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getColor(const DNASignText this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignText_get_color_388_comment =
    "C++ Interface:\n"
    "getColor(const DNASignText this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignText_get_color_388_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void DNASignText::set_letters(basic_string< char > letters)
 *******************************************************************/
static PyObject *Dtool_DNASignText_set_letters_389(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignText * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignText,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void DNASignText::set_letters(basic_string< char > letters)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"letters", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setLetters", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setLetters", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_letters(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call DNASignText.setLetters() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setLetters(non-const DNASignText this, string letters)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignText_set_letters_389_comment =
    "C++ Interface:\n"
    "setLetters(non-const DNASignText this, string letters)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignText_set_letters_389_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > DNASignText::get_letters(void) const
 *******************************************************************/
static PyObject *Dtool_DNASignText_get_letters_390(PyObject *self, PyObject *args,PyObject *kwds) {
    DNASignText * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASignText,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline basic_string< char > DNASignText::get_letters(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLetters", key_word_list));
        else
            (PyArg_Parse(args, ":getLetters"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = ((const DNASignText*)local_this)->get_letters();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLetters(const DNASignText this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignText_get_letters_390_comment =
    "C++ Interface:\n"
    "getLetters(const DNASignText this)\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignText_get_letters_390_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle DNASignText::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_DNASignText_get_class_type_391(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle DNASignText::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = DNASignText::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_DNASignText_get_class_type_391_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_DNASignText_get_class_type_391_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * DNASignText::DNASignText(DNASignText const &signText)
 * DNASignText::DNASignText(basic_string< char > const &initial_name)
 * DNASignText::DNASignText(basic_string< char > const &initial_name = (""))
 *******************************************************************/
int  Dtool_Init_DNASignText(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-DNASignText::DNASignText(basic_string< char > const &initial_name = (""))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":DNASignText", key_word_list))
            {
                DNASignText *return_value = new DNASignText();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_DNASignText,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 DNASignText::DNASignText(DNASignText const &signText)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"signText", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:DNASignText", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:DNASignText", &param0));
                if(!PyErr_Occurred())
                {
                    DNASignText *param0_this = (DNASignText *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_DNASignText, 0, "DNASignText.DNASignText", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        DNASignText *return_value = new DNASignText(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_DNASignText,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 DNASignText::DNASignText(basic_string< char > const &initial_name)
                char *param0_str; int param0_len;
                static char * key_word_list[] = {(char *)"initial_name", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "s#:DNASignText", key_word_list, &param0_str, &param0_len));
                else
                    (PyArg_Parse(args, "s#:DNASignText", &param0_str, &param0_len));
                if(!PyErr_Occurred())
                {
                    DNASignText *return_value = new DNASignText(basic_string<char>(param0_str, param0_len));
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_DNASignText,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "DNASignText() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "DNASignText()\n"
          "DNASignText(const DNASignText signText)\n"
          "DNASignText(string initial_name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_DNASignText(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_DNASignText)
    {
        printf("DNASignText ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    DNASignText * local_this = (DNASignText *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_DNASignText)
        return local_this;
    if(requested_type == &Dtool_DNAGroup)
        return ( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_DNANode)
        return ( DNANode *) local_this;
    if(requested_type == &Dtool_Namable)
        return ( Namable *)( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *)( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *)( DNAGroup *)( DNANode *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *)( DNAGroup *)( DNANode *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_DNASignText(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_DNASignText)
        return from_this;
    if(from_type == &Dtool_DNAGroup)
    {
          DNAGroup* other_this = (DNAGroup*)from_this;
          return (DNASignText*)other_this;
    }
    if(from_type == &Dtool_DNANode)
    {
          DNANode* other_this = (DNANode*)from_this;
          return (DNASignText*)other_this;
    }
    if(from_type == &Dtool_Namable)
    {
          Namable* other_this = (Namable*)from_this;
          return (DNASignText*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (DNASignText*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (DNASignText*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (DNASignText*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. DNAGroup | DNAGroup
//********************************************************************
PyMethodDef Dtool_Methods_DNAGroup[]= {
  { "traverse",(PyCFunction ) &Dtool_DNAGroup_traverse_10, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAGroup_traverse_10_comment},
  { "topLevelTraverse",(PyCFunction ) &Dtool_DNAGroup_top_level_traverse_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAGroup_top_level_traverse_11_comment},
  { "add",(PyCFunction ) &Dtool_DNAGroup_add_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAGroup_add_12_comment},
  { "remove",(PyCFunction ) &Dtool_DNAGroup_remove_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAGroup_remove_13_comment},
  { "at",(PyCFunction ) &Dtool_DNAGroup_at_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAGroup_at_14_comment},
  { "current",(PyCFunction ) &Dtool_DNAGroup_current_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAGroup_current_15_comment},
  { "getNumChildren",(PyCFunction ) &Dtool_DNAGroup_get_num_children_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAGroup_get_num_children_16_comment},
  { "getParent",(PyCFunction ) &Dtool_DNAGroup_get_parent_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAGroup_get_parent_17_comment},
  { "write",(PyCFunction ) &Dtool_DNAGroup_write_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAGroup_write_18_comment},
  { "ls",(PyCFunction ) &Dtool_DNAGroup_ls_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAGroup_ls_19_comment},
  { "getClassType",(PyCFunction ) &Dtool_DNAGroup_get_class_type_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAGroup_get_class_type_20_comment},
  { "upcastToTypedReferenceCount",(PyCFunction ) &Dtool_DNAGroup_upcast_to_TypedReferenceCount_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAGroup_upcast_to_TypedReferenceCount_4_comment},
  { "upcastToNamable",(PyCFunction ) &Dtool_DNAGroup_upcast_to_Namable_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAGroup_upcast_to_Namable_7_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNAGroup(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DNAGroup.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DNAGroup\n"
          "// Description : A group of dna nodes\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_Namable._Dtool_ClassInit(NULL);
        Dtool_DNAGroup.As_PyTypeObject().tp_bases = Py_BuildValue("(OO)",&Dtool_TypedReferenceCount.As_PyTypeObject(),&Dtool_Namable.As_PyTypeObject());
        Dtool_DNAGroup.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNAGroup.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNAGroup.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNAGroup.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAGroup)");
             printf(" Error In PyType_ReadyDNAGroup");
             return;
        }
        Py_INCREF(&Dtool_DNAGroup.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DNAGroup.As_PyTypeObject().tp_dict,"DNAGroup",&Dtool_DNAGroup.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DNAGroup.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DNAGroup[10],&Dtool_DNAGroup.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DNAGroup,DNAGroup::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNAGroup.As_PyTypeObject());
        PyModule_AddObject(module, "DNAGroup",(PyObject *)&Dtool_DNAGroup.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNASuitPoint | DNASuitPoint
//********************************************************************
PyMethodDef Dtool_Methods_DNASuitPoint[]= {
  { "setIndex",(PyCFunction ) &Dtool_DNASuitPoint_set_index_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_set_index_25_comment},
  { "getIndex",(PyCFunction ) &Dtool_DNASuitPoint_get_index_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_get_index_26_comment},
  { "setPointType",(PyCFunction ) &Dtool_DNASuitPoint_set_point_type_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_set_point_type_27_comment},
  { "getPointType",(PyCFunction ) &Dtool_DNASuitPoint_get_point_type_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_get_point_type_28_comment},
  { "setPos",(PyCFunction ) &Dtool_DNASuitPoint_set_pos_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_set_pos_29_comment},
  { "getPos",(PyCFunction ) &Dtool_DNASuitPoint_get_pos_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_get_pos_30_comment},
  { "setGraphId",(PyCFunction ) &Dtool_DNASuitPoint_set_graph_id_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_set_graph_id_31_comment},
  { "getGraphId",(PyCFunction ) &Dtool_DNASuitPoint_get_graph_id_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_get_graph_id_32_comment},
  { "setLandmarkBuildingIndex",(PyCFunction ) &Dtool_DNASuitPoint_set_landmark_building_index_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_set_landmark_building_index_33_comment},
  { "getLandmarkBuildingIndex",(PyCFunction ) &Dtool_DNASuitPoint_get_landmark_building_index_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_get_landmark_building_index_34_comment},
  { "isTerminal",(PyCFunction ) &Dtool_DNASuitPoint_is_terminal_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_is_terminal_35_comment},
  { "output",(PyCFunction ) &Dtool_DNASuitPoint_output_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_output_36_comment},
  { "write",(PyCFunction ) &Dtool_DNASuitPoint_write_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_write_37_comment},
  { "getClassType",(PyCFunction ) &Dtool_DNASuitPoint_get_class_type_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPoint_get_class_type_38_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     DNASuitPoint
//////////////////
static PyObject *  Dtool_Repr_DNASuitPoint(PyObject * self)
{
    DNASuitPoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitPoint,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
//////////////////
//  A __str__ Function
//     DNASuitPoint
//////////////////
static PyObject *  Dtool_Str_DNASuitPoint(PyObject * self)
{
    DNASuitPoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitPoint,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_DNASuitPoint(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DNASuitPoint.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DNASuitPoint\n"
          "// Description :\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_DNASuitPoint.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_DNASuitPoint.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNASuitPoint.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNASuitPoint.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_DNASuitPoint.As_PyTypeObject().tp_repr = & Dtool_Repr_DNASuitPoint;
        // __str__
        Dtool_DNASuitPoint.As_PyTypeObject().tp_str = & Dtool_Str_DNASuitPoint;
        // Enum  DNASuitPoint::DNASuitPointType;
        PyDict_SetItemString(Dtool_DNASuitPoint.As_PyTypeObject().tp_dict,"STREETPOINT",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_DNASuitPoint.As_PyTypeObject().tp_dict,"FRONTDOORPOINT",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_DNASuitPoint.As_PyTypeObject().tp_dict,"SIDEDOORPOINT",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_DNASuitPoint.As_PyTypeObject().tp_dict,"COGHQINPOINT",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_DNASuitPoint.As_PyTypeObject().tp_dict,"COGHQOUTPOINT",PyInt_FromLong(4));
        if(PyType_Ready(&Dtool_DNASuitPoint.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNASuitPoint)");
             printf(" Error In PyType_ReadyDNASuitPoint");
             return;
        }
        Py_INCREF(&Dtool_DNASuitPoint.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DNASuitPoint.As_PyTypeObject().tp_dict,"DNASuitPoint",&Dtool_DNASuitPoint.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DNASuitPoint.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DNASuitPoint[13],&Dtool_DNASuitPoint.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DNASuitPoint,DNASuitPoint::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNASuitPoint.As_PyTypeObject());
        PyModule_AddObject(module, "DNASuitPoint",(PyObject *)&Dtool_DNASuitPoint.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNASuitEdge | DNASuitEdge
//********************************************************************
PyMethodDef Dtool_Methods_DNASuitEdge[]= {
  { "eq",(PyCFunction ) &Dtool_DNASuitEdge_operator_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitEdge_operator_42_comment},
  { "getStartPoint",(PyCFunction ) &Dtool_DNASuitEdge_get_start_point_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitEdge_get_start_point_43_comment},
  { "getEndPoint",(PyCFunction ) &Dtool_DNASuitEdge_get_end_point_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitEdge_get_end_point_44_comment},
  { "getZoneId",(PyCFunction ) &Dtool_DNASuitEdge_get_zone_id_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitEdge_get_zone_id_45_comment},
  { "setZoneId",(PyCFunction ) &Dtool_DNASuitEdge_set_zone_id_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitEdge_set_zone_id_46_comment},
  { "output",(PyCFunction ) &Dtool_DNASuitEdge_output_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitEdge_output_47_comment},
  { "write",(PyCFunction ) &Dtool_DNASuitEdge_write_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitEdge_write_48_comment},
  { "getClassType",(PyCFunction ) &Dtool_DNASuitEdge_get_class_type_49, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitEdge_get_class_type_49_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     DNASuitEdge
//////////////////
static PyObject *  Dtool_Repr_DNASuitEdge(PyObject * self)
{
    DNASuitEdge * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitEdge,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_DNASuitEdge(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DNASuitEdge.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DNASuitEdge\n"
          "// Description :\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_DNASuitEdge.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_DNASuitEdge.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNASuitEdge.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNASuitEdge.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_DNASuitEdge.As_PyTypeObject().tp_repr = & Dtool_Repr_DNASuitEdge;
        // __str__ Repr Proxy
        Dtool_DNASuitEdge.As_PyTypeObject().tp_str = & Dtool_Repr_DNASuitEdge;
        if(PyType_Ready(&Dtool_DNASuitEdge.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNASuitEdge)");
             printf(" Error In PyType_ReadyDNASuitEdge");
             return;
        }
        Py_INCREF(&Dtool_DNASuitEdge.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DNASuitEdge.As_PyTypeObject().tp_dict,"DNASuitEdge",&Dtool_DNASuitEdge.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DNASuitEdge.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DNASuitEdge[7],&Dtool_DNASuitEdge.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DNASuitEdge,DNASuitEdge::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNASuitEdge.As_PyTypeObject());
        PyModule_AddObject(module, "DNASuitEdge",(PyObject *)&Dtool_DNASuitEdge.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNABattleCell | DNABattleCell
//********************************************************************
PyMethodDef Dtool_Methods_DNABattleCell[]= {
  { "setWidthHeight",(PyCFunction ) &Dtool_DNABattleCell_set_width_height_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNABattleCell_set_width_height_53_comment},
  { "getWidth",(PyCFunction ) &Dtool_DNABattleCell_get_width_54, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNABattleCell_get_width_54_comment},
  { "getHeight",(PyCFunction ) &Dtool_DNABattleCell_get_height_55, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNABattleCell_get_height_55_comment},
  { "setPos",(PyCFunction ) &Dtool_DNABattleCell_set_pos_56, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNABattleCell_set_pos_56_comment},
  { "getPos",(PyCFunction ) &Dtool_DNABattleCell_get_pos_57, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNABattleCell_get_pos_57_comment},
  { "output",(PyCFunction ) &Dtool_DNABattleCell_output_58, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNABattleCell_output_58_comment},
  { "traverse",(PyCFunction ) &Dtool_DNABattleCell_traverse_59, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNABattleCell_traverse_59_comment},
  { "write",(PyCFunction ) &Dtool_DNABattleCell_write_60, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNABattleCell_write_60_comment},
  { "getClassType",(PyCFunction ) &Dtool_DNABattleCell_get_class_type_61, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNABattleCell_get_class_type_61_comment},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     DNABattleCell
//////////////////
static PyObject *  Dtool_Repr_DNABattleCell(PyObject * self)
{
    DNABattleCell * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNABattleCell,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_DNABattleCell(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DNABattleCell.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DNABattleCell\n"
          "// Description : A representation of an area where a battle may occur.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_DNABattleCell.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_DNABattleCell.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNABattleCell.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNABattleCell.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_DNABattleCell.As_PyTypeObject().tp_repr = & Dtool_Repr_DNABattleCell;
        // __str__ Repr Proxy
        Dtool_DNABattleCell.As_PyTypeObject().tp_str = & Dtool_Repr_DNABattleCell;
        if(PyType_Ready(&Dtool_DNABattleCell.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNABattleCell)");
             printf(" Error In PyType_ReadyDNABattleCell");
             return;
        }
        Py_INCREF(&Dtool_DNABattleCell.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DNABattleCell.As_PyTypeObject().tp_dict,"DNABattleCell",&Dtool_DNABattleCell.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DNABattleCell.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DNABattleCell[8],&Dtool_DNABattleCell.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DNABattleCell,DNABattleCell::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNABattleCell.As_PyTypeObject());
        PyModule_AddObject(module, "DNABattleCell",(PyObject *)&Dtool_DNABattleCell.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNAVisGroup | DNAVisGroup
//********************************************************************
PyMethodDef Dtool_Methods_DNAVisGroup[]= {
  { "addVisible",(PyCFunction ) &Dtool_DNAVisGroup_add_visible_65, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_add_visible_65_comment},
  { "removeVisible",(PyCFunction ) &Dtool_DNAVisGroup_remove_visible_66, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_remove_visible_66_comment},
  { "getNumVisibles",(PyCFunction ) &Dtool_DNAVisGroup_get_num_visibles_67, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_get_num_visibles_67_comment},
  { "getVisibleName",(PyCFunction ) &Dtool_DNAVisGroup_get_visible_name_68, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_get_visible_name_68_comment},
  { "addSuitEdge",(PyCFunction ) &Dtool_DNAVisGroup_add_suit_edge_69, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_add_suit_edge_69_comment},
  { "removeSuitEdge",(PyCFunction ) &Dtool_DNAVisGroup_remove_suit_edge_70, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_remove_suit_edge_70_comment},
  { "getNumSuitEdges",(PyCFunction ) &Dtool_DNAVisGroup_get_num_suit_edges_71, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_get_num_suit_edges_71_comment},
  { "getSuitEdge",(PyCFunction ) &Dtool_DNAVisGroup_get_suit_edge_72, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_get_suit_edge_72_comment},
  { "addBattleCell",(PyCFunction ) &Dtool_DNAVisGroup_add_battle_cell_73, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_add_battle_cell_73_comment},
  { "removeBattleCell",(PyCFunction ) &Dtool_DNAVisGroup_remove_battle_cell_74, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_remove_battle_cell_74_comment},
  { "getNumBattleCells",(PyCFunction ) &Dtool_DNAVisGroup_get_num_battle_cells_75, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_get_num_battle_cells_75_comment},
  { "getBattleCell",(PyCFunction ) &Dtool_DNAVisGroup_get_battle_cell_76, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_get_battle_cell_76_comment},
  { "getClassType",(PyCFunction ) &Dtool_DNAVisGroup_get_class_type_77, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAVisGroup_get_class_type_77_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNAVisGroup(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DNAVisGroup.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DNAVisGroup\n"
          "// Description : A group of dna nodes with special visibility info\n"
          "//               tagged in a vis property. The vis property should list\n"
          "//               all the other DNAVisGroups (including itself) that\n"
          "//               should be rendered when the avatar is standing in this group\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DNAGroup._Dtool_ClassInit(NULL);
        Dtool_DNAVisGroup.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNAGroup.As_PyTypeObject());
        Dtool_DNAVisGroup.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNAVisGroup.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNAVisGroup.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNAVisGroup.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAVisGroup)");
             printf(" Error In PyType_ReadyDNAVisGroup");
             return;
        }
        Py_INCREF(&Dtool_DNAVisGroup.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DNAVisGroup.As_PyTypeObject().tp_dict,"DNAVisGroup",&Dtool_DNAVisGroup.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DNAVisGroup.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DNAVisGroup[12],&Dtool_DNAVisGroup.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DNAVisGroup,DNAVisGroup::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNAVisGroup.As_PyTypeObject());
        PyModule_AddObject(module, "DNAVisGroup",(PyObject *)&Dtool_DNAVisGroup.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNASuitPath | DNASuitPath
//********************************************************************
PyMethodDef Dtool_Methods_DNASuitPath[]= {
  { "getNumPoints",(PyCFunction ) &Dtool_DNASuitPath_get_num_points_81, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPath_get_num_points_81_comment},
  { "copy",(PyCFunction ) &Dtool_DNASuitPath_copy_82, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPath_copy_82_comment},
  { "getPointIndex",(PyCFunction ) &Dtool_DNASuitPath_get_point_index_83, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPath_get_point_index_83_comment},
  { "output",(PyCFunction ) &Dtool_DNASuitPath_output_84, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPath_output_84_comment},
  { "getClassType",(PyCFunction ) &Dtool_DNASuitPath_get_class_type_85, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASuitPath_get_class_type_85_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __repr__ Function
//     DNASuitPath
//////////////////
static PyObject *  Dtool_Repr_DNASuitPath(PyObject * self)
{
    DNASuitPath * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNASuitPath,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->output(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_DNASuitPath(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DNASuitPath.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DNASuitPath\n"
          "// Description :\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_DNASuitPath.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_DNASuitPath.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNASuitPath.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNASuitPath.As_PyTypeObject().tp_dict);
        // __repr__
        Dtool_DNASuitPath.As_PyTypeObject().tp_repr = & Dtool_Repr_DNASuitPath;
        // __str__ Repr Proxy
        Dtool_DNASuitPath.As_PyTypeObject().tp_str = & Dtool_Repr_DNASuitPath;
        if(PyType_Ready(&Dtool_DNASuitPath.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNASuitPath)");
             printf(" Error In PyType_ReadyDNASuitPath");
             return;
        }
        Py_INCREF(&Dtool_DNASuitPath.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DNASuitPath.As_PyTypeObject().tp_dict,"DNASuitPath",&Dtool_DNASuitPath.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DNASuitPath.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DNASuitPath[4],&Dtool_DNASuitPath.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DNASuitPath,DNASuitPath::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNASuitPath.As_PyTypeObject());
        PyModule_AddObject(module, "DNASuitPath",(PyObject *)&Dtool_DNASuitPath.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PosHpr | PosHpr
//********************************************************************
PyMethodDef Dtool_Methods_PosHpr[]= {
  { "getPos",(PyCFunction ) &Dtool_PosHpr_get_pos_89, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PosHpr_get_pos_89_comment},
  { "getHpr",(PyCFunction ) &Dtool_PosHpr_get_hpr_90, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PosHpr_get_hpr_90_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PosHpr(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PosHpr.As_PyTypeObject().tp_doc =
          "//////////////////////////////////////////////////\n"
          "// Global part storage\n"
          "//////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_PosHpr.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_PosHpr.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PosHpr.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PosHpr.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PosHpr.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PosHpr)");
             printf(" Error In PyType_ReadyPosHpr");
             return;
        }
        Py_INCREF(&Dtool_PosHpr.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PosHpr.As_PyTypeObject().tp_dict,"PosHpr",&Dtool_PosHpr.As_PyObject());
        RegisterRuntimeClass(&Dtool_PosHpr,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PosHpr.As_PyTypeObject());
        PyModule_AddObject(module, "PosHpr",(PyObject *)&Dtool_PosHpr.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNAStorage | DNAStorage
//********************************************************************
PyMethodDef Dtool_Methods_DNAStorage[]= {
  { "printNodeStorage",(PyCFunction ) &Dtool_DNAStorage_print_node_storage_94, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_print_node_storage_94_comment},
  { "printTextureStorage",(PyCFunction ) &Dtool_DNAStorage_print_texture_storage_95, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_print_texture_storage_95_comment},
  { "printFontStorage",(PyCFunction ) &Dtool_DNAStorage_print_font_storage_96, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_print_font_storage_96_comment},
  { "printSuitPointStorage",(PyCFunction ) &Dtool_DNAStorage_print_suit_point_storage_97, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_print_suit_point_storage_97_comment},
  { "printBattleCellStorage",(PyCFunction ) &Dtool_DNAStorage_print_battle_cell_storage_98, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_print_battle_cell_storage_98_comment},
  { "storeTexture",(PyCFunction ) &Dtool_DNAStorage_store_texture_99, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_store_texture_99_comment},
  { "storeFont",(PyCFunction ) &Dtool_DNAStorage_store_font_100, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_store_font_100_comment},
  { "storeNode",(PyCFunction ) &Dtool_DNAStorage_store_node_101, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_store_node_101_comment},
  { "storeHoodNode",(PyCFunction ) &Dtool_DNAStorage_store_hood_node_102, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_store_hood_node_102_comment},
  { "storePlaceNode",(PyCFunction ) &Dtool_DNAStorage_store_place_node_103, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_store_place_node_103_comment},
  { "storeSuitPoint",(PyCFunction ) &Dtool_DNAStorage_store_suit_point_104, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_store_suit_point_104_comment},
  { "getHighestSuitPointIndex",(PyCFunction ) &Dtool_DNAStorage_get_highest_suit_point_index_105, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_highest_suit_point_index_105_comment},
  { "removeSuitPoint",(PyCFunction ) &Dtool_DNAStorage_remove_suit_point_106, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_remove_suit_point_106_comment},
  { "storeBlockNumber",(PyCFunction ) &Dtool_DNAStorage_store_block_number_107, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_store_block_number_107_comment},
  { "storeBlockDoorPosHpr",(PyCFunction ) &Dtool_DNAStorage_store_block_door_pos_hpr_108, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_store_block_door_pos_hpr_108_comment},
  { "storeBlockSignTransform",(PyCFunction ) &Dtool_DNAStorage_store_block_sign_transform_109, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_store_block_sign_transform_109_comment},
  { "storeBlockTitle",(PyCFunction ) &Dtool_DNAStorage_store_block_title_110, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_store_block_title_110_comment},
  { "storeBlockArticle",(PyCFunction ) &Dtool_DNAStorage_store_block_article_111, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_store_block_article_111_comment},
  { "storeBattleCell",(PyCFunction ) &Dtool_DNAStorage_store_battle_cell_112, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_store_battle_cell_112_comment},
  { "removeBattleCell",(PyCFunction ) &Dtool_DNAStorage_remove_battle_cell_113, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_remove_battle_cell_113_comment},
  { "storeSuitEdge",(PyCFunction ) &Dtool_DNAStorage_store_suit_edge_114, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_store_suit_edge_114_comment},
  { "removeSuitEdge",(PyCFunction ) &Dtool_DNAStorage_remove_suit_edge_115, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_remove_suit_edge_115_comment},
  { "deleteUnusedSuitPoints",(PyCFunction ) &Dtool_DNAStorage_delete_unused_suit_points_116, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_delete_unused_suit_points_116_comment},
  { "fixCoincidentSuitPoints",(PyCFunction ) &Dtool_DNAStorage_fix_coincident_suit_points_117, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_fix_coincident_suit_points_117_comment},
  { "resetNodes",(PyCFunction ) &Dtool_DNAStorage_reset_nodes_118, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_reset_nodes_118_comment},
  { "resetTextures",(PyCFunction ) &Dtool_DNAStorage_reset_textures_119, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_reset_textures_119_comment},
  { "resetHood",(PyCFunction ) &Dtool_DNAStorage_reset_hood_120, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_reset_hood_120_comment},
  { "resetHoodNodes",(PyCFunction ) &Dtool_DNAStorage_reset_hood_nodes_121, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_reset_hood_nodes_121_comment},
  { "resetPlaceNodes",(PyCFunction ) &Dtool_DNAStorage_reset_place_nodes_122, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_reset_place_nodes_122_comment},
  { "resetSuitPoints",(PyCFunction ) &Dtool_DNAStorage_reset_suit_points_123, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_reset_suit_points_123_comment},
  { "resetBattleCells",(PyCFunction ) &Dtool_DNAStorage_reset_battle_cells_124, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_reset_battle_cells_124_comment},
  { "resetBlockNumbers",(PyCFunction ) &Dtool_DNAStorage_reset_block_numbers_125, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_reset_block_numbers_125_comment},
  { "resetBlockDoorPosHprs",(PyCFunction ) &Dtool_DNAStorage_reset_block_door_pos_hprs_126, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_reset_block_door_pos_hprs_126_comment},
  { "resetBlockSignTransforms",(PyCFunction ) &Dtool_DNAStorage_reset_block_sign_transforms_127, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_reset_block_sign_transforms_127_comment},
  { "resetBlockTitle",(PyCFunction ) &Dtool_DNAStorage_reset_block_title_128, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_reset_block_title_128_comment},
  { "resetBlockArticle",(PyCFunction ) &Dtool_DNAStorage_reset_block_article_129, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_reset_block_article_129_comment},
  { "findTexture",(PyCFunction ) &Dtool_DNAStorage_find_texture_130, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_find_texture_130_comment},
  { "findNode",(PyCFunction ) &Dtool_DNAStorage_find_node_131, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_find_node_131_comment},
  { "findFont",(PyCFunction ) &Dtool_DNAStorage_find_font_132, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_find_font_132_comment},
  { "getNumCatalogCodes",(PyCFunction ) &Dtool_DNAStorage_get_num_catalog_codes_133, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_num_catalog_codes_133_comment},
  { "getCatalogCode",(PyCFunction ) &Dtool_DNAStorage_get_catalog_code_134, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_catalog_code_134_comment},
  { "storeCatalogString",(PyCFunction ) &Dtool_DNAStorage_store_catalog_string_135, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_store_catalog_string_135_comment},
  { "printCatalog",(PyCFunction ) &Dtool_DNAStorage_print_catalog_136, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_print_catalog_136_comment},
  { "storeDNAGroup",(PyCFunction ) &Dtool_DNAStorage_store_DNAGroup_137, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_store_DNAGroup_137_comment},
  { "removeDNAGroup",(PyCFunction ) &Dtool_DNAStorage_remove_DNAGroup_138, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_remove_DNAGroup_138_comment},
  { "findDNAGroup",(PyCFunction ) &Dtool_DNAStorage_find_DNAGroup_139, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_find_DNAGroup_139_comment},
  { "findPandaNode",(PyCFunction ) &Dtool_DNAStorage_find_PandaNode_140, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_find_PandaNode_140_comment},
  { "getZoneFromBlockNumber",(PyCFunction ) &Dtool_DNAStorage_get_zone_from_block_number_141, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_zone_from_block_number_141_comment},
  { "getBlockNumberAt",(PyCFunction ) &Dtool_DNAStorage_get_block_number_at_142, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_block_number_at_142_comment},
  { "getNumBlockNumbers",(PyCFunction ) &Dtool_DNAStorage_get_num_block_numbers_143, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_num_block_numbers_143_comment},
  { "getDoorPosHprFromBlockNumber",(PyCFunction ) &Dtool_DNAStorage_get_door_pos_hpr_from_block_number_144, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_door_pos_hpr_from_block_number_144_comment},
  { "getDoorPosHprBlockAt",(PyCFunction ) &Dtool_DNAStorage_get_door_pos_hpr_block_at_145, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_door_pos_hpr_block_at_145_comment},
  { "getNumBlockDoorPosHprs",(PyCFunction ) &Dtool_DNAStorage_get_num_block_door_pos_hprs_146, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_num_block_door_pos_hprs_146_comment},
  { "getSignTransformFromBlockNumber",(PyCFunction ) &Dtool_DNAStorage_get_sign_transform_from_block_number_147, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_sign_transform_from_block_number_147_comment},
  { "getSignTransformBlockAt",(PyCFunction ) &Dtool_DNAStorage_get_sign_transform_block_at_148, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_sign_transform_block_at_148_comment},
  { "getNumBlockSignTransforms",(PyCFunction ) &Dtool_DNAStorage_get_num_block_sign_transforms_149, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_num_block_sign_transforms_149_comment},
  { "resetDNAGroups",(PyCFunction ) &Dtool_DNAStorage_reset_DNAGroups_150, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_reset_DNAGroups_150_comment},
  { "getTitleFromBlockNumber",(PyCFunction ) &Dtool_DNAStorage_get_title_from_block_number_151, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_title_from_block_number_151_comment},
  { "getTitleBlockAt",(PyCFunction ) &Dtool_DNAStorage_get_title_block_at_152, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_title_block_at_152_comment},
  { "getNumBlockTitles",(PyCFunction ) &Dtool_DNAStorage_get_num_block_titles_153, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_num_block_titles_153_comment},
  { "getArticleFromBlockNumber",(PyCFunction ) &Dtool_DNAStorage_get_article_from_block_number_154, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_article_from_block_number_154_comment},
  { "storeBlockBuildingType",(PyCFunction ) &Dtool_DNAStorage_store_block_building_type_155, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_store_block_building_type_155_comment},
  { "getBlockBuildingType",(PyCFunction ) &Dtool_DNAStorage_get_block_building_type_156, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_block_building_type_156_comment},
  { "storeDNAVisGroup",(PyCFunction ) &Dtool_DNAStorage_store_DNAVisGroup_157, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_store_DNAVisGroup_157_comment},
  { "removeDNAVisGroup",(PyCFunction ) &Dtool_DNAStorage_remove_DNAVisGroup_158, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_remove_DNAVisGroup_158_comment},
  { "findDNAVisGroup",(PyCFunction ) &Dtool_DNAStorage_find_DNAVisGroup_159, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_find_DNAVisGroup_159_comment},
  { "resetDNAVisGroups",(PyCFunction ) &Dtool_DNAStorage_reset_DNAVisGroups_160, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_reset_DNAVisGroups_160_comment},
  { "getNumDNAVisGroups",(PyCFunction ) &Dtool_DNAStorage_get_num_DNAVisGroups_161, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_num_DNAVisGroups_161_comment},
  { "getDNAVisGroup",(PyCFunction ) &Dtool_DNAStorage_get_DNAVisGroup_162, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_DNAVisGroup_162_comment},
  { "getNumVisiblesInDNAVisGroup",(PyCFunction ) &Dtool_DNAStorage_get_num_visibles_in_DNAVisGroup_163, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_num_visibles_in_DNAVisGroup_163_comment},
  { "getDNAVisGroupName",(PyCFunction ) &Dtool_DNAStorage_get_DNAVisGroup_name_164, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_DNAVisGroup_name_164_comment},
  { "getVisibleName",(PyCFunction ) &Dtool_DNAStorage_get_visible_name_165, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_visible_name_165_comment},
  { "storeDNAVisGroupAI",(PyCFunction ) &Dtool_DNAStorage_store_DNAVisGroupAI_166, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_store_DNAVisGroupAI_166_comment},
  { "getNumDNAVisGroupsAI",(PyCFunction ) &Dtool_DNAStorage_get_num_DNAVisGroupsAI_167, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_num_DNAVisGroupsAI_167_comment},
  { "getDNAVisGroupAI",(PyCFunction ) &Dtool_DNAStorage_get_DNAVisGroupAI_168, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_DNAVisGroupAI_168_comment},
  { "resetDNAVisGroupsAI",(PyCFunction ) &Dtool_DNAStorage_reset_DNAVisGroupsAI_169, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_reset_DNAVisGroupsAI_169_comment},
  { "getNumPandaNodes",(PyCFunction ) &Dtool_DNAStorage_get_num_PandaNodes_170, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_num_PandaNodes_170_comment},
  { "getPandaNodeAt",(PyCFunction ) &Dtool_DNAStorage_get_PandaNode_at_171, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_PandaNode_at_171_comment},
  { "printPandaNodes",(PyCFunction ) &Dtool_DNAStorage_print_PandaNodes_172, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_print_PandaNodes_172_comment},
  { "getSuitEdgeZone",(PyCFunction ) &Dtool_DNAStorage_get_suit_edge_zone_173, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_suit_edge_zone_173_comment},
  { "getSuitEdgeTravelTime",(PyCFunction ) &Dtool_DNAStorage_get_suit_edge_travel_time_174, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_suit_edge_travel_time_174_comment},
  { "getNumSuitPoints",(PyCFunction ) &Dtool_DNAStorage_get_num_suit_points_175, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_num_suit_points_175_comment},
  { "getSuitPointAtIndex",(PyCFunction ) &Dtool_DNAStorage_get_suit_point_at_index_176, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_suit_point_at_index_176_comment},
  { "getSuitPointWithIndex",(PyCFunction ) &Dtool_DNAStorage_get_suit_point_with_index_177, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_suit_point_with_index_177_comment},
  { "getSuitPath",(PyCFunction ) &Dtool_DNAStorage_get_suit_path_178, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_suit_path_178_comment},
  { "getAdjacentPoints",(PyCFunction ) &Dtool_DNAStorage_get_adjacent_points_179, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_adjacent_points_179_comment},
  { "discoverContinuity",(PyCFunction ) &Dtool_DNAStorage_discover_continuity_180, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_discover_continuity_180_comment},
  { "getBlock",(PyCFunction ) &Dtool_DNAStorage_get_block_181, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_get_block_181_comment},
  { "fixup",(PyCFunction ) &Dtool_DNAStorage_fixup_182, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_fixup_182_comment},
  { "write",(PyCFunction ) &Dtool_DNAStorage_write_183, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStorage_write_183_comment},
  { NULL, NULL }
};

//////////////////
//  A __str__ Function
//     DNAStorage
//////////////////
static PyObject *  Dtool_Str_DNAStorage(PyObject * self)
{
    DNAStorage * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_DNAStorage,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os,0);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_DNAStorage(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_DNAStorage.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_DNAStorage.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNAStorage.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNAStorage.As_PyTypeObject().tp_dict);
        // __str__
        Dtool_DNAStorage.As_PyTypeObject().tp_str = & Dtool_Str_DNAStorage;
        if(PyType_Ready(&Dtool_DNAStorage.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAStorage)");
             printf(" Error In PyType_ReadyDNAStorage");
             return;
        }
        Py_INCREF(&Dtool_DNAStorage.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DNAStorage.As_PyTypeObject().tp_dict,"DNAStorage",&Dtool_DNAStorage.As_PyObject());
        RegisterRuntimeClass(&Dtool_DNAStorage,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNAStorage.As_PyTypeObject());
        PyModule_AddObject(module, "DNAStorage",(PyObject *)&Dtool_DNAStorage.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNANode | DNANode
//********************************************************************
PyMethodDef Dtool_Methods_DNANode[]= {
  { "setPos",(PyCFunction ) &Dtool_DNANode_set_pos_187, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNANode_set_pos_187_comment},
  { "getPos",(PyCFunction ) &Dtool_DNANode_get_pos_188, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNANode_get_pos_188_comment},
  { "setHpr",(PyCFunction ) &Dtool_DNANode_set_hpr_189, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNANode_set_hpr_189_comment},
  { "getHpr",(PyCFunction ) &Dtool_DNANode_get_hpr_190, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNANode_get_hpr_190_comment},
  { "setScale",(PyCFunction ) &Dtool_DNANode_set_scale_191, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNANode_set_scale_191_comment},
  { "getScale",(PyCFunction ) &Dtool_DNANode_get_scale_192, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNANode_get_scale_192_comment},
  { "getClassType",(PyCFunction ) &Dtool_DNANode_get_class_type_193, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNANode_get_class_type_193_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNANode(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DNAGroup._Dtool_ClassInit(NULL);
        Dtool_DNANode.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNAGroup.As_PyTypeObject());
        Dtool_DNANode.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNANode.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNANode.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNANode.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNANode)");
             printf(" Error In PyType_ReadyDNANode");
             return;
        }
        Py_INCREF(&Dtool_DNANode.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DNANode.As_PyTypeObject().tp_dict,"DNANode",&Dtool_DNANode.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DNANode.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DNANode[6],&Dtool_DNANode.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DNANode,DNANode::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNANode.As_PyTypeObject());
        PyModule_AddObject(module, "DNANode",(PyObject *)&Dtool_DNANode.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNAWall | DNAWall
//********************************************************************
PyMethodDef Dtool_Methods_DNAWall[]= {
  { "setCode",(PyCFunction ) &Dtool_DNAWall_set_code_197, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAWall_set_code_197_comment},
  { "getCode",(PyCFunction ) &Dtool_DNAWall_get_code_198, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAWall_get_code_198_comment},
  { "setHeight",(PyCFunction ) &Dtool_DNAWall_set_height_199, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAWall_set_height_199_comment},
  { "getHeight",(PyCFunction ) &Dtool_DNAWall_get_height_200, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAWall_get_height_200_comment},
  { "setColor",(PyCFunction ) &Dtool_DNAWall_set_color_201, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAWall_set_color_201_comment},
  { "getColor",(PyCFunction ) &Dtool_DNAWall_get_color_202, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAWall_get_color_202_comment},
  { "getClassType",(PyCFunction ) &Dtool_DNAWall_get_class_type_203, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAWall_get_class_type_203_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNAWall(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DNAWall.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DNAWall\n"
          "// Description : A stackable wall.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DNANode._Dtool_ClassInit(NULL);
        Dtool_DNAWall.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNANode.As_PyTypeObject());
        Dtool_DNAWall.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNAWall.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNAWall.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNAWall.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAWall)");
             printf(" Error In PyType_ReadyDNAWall");
             return;
        }
        Py_INCREF(&Dtool_DNAWall.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DNAWall.As_PyTypeObject().tp_dict,"DNAWall",&Dtool_DNAWall.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DNAWall.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DNAWall[6],&Dtool_DNAWall.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DNAWall,DNAWall::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNAWall.As_PyTypeObject());
        PyModule_AddObject(module, "DNAWall",(PyObject *)&Dtool_DNAWall.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNAFlatBuilding | DNAFlatBuilding
//********************************************************************
PyMethodDef Dtool_Methods_DNAFlatBuilding[]= {
  { "setWidth",(PyCFunction ) &Dtool_DNAFlatBuilding_set_width_207, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAFlatBuilding_set_width_207_comment},
  { "getWidth",(PyCFunction ) &Dtool_DNAFlatBuilding_get_width_208, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAFlatBuilding_get_width_208_comment},
  { "getCurrentWallHeight",(PyCFunction ) &Dtool_DNAFlatBuilding_get_current_wall_height_209, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAFlatBuilding_get_current_wall_height_209_comment},
  { "getClassType",(PyCFunction ) &Dtool_DNAFlatBuilding_get_class_type_210, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAFlatBuilding_get_class_type_210_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNAFlatBuilding(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DNAFlatBuilding.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DNAFlatBuilding\n"
          "// Description : A flat building.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DNANode._Dtool_ClassInit(NULL);
        Dtool_DNAFlatBuilding.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNANode.As_PyTypeObject());
        Dtool_DNAFlatBuilding.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNAFlatBuilding.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNAFlatBuilding.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNAFlatBuilding.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAFlatBuilding)");
             printf(" Error In PyType_ReadyDNAFlatBuilding");
             return;
        }
        Py_INCREF(&Dtool_DNAFlatBuilding.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DNAFlatBuilding.As_PyTypeObject().tp_dict,"DNAFlatBuilding",&Dtool_DNAFlatBuilding.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DNAFlatBuilding.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DNAFlatBuilding[3],&Dtool_DNAFlatBuilding.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DNAFlatBuilding,DNAFlatBuilding::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNAFlatBuilding.As_PyTypeObject());
        PyModule_AddObject(module, "DNAFlatBuilding",(PyObject *)&Dtool_DNAFlatBuilding.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNALandmarkBuilding | DNALandmarkBuilding
//********************************************************************
PyMethodDef Dtool_Methods_DNALandmarkBuilding[]= {
  { "setTitle",(PyCFunction ) &Dtool_DNALandmarkBuilding_set_title_214, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNALandmarkBuilding_set_title_214_comment},
  { "getTitle",(PyCFunction ) &Dtool_DNALandmarkBuilding_get_title_215, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNALandmarkBuilding_get_title_215_comment},
  { "setArticle",(PyCFunction ) &Dtool_DNALandmarkBuilding_set_article_216, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNALandmarkBuilding_set_article_216_comment},
  { "getArticle",(PyCFunction ) &Dtool_DNALandmarkBuilding_get_article_217, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNALandmarkBuilding_get_article_217_comment},
  { "setCode",(PyCFunction ) &Dtool_DNALandmarkBuilding_set_code_218, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNALandmarkBuilding_set_code_218_comment},
  { "getCode",(PyCFunction ) &Dtool_DNALandmarkBuilding_get_code_219, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNALandmarkBuilding_get_code_219_comment},
  { "setWallColor",(PyCFunction ) &Dtool_DNALandmarkBuilding_set_wall_color_220, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNALandmarkBuilding_set_wall_color_220_comment},
  { "getWallColor",(PyCFunction ) &Dtool_DNALandmarkBuilding_get_wall_color_221, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNALandmarkBuilding_get_wall_color_221_comment},
  { "setBuildingType",(PyCFunction ) &Dtool_DNALandmarkBuilding_set_building_type_222, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNALandmarkBuilding_set_building_type_222_comment},
  { "getBuildingType",(PyCFunction ) &Dtool_DNALandmarkBuilding_get_building_type_223, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNALandmarkBuilding_get_building_type_223_comment},
  { "getClassType",(PyCFunction ) &Dtool_DNALandmarkBuilding_get_class_type_224, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNALandmarkBuilding_get_class_type_224_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNALandmarkBuilding(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DNALandmarkBuilding.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DNALandmarkBuilding\n"
          "// Description : A landmark building.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DNANode._Dtool_ClassInit(NULL);
        Dtool_DNALandmarkBuilding.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNANode.As_PyTypeObject());
        Dtool_DNALandmarkBuilding.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNALandmarkBuilding.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNALandmarkBuilding.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNALandmarkBuilding.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNALandmarkBuilding)");
             printf(" Error In PyType_ReadyDNALandmarkBuilding");
             return;
        }
        Py_INCREF(&Dtool_DNALandmarkBuilding.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DNALandmarkBuilding.As_PyTypeObject().tp_dict,"DNALandmarkBuilding",&Dtool_DNALandmarkBuilding.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DNALandmarkBuilding.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DNALandmarkBuilding[10],&Dtool_DNALandmarkBuilding.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DNALandmarkBuilding,DNALandmarkBuilding::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNALandmarkBuilding.As_PyTypeObject());
        PyModule_AddObject(module, "DNALandmarkBuilding",(PyObject *)&Dtool_DNALandmarkBuilding.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNAAnimBuilding | DNAAnimBuilding
//********************************************************************
PyMethodDef Dtool_Methods_DNAAnimBuilding[]= {
  { "setAnim",(PyCFunction ) &Dtool_DNAAnimBuilding_set_anim_228, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAAnimBuilding_set_anim_228_comment},
  { "getAnim",(PyCFunction ) &Dtool_DNAAnimBuilding_get_anim_229, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAAnimBuilding_get_anim_229_comment},
  { "getClassType",(PyCFunction ) &Dtool_DNAAnimBuilding_get_class_type_230, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAAnimBuilding_get_class_type_230_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNAAnimBuilding(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DNAAnimBuilding.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DNAAnimBuilding\n"
          "// Description : An animated building like a sneeizing building.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DNALandmarkBuilding._Dtool_ClassInit(NULL);
        Dtool_DNAAnimBuilding.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNALandmarkBuilding.As_PyTypeObject());
        Dtool_DNAAnimBuilding.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNAAnimBuilding.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNAAnimBuilding.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNAAnimBuilding.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAAnimBuilding)");
             printf(" Error In PyType_ReadyDNAAnimBuilding");
             return;
        }
        Py_INCREF(&Dtool_DNAAnimBuilding.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DNAAnimBuilding.As_PyTypeObject().tp_dict,"DNAAnimBuilding",&Dtool_DNAAnimBuilding.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DNAAnimBuilding.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DNAAnimBuilding[2],&Dtool_DNAAnimBuilding.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DNAAnimBuilding,DNAAnimBuilding::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNAAnimBuilding.As_PyTypeObject());
        PyModule_AddObject(module, "DNAAnimBuilding",(PyObject *)&Dtool_DNAAnimBuilding.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNAProp | DNAProp
//********************************************************************
PyMethodDef Dtool_Methods_DNAProp[]= {
  { "setCode",(PyCFunction ) &Dtool_DNAProp_set_code_234, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAProp_set_code_234_comment},
  { "getCode",(PyCFunction ) &Dtool_DNAProp_get_code_235, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAProp_get_code_235_comment},
  { "setColor",(PyCFunction ) &Dtool_DNAProp_set_color_236, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAProp_set_color_236_comment},
  { "getColor",(PyCFunction ) &Dtool_DNAProp_get_color_237, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAProp_get_color_237_comment},
  { "getClassType",(PyCFunction ) &Dtool_DNAProp_get_class_type_238, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAProp_get_class_type_238_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNAProp(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DNAProp.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DNAProp\n"
          "// Description : A prop like a tree or fire hydrant.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DNANode._Dtool_ClassInit(NULL);
        Dtool_DNAProp.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNANode.As_PyTypeObject());
        Dtool_DNAProp.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNAProp.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNAProp.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNAProp.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAProp)");
             printf(" Error In PyType_ReadyDNAProp");
             return;
        }
        Py_INCREF(&Dtool_DNAProp.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DNAProp.As_PyTypeObject().tp_dict,"DNAProp",&Dtool_DNAProp.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DNAProp.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DNAProp[4],&Dtool_DNAProp.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DNAProp,DNAProp::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNAProp.As_PyTypeObject());
        PyModule_AddObject(module, "DNAProp",(PyObject *)&Dtool_DNAProp.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNAAnimProp | DNAAnimProp
//********************************************************************
PyMethodDef Dtool_Methods_DNAAnimProp[]= {
  { "setAnim",(PyCFunction ) &Dtool_DNAAnimProp_set_anim_242, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAAnimProp_set_anim_242_comment},
  { "getAnim",(PyCFunction ) &Dtool_DNAAnimProp_get_anim_243, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAAnimProp_get_anim_243_comment},
  { "getClassType",(PyCFunction ) &Dtool_DNAAnimProp_get_class_type_244, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAAnimProp_get_class_type_244_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNAAnimProp(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DNAAnimProp.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DNAAnimProp\n"
          "// Description : An animated prop like a walking hydrant.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DNAProp._Dtool_ClassInit(NULL);
        Dtool_DNAAnimProp.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNAProp.As_PyTypeObject());
        Dtool_DNAAnimProp.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNAAnimProp.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNAAnimProp.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNAAnimProp.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAAnimProp)");
             printf(" Error In PyType_ReadyDNAAnimProp");
             return;
        }
        Py_INCREF(&Dtool_DNAAnimProp.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DNAAnimProp.As_PyTypeObject().tp_dict,"DNAAnimProp",&Dtool_DNAAnimProp.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DNAAnimProp.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DNAAnimProp[2],&Dtool_DNAAnimProp.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DNAAnimProp,DNAAnimProp::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNAAnimProp.As_PyTypeObject());
        PyModule_AddObject(module, "DNAAnimProp",(PyObject *)&Dtool_DNAAnimProp.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNACornice | DNACornice
//********************************************************************
PyMethodDef Dtool_Methods_DNACornice[]= {
  { "setCode",(PyCFunction ) &Dtool_DNACornice_set_code_248, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNACornice_set_code_248_comment},
  { "getCode",(PyCFunction ) &Dtool_DNACornice_get_code_249, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNACornice_get_code_249_comment},
  { "setColor",(PyCFunction ) &Dtool_DNACornice_set_color_250, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNACornice_set_color_250_comment},
  { "getColor",(PyCFunction ) &Dtool_DNACornice_get_color_251, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNACornice_get_color_251_comment},
  { "getClassType",(PyCFunction ) &Dtool_DNACornice_get_class_type_252, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNACornice_get_class_type_252_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNACornice(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DNACornice.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DNACornice\n"
          "// Description : A cornice at the top of a flat building\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DNAGroup._Dtool_ClassInit(NULL);
        Dtool_DNACornice.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNAGroup.As_PyTypeObject());
        Dtool_DNACornice.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNACornice.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNACornice.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNACornice.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNACornice)");
             printf(" Error In PyType_ReadyDNACornice");
             return;
        }
        Py_INCREF(&Dtool_DNACornice.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DNACornice.As_PyTypeObject().tp_dict,"DNACornice",&Dtool_DNACornice.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DNACornice.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DNACornice[4],&Dtool_DNACornice.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DNACornice,DNACornice::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNACornice.As_PyTypeObject());
        PyModule_AddObject(module, "DNACornice",(PyObject *)&Dtool_DNACornice.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNAData | DNAData
//********************************************************************
PyMethodDef Dtool_Methods_DNAData[]= {
  { "assign",(PyCFunction ) &Dtool_DNAData_operator_256, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAData_operator_256_comment},
  { "read",(PyCFunction ) &Dtool_DNAData_read_257, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAData_read_257_comment},
  { "resolveDnaFilename",(PyCFunction ) &Dtool_DNAData_resolve_dna_filename_258, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAData_resolve_dna_filename_258_comment},
  { "resolveExternals",(PyCFunction ) &Dtool_DNAData_resolve_externals_259, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAData_resolve_externals_259_comment},
  { "writeDna",(PyCFunction ) &Dtool_DNAData_write_dna_260, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAData_write_dna_260_comment},
  { "setCoordinateSystem",(PyCFunction ) &Dtool_DNAData_set_coordinate_system_261, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAData_set_coordinate_system_261_comment},
  { "getCoordinateSystem",(PyCFunction ) &Dtool_DNAData_get_coordinate_system_262, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAData_get_coordinate_system_262_comment},
  { "setDnaFilename",(PyCFunction ) &Dtool_DNAData_set_dna_filename_263, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAData_set_dna_filename_263_comment},
  { "getDnaFilename",(PyCFunction ) &Dtool_DNAData_get_dna_filename_264, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAData_get_dna_filename_264_comment},
  { "setDnaStorage",(PyCFunction ) &Dtool_DNAData_set_dna_storage_265, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAData_set_dna_storage_265_comment},
  { "getDnaStorage",(PyCFunction ) &Dtool_DNAData_get_dna_storage_266, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAData_get_dna_storage_266_comment},
  { "getClassType",(PyCFunction ) &Dtool_DNAData_get_class_type_267, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAData_get_class_type_267_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNAData(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DNAData.As_PyTypeObject().tp_doc =
          "///////////////////////////////////////////////////////////////////\n"
          "//       Class : DNAData\n"
          "// Description : This is the primary interface into all the DNA data,\n"
          "//               and the root of the DNA file structure.  An DNAData\n"
          "//               structure corresponds exactly with an DNA file on the\n"
          "//               disk.\n"
          "//\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DNAGroup._Dtool_ClassInit(NULL);
        Dtool_DNAData.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNAGroup.As_PyTypeObject());
        Dtool_DNAData.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNAData.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNAData.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNAData.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAData)");
             printf(" Error In PyType_ReadyDNAData");
             return;
        }
        Py_INCREF(&Dtool_DNAData.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DNAData.As_PyTypeObject().tp_dict,"DNAData",&Dtool_DNAData.As_PyObject());
        //  Static Method resolveDnaFilename
        PyDict_SetItemString(Dtool_DNAData.As_PyTypeObject().tp_dict,"resolveDnaFilename",PyCFunction_New(&Dtool_Methods_DNAData[2],&Dtool_DNAData.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DNAData.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DNAData[11],&Dtool_DNAData.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DNAData,DNAData::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNAData.As_PyTypeObject());
        PyModule_AddObject(module, "DNAData",(PyObject *)&Dtool_DNAData.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNADoor | DNADoor
//********************************************************************
PyMethodDef Dtool_Methods_DNADoor[]= {
  { "setCode",(PyCFunction ) &Dtool_DNADoor_set_code_271, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNADoor_set_code_271_comment},
  { "getCode",(PyCFunction ) &Dtool_DNADoor_get_code_272, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNADoor_get_code_272_comment},
  { "setColor",(PyCFunction ) &Dtool_DNADoor_set_color_273, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNADoor_set_color_273_comment},
  { "getColor",(PyCFunction ) &Dtool_DNADoor_get_color_274, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNADoor_get_color_274_comment},
  { "setupDoor",(PyCFunction ) &Dtool_DNADoor_setup_door_275, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNADoor_setup_door_275_comment},
  { "getClassType",(PyCFunction ) &Dtool_DNADoor_get_class_type_276, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNADoor_get_class_type_276_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNADoor(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DNADoor.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DNADoor\n"
          "// Description : A door\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DNAGroup._Dtool_ClassInit(NULL);
        Dtool_DNADoor.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNAGroup.As_PyTypeObject());
        Dtool_DNADoor.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNADoor.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNADoor.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNADoor.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNADoor)");
             printf(" Error In PyType_ReadyDNADoor");
             return;
        }
        Py_INCREF(&Dtool_DNADoor.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DNADoor.As_PyTypeObject().tp_dict,"DNADoor",&Dtool_DNADoor.As_PyObject());
        //  Static Method setupDoor
        PyDict_SetItemString(Dtool_DNADoor.As_PyTypeObject().tp_dict,"setupDoor",PyCFunction_New(&Dtool_Methods_DNADoor[4],&Dtool_DNADoor.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DNADoor.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DNADoor[5],&Dtool_DNADoor.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DNADoor,DNADoor::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNADoor.As_PyTypeObject());
        PyModule_AddObject(module, "DNADoor",(PyObject *)&Dtool_DNADoor.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNAFlatDoor | DNAFlatDoor
//********************************************************************
PyMethodDef Dtool_Methods_DNAFlatDoor[]= {
  { "getClassType",(PyCFunction ) &Dtool_DNAFlatDoor_get_class_type_280, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAFlatDoor_get_class_type_280_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNAFlatDoor(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DNAFlatDoor.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DNAFlatDoor\n"
          "// Description : A door for a flat buildings\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DNADoor._Dtool_ClassInit(NULL);
        Dtool_DNAFlatDoor.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNADoor.As_PyTypeObject());
        Dtool_DNAFlatDoor.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNAFlatDoor.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNAFlatDoor.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNAFlatDoor.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAFlatDoor)");
             printf(" Error In PyType_ReadyDNAFlatDoor");
             return;
        }
        Py_INCREF(&Dtool_DNAFlatDoor.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DNAFlatDoor.As_PyTypeObject().tp_dict,"DNAFlatDoor",&Dtool_DNAFlatDoor.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DNAFlatDoor.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DNAFlatDoor[0],&Dtool_DNAFlatDoor.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DNAFlatDoor,DNAFlatDoor::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNAFlatDoor.As_PyTypeObject());
        PyModule_AddObject(module, "DNAFlatDoor",(PyObject *)&Dtool_DNAFlatDoor.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNAInteractiveProp | DNAInteractiveProp
//********************************************************************
PyMethodDef Dtool_Methods_DNAInteractiveProp[]= {
  { "setCellId",(PyCFunction ) &Dtool_DNAInteractiveProp_set_cell_id_284, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAInteractiveProp_set_cell_id_284_comment},
  { "getCellId",(PyCFunction ) &Dtool_DNAInteractiveProp_get_cell_id_285, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAInteractiveProp_get_cell_id_285_comment},
  { "getClassType",(PyCFunction ) &Dtool_DNAInteractiveProp_get_class_type_286, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAInteractiveProp_get_class_type_286_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNAInteractiveProp(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DNAInteractiveProp.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DNAInteractiveProp\n"
          "// Description : An interactive prop like a walking hydrant.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DNAAnimProp._Dtool_ClassInit(NULL);
        Dtool_DNAInteractiveProp.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNAAnimProp.As_PyTypeObject());
        Dtool_DNAInteractiveProp.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNAInteractiveProp.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNAInteractiveProp.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNAInteractiveProp.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAInteractiveProp)");
             printf(" Error In PyType_ReadyDNAInteractiveProp");
             return;
        }
        Py_INCREF(&Dtool_DNAInteractiveProp.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DNAInteractiveProp.As_PyTypeObject().tp_dict,"DNAInteractiveProp",&Dtool_DNAInteractiveProp.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DNAInteractiveProp.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DNAInteractiveProp[2],&Dtool_DNAInteractiveProp.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DNAInteractiveProp,DNAInteractiveProp::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNAInteractiveProp.As_PyTypeObject());
        PyModule_AddObject(module, "DNAInteractiveProp",(PyObject *)&Dtool_DNAInteractiveProp.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNALoader | DNALoader
//********************************************************************
PyMethodDef Dtool_Methods_DNALoader[]= {
  { "buildGraph",(PyCFunction ) &Dtool_DNALoader_build_graph_290, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNALoader_build_graph_290_comment},
  { "getData",(PyCFunction ) &Dtool_DNALoader_get_data_291, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNALoader_get_data_291_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNALoader(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DNALoader.As_PyTypeObject().tp_doc =
          "///////////////////////////////////////////////////////////////////\n"
          "//       Class : DNALoader\n"
          "// Description : Converts a dna structure, possibly read from a\n"
          "//               dna file but not necessarily, into a scene graph\n"
          "//               suitable for rendering.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_DNALoader.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_DNALoader.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNALoader.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNALoader.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNALoader.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNALoader)");
             printf(" Error In PyType_ReadyDNALoader");
             return;
        }
        Py_INCREF(&Dtool_DNALoader.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DNALoader.As_PyTypeObject().tp_dict,"DNALoader",&Dtool_DNALoader.As_PyObject());
        RegisterRuntimeClass(&Dtool_DNALoader,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNALoader.As_PyTypeObject());
        PyModule_AddObject(module, "DNALoader",(PyObject *)&Dtool_DNALoader.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNAWindows | DNAWindows
//********************************************************************
PyMethodDef Dtool_Methods_DNAWindows[]= {
  { "setCode",(PyCFunction ) &Dtool_DNAWindows_set_code_303, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAWindows_set_code_303_comment},
  { "getCode",(PyCFunction ) &Dtool_DNAWindows_get_code_304, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAWindows_get_code_304_comment},
  { "setWindowCount",(PyCFunction ) &Dtool_DNAWindows_set_window_count_305, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAWindows_set_window_count_305_comment},
  { "getWindowCount",(PyCFunction ) &Dtool_DNAWindows_get_window_count_306, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAWindows_get_window_count_306_comment},
  { "setColor",(PyCFunction ) &Dtool_DNAWindows_set_color_307, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAWindows_set_color_307_comment},
  { "getColor",(PyCFunction ) &Dtool_DNAWindows_get_color_308, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAWindows_get_color_308_comment},
  { "getClassType",(PyCFunction ) &Dtool_DNAWindows_get_class_type_309, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAWindows_get_class_type_309_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNAWindows(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DNAWindows.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DNAWindows\n"
          "// Description : A group of windows with a default layout\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DNAGroup._Dtool_ClassInit(NULL);
        Dtool_DNAWindows.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNAGroup.As_PyTypeObject());
        Dtool_DNAWindows.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNAWindows.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNAWindows.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNAWindows.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAWindows)");
             printf(" Error In PyType_ReadyDNAWindows");
             return;
        }
        Py_INCREF(&Dtool_DNAWindows.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DNAWindows.As_PyTypeObject().tp_dict,"DNAWindows",&Dtool_DNAWindows.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DNAWindows.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DNAWindows[6],&Dtool_DNAWindows.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DNAWindows,DNAWindows::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNAWindows.As_PyTypeObject());
        PyModule_AddObject(module, "DNAWindows",(PyObject *)&Dtool_DNAWindows.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNAStreet | DNAStreet
//********************************************************************
PyMethodDef Dtool_Methods_DNAStreet[]= {
  { "setCode",(PyCFunction ) &Dtool_DNAStreet_set_code_313, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStreet_set_code_313_comment},
  { "getCode",(PyCFunction ) &Dtool_DNAStreet_get_code_314, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStreet_get_code_314_comment},
  { "setStreetTexture",(PyCFunction ) &Dtool_DNAStreet_set_street_texture_315, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStreet_set_street_texture_315_comment},
  { "getStreetTexture",(PyCFunction ) &Dtool_DNAStreet_get_street_texture_316, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStreet_get_street_texture_316_comment},
  { "setSidewalkTexture",(PyCFunction ) &Dtool_DNAStreet_set_sidewalk_texture_317, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStreet_set_sidewalk_texture_317_comment},
  { "getSidewalkTexture",(PyCFunction ) &Dtool_DNAStreet_get_sidewalk_texture_318, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStreet_get_sidewalk_texture_318_comment},
  { "setCurbTexture",(PyCFunction ) &Dtool_DNAStreet_set_curb_texture_319, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStreet_set_curb_texture_319_comment},
  { "getCurbTexture",(PyCFunction ) &Dtool_DNAStreet_get_curb_texture_320, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStreet_get_curb_texture_320_comment},
  { "setStreetColor",(PyCFunction ) &Dtool_DNAStreet_set_street_color_321, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStreet_set_street_color_321_comment},
  { "getStreetColor",(PyCFunction ) &Dtool_DNAStreet_get_street_color_322, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStreet_get_street_color_322_comment},
  { "setSidewalkColor",(PyCFunction ) &Dtool_DNAStreet_set_sidewalk_color_323, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStreet_set_sidewalk_color_323_comment},
  { "getSidewalkColor",(PyCFunction ) &Dtool_DNAStreet_get_sidewalk_color_324, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStreet_get_sidewalk_color_324_comment},
  { "setCurbColor",(PyCFunction ) &Dtool_DNAStreet_set_curb_color_325, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStreet_set_curb_color_325_comment},
  { "getCurbColor",(PyCFunction ) &Dtool_DNAStreet_get_curb_color_326, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStreet_get_curb_color_326_comment},
  { "getClassType",(PyCFunction ) &Dtool_DNAStreet_get_class_type_327, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNAStreet_get_class_type_327_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNAStreet(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DNAStreet.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DNAStreet\n"
          "// Description : A street.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DNANode._Dtool_ClassInit(NULL);
        Dtool_DNAStreet.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNANode.As_PyTypeObject());
        Dtool_DNAStreet.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNAStreet.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNAStreet.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNAStreet.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNAStreet)");
             printf(" Error In PyType_ReadyDNAStreet");
             return;
        }
        Py_INCREF(&Dtool_DNAStreet.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DNAStreet.As_PyTypeObject().tp_dict,"DNAStreet",&Dtool_DNAStreet.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DNAStreet.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DNAStreet[14],&Dtool_DNAStreet.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DNAStreet,DNAStreet::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNAStreet.As_PyTypeObject());
        PyModule_AddObject(module, "DNAStreet",(PyObject *)&Dtool_DNAStreet.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNASign | DNASign
//********************************************************************
PyMethodDef Dtool_Methods_DNASign[]= {
  { "setCode",(PyCFunction ) &Dtool_DNASign_set_code_331, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASign_set_code_331_comment},
  { "getCode",(PyCFunction ) &Dtool_DNASign_get_code_332, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASign_get_code_332_comment},
  { "setColor",(PyCFunction ) &Dtool_DNASign_set_color_333, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASign_set_color_333_comment},
  { "getColor",(PyCFunction ) &Dtool_DNASign_get_color_334, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASign_get_color_334_comment},
  { "getClassType",(PyCFunction ) &Dtool_DNASign_get_class_type_335, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASign_get_class_type_335_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNASign(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DNASign.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DNASign\n"
          "// Description : A Sign\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DNANode._Dtool_ClassInit(NULL);
        Dtool_DNASign.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNANode.As_PyTypeObject());
        Dtool_DNASign.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNASign.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNASign.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNASign.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNASign)");
             printf(" Error In PyType_ReadyDNASign");
             return;
        }
        Py_INCREF(&Dtool_DNASign.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DNASign.As_PyTypeObject().tp_dict,"DNASign",&Dtool_DNASign.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DNASign.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DNASign[4],&Dtool_DNASign.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DNASign,DNASign::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNASign.As_PyTypeObject());
        PyModule_AddObject(module, "DNASign",(PyObject *)&Dtool_DNASign.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNASignBaseline | DNASignBaseline
//********************************************************************
PyMethodDef Dtool_Methods_DNASignBaseline[]= {
  { "setCode",(PyCFunction ) &Dtool_DNASignBaseline_set_code_339, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_set_code_339_comment},
  { "getCode",(PyCFunction ) &Dtool_DNASignBaseline_get_code_340, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_get_code_340_comment},
  { "setColor",(PyCFunction ) &Dtool_DNASignBaseline_set_color_341, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_set_color_341_comment},
  { "getColor",(PyCFunction ) &Dtool_DNASignBaseline_get_color_342, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_get_color_342_comment},
  { "setFont",(PyCFunction ) &Dtool_DNASignBaseline_set_font_343, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_set_font_343_comment},
  { "getFont",(PyCFunction ) &Dtool_DNASignBaseline_get_font_344, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_get_font_344_comment},
  { "setIndent",(PyCFunction ) &Dtool_DNASignBaseline_set_indent_345, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_set_indent_345_comment},
  { "getIndent",(PyCFunction ) &Dtool_DNASignBaseline_get_indent_346, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_get_indent_346_comment},
  { "setKern",(PyCFunction ) &Dtool_DNASignBaseline_set_kern_347, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_set_kern_347_comment},
  { "getKern",(PyCFunction ) &Dtool_DNASignBaseline_get_kern_348, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_get_kern_348_comment},
  { "getCurrentKern",(PyCFunction ) &Dtool_DNASignBaseline_get_current_kern_349, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_get_current_kern_349_comment},
  { "setWiggle",(PyCFunction ) &Dtool_DNASignBaseline_set_wiggle_350, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_set_wiggle_350_comment},
  { "getWiggle",(PyCFunction ) &Dtool_DNASignBaseline_get_wiggle_351, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_get_wiggle_351_comment},
  { "getCurrentWiggle",(PyCFunction ) &Dtool_DNASignBaseline_get_current_wiggle_352, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_get_current_wiggle_352_comment},
  { "setStumble",(PyCFunction ) &Dtool_DNASignBaseline_set_stumble_353, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_set_stumble_353_comment},
  { "getStumble",(PyCFunction ) &Dtool_DNASignBaseline_get_stumble_354, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_get_stumble_354_comment},
  { "getCurrentStumble",(PyCFunction ) &Dtool_DNASignBaseline_get_current_stumble_355, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_get_current_stumble_355_comment},
  { "setStomp",(PyCFunction ) &Dtool_DNASignBaseline_set_stomp_356, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_set_stomp_356_comment},
  { "getStomp",(PyCFunction ) &Dtool_DNASignBaseline_get_stomp_357, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_get_stomp_357_comment},
  { "getCurrentStomp",(PyCFunction ) &Dtool_DNASignBaseline_get_current_stomp_358, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_get_current_stomp_358_comment},
  { "setWidth",(PyCFunction ) &Dtool_DNASignBaseline_set_width_359, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_set_width_359_comment},
  { "getWidth",(PyCFunction ) &Dtool_DNASignBaseline_get_width_360, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_get_width_360_comment},
  { "setHeight",(PyCFunction ) &Dtool_DNASignBaseline_set_height_361, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_set_height_361_comment},
  { "getHeight",(PyCFunction ) &Dtool_DNASignBaseline_get_height_362, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_get_height_362_comment},
  { "setFlags",(PyCFunction ) &Dtool_DNASignBaseline_set_flags_363, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_set_flags_363_comment},
  { "getFlags",(PyCFunction ) &Dtool_DNASignBaseline_get_flags_364, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_get_flags_364_comment},
  { "isFirstLetterOfWord",(PyCFunction ) &Dtool_DNASignBaseline_isFirstLetterOfWord_365, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_isFirstLetterOfWord_365_comment},
  { "resetCounter",(PyCFunction ) &Dtool_DNASignBaseline_reset_counter_366, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_reset_counter_366_comment},
  { "incCounter",(PyCFunction ) &Dtool_DNASignBaseline_inc_counter_367, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_inc_counter_367_comment},
  { "baselineNextPosHprScale",(PyCFunction ) &Dtool_DNASignBaseline_baseline_next_pos_hpr_scale_368, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_baseline_next_pos_hpr_scale_368_comment},
  { "getClassType",(PyCFunction ) &Dtool_DNASignBaseline_get_class_type_369, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignBaseline_get_class_type_369_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNASignBaseline(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DNASignBaseline.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//   Class : DNASignBaseline\n"
          "// Description : A Sign\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DNANode._Dtool_ClassInit(NULL);
        Dtool_DNASignBaseline.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNANode.As_PyTypeObject());
        Dtool_DNASignBaseline.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNASignBaseline.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNASignBaseline.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNASignBaseline.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNASignBaseline)");
             printf(" Error In PyType_ReadyDNASignBaseline");
             return;
        }
        Py_INCREF(&Dtool_DNASignBaseline.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DNASignBaseline.As_PyTypeObject().tp_dict,"DNASignBaseline",&Dtool_DNASignBaseline.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DNASignBaseline.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DNASignBaseline[30],&Dtool_DNASignBaseline.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DNASignBaseline,DNASignBaseline::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNASignBaseline.As_PyTypeObject());
        PyModule_AddObject(module, "DNASignBaseline",(PyObject *)&Dtool_DNASignBaseline.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNASignGraphic | DNASignGraphic
//********************************************************************
PyMethodDef Dtool_Methods_DNASignGraphic[]= {
  { "setCode",(PyCFunction ) &Dtool_DNASignGraphic_set_code_373, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignGraphic_set_code_373_comment},
  { "getCode",(PyCFunction ) &Dtool_DNASignGraphic_get_code_374, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignGraphic_get_code_374_comment},
  { "setColor",(PyCFunction ) &Dtool_DNASignGraphic_set_color_375, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignGraphic_set_color_375_comment},
  { "getColor",(PyCFunction ) &Dtool_DNASignGraphic_get_color_376, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignGraphic_get_color_376_comment},
  { "setWidth",(PyCFunction ) &Dtool_DNASignGraphic_set_width_377, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignGraphic_set_width_377_comment},
  { "getWidth",(PyCFunction ) &Dtool_DNASignGraphic_get_width_378, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignGraphic_get_width_378_comment},
  { "setHeight",(PyCFunction ) &Dtool_DNASignGraphic_set_height_379, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignGraphic_set_height_379_comment},
  { "getHeight",(PyCFunction ) &Dtool_DNASignGraphic_get_height_380, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignGraphic_get_height_380_comment},
  { "getClassType",(PyCFunction ) &Dtool_DNASignGraphic_get_class_type_381, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignGraphic_get_class_type_381_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNASignGraphic(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DNASignGraphic.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//   Class : DNASignGraphic\n"
          "// Description : A graphic\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DNANode._Dtool_ClassInit(NULL);
        Dtool_DNASignGraphic.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNANode.As_PyTypeObject());
        Dtool_DNASignGraphic.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNASignGraphic.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNASignGraphic.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNASignGraphic.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNASignGraphic)");
             printf(" Error In PyType_ReadyDNASignGraphic");
             return;
        }
        Py_INCREF(&Dtool_DNASignGraphic.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DNASignGraphic.As_PyTypeObject().tp_dict,"DNASignGraphic",&Dtool_DNASignGraphic.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DNASignGraphic.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DNASignGraphic[8],&Dtool_DNASignGraphic.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DNASignGraphic,DNASignGraphic::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNASignGraphic.As_PyTypeObject());
        PyModule_AddObject(module, "DNASignGraphic",(PyObject *)&Dtool_DNASignGraphic.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. DNASignText | DNASignText
//********************************************************************
PyMethodDef Dtool_Methods_DNASignText[]= {
  { "setCode",(PyCFunction ) &Dtool_DNASignText_set_code_385, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignText_set_code_385_comment},
  { "getCode",(PyCFunction ) &Dtool_DNASignText_get_code_386, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignText_get_code_386_comment},
  { "setColor",(PyCFunction ) &Dtool_DNASignText_set_color_387, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignText_set_color_387_comment},
  { "getColor",(PyCFunction ) &Dtool_DNASignText_get_color_388, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignText_get_color_388_comment},
  { "setLetters",(PyCFunction ) &Dtool_DNASignText_set_letters_389, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignText_set_letters_389_comment},
  { "getLetters",(PyCFunction ) &Dtool_DNASignText_get_letters_390, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignText_get_letters_390_comment},
  { "getClassType",(PyCFunction ) &Dtool_DNASignText_get_class_type_391, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_DNASignText_get_class_type_391_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_DNASignText(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_DNASignText.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : DNASignText\n"
          "// Description : A Sign\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DNANode._Dtool_ClassInit(NULL);
        Dtool_DNASignText.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DNANode.As_PyTypeObject());
        Dtool_DNASignText.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_DNASignText.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_DNASignText.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_DNASignText.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(DNASignText)");
             printf(" Error In PyType_ReadyDNASignText");
             return;
        }
        Py_INCREF(&Dtool_DNASignText.As_PyTypeObject());
        PyDict_SetItemString(Dtool_DNASignText.As_PyTypeObject().tp_dict,"DNASignText",&Dtool_DNASignText.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_DNASignText.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_DNASignText[6],&Dtool_DNASignText.As_PyObject()));
        RegisterRuntimeClass(&Dtool_DNASignText,DNASignText::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_DNASignText.As_PyTypeObject());
        PyModule_AddObject(module, "DNASignText",(PyObject *)&Dtool_DNASignText.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Enums  ..CoordinateSystem
//********************************************************************
   PyModule_AddIntConstant(module,"CSDefault",0);
   PyModule_AddIntConstant(module,"CSZupRight",1);
   PyModule_AddIntConstant(module,"CSYupRight",2);
   PyModule_AddIntConstant(module,"CSZupLeft",3);
   PyModule_AddIntConstant(module,"CSYupLeft",4);
   PyModule_AddIntConstant(module,"CSInvalid",5);
//********************************************************************
//*** Module Init Updcall ..DNAGroup
//********************************************************************
   Dtool_PyModuleClassInit_DNAGroup(module);
//********************************************************************
//*** Module Init Updcall ..DNASuitPoint
//********************************************************************
   Dtool_PyModuleClassInit_DNASuitPoint(module);
//********************************************************************
//*** Module Init Updcall ..DNASuitEdge
//********************************************************************
   Dtool_PyModuleClassInit_DNASuitEdge(module);
//********************************************************************
//*** Module Init Updcall ..DNABattleCell
//********************************************************************
   Dtool_PyModuleClassInit_DNABattleCell(module);
//********************************************************************
//*** Module Init Updcall ..DNAVisGroup
//********************************************************************
   Dtool_PyModuleClassInit_DNAVisGroup(module);
//********************************************************************
//*** Module Init Updcall ..DNASuitPath
//********************************************************************
   Dtool_PyModuleClassInit_DNASuitPath(module);
//********************************************************************
//*** Module Init Updcall ..PosHpr
//********************************************************************
   Dtool_PyModuleClassInit_PosHpr(module);
//********************************************************************
//*** Module Init Updcall ..DNAStorage
//********************************************************************
   Dtool_PyModuleClassInit_DNAStorage(module);
//********************************************************************
//*** Module Init Updcall ..DNANode
//********************************************************************
   Dtool_PyModuleClassInit_DNANode(module);
//********************************************************************
//*** Module Init Updcall ..DNAWall
//********************************************************************
   Dtool_PyModuleClassInit_DNAWall(module);
//********************************************************************
//*** Module Init Updcall ..DNAFlatBuilding
//********************************************************************
   Dtool_PyModuleClassInit_DNAFlatBuilding(module);
//********************************************************************
//*** Module Init Updcall ..DNALandmarkBuilding
//********************************************************************
   Dtool_PyModuleClassInit_DNALandmarkBuilding(module);
//********************************************************************
//*** Module Init Updcall ..DNAAnimBuilding
//********************************************************************
   Dtool_PyModuleClassInit_DNAAnimBuilding(module);
//********************************************************************
//*** Module Init Updcall ..DNAProp
//********************************************************************
   Dtool_PyModuleClassInit_DNAProp(module);
//********************************************************************
//*** Module Init Updcall ..DNAAnimProp
//********************************************************************
   Dtool_PyModuleClassInit_DNAAnimProp(module);
//********************************************************************
//*** Module Init Updcall ..DNACornice
//********************************************************************
   Dtool_PyModuleClassInit_DNACornice(module);
//********************************************************************
//*** Module Init Updcall ..DNAData
//********************************************************************
   Dtool_PyModuleClassInit_DNAData(module);
//********************************************************************
//*** Module Init Updcall ..DNADoor
//********************************************************************
   Dtool_PyModuleClassInit_DNADoor(module);
//********************************************************************
//*** Module Init Updcall ..DNAFlatDoor
//********************************************************************
   Dtool_PyModuleClassInit_DNAFlatDoor(module);
//********************************************************************
//*** Module Init Updcall ..DNAInteractiveProp
//********************************************************************
   Dtool_PyModuleClassInit_DNAInteractiveProp(module);
//********************************************************************
//*** Module Init Updcall ..DNALoader
//********************************************************************
   Dtool_PyModuleClassInit_DNALoader(module);
//********************************************************************
//*** Module Init Updcall ..DNAWindows
//********************************************************************
   Dtool_PyModuleClassInit_DNAWindows(module);
//********************************************************************
//*** Module Init Updcall ..DNAStreet
//********************************************************************
   Dtool_PyModuleClassInit_DNAStreet(module);
//********************************************************************
//*** Module Init Updcall ..DNASign
//********************************************************************
   Dtool_PyModuleClassInit_DNASign(module);
//********************************************************************
//*** Module Init Updcall ..DNASignBaseline
//********************************************************************
   Dtool_PyModuleClassInit_DNASignBaseline(module);
//********************************************************************
//*** Module Init Updcall ..DNASignGraphic
//********************************************************************
   Dtool_PyModuleClassInit_DNASignGraphic(module);
//********************************************************************
//*** Module Init Updcall ..DNASignText
//********************************************************************
   Dtool_PyModuleClassInit_DNASignText(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  { "getDnaPath", (PyCFunction) &Dtool_get_dna_path_1, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_get_dna_path_1_comment},
  { "loadDNAFile", (PyCFunction) &Dtool_load_DNA_file_393, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_load_DNA_file_393_comment},
  { "loadDNAFileAI", (PyCFunction) &Dtool_load_DNA_file_AI_394, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_load_DNA_file_AI_394_comment},
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libdna_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687213981,  /* file_identifier */
  "libdna",  /* library_name */
  "yMIf",  /* library_hash_name */
  "toontown",  /* module_name */
  "libdna.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  937  /* next_index */
};

Configure(_in_configure_libdna);
ConfigureFn(_in_configure_libdna) {
  interrogate_request_module(&_in_module_def);
}

