/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/ode -Ipanda/src/ode -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libpandaode_igate.cxx -od built_Rocket/pandac/input/libpandaode.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/ode -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sthirdparty/win-libs-vc9/ode/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDAODE -module pandaode -library libpandaode config_ode.h odeAMotorJoint.h odeBallJoint.h odeBody.h odeBoxGeom.h odeCappedCylinderGeom.h odeCollisionEntry.h odeContact.h odeContactGeom.h odeContactJoint.h odeCylinderGeom.h odeFixedJoint.h odeGeom.h odeHashSpace.h odeHinge2Joint.h odeHingeJoint.h odeJoint.h odeJointCollection.h odeJointGroup.h odeLMotorJoint.h odeMass.h odeNullJoint.h odePlane2dJoint.h odePlaneGeom.h odeQuadTreeSpace.h odeRayGeom.h odeSimpleSpace.h odeSliderJoint.h odeSpace.h odeSphereGeom.h odeSurfaceParameters.h odeTriMeshData.h odeTriMeshGeom.h odeUniversalJoint.h odeUtil.h odeWorld.h ode_includes.h 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libpandaode
#include "py_panda.h"  

#include "Python.h"
#include "config_ode.h"
#include "dconfig.h"
#include "geomNode.h"
#include "geomTriangles.h"
#include "geomTristrips.h"
#include "geomVertexData.h"
#include "geomVertexReader.h"
#include "luse.h"
#include "nodePathCollection.h"
#include "notifyCategoryProxy.h"
#include "odeAMotorJoint.h"
#include "odeBallJoint.h"
#include "odeBody.h"
#include "odeBoxGeom.h"
#include "odeCappedCylinderGeom.h"
#include "odeCollisionEntry.h"
#include "odeContact.h"
#include "odeContactGeom.h"
#include "odeContactJoint.h"
#include "odeCylinderGeom.h"
#include "odeFixedJoint.h"
#include "odeGeom.h"
#include "odeHashSpace.h"
#include "odeHinge2Joint.h"
#include "odeHingeJoint.h"
#include "odeJoint.h"
#include "odeJointCollection.h"
#include "odeJointGroup.h"
#include "odeLMotorJoint.h"
#include "odeMass.h"
#include "odeNullJoint.h"
#include "odePlane2dJoint.h"
#include "odePlaneGeom.h"
#include "odeQuadTreeSpace.h"
#include "odeRayGeom.h"
#include "odeSimpleSpace.h"
#include "odeSliderJoint.h"
#include "odeSpace.h"
#include "odeSphereGeom.h"
#include "odeSurfaceParameters.h"
#include "odeTriMeshData.h"
#include "odeTriMeshGeom.h"
#include "odeUniversalJoint.h"
#include "odeUtil.h"
#include "odeWorld.h"
#include "ode_includes.h"
#include "pandabase.h"
#include "py_panda.h"
#include "typedObject.h"
#include "typedReferenceCount.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. dxBody
//********************************************************************
typedef  dxBody  dxBody_localtype;
Define_Module_Class_Private(pandaode,dxBody,dxBody_localtype,DxBody);
//********************************************************************
//*** prototypes for .. dxGeom
//********************************************************************
typedef  dxGeom  dxGeom_localtype;
Define_Module_Class_Private(pandaode,dxGeom,dxGeom_localtype,DxGeom);
//********************************************************************
//*** prototypes for .. dxJoint
//********************************************************************
typedef  dxJoint  dxJoint_localtype;
Define_Module_Class_Private(pandaode,dxJoint,dxJoint_localtype,DxJoint);
//********************************************************************
//*** prototypes for .. dxJointGroup
//********************************************************************
typedef  dxJointGroup  dxJointGroup_localtype;
Define_Module_Class_Private(pandaode,dxJointGroup,dxJointGroup_localtype,DxJointGroup);
//********************************************************************
//*** prototypes for .. dxSpace
//********************************************************************
typedef  dxSpace  dxSpace_localtype;
Define_Module_Class_Private(pandaode,dxSpace,dxSpace_localtype,DxSpace);
//********************************************************************
//*** prototypes for .. dxTriMeshData
//********************************************************************
typedef  dxTriMeshData  dxTriMeshData_localtype;
Define_Module_Class_Private(pandaode,dxTriMeshData,dxTriMeshData_localtype,DxTriMeshData);
//********************************************************************
//*** prototypes for .. dxWorld
//********************************************************************
typedef  dxWorld  dxWorld_localtype;
Define_Module_Class_Private(pandaode,dxWorld,dxWorld_localtype,DxWorld);
//********************************************************************
//*** prototypes for .. OdeWorld
//********************************************************************
typedef  OdeWorld  OdeWorld_localtype;
Define_Module_Class(pandaode,OdeWorld,OdeWorld_localtype,OdeWorld);
//********************************************************************
//*** prototypes for .. OdeJointGroup
//********************************************************************
typedef  OdeJointGroup  OdeJointGroup_localtype;
Define_Module_Class(pandaode,OdeJointGroup,OdeJointGroup_localtype,OdeJointGroup);
//********************************************************************
//*** prototypes for .. OdeJointFeedback
//********************************************************************
typedef  OdeJointFeedback  OdeJointFeedback_localtype;
Define_Module_Class(pandaode,OdeJointFeedback,OdeJointFeedback_localtype,OdeJointFeedback);
//********************************************************************
//*** prototypes for .. OdeJoint
//********************************************************************
typedef  OdeJoint  OdeJoint_localtype;
Define_Module_Class(pandaode,OdeJoint,OdeJoint_localtype,OdeJoint);
//********************************************************************
//*** prototypes for .. OdeAMotorJoint
//********************************************************************
typedef  OdeAMotorJoint  OdeAMotorJoint_localtype;
Define_Module_Class(pandaode,OdeAMotorJoint,OdeAMotorJoint_localtype,OdeAMotorJoint);
//********************************************************************
//*** prototypes for .. OdeBallJoint
//********************************************************************
typedef  OdeBallJoint  OdeBallJoint_localtype;
Define_Module_Class(pandaode,OdeBallJoint,OdeBallJoint_localtype,OdeBallJoint);
//********************************************************************
//*** prototypes for .. OdeMass
//********************************************************************
typedef  OdeMass  OdeMass_localtype;
Define_Module_ClassRef(pandaode,OdeMass,OdeMass_localtype,OdeMass);
//********************************************************************
//*** prototypes for .. OdeBody
//********************************************************************
typedef  OdeBody  OdeBody_localtype;
Define_Module_Class(pandaode,OdeBody,OdeBody_localtype,OdeBody);
//********************************************************************
//*** prototypes for .. OdeSpace
//********************************************************************
typedef  OdeSpace  OdeSpace_localtype;
Define_Module_Class(pandaode,OdeSpace,OdeSpace_localtype,OdeSpace);
//********************************************************************
//*** prototypes for .. OdeGeom
//********************************************************************
typedef  OdeGeom  OdeGeom_localtype;
Define_Module_Class(pandaode,OdeGeom,OdeGeom_localtype,OdeGeom);
//********************************************************************
//*** prototypes for .. OdeBoxGeom
//********************************************************************
typedef  OdeBoxGeom  OdeBoxGeom_localtype;
Define_Module_Class(pandaode,OdeBoxGeom,OdeBoxGeom_localtype,OdeBoxGeom);
//********************************************************************
//*** prototypes for .. OdeCappedCylinderGeom
//********************************************************************
typedef  OdeCappedCylinderGeom  OdeCappedCylinderGeom_localtype;
Define_Module_Class(pandaode,OdeCappedCylinderGeom,OdeCappedCylinderGeom_localtype,OdeCappedCylinderGeom);
//********************************************************************
//*** prototypes for .. OdeContactGeom
//********************************************************************
typedef  OdeContactGeom  OdeContactGeom_localtype;
Define_Module_ClassRef(pandaode,OdeContactGeom,OdeContactGeom_localtype,OdeContactGeom);
//********************************************************************
//*** prototypes for .. OdeCollisionEntry
//********************************************************************
typedef  OdeCollisionEntry  OdeCollisionEntry_localtype;
Define_Module_ClassRef(pandaode,OdeCollisionEntry,OdeCollisionEntry_localtype,OdeCollisionEntry);
//********************************************************************
//*** prototypes for .. OdeSurfaceParameters
//********************************************************************
typedef  OdeSurfaceParameters  OdeSurfaceParameters_localtype;
Define_Module_Class(pandaode,OdeSurfaceParameters,OdeSurfaceParameters_localtype,OdeSurfaceParameters);
//********************************************************************
//*** prototypes for .. OdeContact
//********************************************************************
typedef  OdeContact  OdeContact_localtype;
Define_Module_ClassRef(pandaode,OdeContact,OdeContact_localtype,OdeContact);
//********************************************************************
//*** prototypes for .. OdeContactJoint
//********************************************************************
typedef  OdeContactJoint  OdeContactJoint_localtype;
Define_Module_Class(pandaode,OdeContactJoint,OdeContactJoint_localtype,OdeContactJoint);
//********************************************************************
//*** prototypes for .. OdeCylinderGeom
//********************************************************************
typedef  OdeCylinderGeom  OdeCylinderGeom_localtype;
Define_Module_Class(pandaode,OdeCylinderGeom,OdeCylinderGeom_localtype,OdeCylinderGeom);
//********************************************************************
//*** prototypes for .. OdeFixedJoint
//********************************************************************
typedef  OdeFixedJoint  OdeFixedJoint_localtype;
Define_Module_Class(pandaode,OdeFixedJoint,OdeFixedJoint_localtype,OdeFixedJoint);
//********************************************************************
//*** prototypes for .. OdeHashSpace
//********************************************************************
typedef  OdeHashSpace  OdeHashSpace_localtype;
Define_Module_Class(pandaode,OdeHashSpace,OdeHashSpace_localtype,OdeHashSpace);
//********************************************************************
//*** prototypes for .. OdeHinge2Joint
//********************************************************************
typedef  OdeHinge2Joint  OdeHinge2Joint_localtype;
Define_Module_Class(pandaode,OdeHinge2Joint,OdeHinge2Joint_localtype,OdeHinge2Joint);
//********************************************************************
//*** prototypes for .. OdeHingeJoint
//********************************************************************
typedef  OdeHingeJoint  OdeHingeJoint_localtype;
Define_Module_Class(pandaode,OdeHingeJoint,OdeHingeJoint_localtype,OdeHingeJoint);
//********************************************************************
//*** prototypes for .. OdeJointCollection
//********************************************************************
typedef  OdeJointCollection  OdeJointCollection_localtype;
Define_Module_Class(pandaode,OdeJointCollection,OdeJointCollection_localtype,OdeJointCollection);
//********************************************************************
//*** prototypes for .. OdeLMotorJoint
//********************************************************************
typedef  OdeLMotorJoint  OdeLMotorJoint_localtype;
Define_Module_Class(pandaode,OdeLMotorJoint,OdeLMotorJoint_localtype,OdeLMotorJoint);
//********************************************************************
//*** prototypes for .. OdeNullJoint
//********************************************************************
typedef  OdeNullJoint  OdeNullJoint_localtype;
Define_Module_Class(pandaode,OdeNullJoint,OdeNullJoint_localtype,OdeNullJoint);
//********************************************************************
//*** prototypes for .. OdePlane2dJoint
//********************************************************************
typedef  OdePlane2dJoint  OdePlane2dJoint_localtype;
Define_Module_Class(pandaode,OdePlane2dJoint,OdePlane2dJoint_localtype,OdePlane2dJoint);
//********************************************************************
//*** prototypes for .. OdePlaneGeom
//********************************************************************
typedef  OdePlaneGeom  OdePlaneGeom_localtype;
Define_Module_Class(pandaode,OdePlaneGeom,OdePlaneGeom_localtype,OdePlaneGeom);
//********************************************************************
//*** prototypes for .. OdeQuadTreeSpace
//********************************************************************
typedef  OdeQuadTreeSpace  OdeQuadTreeSpace_localtype;
Define_Module_Class(pandaode,OdeQuadTreeSpace,OdeQuadTreeSpace_localtype,OdeQuadTreeSpace);
//********************************************************************
//*** prototypes for .. OdeRayGeom
//********************************************************************
typedef  OdeRayGeom  OdeRayGeom_localtype;
Define_Module_Class(pandaode,OdeRayGeom,OdeRayGeom_localtype,OdeRayGeom);
//********************************************************************
//*** prototypes for .. OdeSimpleSpace
//********************************************************************
typedef  OdeSimpleSpace  OdeSimpleSpace_localtype;
Define_Module_Class(pandaode,OdeSimpleSpace,OdeSimpleSpace_localtype,OdeSimpleSpace);
//********************************************************************
//*** prototypes for .. OdeSliderJoint
//********************************************************************
typedef  OdeSliderJoint  OdeSliderJoint_localtype;
Define_Module_Class(pandaode,OdeSliderJoint,OdeSliderJoint_localtype,OdeSliderJoint);
//********************************************************************
//*** prototypes for .. OdeSphereGeom
//********************************************************************
typedef  OdeSphereGeom  OdeSphereGeom_localtype;
Define_Module_Class(pandaode,OdeSphereGeom,OdeSphereGeom_localtype,OdeSphereGeom);
//********************************************************************
//*** prototypes for .. OdeTriMeshData
//********************************************************************
typedef  OdeTriMeshData  OdeTriMeshData_localtype;
Define_Module_ClassRef(pandaode,OdeTriMeshData,OdeTriMeshData_localtype,OdeTriMeshData);
//********************************************************************
//*** prototypes for .. OdeTriMeshGeom
//********************************************************************
typedef  OdeTriMeshGeom  OdeTriMeshGeom_localtype;
Define_Module_Class(pandaode,OdeTriMeshGeom,OdeTriMeshGeom_localtype,OdeTriMeshGeom);
//********************************************************************
//*** prototypes for .. OdeUniversalJoint
//********************************************************************
typedef  OdeUniversalJoint  OdeUniversalJoint_localtype;
Define_Module_Class(pandaode,OdeUniversalJoint,OdeUniversalJoint_localtype,OdeUniversalJoint);
//********************************************************************
//*** prototypes for .. OdeUtil
//********************************************************************
typedef  OdeUtil  OdeUtil_localtype;
Define_Module_Class(pandaode,OdeUtil,OdeUtil_localtype,OdeUtil);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_BitMask_unsigned_int_32;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LMatrix3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LPoint3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LQuaternionf;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVecBase4f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_LVector3f;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_NodePath;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypeHandle;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedObject;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_TypedReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ostream;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. dxBody 
//********************************************************************
int  Dtool_Init_dxBody(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (dxBody)");
       return -1;
}
inline void  * Dtool_UpcastInterface_dxBody(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_dxBody)
    {
        printf("dxBody ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    dxBody * local_this = (dxBody *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_dxBody)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_dxBody(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_dxBody)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. dxGeom 
//********************************************************************
int  Dtool_Init_dxGeom(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (dxGeom)");
       return -1;
}
inline void  * Dtool_UpcastInterface_dxGeom(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_dxGeom)
    {
        printf("dxGeom ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    dxGeom * local_this = (dxGeom *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_dxGeom)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_dxGeom(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_dxGeom)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. dxJoint 
//********************************************************************
int  Dtool_Init_dxJoint(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (dxJoint)");
       return -1;
}
inline void  * Dtool_UpcastInterface_dxJoint(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_dxJoint)
    {
        printf("dxJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    dxJoint * local_this = (dxJoint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_dxJoint)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_dxJoint(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_dxJoint)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. dxJointGroup 
//********************************************************************
int  Dtool_Init_dxJointGroup(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (dxJointGroup)");
       return -1;
}
inline void  * Dtool_UpcastInterface_dxJointGroup(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_dxJointGroup)
    {
        printf("dxJointGroup ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    dxJointGroup * local_this = (dxJointGroup *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_dxJointGroup)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_dxJointGroup(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_dxJointGroup)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. dxSpace 
//********************************************************************
int  Dtool_Init_dxSpace(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (dxSpace)");
       return -1;
}
inline void  * Dtool_UpcastInterface_dxSpace(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_dxSpace)
    {
        printf("dxSpace ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    dxSpace * local_this = (dxSpace *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_dxSpace)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_dxSpace(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_dxSpace)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. dxTriMeshData 
//********************************************************************
int  Dtool_Init_dxTriMeshData(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (dxTriMeshData)");
       return -1;
}
inline void  * Dtool_UpcastInterface_dxTriMeshData(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_dxTriMeshData)
    {
        printf("dxTriMeshData ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    dxTriMeshData * local_this = (dxTriMeshData *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_dxTriMeshData)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_dxTriMeshData(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_dxTriMeshData)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. dxWorld 
//********************************************************************
int  Dtool_Init_dxWorld(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (dxWorld)");
       return -1;
}
inline void  * Dtool_UpcastInterface_dxWorld(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_dxWorld)
    {
        printf("dxWorld ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    dxWorld * local_this = (dxWorld *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_dxWorld)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_dxWorld(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_dxWorld)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeWorld 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void OdeWorld::destroy(void)
 *******************************************************************/
static PyObject *Dtool_OdeWorld_destroy_11(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void OdeWorld::destroy(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":destroy", key_word_list));
        else
            (PyArg_Parse(args, ":destroy"));
        if(!PyErr_Occurred())
        {
            (local_this)->destroy();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeWorld.destroy() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "destroy(non-const OdeWorld this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_destroy_11_comment =
    "C++ Interface:\n"
    "destroy(non-const OdeWorld this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_destroy_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool OdeWorld::is_empty(void) const
 *******************************************************************/
static PyObject *Dtool_OdeWorld_is_empty_12(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool OdeWorld::is_empty(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isEmpty", key_word_list));
        else
            (PyArg_Parse(args, ":isEmpty"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const OdeWorld*)local_this)->is_empty();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isEmpty(const OdeWorld this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_is_empty_12_comment =
    "C++ Interface:\n"
    "isEmpty(const OdeWorld this)\n"
    "\n"
    "// Filename: odeWorld.I\n"
    "// Created by:  joswilso (27Dec06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OdeWorld::is_empty\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the ID is 0, meaning the OdeWorld\n"
    "//               does not point to a valid world. It is an error to\n"
    "//               call a method on an empty world.\n"
    "//               Note that an empty OdeWorld also evaluates to False.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeWorld_is_empty_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline dxWorld *OdeWorld::get_id(void) const
 *******************************************************************/
static PyObject *Dtool_OdeWorld_get_id_13(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline dxWorld *OdeWorld::get_id(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getId", key_word_list));
        else
            (PyArg_Parse(args, ":getId"));
        if(!PyErr_Occurred())
        {
            dxWorld *return_value = ((const OdeWorld*)local_this)->get_id();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_dxWorld,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getId(const OdeWorld this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_get_id_13_comment =
    "C++ Interface:\n"
    "getId(const OdeWorld this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OdeWorld::get_id\n"
    "//       Access: Published\n"
    "//  Description: Returns the underlying dWorldID.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeWorld_get_id_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeWorld::set_gravity(LVecBase3f const &vec)
 * inline void OdeWorld::set_gravity(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_OdeWorld_set_gravity_14(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeWorld::set_gravity(LVecBase3f const &vec)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"vec", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setGravity", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setGravity", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeWorld.setGravity", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_gravity(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeWorld.setGravity() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeWorld::set_gravity(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setGravity", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_gravity((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeWorld.setGravity() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setGravity() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setGravity(non-const OdeWorld this, const VBase3 vec)\n"
          "setGravity(non-const OdeWorld this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_set_gravity_14_comment =
    "C++ Interface:\n"
    "setGravity(non-const OdeWorld this, const VBase3 vec)\n"
    "setGravity(non-const OdeWorld this, float x, float y, float z)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_set_gravity_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeWorld::set_erp(float erp)
 *******************************************************************/
static PyObject *Dtool_OdeWorld_set_erp_15(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeWorld::set_erp(float erp)
        double param1;
        static char * key_word_list[] = {(char *)"erp", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setErp", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setErp", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_erp((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeWorld.setErp() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setErp(non-const OdeWorld this, float erp)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_set_erp_15_comment =
    "C++ Interface:\n"
    "setErp(non-const OdeWorld this, float erp)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_set_erp_15_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeWorld::set_cfm(float cfm)
 *******************************************************************/
static PyObject *Dtool_OdeWorld_set_cfm_16(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeWorld::set_cfm(float cfm)
        double param1;
        static char * key_word_list[] = {(char *)"cfm", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setCfm", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setCfm", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_cfm((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeWorld.setCfm() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCfm(non-const OdeWorld this, float cfm)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_set_cfm_16_comment =
    "C++ Interface:\n"
    "setCfm(non-const OdeWorld this, float cfm)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_set_cfm_16_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeWorld::set_quick_step_num_iterations(int num)
 *******************************************************************/
static PyObject *Dtool_OdeWorld_set_quick_step_num_iterations_17(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeWorld::set_quick_step_num_iterations(int num)
        int param1;
        static char * key_word_list[] = {(char *)"num", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setQuickStepNumIterations", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setQuickStepNumIterations", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_quick_step_num_iterations((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeWorld.setQuickStepNumIterations() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setQuickStepNumIterations(non-const OdeWorld this, int num)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_set_quick_step_num_iterations_17_comment =
    "C++ Interface:\n"
    "setQuickStepNumIterations(non-const OdeWorld this, int num)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_set_quick_step_num_iterations_17_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeWorld::set_quick_step_w(float over_relaxation)
 *******************************************************************/
static PyObject *Dtool_OdeWorld_set_quick_step_w_18(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeWorld::set_quick_step_w(float over_relaxation)
        double param1;
        static char * key_word_list[] = {(char *)"over_relaxation", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setQuickStepW", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setQuickStepW", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_quick_step_w((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeWorld.setQuickStepW() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setQuickStepW(non-const OdeWorld this, float over_relaxation)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_set_quick_step_w_18_comment =
    "C++ Interface:\n"
    "setQuickStepW(non-const OdeWorld this, float over_relaxation)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_set_quick_step_w_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeWorld::set_contact_max_correcting_vel(float vel)
 *******************************************************************/
static PyObject *Dtool_OdeWorld_set_contact_max_correcting_vel_19(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeWorld::set_contact_max_correcting_vel(float vel)
        double param1;
        static char * key_word_list[] = {(char *)"vel", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setContactMaxCorrectingVel", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setContactMaxCorrectingVel", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_contact_max_correcting_vel((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeWorld.setContactMaxCorrectingVel() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setContactMaxCorrectingVel(non-const OdeWorld this, float vel)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_set_contact_max_correcting_vel_19_comment =
    "C++ Interface:\n"
    "setContactMaxCorrectingVel(non-const OdeWorld this, float vel)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_set_contact_max_correcting_vel_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeWorld::set_contact_surface_layer(float depth)
 *******************************************************************/
static PyObject *Dtool_OdeWorld_set_contact_surface_layer_20(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeWorld::set_contact_surface_layer(float depth)
        double param1;
        static char * key_word_list[] = {(char *)"depth", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setContactSurfaceLayer", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setContactSurfaceLayer", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_contact_surface_layer((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeWorld.setContactSurfaceLayer() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setContactSurfaceLayer(non-const OdeWorld this, float depth)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_set_contact_surface_layer_20_comment =
    "C++ Interface:\n"
    "setContactSurfaceLayer(non-const OdeWorld this, float depth)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_set_contact_surface_layer_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeWorld::set_auto_enable_depth_sf1(int auto_enable_depth)
 *******************************************************************/
static PyObject *Dtool_OdeWorld_set_auto_enable_depth_sf1_21(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeWorld::set_auto_enable_depth_sf1(int auto_enable_depth)
        int param1;
        static char * key_word_list[] = {(char *)"auto_enable_depth", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setAutoEnableDepthSf1", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setAutoEnableDepthSf1", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_auto_enable_depth_sf1((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeWorld.setAutoEnableDepthSf1() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAutoEnableDepthSf1(non-const OdeWorld this, int auto_enable_depth)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_set_auto_enable_depth_sf1_21_comment =
    "C++ Interface:\n"
    "setAutoEnableDepthSf1(non-const OdeWorld this, int auto_enable_depth)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_set_auto_enable_depth_sf1_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeWorld::set_auto_disable_linear_threshold(float linear_threshold)
 *******************************************************************/
static PyObject *Dtool_OdeWorld_set_auto_disable_linear_threshold_22(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeWorld::set_auto_disable_linear_threshold(float linear_threshold)
        double param1;
        static char * key_word_list[] = {(char *)"linear_threshold", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setAutoDisableLinearThreshold", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setAutoDisableLinearThreshold", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_auto_disable_linear_threshold((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeWorld.setAutoDisableLinearThreshold() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAutoDisableLinearThreshold(non-const OdeWorld this, float linear_threshold)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_set_auto_disable_linear_threshold_22_comment =
    "C++ Interface:\n"
    "setAutoDisableLinearThreshold(non-const OdeWorld this, float linear_threshold)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_set_auto_disable_linear_threshold_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeWorld::set_auto_disable_angular_threshold(float angular_threshold)
 *******************************************************************/
static PyObject *Dtool_OdeWorld_set_auto_disable_angular_threshold_23(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeWorld::set_auto_disable_angular_threshold(float angular_threshold)
        double param1;
        static char * key_word_list[] = {(char *)"angular_threshold", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setAutoDisableAngularThreshold", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setAutoDisableAngularThreshold", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_auto_disable_angular_threshold((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeWorld.setAutoDisableAngularThreshold() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAutoDisableAngularThreshold(non-const OdeWorld this, float angular_threshold)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_set_auto_disable_angular_threshold_23_comment =
    "C++ Interface:\n"
    "setAutoDisableAngularThreshold(non-const OdeWorld this, float angular_threshold)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_set_auto_disable_angular_threshold_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeWorld::set_auto_disable_steps(int steps)
 *******************************************************************/
static PyObject *Dtool_OdeWorld_set_auto_disable_steps_24(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeWorld::set_auto_disable_steps(int steps)
        int param1;
        static char * key_word_list[] = {(char *)"steps", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setAutoDisableSteps", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setAutoDisableSteps", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_auto_disable_steps((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeWorld.setAutoDisableSteps() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAutoDisableSteps(non-const OdeWorld this, int steps)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_set_auto_disable_steps_24_comment =
    "C++ Interface:\n"
    "setAutoDisableSteps(non-const OdeWorld this, int steps)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_set_auto_disable_steps_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeWorld::set_auto_disable_time(float time)
 *******************************************************************/
static PyObject *Dtool_OdeWorld_set_auto_disable_time_25(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeWorld::set_auto_disable_time(float time)
        double param1;
        static char * key_word_list[] = {(char *)"time", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setAutoDisableTime", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setAutoDisableTime", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_auto_disable_time((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeWorld.setAutoDisableTime() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAutoDisableTime(non-const OdeWorld this, float time)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_set_auto_disable_time_25_comment =
    "C++ Interface:\n"
    "setAutoDisableTime(non-const OdeWorld this, float time)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_set_auto_disable_time_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeWorld::set_auto_disable_flag(int do_auto_disable)
 *******************************************************************/
static PyObject *Dtool_OdeWorld_set_auto_disable_flag_26(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeWorld::set_auto_disable_flag(int do_auto_disable)
        int param1;
        static char * key_word_list[] = {(char *)"do_auto_disable", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setAutoDisableFlag", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setAutoDisableFlag", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_auto_disable_flag((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeWorld.setAutoDisableFlag() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAutoDisableFlag(non-const OdeWorld this, int do_auto_disable)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_set_auto_disable_flag_26_comment =
    "C++ Interface:\n"
    "setAutoDisableFlag(non-const OdeWorld this, int do_auto_disable)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_set_auto_disable_flag_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f OdeWorld::get_gravity(void) const
 *******************************************************************/
static PyObject *Dtool_OdeWorld_get_gravity_27(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f OdeWorld::get_gravity(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getGravity", key_word_list));
        else
            (PyArg_Parse(args, ":getGravity"));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const OdeWorld*)local_this)->get_gravity();
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGravity(const OdeWorld this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_get_gravity_27_comment =
    "C++ Interface:\n"
    "getGravity(const OdeWorld this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_get_gravity_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeWorld::get_erp(void) const
 *******************************************************************/
static PyObject *Dtool_OdeWorld_get_erp_28(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeWorld::get_erp(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getErp", key_word_list));
        else
            (PyArg_Parse(args, ":getErp"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeWorld*)local_this)->get_erp();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getErp(const OdeWorld this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_get_erp_28_comment =
    "C++ Interface:\n"
    "getErp(const OdeWorld this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_get_erp_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeWorld::get_cfm(void) const
 *******************************************************************/
static PyObject *Dtool_OdeWorld_get_cfm_29(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeWorld::get_cfm(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCfm", key_word_list));
        else
            (PyArg_Parse(args, ":getCfm"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeWorld*)local_this)->get_cfm();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCfm(const OdeWorld this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_get_cfm_29_comment =
    "C++ Interface:\n"
    "getCfm(const OdeWorld this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_get_cfm_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeWorld::get_quick_step_num_iterations(void) const
 *******************************************************************/
static PyObject *Dtool_OdeWorld_get_quick_step_num_iterations_30(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int OdeWorld::get_quick_step_num_iterations(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getQuickStepNumIterations", key_word_list));
        else
            (PyArg_Parse(args, ":getQuickStepNumIterations"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const OdeWorld*)local_this)->get_quick_step_num_iterations();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getQuickStepNumIterations(const OdeWorld this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_get_quick_step_num_iterations_30_comment =
    "C++ Interface:\n"
    "getQuickStepNumIterations(const OdeWorld this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_get_quick_step_num_iterations_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeWorld::get_quick_step_w(void) const
 *******************************************************************/
static PyObject *Dtool_OdeWorld_get_quick_step_w_31(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeWorld::get_quick_step_w(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getQuickStepW", key_word_list));
        else
            (PyArg_Parse(args, ":getQuickStepW"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeWorld*)local_this)->get_quick_step_w();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getQuickStepW(const OdeWorld this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_get_quick_step_w_31_comment =
    "C++ Interface:\n"
    "getQuickStepW(const OdeWorld this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_get_quick_step_w_31_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeWorld::get_contact_max_correcting_vel(void) const
 *******************************************************************/
static PyObject *Dtool_OdeWorld_get_contact_max_correcting_vel_32(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeWorld::get_contact_max_correcting_vel(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getContactMaxCorrectingVel", key_word_list));
        else
            (PyArg_Parse(args, ":getContactMaxCorrectingVel"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeWorld*)local_this)->get_contact_max_correcting_vel();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getContactMaxCorrectingVel(const OdeWorld this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_get_contact_max_correcting_vel_32_comment =
    "C++ Interface:\n"
    "getContactMaxCorrectingVel(const OdeWorld this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_get_contact_max_correcting_vel_32_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeWorld::get_contact_surface_layer(void) const
 *******************************************************************/
static PyObject *Dtool_OdeWorld_get_contact_surface_layer_33(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeWorld::get_contact_surface_layer(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getContactSurfaceLayer", key_word_list));
        else
            (PyArg_Parse(args, ":getContactSurfaceLayer"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeWorld*)local_this)->get_contact_surface_layer();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getContactSurfaceLayer(const OdeWorld this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_get_contact_surface_layer_33_comment =
    "C++ Interface:\n"
    "getContactSurfaceLayer(const OdeWorld this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_get_contact_surface_layer_33_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeWorld::get_auto_enable_depth_sf1(void) const
 *******************************************************************/
static PyObject *Dtool_OdeWorld_get_auto_enable_depth_sf1_34(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int OdeWorld::get_auto_enable_depth_sf1(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAutoEnableDepthSf1", key_word_list));
        else
            (PyArg_Parse(args, ":getAutoEnableDepthSf1"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const OdeWorld*)local_this)->get_auto_enable_depth_sf1();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAutoEnableDepthSf1(const OdeWorld this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_get_auto_enable_depth_sf1_34_comment =
    "C++ Interface:\n"
    "getAutoEnableDepthSf1(const OdeWorld this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_get_auto_enable_depth_sf1_34_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeWorld::get_auto_disable_linear_threshold(void) const
 *******************************************************************/
static PyObject *Dtool_OdeWorld_get_auto_disable_linear_threshold_35(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeWorld::get_auto_disable_linear_threshold(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAutoDisableLinearThreshold", key_word_list));
        else
            (PyArg_Parse(args, ":getAutoDisableLinearThreshold"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeWorld*)local_this)->get_auto_disable_linear_threshold();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAutoDisableLinearThreshold(const OdeWorld this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_get_auto_disable_linear_threshold_35_comment =
    "C++ Interface:\n"
    "getAutoDisableLinearThreshold(const OdeWorld this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_get_auto_disable_linear_threshold_35_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeWorld::get_auto_disable_angular_threshold(void) const
 *******************************************************************/
static PyObject *Dtool_OdeWorld_get_auto_disable_angular_threshold_36(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeWorld::get_auto_disable_angular_threshold(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAutoDisableAngularThreshold", key_word_list));
        else
            (PyArg_Parse(args, ":getAutoDisableAngularThreshold"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeWorld*)local_this)->get_auto_disable_angular_threshold();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAutoDisableAngularThreshold(const OdeWorld this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_get_auto_disable_angular_threshold_36_comment =
    "C++ Interface:\n"
    "getAutoDisableAngularThreshold(const OdeWorld this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_get_auto_disable_angular_threshold_36_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeWorld::get_auto_disable_steps(void) const
 *******************************************************************/
static PyObject *Dtool_OdeWorld_get_auto_disable_steps_37(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int OdeWorld::get_auto_disable_steps(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAutoDisableSteps", key_word_list));
        else
            (PyArg_Parse(args, ":getAutoDisableSteps"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const OdeWorld*)local_this)->get_auto_disable_steps();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAutoDisableSteps(const OdeWorld this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_get_auto_disable_steps_37_comment =
    "C++ Interface:\n"
    "getAutoDisableSteps(const OdeWorld this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_get_auto_disable_steps_37_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeWorld::get_auto_disable_time(void) const
 *******************************************************************/
static PyObject *Dtool_OdeWorld_get_auto_disable_time_38(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeWorld::get_auto_disable_time(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAutoDisableTime", key_word_list));
        else
            (PyArg_Parse(args, ":getAutoDisableTime"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeWorld*)local_this)->get_auto_disable_time();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAutoDisableTime(const OdeWorld this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_get_auto_disable_time_38_comment =
    "C++ Interface:\n"
    "getAutoDisableTime(const OdeWorld this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_get_auto_disable_time_38_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeWorld::get_auto_disable_flag(void) const
 *******************************************************************/
static PyObject *Dtool_OdeWorld_get_auto_disable_flag_39(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int OdeWorld::get_auto_disable_flag(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAutoDisableFlag", key_word_list));
        else
            (PyArg_Parse(args, ":getAutoDisableFlag"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const OdeWorld*)local_this)->get_auto_disable_flag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAutoDisableFlag(const OdeWorld this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_get_auto_disable_flag_39_comment =
    "C++ Interface:\n"
    "getAutoDisableFlag(const OdeWorld this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_get_auto_disable_flag_39_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f OdeWorld::impulse_to_force(float stepsize, LVecBase3f const &impulse)
 * inline LVecBase3f OdeWorld::impulse_to_force(float stepsize, float ix, float iy, float iz)
 *******************************************************************/
static PyObject *Dtool_OdeWorld_impulse_to_force_40(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline LVecBase3f OdeWorld::impulse_to_force(float stepsize, LVecBase3f const &impulse)
                double param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"stepsize", (char *)"impulse", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "dO:impulseToForce", key_word_list, &param1, &param2))
                {
                    LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "OdeWorld.impulseToForce", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        LVecBase3f result = (local_this)->impulse_to_force((float)param1, *param2_this);
                        LVecBase3f *return_value = new LVecBase3f(result);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeWorld.impulseToForce() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline LVecBase3f OdeWorld::impulse_to_force(float stepsize, float ix, float iy, float iz)
            double param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"stepsize", (char *)"ix", (char *)"iy", (char *)"iz", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:impulseToForce", key_word_list, &param1, &param2, &param3, &param4))
            {
                LVecBase3f result = (local_this)->impulse_to_force((float)param1, (float)param2, (float)param3, (float)param4);
                LVecBase3f *return_value = new LVecBase3f(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeWorld.impulseToForce() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "impulseToForce() takes 3 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "impulseToForce(non-const OdeWorld this, float stepsize, const VBase3 impulse)\n"
          "impulseToForce(non-const OdeWorld this, float stepsize, float ix, float iy, float iz)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_impulse_to_force_40_comment =
    "C++ Interface:\n"
    "impulseToForce(non-const OdeWorld this, float stepsize, const VBase3 impulse)\n"
    "impulseToForce(non-const OdeWorld this, float stepsize, float ix, float iy, float iz)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_impulse_to_force_40_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeWorld::step(float stepsize)
 *******************************************************************/
static PyObject *Dtool_OdeWorld_step_41(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeWorld::step(float stepsize)
        double param1;
        static char * key_word_list[] = {(char *)"stepsize", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:step", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:step", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->step((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeWorld.step() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "step(non-const OdeWorld this, float stepsize)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_step_41_comment =
    "C++ Interface:\n"
    "step(non-const OdeWorld this, float stepsize)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_step_41_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeWorld::quick_step(float stepsize)
 *******************************************************************/
static PyObject *Dtool_OdeWorld_quick_step_42(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeWorld::quick_step(float stepsize)
        double param1;
        static char * key_word_list[] = {(char *)"stepsize", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:quickStep", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:quickStep", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->quick_step((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeWorld.quickStep() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "quickStep(non-const OdeWorld this, float stepsize)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_quick_step_42_comment =
    "C++ Interface:\n"
    "quickStep(non-const OdeWorld this, float stepsize)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_quick_step_42_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeWorld::step_fast1(float stepsize, int maxiterations)
 *******************************************************************/
static PyObject *Dtool_OdeWorld_step_fast1_43(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeWorld::step_fast1(float stepsize, int maxiterations)
        double param1;
        int param2;
        static char * key_word_list[] = {(char *)"stepsize", (char *)"maxiterations", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "di:stepFast1", key_word_list, &param1, &param2))
        {
            (local_this)->step_fast1((float)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeWorld.stepFast1() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "stepFast1(non-const OdeWorld this, float stepsize, int maxiterations)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_step_fast1_43_comment =
    "C++ Interface:\n"
    "stepFast1(non-const OdeWorld this, float stepsize, int maxiterations)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_step_fast1_43_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeWorld::compare_to(OdeWorld const &other) const
 *******************************************************************/
static PyObject *Dtool_OdeWorld_compare_to_44(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline int OdeWorld::compare_to(OdeWorld const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:compareTo", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:compareTo", &param1));
            if(!PyErr_Occurred())
            {
                OdeWorld *param1_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeWorld, 1, "OdeWorld.compareTo", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = ((const OdeWorld*)local_this)->compare_to(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "compareTo(const OdeWorld this, const OdeWorld other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_compare_to_44_comment =
    "C++ Interface:\n"
    "compareTo(const OdeWorld this, const OdeWorld other)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_compare_to_44_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void OdeWorld::init_surface_table(unsigned char num_surfaces)
 *******************************************************************/
static PyObject *Dtool_OdeWorld_init_surface_table_45(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void OdeWorld::init_surface_table(unsigned char num_surfaces)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"num_surfaces", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:initSurfaceTable", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:initSurfaceTable", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                (local_this)->init_surface_table(PyLong_AsUnsignedLong(param1_uint));
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeWorld.initSurfaceTable() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "initSurfaceTable(non-const OdeWorld this, unsigned int num_surfaces)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_init_surface_table_45_comment =
    "C++ Interface:\n"
    "initSurfaceTable(non-const OdeWorld this, unsigned int num_surfaces)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_init_surface_table_45_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void OdeWorld::add_body_dampening(OdeBody &body, int surface)
 *******************************************************************/
static PyObject *Dtool_OdeWorld_add_body_dampening_46(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void OdeWorld::add_body_dampening(OdeBody &body, int surface)
            PyObject *param1;
            int param2;
            static char * key_word_list[] = {(char *)"body", (char *)"surface", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:addBodyDampening", key_word_list, &param1, &param2))
            {
                OdeBody *param1_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeBody, 1, "OdeWorld.addBodyDampening", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_body_dampening(*param1_this, (int)param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeWorld.addBodyDampening() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addBodyDampening(non-const OdeWorld this, non-const OdeBody body, int surface)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_add_body_dampening_46_comment =
    "C++ Interface:\n"
    "addBodyDampening(non-const OdeWorld this, non-const OdeBody body, int surface)\n"
    "\n"
    "//void assign_surface_body(OdeBody& body, int surface);\n"
    "";
#else
static const char * Dtool_OdeWorld_add_body_dampening_46_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void OdeWorld::set_surface_entry(unsigned char pos1, unsigned char pos2, float mu, float bounce, float bounce_vel, float soft_erp, float soft_cfm, float slip, float dampen)
 *******************************************************************/
static PyObject *Dtool_OdeWorld_set_surface_entry_47(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void OdeWorld::set_surface_entry(unsigned char pos1, unsigned char pos2, float mu, float bounce, float bounce_vel, float soft_erp, float soft_cfm, float slip, float dampen)
        PyObject *param1;
        PyObject *param2;
        double param3;
        double param4;
        double param5;
        double param6;
        double param7;
        double param8;
        double param9;
        static char * key_word_list[] = {(char *)"pos1", (char *)"pos2", (char *)"mu", (char *)"bounce", (char *)"bounce_vel", (char *)"soft_erp", (char *)"soft_cfm", (char *)"slip", (char *)"dampen", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OOddddddd:setSurfaceEntry", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9))
        {
             PyObject *param1_uint = PyNumber_Long(param1); PyObject *param2_uint = PyNumber_Long(param2);
            if (!((param1_uint == NULL)|| (param2_uint == NULL)))
            {
                (local_this)->set_surface_entry(PyLong_AsUnsignedLong(param1_uint), PyLong_AsUnsignedLong(param2_uint), (float)param3, (float)param4, (float)param5, (float)param6, (float)param7, (float)param8, (float)param9);
                 Py_XDECREF(param1_uint); Py_XDECREF(param2_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeWorld.setSurfaceEntry() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSurfaceEntry(non-const OdeWorld this, unsigned int pos1, unsigned int pos2, float mu, float bounce, float bounce_vel, float soft_erp, float soft_cfm, float slip, float dampen)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_set_surface_entry_47_comment =
    "C++ Interface:\n"
    "setSurfaceEntry(non-const OdeWorld this, unsigned int pos1, unsigned int pos2, float mu, float bounce, float bounce_vel, float soft_erp, float soft_cfm, float slip, float dampen)\n"
    "\n"
    "//void assign_surface_body(OdeBody& body, int surface);\n"
    "";
#else
static const char * Dtool_OdeWorld_set_surface_entry_47_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * float OdeWorld::apply_dampening(float dt, OdeBody &body)
 *******************************************************************/
static PyObject *Dtool_OdeWorld_apply_dampening_48(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-float OdeWorld::apply_dampening(float dt, OdeBody &body)
            double param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"dt", (char *)"body", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dO:applyDampening", key_word_list, &param1, &param2))
            {
                OdeBody *param2_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_OdeBody, 2, "OdeWorld.applyDampening", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    float return_value = (local_this)->apply_dampening((float)param1, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyFloat_FromDouble(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeWorld.applyDampening() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "applyDampening(non-const OdeWorld this, float dt, non-const OdeBody body)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_apply_dampening_48_comment =
    "C++ Interface:\n"
    "applyDampening(non-const OdeWorld this, float dt, non-const OdeBody body)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_apply_dampening_48_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeWorld::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeWorld_get_class_type_50(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeWorld::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeWorld::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_get_class_type_50_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_get_class_type_50_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool OdeWorld::operator typecast bool(void) const
 *******************************************************************/
static PyObject *Dtool_OdeWorld_operator_typecast_bool_49(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeWorld * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeWorld,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool OdeWorld::operator typecast bool(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":__nonzero__", key_word_list));
        else
            (PyArg_Parse(args, ":__nonzero__"));
        if(!PyErr_Occurred())
        {
            bool return_value = (bool)(*(const OdeWorld*)local_this);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__nonzero__(const OdeWorld this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeWorld_operator_typecast_bool_49_comment =
    "C++ Interface:\n"
    "__nonzero__(const OdeWorld this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeWorld_operator_typecast_bool_49_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeWorld::OdeWorld(void)
 * OdeWorld::OdeWorld(OdeWorld const &copy)
 *******************************************************************/
int  Dtool_Init_OdeWorld(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-OdeWorld::OdeWorld(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":OdeWorld", key_word_list))
            {
                OdeWorld *return_value = new OdeWorld();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeWorld,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeWorld::OdeWorld(OdeWorld const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:OdeWorld", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:OdeWorld", &param0));
                if(!PyErr_Occurred())
                {
                    OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeWorld, 0, "OdeWorld.OdeWorld", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        OdeWorld *return_value = new OdeWorld(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeWorld,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OdeWorld() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OdeWorld()\n"
          "OdeWorld(const OdeWorld copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OdeWorld(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeWorld)
    {
        printf("OdeWorld ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeWorld * local_this = (OdeWorld *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeWorld)
        return local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeWorld(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeWorld)
        return from_this;
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeWorld*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeJointGroup 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void OdeJointGroup::destroy(void)
 *******************************************************************/
static PyObject *Dtool_OdeJointGroup_destroy_53(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJointGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJointGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void OdeJointGroup::destroy(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":destroy", key_word_list));
        else
            (PyArg_Parse(args, ":destroy"));
        if(!PyErr_Occurred())
        {
            (local_this)->destroy();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeJointGroup.destroy() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "destroy(non-const OdeJointGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJointGroup_destroy_53_comment =
    "C++ Interface:\n"
    "destroy(non-const OdeJointGroup this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJointGroup_destroy_53_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline dxJointGroup *OdeJointGroup::get_id(void) const
 *******************************************************************/
static PyObject *Dtool_OdeJointGroup_get_id_54(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJointGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJointGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline dxJointGroup *OdeJointGroup::get_id(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getId", key_word_list));
        else
            (PyArg_Parse(args, ":getId"));
        if(!PyErr_Occurred())
        {
            dxJointGroup *return_value = ((const OdeJointGroup*)local_this)->get_id();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_dxJointGroup,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getId(const OdeJointGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJointGroup_get_id_54_comment =
    "C++ Interface:\n"
    "getId(const OdeJointGroup this)\n"
    "\n"
    "// Filename: odeJointGroup.I\n"
    "// Created by:  joswilso (27Dec06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeJointGroup_get_id_54_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeJointGroup::empty(void) const
 *******************************************************************/
static PyObject *Dtool_OdeJointGroup_empty_55(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJointGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJointGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline void OdeJointGroup::empty(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":empty", key_word_list));
        else
            (PyArg_Parse(args, ":empty"));
        if(!PyErr_Occurred())
        {
            ((const OdeJointGroup*)local_this)->empty();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "empty(const OdeJointGroup this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJointGroup_empty_55_comment =
    "C++ Interface:\n"
    "empty(const OdeJointGroup this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJointGroup_empty_55_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeJointGroup::compare_to(OdeJointGroup const &other) const
 *******************************************************************/
static PyObject *Dtool_OdeJointGroup_compare_to_56(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJointGroup * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJointGroup,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline int OdeJointGroup::compare_to(OdeJointGroup const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:compareTo", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:compareTo", &param1));
            if(!PyErr_Occurred())
            {
                OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeJointGroup, 1, "OdeJointGroup.compareTo", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = ((const OdeJointGroup*)local_this)->compare_to(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "compareTo(const OdeJointGroup this, const OdeJointGroup other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJointGroup_compare_to_56_comment =
    "C++ Interface:\n"
    "compareTo(const OdeJointGroup this, const OdeJointGroup other)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJointGroup_compare_to_56_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeJointGroup::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeJointGroup_get_class_type_57(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeJointGroup::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeJointGroup::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJointGroup_get_class_type_57_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJointGroup_get_class_type_57_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeJointGroup::OdeJointGroup(void)
 *******************************************************************/
int  Dtool_Init_OdeJointGroup(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-OdeJointGroup::OdeJointGroup(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":OdeJointGroup", key_word_list))
        {
            OdeJointGroup *return_value = new OdeJointGroup();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeJointGroup,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "OdeJointGroup()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OdeJointGroup(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeJointGroup)
    {
        printf("OdeJointGroup ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeJointGroup * local_this = (OdeJointGroup *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeJointGroup)
        return local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeJointGroup(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeJointGroup)
        return from_this;
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeJointGroup*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeJointFeedback 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline LVector3f const OdeJointFeedback::get_force1(void) const
 *******************************************************************/
static PyObject *Dtool_OdeJointFeedback_get_force1_60(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJointFeedback * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJointFeedback,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVector3f const OdeJointFeedback::get_force1(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getForce1", key_word_list));
        else
            (PyArg_Parse(args, ":getForce1"));
        if(!PyErr_Occurred())
        {
            LVector3f const result = ((const OdeJointFeedback*)local_this)->get_force1();
            LVector3f const *return_value = new LVector3f const(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,true, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getForce1(const OdeJointFeedback this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJointFeedback_get_force1_60_comment =
    "C++ Interface:\n"
    "getForce1(const OdeJointFeedback this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJointFeedback_get_force1_60_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector3f const OdeJointFeedback::get_force2(void) const
 *******************************************************************/
static PyObject *Dtool_OdeJointFeedback_get_force2_61(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJointFeedback * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJointFeedback,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVector3f const OdeJointFeedback::get_force2(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getForce2", key_word_list));
        else
            (PyArg_Parse(args, ":getForce2"));
        if(!PyErr_Occurred())
        {
            LVector3f const result = ((const OdeJointFeedback*)local_this)->get_force2();
            LVector3f const *return_value = new LVector3f const(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,true, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getForce2(const OdeJointFeedback this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJointFeedback_get_force2_61_comment =
    "C++ Interface:\n"
    "getForce2(const OdeJointFeedback this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJointFeedback_get_force2_61_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector3f const OdeJointFeedback::get_torque1(void) const
 *******************************************************************/
static PyObject *Dtool_OdeJointFeedback_get_torque1_62(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJointFeedback * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJointFeedback,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVector3f const OdeJointFeedback::get_torque1(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTorque1", key_word_list));
        else
            (PyArg_Parse(args, ":getTorque1"));
        if(!PyErr_Occurred())
        {
            LVector3f const result = ((const OdeJointFeedback*)local_this)->get_torque1();
            LVector3f const *return_value = new LVector3f const(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,true, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTorque1(const OdeJointFeedback this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJointFeedback_get_torque1_62_comment =
    "C++ Interface:\n"
    "getTorque1(const OdeJointFeedback this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJointFeedback_get_torque1_62_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVector3f const OdeJointFeedback::get_torque2(void) const
 *******************************************************************/
static PyObject *Dtool_OdeJointFeedback_get_torque2_63(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJointFeedback * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJointFeedback,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVector3f const OdeJointFeedback::get_torque2(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTorque2", key_word_list));
        else
            (PyArg_Parse(args, ":getTorque2"));
        if(!PyErr_Occurred())
        {
            LVector3f const result = ((const OdeJointFeedback*)local_this)->get_torque2();
            LVector3f const *return_value = new LVector3f const(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVector3f,true, true);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTorque2(const OdeJointFeedback this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJointFeedback_get_torque2_63_comment =
    "C++ Interface:\n"
    "getTorque2(const OdeJointFeedback this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJointFeedback_get_torque2_63_comment = NULL;
#endif

int  Dtool_Init_OdeJointFeedback(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (OdeJointFeedback)");
       return -1;
}
inline void  * Dtool_UpcastInterface_OdeJointFeedback(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeJointFeedback)
    {
        printf("OdeJointFeedback ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeJointFeedback * local_this = (OdeJointFeedback *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeJointFeedback)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeJointFeedback(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeJointFeedback)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeJoint 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void OdeJoint::destroy(void)
 *******************************************************************/
static PyObject *Dtool_OdeJoint_destroy_67(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void OdeJoint::destroy(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":destroy", key_word_list));
        else
            (PyArg_Parse(args, ":destroy"));
        if(!PyErr_Occurred())
        {
            (local_this)->destroy();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeJoint.destroy() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "destroy(non-const OdeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJoint_destroy_67_comment =
    "C++ Interface:\n"
    "destroy(non-const OdeJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJoint_destroy_67_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool OdeJoint::is_empty(void) const
 *******************************************************************/
static PyObject *Dtool_OdeJoint_is_empty_68(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool OdeJoint::is_empty(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isEmpty", key_word_list));
        else
            (PyArg_Parse(args, ":isEmpty"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const OdeJoint*)local_this)->is_empty();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isEmpty(const OdeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJoint_is_empty_68_comment =
    "C++ Interface:\n"
    "isEmpty(const OdeJoint this)\n"
    "\n"
    "// Filename: odeJoint.I\n"
    "// Created by:  joswilso (27Dec06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OdeJoint::is_empty\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the ID is 0, meaning the OdeJoint\n"
    "//               does not point to a valid joint. It is an error to\n"
    "//               call a method on an empty joint.\n"
    "//               Note that an empty OdeJoint also evaluates to False.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeJoint_is_empty_68_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline dxJoint *OdeJoint::get_id(void) const
 *******************************************************************/
static PyObject *Dtool_OdeJoint_get_id_69(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline dxJoint *OdeJoint::get_id(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getId", key_word_list));
        else
            (PyArg_Parse(args, ":getId"));
        if(!PyErr_Occurred())
        {
            dxJoint *return_value = ((const OdeJoint*)local_this)->get_id();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_dxJoint,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getId(const OdeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJoint_get_id_69_comment =
    "C++ Interface:\n"
    "getId(const OdeJoint this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OdeJoint::get_id\n"
    "//       Access: Published\n"
    "//  Description: Returns the underlying dJointID.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeJoint_get_id_69_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeJoint::get_joint_type(void) const
 *******************************************************************/
static PyObject *Dtool_OdeJoint_get_joint_type_70(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int OdeJoint::get_joint_type(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getJointType", key_word_list));
        else
            (PyArg_Parse(args, ":getJointType"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const OdeJoint*)local_this)->get_joint_type();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getJointType(const OdeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJoint_get_joint_type_70_comment =
    "C++ Interface:\n"
    "getJointType(const OdeJoint this)\n"
    "\n"
    "/* INLINE void *get_data(); */\n"
    "";
#else
static const char * Dtool_OdeJoint_get_joint_type_70_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeBody OdeJoint::get_body(int index) const
 *******************************************************************/
static PyObject *Dtool_OdeJoint_get_body_71(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-OdeBody OdeJoint::get_body(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getBody", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getBody", &param1));
        if(!PyErr_Occurred())
        {
            OdeBody result = ((const OdeJoint*)local_this)->get_body((int)param1);
            OdeBody *return_value = new OdeBody(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeBody,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBody(const OdeJoint this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJoint_get_body_71_comment =
    "C++ Interface:\n"
    "getBody(const OdeJoint this, int index)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJoint_get_body_71_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeJoint::set_feedback(OdeJointFeedback *)
 * inline void OdeJoint::set_feedback(bool flag)
 * inline void OdeJoint::set_feedback(bool flag = (1))
 *******************************************************************/
static PyObject *Dtool_OdeJoint_set_feedback_72(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeJoint::set_feedback(bool flag = (1))
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":setFeedback", key_word_list));
            else
                (PyArg_Parse(args, ":setFeedback"));
            if(!PyErr_Occurred())
            {
                (local_this)->set_feedback();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeJoint.setFeedback() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline void OdeJoint::set_feedback(OdeJointFeedback *)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"param0", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFeedback", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setFeedback", &param1));
                if(!PyErr_Occurred())
                {
                    OdeJointFeedback *param1_this = (OdeJointFeedback *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeJointFeedback, 1, "OdeJoint.setFeedback", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_feedback(param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // -2 inline void OdeJoint::set_feedback(bool flag)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"flag", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFeedback", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setFeedback", &param1));
                if(!PyErr_Occurred())
                {
                    (local_this)->set_feedback((PyObject_IsTrue(param1)!=0));
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setFeedback() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setFeedback(non-const OdeJoint this)\n"
          "setFeedback(non-const OdeJoint this, non-const OdeJointFeedback)\n"
          "setFeedback(non-const OdeJoint this, bool flag)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJoint_set_feedback_72_comment =
    "C++ Interface:\n"
    "setFeedback(non-const OdeJoint this)\n"
    "setFeedback(non-const OdeJoint this, non-const OdeJointFeedback)\n"
    "setFeedback(non-const OdeJoint this, bool flag)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJoint_set_feedback_72_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline OdeJointFeedback *OdeJoint::get_feedback(void)
 *******************************************************************/
static PyObject *Dtool_OdeJoint_get_feedback_73(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline OdeJointFeedback *OdeJoint::get_feedback(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFeedback", key_word_list));
        else
            (PyArg_Parse(args, ":getFeedback"));
        if(!PyErr_Occurred())
        {
            OdeJointFeedback *return_value = (local_this)->get_feedback();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_OdeJointFeedback,false, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeJoint.getFeedback() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFeedback(non-const OdeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJoint_get_feedback_73_comment =
    "C++ Interface:\n"
    "getFeedback(non-const OdeJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJoint_get_feedback_73_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void OdeJoint::attach_bodies(OdeBody const &body1, OdeBody const &body2)
 *******************************************************************/
static PyObject *Dtool_OdeJoint_attach_bodies_74(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void OdeJoint::attach_bodies(OdeBody const &body1, OdeBody const &body2)
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"body1", (char *)"body2", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:attachBodies", key_word_list, &param1, &param2))
            {
                OdeBody *param1_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeBody, 1, "OdeJoint.attachBodies", 1, coerced_ptr, report_errors);
OdeBody *param2_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_OdeBody, 2, "OdeJoint.attachBodies", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    (local_this)->attach_bodies(*param1_this, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeJoint.attachBodies() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "attachBodies(non-const OdeJoint this, const OdeBody body1, const OdeBody body2)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJoint_attach_bodies_74_comment =
    "C++ Interface:\n"
    "attachBodies(non-const OdeJoint this, const OdeBody body1, const OdeBody body2)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJoint_attach_bodies_74_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void OdeJoint::attach_body(OdeBody const &body, int index)
 *******************************************************************/
static PyObject *Dtool_OdeJoint_attach_body_75(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void OdeJoint::attach_body(OdeBody const &body, int index)
            PyObject *param1;
            int param2;
            static char * key_word_list[] = {(char *)"body", (char *)"index", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:attachBody", key_word_list, &param1, &param2))
            {
                OdeBody *param1_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeBody, 1, "OdeJoint.attachBody", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->attach_body(*param1_this, (int)param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeJoint.attachBody() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "attachBody(non-const OdeJoint this, const OdeBody body, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJoint_attach_body_75_comment =
    "C++ Interface:\n"
    "attachBody(non-const OdeJoint this, const OdeBody body, int index)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJoint_attach_body_75_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void OdeJoint::detach(void)
 *******************************************************************/
static PyObject *Dtool_OdeJoint_detach_76(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void OdeJoint::detach(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":detach", key_word_list));
        else
            (PyArg_Parse(args, ":detach"));
        if(!PyErr_Occurred())
        {
            (local_this)->detach();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeJoint.detach() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "detach(non-const OdeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJoint_detach_76_comment =
    "C++ Interface:\n"
    "detach(non-const OdeJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJoint_detach_76_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void OdeJoint::write(ostream &out, unsigned int indent) const
 * virtual void OdeJoint::write(ostream &out, unsigned int indent = (0)) const
 * virtual void OdeJoint::write(ostream &out = (cout), unsigned int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_OdeJoint_write_77(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-virtual void OdeJoint::write(ostream &out = (cout), unsigned int indent = (0)) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":write", key_word_list));
            else
                (PyArg_Parse(args, ":write"));
            if(!PyErr_Occurred())
            {
                ((const OdeJoint*)local_this)->write();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void OdeJoint::write(ostream &out, unsigned int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "OdeJoint.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const OdeJoint*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void OdeJoint::write(ostream &out, unsigned int indent) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "OdeJoint.write", 0, coerced_ptr, report_errors);
 PyObject *param2_uint = PyNumber_Long(param2);
                    if (!((param1_this == NULL)|| (param2_uint == NULL)))
                    {
                        ((const OdeJoint*)local_this)->write(*param1_this, PyLong_AsUnsignedLong(param2_uint));
                         Py_XDECREF(param2_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 1, 2, or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const OdeJoint this)\n"
          "write(const OdeJoint this, non-const Ostream out)\n"
          "write(const OdeJoint this, non-const Ostream out, unsigned int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJoint_write_77_comment =
    "C++ Interface:\n"
    "write(const OdeJoint this)\n"
    "write(const OdeJoint this, non-const Ostream out)\n"
    "write(const OdeJoint this, non-const Ostream out, unsigned int indent)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJoint_write_77_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeJoint::compare_to(OdeJoint const &other) const
 *******************************************************************/
static PyObject *Dtool_OdeJoint_compare_to_78(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline int OdeJoint::compare_to(OdeJoint const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:compareTo", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:compareTo", &param1));
            if(!PyErr_Occurred())
            {
                OdeJoint *param1_this = (OdeJoint *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeJoint, 1, "OdeJoint.compareTo", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = ((const OdeJoint*)local_this)->compare_to(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "compareTo(const OdeJoint this, const OdeJoint other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJoint_compare_to_78_comment =
    "C++ Interface:\n"
    "compareTo(const OdeJoint this, const OdeJoint other)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJoint_compare_to_78_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool OdeJoint::operator ==(OdeJoint const &other) const
 *******************************************************************/
static PyObject *Dtool_OdeJoint_operator_79(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline bool OdeJoint::operator ==(OdeJoint const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:eq", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:eq", &param1));
            if(!PyErr_Occurred())
            {
                OdeJoint *param1_this = (OdeJoint *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeJoint, 1, "OdeJoint.eq", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const OdeJoint*)local_this)->operator ==(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "eq(const OdeJoint this, const OdeJoint other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJoint_operator_79_comment =
    "C++ Interface:\n"
    "eq(const OdeJoint this, const OdeJoint other)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJoint_operator_79_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeBallJoint OdeJoint::convert_to_ball(void) const
 *******************************************************************/
static PyObject *Dtool_OdeJoint_convert_to_ball_81(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-OdeBallJoint OdeJoint::convert_to_ball(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":convertToBall", key_word_list));
        else
            (PyArg_Parse(args, ":convertToBall"));
        if(!PyErr_Occurred())
        {
            OdeBallJoint result = ((const OdeJoint*)local_this)->convert_to_ball();
            OdeBallJoint *return_value = new OdeBallJoint(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeBallJoint,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "convertToBall(const OdeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJoint_convert_to_ball_81_comment =
    "C++ Interface:\n"
    "convertToBall(const OdeJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJoint_convert_to_ball_81_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeHingeJoint OdeJoint::convert_to_hinge(void) const
 *******************************************************************/
static PyObject *Dtool_OdeJoint_convert_to_hinge_82(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-OdeHingeJoint OdeJoint::convert_to_hinge(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":convertToHinge", key_word_list));
        else
            (PyArg_Parse(args, ":convertToHinge"));
        if(!PyErr_Occurred())
        {
            OdeHingeJoint result = ((const OdeJoint*)local_this)->convert_to_hinge();
            OdeHingeJoint *return_value = new OdeHingeJoint(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeHingeJoint,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "convertToHinge(const OdeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJoint_convert_to_hinge_82_comment =
    "C++ Interface:\n"
    "convertToHinge(const OdeJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJoint_convert_to_hinge_82_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeSliderJoint OdeJoint::convert_to_slider(void) const
 *******************************************************************/
static PyObject *Dtool_OdeJoint_convert_to_slider_83(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-OdeSliderJoint OdeJoint::convert_to_slider(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":convertToSlider", key_word_list));
        else
            (PyArg_Parse(args, ":convertToSlider"));
        if(!PyErr_Occurred())
        {
            OdeSliderJoint result = ((const OdeJoint*)local_this)->convert_to_slider();
            OdeSliderJoint *return_value = new OdeSliderJoint(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeSliderJoint,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "convertToSlider(const OdeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJoint_convert_to_slider_83_comment =
    "C++ Interface:\n"
    "convertToSlider(const OdeJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJoint_convert_to_slider_83_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeContactJoint OdeJoint::convert_to_contact(void) const
 *******************************************************************/
static PyObject *Dtool_OdeJoint_convert_to_contact_84(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-OdeContactJoint OdeJoint::convert_to_contact(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":convertToContact", key_word_list));
        else
            (PyArg_Parse(args, ":convertToContact"));
        if(!PyErr_Occurred())
        {
            OdeContactJoint result = ((const OdeJoint*)local_this)->convert_to_contact();
            OdeContactJoint *return_value = new OdeContactJoint(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeContactJoint,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "convertToContact(const OdeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJoint_convert_to_contact_84_comment =
    "C++ Interface:\n"
    "convertToContact(const OdeJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJoint_convert_to_contact_84_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeUniversalJoint OdeJoint::convert_to_universal(void) const
 *******************************************************************/
static PyObject *Dtool_OdeJoint_convert_to_universal_85(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-OdeUniversalJoint OdeJoint::convert_to_universal(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":convertToUniversal", key_word_list));
        else
            (PyArg_Parse(args, ":convertToUniversal"));
        if(!PyErr_Occurred())
        {
            OdeUniversalJoint result = ((const OdeJoint*)local_this)->convert_to_universal();
            OdeUniversalJoint *return_value = new OdeUniversalJoint(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeUniversalJoint,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "convertToUniversal(const OdeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJoint_convert_to_universal_85_comment =
    "C++ Interface:\n"
    "convertToUniversal(const OdeJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJoint_convert_to_universal_85_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeHinge2Joint OdeJoint::convert_to_hinge2(void) const
 *******************************************************************/
static PyObject *Dtool_OdeJoint_convert_to_hinge2_86(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-OdeHinge2Joint OdeJoint::convert_to_hinge2(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":convertToHinge2", key_word_list));
        else
            (PyArg_Parse(args, ":convertToHinge2"));
        if(!PyErr_Occurred())
        {
            OdeHinge2Joint result = ((const OdeJoint*)local_this)->convert_to_hinge2();
            OdeHinge2Joint *return_value = new OdeHinge2Joint(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeHinge2Joint,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "convertToHinge2(const OdeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJoint_convert_to_hinge2_86_comment =
    "C++ Interface:\n"
    "convertToHinge2(const OdeJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJoint_convert_to_hinge2_86_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeFixedJoint OdeJoint::convert_to_fixed(void) const
 *******************************************************************/
static PyObject *Dtool_OdeJoint_convert_to_fixed_87(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-OdeFixedJoint OdeJoint::convert_to_fixed(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":convertToFixed", key_word_list));
        else
            (PyArg_Parse(args, ":convertToFixed"));
        if(!PyErr_Occurred())
        {
            OdeFixedJoint result = ((const OdeJoint*)local_this)->convert_to_fixed();
            OdeFixedJoint *return_value = new OdeFixedJoint(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeFixedJoint,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "convertToFixed(const OdeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJoint_convert_to_fixed_87_comment =
    "C++ Interface:\n"
    "convertToFixed(const OdeJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJoint_convert_to_fixed_87_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeNullJoint OdeJoint::convert_to_null(void) const
 *******************************************************************/
static PyObject *Dtool_OdeJoint_convert_to_null_88(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-OdeNullJoint OdeJoint::convert_to_null(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":convertToNull", key_word_list));
        else
            (PyArg_Parse(args, ":convertToNull"));
        if(!PyErr_Occurred())
        {
            OdeNullJoint result = ((const OdeJoint*)local_this)->convert_to_null();
            OdeNullJoint *return_value = new OdeNullJoint(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeNullJoint,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "convertToNull(const OdeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJoint_convert_to_null_88_comment =
    "C++ Interface:\n"
    "convertToNull(const OdeJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJoint_convert_to_null_88_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeAMotorJoint OdeJoint::convert_to_a_motor(void) const
 *******************************************************************/
static PyObject *Dtool_OdeJoint_convert_to_a_motor_89(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-OdeAMotorJoint OdeJoint::convert_to_a_motor(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":convertToAMotor", key_word_list));
        else
            (PyArg_Parse(args, ":convertToAMotor"));
        if(!PyErr_Occurred())
        {
            OdeAMotorJoint result = ((const OdeJoint*)local_this)->convert_to_a_motor();
            OdeAMotorJoint *return_value = new OdeAMotorJoint(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeAMotorJoint,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "convertToAMotor(const OdeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJoint_convert_to_a_motor_89_comment =
    "C++ Interface:\n"
    "convertToAMotor(const OdeJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJoint_convert_to_a_motor_89_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeLMotorJoint OdeJoint::convert_to_l_motor(void) const
 *******************************************************************/
static PyObject *Dtool_OdeJoint_convert_to_l_motor_90(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-OdeLMotorJoint OdeJoint::convert_to_l_motor(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":convertToLMotor", key_word_list));
        else
            (PyArg_Parse(args, ":convertToLMotor"));
        if(!PyErr_Occurred())
        {
            OdeLMotorJoint result = ((const OdeJoint*)local_this)->convert_to_l_motor();
            OdeLMotorJoint *return_value = new OdeLMotorJoint(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeLMotorJoint,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "convertToLMotor(const OdeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJoint_convert_to_l_motor_90_comment =
    "C++ Interface:\n"
    "convertToLMotor(const OdeJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJoint_convert_to_l_motor_90_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdePlane2dJoint OdeJoint::convert_to_plane2d(void) const
 *******************************************************************/
static PyObject *Dtool_OdeJoint_convert_to_plane2d_91(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-OdePlane2dJoint OdeJoint::convert_to_plane2d(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":convertToPlane2d", key_word_list));
        else
            (PyArg_Parse(args, ":convertToPlane2d"));
        if(!PyErr_Occurred())
        {
            OdePlane2dJoint result = ((const OdeJoint*)local_this)->convert_to_plane2d();
            OdePlane2dJoint *return_value = new OdePlane2dJoint(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdePlane2dJoint,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "convertToPlane2d(const OdeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJoint_convert_to_plane2d_91_comment =
    "C++ Interface:\n"
    "convertToPlane2d(const OdeJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJoint_convert_to_plane2d_91_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeJoint::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeJoint_get_class_type_92(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeJoint::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeJoint::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJoint_get_class_type_92_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJoint_get_class_type_92_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool OdeJoint::operator typecast bool(void) const
 *******************************************************************/
static PyObject *Dtool_OdeJoint_operator_typecast_bool_80(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool OdeJoint::operator typecast bool(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":__nonzero__", key_word_list));
        else
            (PyArg_Parse(args, ":__nonzero__"));
        if(!PyErr_Occurred())
        {
            bool return_value = (bool)(*(const OdeJoint*)local_this);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__nonzero__(const OdeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJoint_operator_typecast_bool_80_comment =
    "C++ Interface:\n"
    "__nonzero__(const OdeJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJoint_operator_typecast_bool_80_comment = NULL;
#endif

int  Dtool_Init_OdeJoint(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (OdeJoint)");
       return -1;
}
inline void  * Dtool_UpcastInterface_OdeJoint(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeJoint)
    {
        printf("OdeJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeJoint * local_this = (OdeJoint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeJoint)
        return local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeJoint(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeJoint)
        return from_this;
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeJoint*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeAMotorJoint 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void OdeAMotorJoint::set_num_axes(int num)
 *******************************************************************/
static PyObject *Dtool_OdeAMotorJoint_set_num_axes_95(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeAMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeAMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeAMotorJoint::set_num_axes(int num)
        int param1;
        static char * key_word_list[] = {(char *)"num", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setNumAxes", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setNumAxes", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_num_axes((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeAMotorJoint.setNumAxes() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setNumAxes(non-const OdeAMotorJoint this, int num)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeAMotorJoint_set_num_axes_95_comment =
    "C++ Interface:\n"
    "setNumAxes(non-const OdeAMotorJoint this, int num)\n"
    "\n"
    "// Filename: odeAMotorJoint.I\n"
    "// Created by:  joswilso (27Dec06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeAMotorJoint_set_num_axes_95_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeAMotorJoint::set_axis(int anum, int rel, LVecBase3f const &axis)
 * inline void OdeAMotorJoint::set_axis(int anum, int rel, float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_OdeAMotorJoint_set_axis_96(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeAMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeAMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeAMotorJoint::set_axis(int anum, int rel, LVecBase3f const &axis)
                int param1;
                int param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"anum", (char *)"rel", (char *)"axis", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iiO:setAxis", key_word_list, &param1, &param2, &param3))
                {
                    LVecBase3f *param3_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase3f, 3, "OdeAMotorJoint.setAxis", 1, coerced_ptr, report_errors);

                    if (!((param3_this == NULL)))
                    {
                        (local_this)->set_axis((int)param1, (int)param2, *param3_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeAMotorJoint.setAxis() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(5):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeAMotorJoint::set_axis(int anum, int rel, float x, float y, float z)
            int param1;
            int param2;
            double param3;
            double param4;
            double param5;
            static char * key_word_list[] = {(char *)"anum", (char *)"rel", (char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iiddd:setAxis", key_word_list, &param1, &param2, &param3, &param4, &param5))
            {
                (local_this)->set_axis((int)param1, (int)param2, (float)param3, (float)param4, (float)param5);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeAMotorJoint.setAxis() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setAxis() takes 4 or 6 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setAxis(non-const OdeAMotorJoint this, int anum, int rel, const VBase3 axis)\n"
          "setAxis(non-const OdeAMotorJoint this, int anum, int rel, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeAMotorJoint_set_axis_96_comment =
    "C++ Interface:\n"
    "setAxis(non-const OdeAMotorJoint this, int anum, int rel, const VBase3 axis)\n"
    "setAxis(non-const OdeAMotorJoint this, int anum, int rel, float x, float y, float z)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeAMotorJoint_set_axis_96_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeAMotorJoint::set_angle(int anum, float angle)
 *******************************************************************/
static PyObject *Dtool_OdeAMotorJoint_set_angle_97(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeAMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeAMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeAMotorJoint::set_angle(int anum, float angle)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"anum", (char *)"angle", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setAngle", key_word_list, &param1, &param2))
        {
            (local_this)->set_angle((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeAMotorJoint.setAngle() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAngle(non-const OdeAMotorJoint this, int anum, float angle)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeAMotorJoint_set_angle_97_comment =
    "C++ Interface:\n"
    "setAngle(non-const OdeAMotorJoint this, int anum, float angle)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeAMotorJoint_set_angle_97_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeAMotorJoint::set_mode(int mode)
 *******************************************************************/
static PyObject *Dtool_OdeAMotorJoint_set_mode_98(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeAMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeAMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeAMotorJoint::set_mode(int mode)
        int param1;
        static char * key_word_list[] = {(char *)"mode", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setMode", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setMode", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_mode((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeAMotorJoint.setMode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMode(non-const OdeAMotorJoint this, int mode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeAMotorJoint_set_mode_98_comment =
    "C++ Interface:\n"
    "setMode(non-const OdeAMotorJoint this, int mode)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeAMotorJoint_set_mode_98_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeAMotorJoint::add_torques(float torque1, float torque2, float torque3)
 *******************************************************************/
static PyObject *Dtool_OdeAMotorJoint_add_torques_99(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeAMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeAMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeAMotorJoint::add_torques(float torque1, float torque2, float torque3)
        double param1;
        double param2;
        double param3;
        static char * key_word_list[] = {(char *)"torque1", (char *)"torque2", (char *)"torque3", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:addTorques", key_word_list, &param1, &param2, &param3))
        {
            (local_this)->add_torques((float)param1, (float)param2, (float)param3);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeAMotorJoint.addTorques() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addTorques(non-const OdeAMotorJoint this, float torque1, float torque2, float torque3)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeAMotorJoint_add_torques_99_comment =
    "C++ Interface:\n"
    "addTorques(non-const OdeAMotorJoint this, float torque1, float torque2, float torque3)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeAMotorJoint_add_torques_99_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeAMotorJoint::get_num_axes(void) const
 *******************************************************************/
static PyObject *Dtool_OdeAMotorJoint_get_num_axes_100(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeAMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeAMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int OdeAMotorJoint::get_num_axes(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumAxes", key_word_list));
        else
            (PyArg_Parse(args, ":getNumAxes"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const OdeAMotorJoint*)local_this)->get_num_axes();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumAxes(const OdeAMotorJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeAMotorJoint_get_num_axes_100_comment =
    "C++ Interface:\n"
    "getNumAxes(const OdeAMotorJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeAMotorJoint_get_num_axes_100_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f OdeAMotorJoint::get_axis(int anum) const
 *******************************************************************/
static PyObject *Dtool_OdeAMotorJoint_get_axis_101(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeAMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeAMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f OdeAMotorJoint::get_axis(int anum) const
        int param1;
        static char * key_word_list[] = {(char *)"anum", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getAxis", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getAxis", &param1));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const OdeAMotorJoint*)local_this)->get_axis((int)param1);
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAxis(const OdeAMotorJoint this, int anum)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeAMotorJoint_get_axis_101_comment =
    "C++ Interface:\n"
    "getAxis(const OdeAMotorJoint this, int anum)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeAMotorJoint_get_axis_101_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeAMotorJoint::get_axis_rel(int anum) const
 *******************************************************************/
static PyObject *Dtool_OdeAMotorJoint_get_axis_rel_102(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeAMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeAMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int OdeAMotorJoint::get_axis_rel(int anum) const
        int param1;
        static char * key_word_list[] = {(char *)"anum", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getAxisRel", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getAxisRel", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const OdeAMotorJoint*)local_this)->get_axis_rel((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAxisRel(const OdeAMotorJoint this, int anum)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeAMotorJoint_get_axis_rel_102_comment =
    "C++ Interface:\n"
    "getAxisRel(const OdeAMotorJoint this, int anum)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeAMotorJoint_get_axis_rel_102_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeAMotorJoint::get_angle(int anum) const
 *******************************************************************/
static PyObject *Dtool_OdeAMotorJoint_get_angle_103(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeAMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeAMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeAMotorJoint::get_angle(int anum) const
        int param1;
        static char * key_word_list[] = {(char *)"anum", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getAngle", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getAngle", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeAMotorJoint*)local_this)->get_angle((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAngle(const OdeAMotorJoint this, int anum)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeAMotorJoint_get_angle_103_comment =
    "C++ Interface:\n"
    "getAngle(const OdeAMotorJoint this, int anum)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeAMotorJoint_get_angle_103_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeAMotorJoint::get_angle_rate(int anum) const
 *******************************************************************/
static PyObject *Dtool_OdeAMotorJoint_get_angle_rate_104(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeAMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeAMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeAMotorJoint::get_angle_rate(int anum) const
        int param1;
        static char * key_word_list[] = {(char *)"anum", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getAngleRate", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getAngleRate", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeAMotorJoint*)local_this)->get_angle_rate((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAngleRate(const OdeAMotorJoint this, int anum)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeAMotorJoint_get_angle_rate_104_comment =
    "C++ Interface:\n"
    "getAngleRate(const OdeAMotorJoint this, int anum)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeAMotorJoint_get_angle_rate_104_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeAMotorJoint::get_mode(void) const
 *******************************************************************/
static PyObject *Dtool_OdeAMotorJoint_get_mode_105(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeAMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeAMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int OdeAMotorJoint::get_mode(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMode", key_word_list));
        else
            (PyArg_Parse(args, ":getMode"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const OdeAMotorJoint*)local_this)->get_mode();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMode(const OdeAMotorJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeAMotorJoint_get_mode_105_comment =
    "C++ Interface:\n"
    "getMode(const OdeAMotorJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeAMotorJoint_get_mode_105_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeAMotorJoint::set_param_lo_stop(int axis, float val)
 *******************************************************************/
static PyObject *Dtool_OdeAMotorJoint_set_param_lo_stop_106(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeAMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeAMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeAMotorJoint::set_param_lo_stop(int axis, float val)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"axis", (char *)"val", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setParamLoStop", key_word_list, &param1, &param2))
        {
            (local_this)->set_param_lo_stop((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeAMotorJoint.setParamLoStop() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamLoStop(non-const OdeAMotorJoint this, int axis, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeAMotorJoint_set_param_lo_stop_106_comment =
    "C++ Interface:\n"
    "setParamLoStop(non-const OdeAMotorJoint this, int axis, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeAMotorJoint_set_param_lo_stop_106_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeAMotorJoint::set_param_hi_stop(int axis, float val)
 *******************************************************************/
static PyObject *Dtool_OdeAMotorJoint_set_param_hi_stop_107(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeAMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeAMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeAMotorJoint::set_param_hi_stop(int axis, float val)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"axis", (char *)"val", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setParamHiStop", key_word_list, &param1, &param2))
        {
            (local_this)->set_param_hi_stop((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeAMotorJoint.setParamHiStop() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamHiStop(non-const OdeAMotorJoint this, int axis, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeAMotorJoint_set_param_hi_stop_107_comment =
    "C++ Interface:\n"
    "setParamHiStop(non-const OdeAMotorJoint this, int axis, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeAMotorJoint_set_param_hi_stop_107_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeAMotorJoint::set_param_vel(int axis, float val)
 *******************************************************************/
static PyObject *Dtool_OdeAMotorJoint_set_param_vel_108(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeAMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeAMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeAMotorJoint::set_param_vel(int axis, float val)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"axis", (char *)"val", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setParamVel", key_word_list, &param1, &param2))
        {
            (local_this)->set_param_vel((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeAMotorJoint.setParamVel() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamVel(non-const OdeAMotorJoint this, int axis, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeAMotorJoint_set_param_vel_108_comment =
    "C++ Interface:\n"
    "setParamVel(non-const OdeAMotorJoint this, int axis, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeAMotorJoint_set_param_vel_108_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeAMotorJoint::set_param_f_max(int axis, float val)
 *******************************************************************/
static PyObject *Dtool_OdeAMotorJoint_set_param_f_max_109(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeAMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeAMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeAMotorJoint::set_param_f_max(int axis, float val)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"axis", (char *)"val", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setParamFMax", key_word_list, &param1, &param2))
        {
            (local_this)->set_param_f_max((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeAMotorJoint.setParamFMax() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamFMax(non-const OdeAMotorJoint this, int axis, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeAMotorJoint_set_param_f_max_109_comment =
    "C++ Interface:\n"
    "setParamFMax(non-const OdeAMotorJoint this, int axis, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeAMotorJoint_set_param_f_max_109_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeAMotorJoint::set_param_fudge_factor(int axis, float val)
 *******************************************************************/
static PyObject *Dtool_OdeAMotorJoint_set_param_fudge_factor_110(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeAMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeAMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeAMotorJoint::set_param_fudge_factor(int axis, float val)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"axis", (char *)"val", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setParamFudgeFactor", key_word_list, &param1, &param2))
        {
            (local_this)->set_param_fudge_factor((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeAMotorJoint.setParamFudgeFactor() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamFudgeFactor(non-const OdeAMotorJoint this, int axis, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeAMotorJoint_set_param_fudge_factor_110_comment =
    "C++ Interface:\n"
    "setParamFudgeFactor(non-const OdeAMotorJoint this, int axis, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeAMotorJoint_set_param_fudge_factor_110_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeAMotorJoint::set_param_bounce(int axis, float val)
 *******************************************************************/
static PyObject *Dtool_OdeAMotorJoint_set_param_bounce_111(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeAMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeAMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeAMotorJoint::set_param_bounce(int axis, float val)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"axis", (char *)"val", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setParamBounce", key_word_list, &param1, &param2))
        {
            (local_this)->set_param_bounce((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeAMotorJoint.setParamBounce() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamBounce(non-const OdeAMotorJoint this, int axis, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeAMotorJoint_set_param_bounce_111_comment =
    "C++ Interface:\n"
    "setParamBounce(non-const OdeAMotorJoint this, int axis, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeAMotorJoint_set_param_bounce_111_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeAMotorJoint::set_param_CFM(int axis, float val)
 *******************************************************************/
static PyObject *Dtool_OdeAMotorJoint_set_param_CFM_112(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeAMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeAMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeAMotorJoint::set_param_CFM(int axis, float val)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"axis", (char *)"val", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setParamCFM", key_word_list, &param1, &param2))
        {
            (local_this)->set_param_CFM((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeAMotorJoint.setParamCFM() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamCFM(non-const OdeAMotorJoint this, int axis, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeAMotorJoint_set_param_CFM_112_comment =
    "C++ Interface:\n"
    "setParamCFM(non-const OdeAMotorJoint this, int axis, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeAMotorJoint_set_param_CFM_112_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeAMotorJoint::set_param_stop_ERP(int axis, float val)
 *******************************************************************/
static PyObject *Dtool_OdeAMotorJoint_set_param_stop_ERP_113(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeAMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeAMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeAMotorJoint::set_param_stop_ERP(int axis, float val)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"axis", (char *)"val", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setParamStopERP", key_word_list, &param1, &param2))
        {
            (local_this)->set_param_stop_ERP((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeAMotorJoint.setParamStopERP() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamStopERP(non-const OdeAMotorJoint this, int axis, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeAMotorJoint_set_param_stop_ERP_113_comment =
    "C++ Interface:\n"
    "setParamStopERP(non-const OdeAMotorJoint this, int axis, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeAMotorJoint_set_param_stop_ERP_113_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeAMotorJoint::set_param_stop_CFM(int axis, float val)
 *******************************************************************/
static PyObject *Dtool_OdeAMotorJoint_set_param_stop_CFM_114(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeAMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeAMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeAMotorJoint::set_param_stop_CFM(int axis, float val)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"axis", (char *)"val", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setParamStopCFM", key_word_list, &param1, &param2))
        {
            (local_this)->set_param_stop_CFM((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeAMotorJoint.setParamStopCFM() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamStopCFM(non-const OdeAMotorJoint this, int axis, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeAMotorJoint_set_param_stop_CFM_114_comment =
    "C++ Interface:\n"
    "setParamStopCFM(non-const OdeAMotorJoint this, int axis, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeAMotorJoint_set_param_stop_CFM_114_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeAMotorJoint::get_param_lo_stop(int axis) const
 *******************************************************************/
static PyObject *Dtool_OdeAMotorJoint_get_param_lo_stop_115(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeAMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeAMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeAMotorJoint::get_param_lo_stop(int axis) const
        int param1;
        static char * key_word_list[] = {(char *)"axis", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParamLoStop", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParamLoStop", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeAMotorJoint*)local_this)->get_param_lo_stop((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamLoStop(const OdeAMotorJoint this, int axis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeAMotorJoint_get_param_lo_stop_115_comment =
    "C++ Interface:\n"
    "getParamLoStop(const OdeAMotorJoint this, int axis)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeAMotorJoint_get_param_lo_stop_115_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeAMotorJoint::get_param_hi_stop(int axis) const
 *******************************************************************/
static PyObject *Dtool_OdeAMotorJoint_get_param_hi_stop_116(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeAMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeAMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeAMotorJoint::get_param_hi_stop(int axis) const
        int param1;
        static char * key_word_list[] = {(char *)"axis", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParamHiStop", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParamHiStop", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeAMotorJoint*)local_this)->get_param_hi_stop((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamHiStop(const OdeAMotorJoint this, int axis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeAMotorJoint_get_param_hi_stop_116_comment =
    "C++ Interface:\n"
    "getParamHiStop(const OdeAMotorJoint this, int axis)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeAMotorJoint_get_param_hi_stop_116_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeAMotorJoint::get_param_vel(int axis) const
 *******************************************************************/
static PyObject *Dtool_OdeAMotorJoint_get_param_vel_117(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeAMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeAMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeAMotorJoint::get_param_vel(int axis) const
        int param1;
        static char * key_word_list[] = {(char *)"axis", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParamVel", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParamVel", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeAMotorJoint*)local_this)->get_param_vel((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamVel(const OdeAMotorJoint this, int axis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeAMotorJoint_get_param_vel_117_comment =
    "C++ Interface:\n"
    "getParamVel(const OdeAMotorJoint this, int axis)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeAMotorJoint_get_param_vel_117_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeAMotorJoint::get_param_f_max(int axis) const
 *******************************************************************/
static PyObject *Dtool_OdeAMotorJoint_get_param_f_max_118(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeAMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeAMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeAMotorJoint::get_param_f_max(int axis) const
        int param1;
        static char * key_word_list[] = {(char *)"axis", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParamFMax", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParamFMax", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeAMotorJoint*)local_this)->get_param_f_max((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamFMax(const OdeAMotorJoint this, int axis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeAMotorJoint_get_param_f_max_118_comment =
    "C++ Interface:\n"
    "getParamFMax(const OdeAMotorJoint this, int axis)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeAMotorJoint_get_param_f_max_118_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeAMotorJoint::get_param_fudge_factor(int axis) const
 *******************************************************************/
static PyObject *Dtool_OdeAMotorJoint_get_param_fudge_factor_119(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeAMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeAMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeAMotorJoint::get_param_fudge_factor(int axis) const
        int param1;
        static char * key_word_list[] = {(char *)"axis", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParamFudgeFactor", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParamFudgeFactor", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeAMotorJoint*)local_this)->get_param_fudge_factor((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamFudgeFactor(const OdeAMotorJoint this, int axis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeAMotorJoint_get_param_fudge_factor_119_comment =
    "C++ Interface:\n"
    "getParamFudgeFactor(const OdeAMotorJoint this, int axis)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeAMotorJoint_get_param_fudge_factor_119_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeAMotorJoint::get_param_bounce(int axis) const
 *******************************************************************/
static PyObject *Dtool_OdeAMotorJoint_get_param_bounce_120(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeAMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeAMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeAMotorJoint::get_param_bounce(int axis) const
        int param1;
        static char * key_word_list[] = {(char *)"axis", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParamBounce", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParamBounce", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeAMotorJoint*)local_this)->get_param_bounce((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamBounce(const OdeAMotorJoint this, int axis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeAMotorJoint_get_param_bounce_120_comment =
    "C++ Interface:\n"
    "getParamBounce(const OdeAMotorJoint this, int axis)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeAMotorJoint_get_param_bounce_120_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeAMotorJoint::get_param_CFM(int axis) const
 *******************************************************************/
static PyObject *Dtool_OdeAMotorJoint_get_param_CFM_121(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeAMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeAMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeAMotorJoint::get_param_CFM(int axis) const
        int param1;
        static char * key_word_list[] = {(char *)"axis", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParamCFM", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParamCFM", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeAMotorJoint*)local_this)->get_param_CFM((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamCFM(const OdeAMotorJoint this, int axis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeAMotorJoint_get_param_CFM_121_comment =
    "C++ Interface:\n"
    "getParamCFM(const OdeAMotorJoint this, int axis)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeAMotorJoint_get_param_CFM_121_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeAMotorJoint::get_param_stop_ERP(int axis) const
 *******************************************************************/
static PyObject *Dtool_OdeAMotorJoint_get_param_stop_ERP_122(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeAMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeAMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeAMotorJoint::get_param_stop_ERP(int axis) const
        int param1;
        static char * key_word_list[] = {(char *)"axis", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParamStopERP", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParamStopERP", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeAMotorJoint*)local_this)->get_param_stop_ERP((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamStopERP(const OdeAMotorJoint this, int axis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeAMotorJoint_get_param_stop_ERP_122_comment =
    "C++ Interface:\n"
    "getParamStopERP(const OdeAMotorJoint this, int axis)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeAMotorJoint_get_param_stop_ERP_122_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeAMotorJoint::get_param_stop_CFM(int axis) const
 *******************************************************************/
static PyObject *Dtool_OdeAMotorJoint_get_param_stop_CFM_123(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeAMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeAMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeAMotorJoint::get_param_stop_CFM(int axis) const
        int param1;
        static char * key_word_list[] = {(char *)"axis", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParamStopCFM", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParamStopCFM", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeAMotorJoint*)local_this)->get_param_stop_CFM((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamStopCFM(const OdeAMotorJoint this, int axis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeAMotorJoint_get_param_stop_CFM_123_comment =
    "C++ Interface:\n"
    "getParamStopCFM(const OdeAMotorJoint this, int axis)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeAMotorJoint_get_param_stop_CFM_123_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeAMotorJoint::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeAMotorJoint_get_class_type_124(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeAMotorJoint::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeAMotorJoint::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeAMotorJoint_get_class_type_124_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeAMotorJoint_get_class_type_124_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeAMotorJoint::OdeAMotorJoint(OdeWorld &world)
 * OdeAMotorJoint::OdeAMotorJoint(OdeWorld &world, OdeJointGroup &joint_group)
 *******************************************************************/
int  Dtool_Init_OdeAMotorJoint(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeAMotorJoint::OdeAMotorJoint(OdeWorld &world)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"world", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:OdeAMotorJoint", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:OdeAMotorJoint", &param0));
                if(!PyErr_Occurred())
                {
                    OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeWorld, 0, "OdeAMotorJoint.OdeAMotorJoint", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        OdeAMotorJoint *return_value = new OdeAMotorJoint(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeAMotorJoint,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeAMotorJoint::OdeAMotorJoint(OdeWorld &world, OdeJointGroup &joint_group)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"world", (char *)"joint_group", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:OdeAMotorJoint", key_word_list, &param0, &param1))
                {
                    OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeWorld, 0, "OdeAMotorJoint.OdeAMotorJoint", 0, coerced_ptr, report_errors);
OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeJointGroup, 1, "OdeAMotorJoint.OdeAMotorJoint", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        OdeAMotorJoint *return_value = new OdeAMotorJoint(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeAMotorJoint,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OdeAMotorJoint() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OdeAMotorJoint(non-const OdeWorld world)\n"
          "OdeAMotorJoint(non-const OdeWorld world, non-const OdeJointGroup joint_group)\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_OdeAMotorJoint_get_axes(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumAxes", "getAxis");
}
inline void  * Dtool_UpcastInterface_OdeAMotorJoint(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeAMotorJoint)
    {
        printf("OdeAMotorJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeAMotorJoint * local_this = (OdeAMotorJoint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeAMotorJoint)
        return local_this;
    if(requested_type == &Dtool_OdeJoint)
        return ( OdeJoint *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( OdeJoint *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeAMotorJoint(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeAMotorJoint)
        return from_this;
    if(from_type == &Dtool_OdeJoint)
    {
          OdeJoint* other_this = (OdeJoint*)from_this;
          return (OdeAMotorJoint*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeAMotorJoint*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeBallJoint 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void OdeBallJoint::set_anchor(LVecBase3f const &anchor)
 * inline void OdeBallJoint::set_anchor(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_OdeBallJoint_set_anchor_127(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBallJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBallJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeBallJoint::set_anchor(LVecBase3f const &anchor)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"anchor", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAnchor", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setAnchor", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeBallJoint.setAnchor", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_anchor(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeBallJoint.setAnchor() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeBallJoint::set_anchor(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setAnchor", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_anchor((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeBallJoint.setAnchor() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setAnchor() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setAnchor(non-const OdeBallJoint this, const VBase3 anchor)\n"
          "setAnchor(non-const OdeBallJoint this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBallJoint_set_anchor_127_comment =
    "C++ Interface:\n"
    "setAnchor(non-const OdeBallJoint this, const VBase3 anchor)\n"
    "setAnchor(non-const OdeBallJoint this, float x, float y, float z)\n"
    "\n"
    "// Filename: odeBallJoint.I\n"
    "// Created by:  joswilso (27Dec06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeBallJoint_set_anchor_127_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeBallJoint::set_anchor2(LVecBase3f const &anchor)
 * inline void OdeBallJoint::set_anchor2(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_OdeBallJoint_set_anchor2_128(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBallJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBallJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeBallJoint::set_anchor2(LVecBase3f const &anchor)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"anchor", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAnchor2", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setAnchor2", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeBallJoint.setAnchor2", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_anchor2(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeBallJoint.setAnchor2() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeBallJoint::set_anchor2(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setAnchor2", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_anchor2((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeBallJoint.setAnchor2() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setAnchor2() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setAnchor2(non-const OdeBallJoint this, const VBase3 anchor)\n"
          "setAnchor2(non-const OdeBallJoint this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBallJoint_set_anchor2_128_comment =
    "C++ Interface:\n"
    "setAnchor2(non-const OdeBallJoint this, const VBase3 anchor)\n"
    "setAnchor2(non-const OdeBallJoint this, float x, float y, float z)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBallJoint_set_anchor2_128_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f OdeBallJoint::get_anchor(void) const
 *******************************************************************/
static PyObject *Dtool_OdeBallJoint_get_anchor_129(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBallJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBallJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f OdeBallJoint::get_anchor(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAnchor", key_word_list));
        else
            (PyArg_Parse(args, ":getAnchor"));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const OdeBallJoint*)local_this)->get_anchor();
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAnchor(const OdeBallJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBallJoint_get_anchor_129_comment =
    "C++ Interface:\n"
    "getAnchor(const OdeBallJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBallJoint_get_anchor_129_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f OdeBallJoint::get_anchor2(void) const
 *******************************************************************/
static PyObject *Dtool_OdeBallJoint_get_anchor2_130(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBallJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBallJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f OdeBallJoint::get_anchor2(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAnchor2", key_word_list));
        else
            (PyArg_Parse(args, ":getAnchor2"));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const OdeBallJoint*)local_this)->get_anchor2();
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAnchor2(const OdeBallJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBallJoint_get_anchor2_130_comment =
    "C++ Interface:\n"
    "getAnchor2(const OdeBallJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBallJoint_get_anchor2_130_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeBallJoint::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeBallJoint_get_class_type_131(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeBallJoint::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeBallJoint::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBallJoint_get_class_type_131_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBallJoint_get_class_type_131_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeBallJoint::OdeBallJoint(OdeWorld &world)
 * OdeBallJoint::OdeBallJoint(OdeWorld &world, OdeJointGroup &joint_group)
 *******************************************************************/
int  Dtool_Init_OdeBallJoint(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeBallJoint::OdeBallJoint(OdeWorld &world)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"world", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:OdeBallJoint", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:OdeBallJoint", &param0));
                if(!PyErr_Occurred())
                {
                    OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeWorld, 0, "OdeBallJoint.OdeBallJoint", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        OdeBallJoint *return_value = new OdeBallJoint(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeBallJoint,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeBallJoint::OdeBallJoint(OdeWorld &world, OdeJointGroup &joint_group)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"world", (char *)"joint_group", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:OdeBallJoint", key_word_list, &param0, &param1))
                {
                    OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeWorld, 0, "OdeBallJoint.OdeBallJoint", 0, coerced_ptr, report_errors);
OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeJointGroup, 1, "OdeBallJoint.OdeBallJoint", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        OdeBallJoint *return_value = new OdeBallJoint(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeBallJoint,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OdeBallJoint() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OdeBallJoint(non-const OdeWorld world)\n"
          "OdeBallJoint(non-const OdeWorld world, non-const OdeJointGroup joint_group)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OdeBallJoint(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeBallJoint)
    {
        printf("OdeBallJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeBallJoint * local_this = (OdeBallJoint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeBallJoint)
        return local_this;
    if(requested_type == &Dtool_OdeJoint)
        return ( OdeJoint *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( OdeJoint *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeBallJoint(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeBallJoint)
        return from_this;
    if(from_type == &Dtool_OdeJoint)
    {
          OdeJoint* other_this = (OdeJoint*)from_this;
          return (OdeBallJoint*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeBallJoint*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeMass 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline int OdeMass::check(void)
 *******************************************************************/
static PyObject *Dtool_OdeMass_check_135(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeMass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeMass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int OdeMass::check(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":check", key_word_list));
        else
            (PyArg_Parse(args, ":check"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->check();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeMass.check() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "check(non-const OdeMass this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeMass_check_135_comment =
    "C++ Interface:\n"
    "check(non-const OdeMass this)\n"
    "\n"
    "// Filename: odeMass.I\n"
    "// Created by:  joswilso (27Dec06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeMass_check_135_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeMass::set_zero(void)
 *******************************************************************/
static PyObject *Dtool_OdeMass_set_zero_136(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeMass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeMass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeMass::set_zero(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":setZero", key_word_list));
        else
            (PyArg_Parse(args, ":setZero"));
        if(!PyErr_Occurred())
        {
            (local_this)->set_zero();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeMass.setZero() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setZero(non-const OdeMass this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeMass_set_zero_136_comment =
    "C++ Interface:\n"
    "setZero(non-const OdeMass this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeMass_set_zero_136_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeMass::set_parameters(float themass, LVecBase3f const &center, LMatrix3f const &r)
 * inline void OdeMass::set_parameters(float themass, float cgx, float cgy, float cgz, float I11, float I22, float I33, float I12, float I13, float I23)
 *******************************************************************/
static PyObject *Dtool_OdeMass_set_parameters_137(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeMass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeMass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeMass::set_parameters(float themass, LVecBase3f const &center, LMatrix3f const &r)
                double param1;
                PyObject *param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"themass", (char *)"center", (char *)"r", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "dOO:setParameters", key_word_list, &param1, &param2, &param3))
                {
                    LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "OdeMass.setParameters", 1, coerced_ptr, report_errors);
LMatrix3f *param3_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LMatrix3f, 3, "OdeMass.setParameters", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)|| (param3_this == NULL)))
                    {
                        (local_this)->set_parameters((float)param1, *param2_this, *param3_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeMass.setParameters() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(10):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeMass::set_parameters(float themass, float cgx, float cgy, float cgz, float I11, float I22, float I33, float I12, float I13, float I23)
            double param1;
            double param2;
            double param3;
            double param4;
            double param5;
            double param6;
            double param7;
            double param8;
            double param9;
            double param10;
            static char * key_word_list[] = {(char *)"themass", (char *)"cgx", (char *)"cgy", (char *)"cgz", (char *)"I11", (char *)"I22", (char *)"I33", (char *)"I12", (char *)"I13", (char *)"I23", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddddddddd:setParameters", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10))
            {
                (local_this)->set_parameters((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6, (float)param7, (float)param8, (float)param9, (float)param10);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeMass.setParameters() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setParameters() takes 4 or 11 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setParameters(non-const OdeMass this, float themass, const VBase3 center, const Mat3 r)\n"
          "setParameters(non-const OdeMass this, float themass, float cgx, float cgy, float cgz, float I11, float I22, float I33, float I12, float I13, float I23)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeMass_set_parameters_137_comment =
    "C++ Interface:\n"
    "setParameters(non-const OdeMass this, float themass, const VBase3 center, const Mat3 r)\n"
    "setParameters(non-const OdeMass this, float themass, float cgx, float cgy, float cgz, float I11, float I22, float I33, float I12, float I13, float I23)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeMass_set_parameters_137_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeMass::set_sphere(float density, float radius)
 *******************************************************************/
static PyObject *Dtool_OdeMass_set_sphere_138(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeMass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeMass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeMass::set_sphere(float density, float radius)
        double param1;
        double param2;
        static char * key_word_list[] = {(char *)"density", (char *)"radius", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:setSphere", key_word_list, &param1, &param2))
        {
            (local_this)->set_sphere((float)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeMass.setSphere() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSphere(non-const OdeMass this, float density, float radius)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeMass_set_sphere_138_comment =
    "C++ Interface:\n"
    "setSphere(non-const OdeMass this, float density, float radius)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeMass_set_sphere_138_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeMass::set_sphere_total(float total_mass, float radius)
 *******************************************************************/
static PyObject *Dtool_OdeMass_set_sphere_total_139(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeMass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeMass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeMass::set_sphere_total(float total_mass, float radius)
        double param1;
        double param2;
        static char * key_word_list[] = {(char *)"total_mass", (char *)"radius", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:setSphereTotal", key_word_list, &param1, &param2))
        {
            (local_this)->set_sphere_total((float)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeMass.setSphereTotal() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSphereTotal(non-const OdeMass this, float total_mass, float radius)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeMass_set_sphere_total_139_comment =
    "C++ Interface:\n"
    "setSphereTotal(non-const OdeMass this, float total_mass, float radius)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeMass_set_sphere_total_139_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeMass::set_capsule(float density, int direction, float radius, float length)
 *******************************************************************/
static PyObject *Dtool_OdeMass_set_capsule_140(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeMass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeMass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeMass::set_capsule(float density, int direction, float radius, float length)
        double param1;
        int param2;
        double param3;
        double param4;
        static char * key_word_list[] = {(char *)"density", (char *)"direction", (char *)"radius", (char *)"length", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "didd:setCapsule", key_word_list, &param1, &param2, &param3, &param4))
        {
            (local_this)->set_capsule((float)param1, (int)param2, (float)param3, (float)param4);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeMass.setCapsule() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCapsule(non-const OdeMass this, float density, int direction, float radius, float length)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeMass_set_capsule_140_comment =
    "C++ Interface:\n"
    "setCapsule(non-const OdeMass this, float density, int direction, float radius, float length)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeMass_set_capsule_140_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeMass::set_capsule_total(float total_mass, int direction, float radius, float length)
 *******************************************************************/
static PyObject *Dtool_OdeMass_set_capsule_total_141(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeMass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeMass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeMass::set_capsule_total(float total_mass, int direction, float radius, float length)
        double param1;
        int param2;
        double param3;
        double param4;
        static char * key_word_list[] = {(char *)"total_mass", (char *)"direction", (char *)"radius", (char *)"length", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "didd:setCapsuleTotal", key_word_list, &param1, &param2, &param3, &param4))
        {
            (local_this)->set_capsule_total((float)param1, (int)param2, (float)param3, (float)param4);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeMass.setCapsuleTotal() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCapsuleTotal(non-const OdeMass this, float total_mass, int direction, float radius, float length)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeMass_set_capsule_total_141_comment =
    "C++ Interface:\n"
    "setCapsuleTotal(non-const OdeMass this, float total_mass, int direction, float radius, float length)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeMass_set_capsule_total_141_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeMass::set_cylinder(float density, int direction, float radius, float length)
 *******************************************************************/
static PyObject *Dtool_OdeMass_set_cylinder_142(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeMass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeMass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeMass::set_cylinder(float density, int direction, float radius, float length)
        double param1;
        int param2;
        double param3;
        double param4;
        static char * key_word_list[] = {(char *)"density", (char *)"direction", (char *)"radius", (char *)"length", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "didd:setCylinder", key_word_list, &param1, &param2, &param3, &param4))
        {
            (local_this)->set_cylinder((float)param1, (int)param2, (float)param3, (float)param4);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeMass.setCylinder() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCylinder(non-const OdeMass this, float density, int direction, float radius, float length)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeMass_set_cylinder_142_comment =
    "C++ Interface:\n"
    "setCylinder(non-const OdeMass this, float density, int direction, float radius, float length)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeMass_set_cylinder_142_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeMass::set_cylinder_total(float total_mass, int direction, float radius, float length)
 *******************************************************************/
static PyObject *Dtool_OdeMass_set_cylinder_total_143(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeMass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeMass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeMass::set_cylinder_total(float total_mass, int direction, float radius, float length)
        double param1;
        int param2;
        double param3;
        double param4;
        static char * key_word_list[] = {(char *)"total_mass", (char *)"direction", (char *)"radius", (char *)"length", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "didd:setCylinderTotal", key_word_list, &param1, &param2, &param3, &param4))
        {
            (local_this)->set_cylinder_total((float)param1, (int)param2, (float)param3, (float)param4);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeMass.setCylinderTotal() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCylinderTotal(non-const OdeMass this, float total_mass, int direction, float radius, float length)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeMass_set_cylinder_total_143_comment =
    "C++ Interface:\n"
    "setCylinderTotal(non-const OdeMass this, float total_mass, int direction, float radius, float length)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeMass_set_cylinder_total_143_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeMass::set_box(float density, LVecBase3f const &size)
 * inline void OdeMass::set_box(float density, float lx, float ly, float lz)
 *******************************************************************/
static PyObject *Dtool_OdeMass_set_box_144(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeMass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeMass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeMass::set_box(float density, LVecBase3f const &size)
                double param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"density", (char *)"size", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "dO:setBox", key_word_list, &param1, &param2))
                {
                    LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "OdeMass.setBox", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        (local_this)->set_box((float)param1, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeMass.setBox() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeMass::set_box(float density, float lx, float ly, float lz)
            double param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"density", (char *)"lx", (char *)"ly", (char *)"lz", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:setBox", key_word_list, &param1, &param2, &param3, &param4))
            {
                (local_this)->set_box((float)param1, (float)param2, (float)param3, (float)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeMass.setBox() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setBox() takes 3 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setBox(non-const OdeMass this, float density, const VBase3 size)\n"
          "setBox(non-const OdeMass this, float density, float lx, float ly, float lz)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeMass_set_box_144_comment =
    "C++ Interface:\n"
    "setBox(non-const OdeMass this, float density, const VBase3 size)\n"
    "setBox(non-const OdeMass this, float density, float lx, float ly, float lz)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeMass_set_box_144_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeMass::set_box_total(float total_mass, LVecBase3f const &size)
 * inline void OdeMass::set_box_total(float total_mass, float lx, float ly, float lz)
 *******************************************************************/
static PyObject *Dtool_OdeMass_set_box_total_145(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeMass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeMass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeMass::set_box_total(float total_mass, LVecBase3f const &size)
                double param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"total_mass", (char *)"size", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "dO:setBoxTotal", key_word_list, &param1, &param2))
                {
                    LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "OdeMass.setBoxTotal", 1, coerced_ptr, report_errors);

                    if (!((param2_this == NULL)))
                    {
                        (local_this)->set_box_total((float)param1, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeMass.setBoxTotal() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeMass::set_box_total(float total_mass, float lx, float ly, float lz)
            double param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"total_mass", (char *)"lx", (char *)"ly", (char *)"lz", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:setBoxTotal", key_word_list, &param1, &param2, &param3, &param4))
            {
                (local_this)->set_box_total((float)param1, (float)param2, (float)param3, (float)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeMass.setBoxTotal() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setBoxTotal() takes 3 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setBoxTotal(non-const OdeMass this, float total_mass, const VBase3 size)\n"
          "setBoxTotal(non-const OdeMass this, float total_mass, float lx, float ly, float lz)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeMass_set_box_total_145_comment =
    "C++ Interface:\n"
    "setBoxTotal(non-const OdeMass this, float total_mass, const VBase3 size)\n"
    "setBoxTotal(non-const OdeMass this, float total_mass, float lx, float ly, float lz)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeMass_set_box_total_145_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeMass::adjust(float newmass)
 *******************************************************************/
static PyObject *Dtool_OdeMass_adjust_146(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeMass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeMass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeMass::adjust(float newmass)
        double param1;
        static char * key_word_list[] = {(char *)"newmass", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:adjust", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:adjust", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->adjust((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeMass.adjust() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "adjust(non-const OdeMass this, float newmass)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeMass_adjust_146_comment =
    "C++ Interface:\n"
    "adjust(non-const OdeMass this, float newmass)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeMass_adjust_146_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeMass::translate(LVecBase3f const &pos)
 * inline void OdeMass::translate(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_OdeMass_translate_147(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeMass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeMass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeMass::translate(LVecBase3f const &pos)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"pos", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:translate", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:translate", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeMass.translate", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->translate(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeMass.translate() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeMass::translate(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:translate", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->translate((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeMass.translate() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "translate() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "translate(non-const OdeMass this, const VBase3 pos)\n"
          "translate(non-const OdeMass this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeMass_translate_147_comment =
    "C++ Interface:\n"
    "translate(non-const OdeMass this, const VBase3 pos)\n"
    "translate(non-const OdeMass this, float x, float y, float z)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeMass_translate_147_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeMass::rotate(LMatrix3f const &r)
 *******************************************************************/
static PyObject *Dtool_OdeMass_rotate_148(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeMass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeMass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeMass::rotate(LMatrix3f const &r)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"r", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:rotate", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:rotate", &param1));
            if(!PyErr_Occurred())
            {
                LMatrix3f *param1_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LMatrix3f, 1, "OdeMass.rotate", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->rotate(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeMass.rotate() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "rotate(non-const OdeMass this, const Mat3 r)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeMass_rotate_148_comment =
    "C++ Interface:\n"
    "rotate(non-const OdeMass this, const Mat3 r)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeMass_rotate_148_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeMass::add(OdeMass &other)
 *******************************************************************/
static PyObject *Dtool_OdeMass_add_149(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeMass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeMass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeMass::add(OdeMass &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:add", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:add", &param1));
            if(!PyErr_Occurred())
            {
                OdeMass *param1_this = (OdeMass *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeMass, 1, "OdeMass.add", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeMass.add() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "add(non-const OdeMass this, non-const OdeMass other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeMass_add_149_comment =
    "C++ Interface:\n"
    "add(non-const OdeMass this, non-const OdeMass other)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeMass_add_149_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeMass::get_magnitude(void) const
 *******************************************************************/
static PyObject *Dtool_OdeMass_get_magnitude_150(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeMass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeMass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeMass::get_magnitude(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMagnitude", key_word_list));
        else
            (PyArg_Parse(args, ":getMagnitude"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeMass*)local_this)->get_magnitude();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMagnitude(const OdeMass this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeMass_get_magnitude_150_comment =
    "C++ Interface:\n"
    "getMagnitude(const OdeMass this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeMass_get_magnitude_150_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f OdeMass::get_center(void) const
 *******************************************************************/
static PyObject *Dtool_OdeMass_get_center_151(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeMass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeMass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f OdeMass::get_center(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCenter", key_word_list));
        else
            (PyArg_Parse(args, ":getCenter"));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const OdeMass*)local_this)->get_center();
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCenter(const OdeMass this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeMass_get_center_151_comment =
    "C++ Interface:\n"
    "getCenter(const OdeMass this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeMass_get_center_151_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LMatrix3f OdeMass::get_inertial_tensor(void) const
 *******************************************************************/
static PyObject *Dtool_OdeMass_get_inertial_tensor_152(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeMass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeMass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LMatrix3f OdeMass::get_inertial_tensor(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getInertialTensor", key_word_list));
        else
            (PyArg_Parse(args, ":getInertialTensor"));
        if(!PyErr_Occurred())
        {
            LMatrix3f result = ((const OdeMass*)local_this)->get_inertial_tensor();
            LMatrix3f *return_value = new LMatrix3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LMatrix3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInertialTensor(const OdeMass this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeMass_get_inertial_tensor_152_comment =
    "C++ Interface:\n"
    "getInertialTensor(const OdeMass this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeMass_get_inertial_tensor_152_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void OdeMass::write(ostream &out, unsigned int indent) const
 * virtual void OdeMass::write(ostream &out, unsigned int indent = (0)) const
 * virtual void OdeMass::write(ostream &out = (cout), unsigned int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_OdeMass_write_153(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeMass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeMass,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-virtual void OdeMass::write(ostream &out = (cout), unsigned int indent = (0)) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":write", key_word_list));
            else
                (PyArg_Parse(args, ":write"));
            if(!PyErr_Occurred())
            {
                ((const OdeMass*)local_this)->write();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void OdeMass::write(ostream &out, unsigned int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "OdeMass.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const OdeMass*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void OdeMass::write(ostream &out, unsigned int indent) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "OdeMass.write", 0, coerced_ptr, report_errors);
 PyObject *param2_uint = PyNumber_Long(param2);
                    if (!((param1_this == NULL)|| (param2_uint == NULL)))
                    {
                        ((const OdeMass*)local_this)->write(*param1_this, PyLong_AsUnsignedLong(param2_uint));
                         Py_XDECREF(param2_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 1, 2, or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const OdeMass this)\n"
          "write(const OdeMass this, non-const Ostream out)\n"
          "write(const OdeMass this, non-const Ostream out, unsigned int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeMass_write_153_comment =
    "C++ Interface:\n"
    "write(const OdeMass this)\n"
    "write(const OdeMass this, non-const Ostream out)\n"
    "write(const OdeMass this, non-const Ostream out, unsigned int indent)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeMass_write_153_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeMass::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeMass_get_class_type_154(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeMass::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeMass::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeMass_get_class_type_154_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeMass_get_class_type_154_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeMass::OdeMass(void)
 * OdeMass::OdeMass(OdeMass const &copy)
 *******************************************************************/
int  Dtool_Init_OdeMass(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-OdeMass::OdeMass(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":OdeMass", key_word_list))
            {
                OdeMass *return_value = new OdeMass();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeMass,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeMass::OdeMass(OdeMass const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:OdeMass", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:OdeMass", &param0));
                if(!PyErr_Occurred())
                {
                    OdeMass *param0_this = (OdeMass *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeMass, 0, "OdeMass.OdeMass", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        OdeMass *return_value = new OdeMass(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeMass,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OdeMass() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OdeMass()\n"
          "OdeMass(const OdeMass copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OdeMass(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeMass)
    {
        printf("OdeMass ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeMass * local_this = (OdeMass *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeMass)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeMass(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeMass)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (OdeMass*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeMass*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (OdeMass*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeBody 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void OdeBody::destroy(void)
 *******************************************************************/
static PyObject *Dtool_OdeBody_destroy_157(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void OdeBody::destroy(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":destroy", key_word_list));
        else
            (PyArg_Parse(args, ":destroy"));
        if(!PyErr_Occurred())
        {
            (local_this)->destroy();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeBody.destroy() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "destroy(non-const OdeBody this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_destroy_157_comment =
    "C++ Interface:\n"
    "destroy(non-const OdeBody this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_destroy_157_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool OdeBody::is_empty(void) const
 *******************************************************************/
static PyObject *Dtool_OdeBody_is_empty_158(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool OdeBody::is_empty(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isEmpty", key_word_list));
        else
            (PyArg_Parse(args, ":isEmpty"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const OdeBody*)local_this)->is_empty();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isEmpty(const OdeBody this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_is_empty_158_comment =
    "C++ Interface:\n"
    "isEmpty(const OdeBody this)\n"
    "\n"
    "// Filename: odeBody.I\n"
    "// Created by:  joswilso (27Dec06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OdeBody::is_empty\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the ID is 0, meaning the OdeBody\n"
    "//               does not point to a valid body. It is an error to\n"
    "//               call a method on an empty body.\n"
    "//               Note that an empty OdeBody also evaluates to False.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeBody_is_empty_158_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline dxBody *OdeBody::get_id(void) const
 *******************************************************************/
static PyObject *Dtool_OdeBody_get_id_159(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline dxBody *OdeBody::get_id(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getId", key_word_list));
        else
            (PyArg_Parse(args, ":getId"));
        if(!PyErr_Occurred())
        {
            dxBody *return_value = ((const OdeBody*)local_this)->get_id();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_dxBody,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getId(const OdeBody this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_get_id_159_comment =
    "C++ Interface:\n"
    "getId(const OdeBody this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OdeBody::get_id\n"
    "//       Access: Published\n"
    "//  Description: Returns the underlying dBodyID.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeBody_get_id_159_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeBody::set_auto_disable_linear_threshold(float linear_threshold)
 *******************************************************************/
static PyObject *Dtool_OdeBody_set_auto_disable_linear_threshold_160(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeBody::set_auto_disable_linear_threshold(float linear_threshold)
        double param1;
        static char * key_word_list[] = {(char *)"linear_threshold", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setAutoDisableLinearThreshold", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setAutoDisableLinearThreshold", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_auto_disable_linear_threshold((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeBody.setAutoDisableLinearThreshold() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAutoDisableLinearThreshold(non-const OdeBody this, float linear_threshold)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_set_auto_disable_linear_threshold_160_comment =
    "C++ Interface:\n"
    "setAutoDisableLinearThreshold(non-const OdeBody this, float linear_threshold)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_set_auto_disable_linear_threshold_160_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeBody::set_auto_disable_angular_threshold(float angular_threshold)
 *******************************************************************/
static PyObject *Dtool_OdeBody_set_auto_disable_angular_threshold_161(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeBody::set_auto_disable_angular_threshold(float angular_threshold)
        double param1;
        static char * key_word_list[] = {(char *)"angular_threshold", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setAutoDisableAngularThreshold", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setAutoDisableAngularThreshold", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_auto_disable_angular_threshold((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeBody.setAutoDisableAngularThreshold() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAutoDisableAngularThreshold(non-const OdeBody this, float angular_threshold)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_set_auto_disable_angular_threshold_161_comment =
    "C++ Interface:\n"
    "setAutoDisableAngularThreshold(non-const OdeBody this, float angular_threshold)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_set_auto_disable_angular_threshold_161_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeBody::set_auto_disable_steps(int steps)
 *******************************************************************/
static PyObject *Dtool_OdeBody_set_auto_disable_steps_162(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeBody::set_auto_disable_steps(int steps)
        int param1;
        static char * key_word_list[] = {(char *)"steps", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setAutoDisableSteps", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setAutoDisableSteps", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_auto_disable_steps((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeBody.setAutoDisableSteps() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAutoDisableSteps(non-const OdeBody this, int steps)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_set_auto_disable_steps_162_comment =
    "C++ Interface:\n"
    "setAutoDisableSteps(non-const OdeBody this, int steps)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_set_auto_disable_steps_162_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeBody::set_auto_disable_time(float time)
 *******************************************************************/
static PyObject *Dtool_OdeBody_set_auto_disable_time_163(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeBody::set_auto_disable_time(float time)
        double param1;
        static char * key_word_list[] = {(char *)"time", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setAutoDisableTime", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setAutoDisableTime", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_auto_disable_time((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeBody.setAutoDisableTime() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAutoDisableTime(non-const OdeBody this, float time)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_set_auto_disable_time_163_comment =
    "C++ Interface:\n"
    "setAutoDisableTime(non-const OdeBody this, float time)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_set_auto_disable_time_163_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeBody::set_auto_disable_flag(int do_auto_disable)
 *******************************************************************/
static PyObject *Dtool_OdeBody_set_auto_disable_flag_164(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeBody::set_auto_disable_flag(int do_auto_disable)
        int param1;
        static char * key_word_list[] = {(char *)"do_auto_disable", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setAutoDisableFlag", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setAutoDisableFlag", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_auto_disable_flag((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeBody.setAutoDisableFlag() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAutoDisableFlag(non-const OdeBody this, int do_auto_disable)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_set_auto_disable_flag_164_comment =
    "C++ Interface:\n"
    "setAutoDisableFlag(non-const OdeBody this, int do_auto_disable)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_set_auto_disable_flag_164_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeBody::set_auto_disable_defaults(void)
 *******************************************************************/
static PyObject *Dtool_OdeBody_set_auto_disable_defaults_165(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeBody::set_auto_disable_defaults(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":setAutoDisableDefaults", key_word_list));
        else
            (PyArg_Parse(args, ":setAutoDisableDefaults"));
        if(!PyErr_Occurred())
        {
            (local_this)->set_auto_disable_defaults();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeBody.setAutoDisableDefaults() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAutoDisableDefaults(non-const OdeBody this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_set_auto_disable_defaults_165_comment =
    "C++ Interface:\n"
    "setAutoDisableDefaults(non-const OdeBody this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_set_auto_disable_defaults_165_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeBody::set_data(PyObject *data)
 *******************************************************************/
static PyObject *Dtool_OdeBody_set_data_166(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeBody::set_data(PyObject *data)
        PyObject *param1;
        static char * key_word_list[] = {(char *)"data", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:setData", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:setData", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_data(param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeBody.setData() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setData(non-const OdeBody this, any data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_set_data_166_comment =
    "C++ Interface:\n"
    "setData(non-const OdeBody this, any data)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_set_data_166_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeBody::set_position(LVecBase3f const &pos)
 * inline void OdeBody::set_position(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_OdeBody_set_position_167(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeBody::set_position(LVecBase3f const &pos)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"pos", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setPosition", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setPosition", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeBody.setPosition", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_position(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeBody.setPosition() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeBody::set_position(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setPosition", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_position((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeBody.setPosition() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setPosition() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setPosition(non-const OdeBody this, const VBase3 pos)\n"
          "setPosition(non-const OdeBody this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_set_position_167_comment =
    "C++ Interface:\n"
    "setPosition(non-const OdeBody this, const VBase3 pos)\n"
    "setPosition(non-const OdeBody this, float x, float y, float z)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_set_position_167_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeBody::set_rotation(LMatrix3f const r)
 *******************************************************************/
static PyObject *Dtool_OdeBody_set_rotation_168(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeBody::set_rotation(LMatrix3f const r)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"r", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setRotation", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setRotation", &param1));
            if(!PyErr_Occurred())
            {
                LMatrix3f *param1_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LMatrix3f, 1, "OdeBody.setRotation", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_rotation(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeBody.setRotation() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRotation(non-const OdeBody this, const Mat3 r)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_set_rotation_168_comment =
    "C++ Interface:\n"
    "setRotation(non-const OdeBody this, const Mat3 r)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_set_rotation_168_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeBody::set_quaternion(LQuaternionf const q)
 *******************************************************************/
static PyObject *Dtool_OdeBody_set_quaternion_169(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeBody::set_quaternion(LQuaternionf const q)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"q", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setQuaternion", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setQuaternion", &param1));
            if(!PyErr_Occurred())
            {
                LQuaternionf *param1_this = (LQuaternionf *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LQuaternionf, 1, "OdeBody.setQuaternion", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_quaternion(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeBody.setQuaternion() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setQuaternion(non-const OdeBody this, const Quat q)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_set_quaternion_169_comment =
    "C++ Interface:\n"
    "setQuaternion(non-const OdeBody this, const Quat q)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_set_quaternion_169_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeBody::set_linear_vel(LVecBase3f const &vel)
 * inline void OdeBody::set_linear_vel(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_OdeBody_set_linear_vel_170(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeBody::set_linear_vel(LVecBase3f const &vel)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"vel", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setLinearVel", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setLinearVel", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeBody.setLinearVel", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_linear_vel(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeBody.setLinearVel() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeBody::set_linear_vel(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setLinearVel", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_linear_vel((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeBody.setLinearVel() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setLinearVel() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setLinearVel(non-const OdeBody this, const VBase3 vel)\n"
          "setLinearVel(non-const OdeBody this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_set_linear_vel_170_comment =
    "C++ Interface:\n"
    "setLinearVel(non-const OdeBody this, const VBase3 vel)\n"
    "setLinearVel(non-const OdeBody this, float x, float y, float z)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_set_linear_vel_170_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeBody::set_angular_vel(LVecBase3f const &vel)
 * inline void OdeBody::set_angular_vel(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_OdeBody_set_angular_vel_171(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeBody::set_angular_vel(LVecBase3f const &vel)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"vel", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAngularVel", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setAngularVel", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeBody.setAngularVel", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_angular_vel(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeBody.setAngularVel() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeBody::set_angular_vel(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setAngularVel", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_angular_vel((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeBody.setAngularVel() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setAngularVel() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setAngularVel(non-const OdeBody this, const VBase3 vel)\n"
          "setAngularVel(non-const OdeBody this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_set_angular_vel_171_comment =
    "C++ Interface:\n"
    "setAngularVel(non-const OdeBody this, const VBase3 vel)\n"
    "setAngularVel(non-const OdeBody this, float x, float y, float z)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_set_angular_vel_171_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeBody::set_mass(OdeMass &mass)
 *******************************************************************/
static PyObject *Dtool_OdeBody_set_mass_172(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeBody::set_mass(OdeMass &mass)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"mass", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setMass", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setMass", &param1));
            if(!PyErr_Occurred())
            {
                OdeMass *param1_this = (OdeMass *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeMass, 1, "OdeBody.setMass", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_mass(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeBody.setMass() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMass(non-const OdeBody this, non-const OdeMass mass)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_set_mass_172_comment =
    "C++ Interface:\n"
    "setMass(non-const OdeBody this, non-const OdeMass mass)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_set_mass_172_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeBody::get_auto_disable_linear_threshold(void) const
 *******************************************************************/
static PyObject *Dtool_OdeBody_get_auto_disable_linear_threshold_173(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeBody::get_auto_disable_linear_threshold(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAutoDisableLinearThreshold", key_word_list));
        else
            (PyArg_Parse(args, ":getAutoDisableLinearThreshold"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeBody*)local_this)->get_auto_disable_linear_threshold();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAutoDisableLinearThreshold(const OdeBody this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_get_auto_disable_linear_threshold_173_comment =
    "C++ Interface:\n"
    "getAutoDisableLinearThreshold(const OdeBody this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_get_auto_disable_linear_threshold_173_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeBody::get_auto_disable_angular_threshold(void) const
 *******************************************************************/
static PyObject *Dtool_OdeBody_get_auto_disable_angular_threshold_174(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeBody::get_auto_disable_angular_threshold(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAutoDisableAngularThreshold", key_word_list));
        else
            (PyArg_Parse(args, ":getAutoDisableAngularThreshold"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeBody*)local_this)->get_auto_disable_angular_threshold();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAutoDisableAngularThreshold(const OdeBody this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_get_auto_disable_angular_threshold_174_comment =
    "C++ Interface:\n"
    "getAutoDisableAngularThreshold(const OdeBody this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_get_auto_disable_angular_threshold_174_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeBody::get_auto_disable_steps(void) const
 *******************************************************************/
static PyObject *Dtool_OdeBody_get_auto_disable_steps_175(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int OdeBody::get_auto_disable_steps(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAutoDisableSteps", key_word_list));
        else
            (PyArg_Parse(args, ":getAutoDisableSteps"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const OdeBody*)local_this)->get_auto_disable_steps();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAutoDisableSteps(const OdeBody this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_get_auto_disable_steps_175_comment =
    "C++ Interface:\n"
    "getAutoDisableSteps(const OdeBody this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_get_auto_disable_steps_175_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeBody::get_auto_disable_time(void) const
 *******************************************************************/
static PyObject *Dtool_OdeBody_get_auto_disable_time_176(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeBody::get_auto_disable_time(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAutoDisableTime", key_word_list));
        else
            (PyArg_Parse(args, ":getAutoDisableTime"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeBody*)local_this)->get_auto_disable_time();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAutoDisableTime(const OdeBody this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_get_auto_disable_time_176_comment =
    "C++ Interface:\n"
    "getAutoDisableTime(const OdeBody this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_get_auto_disable_time_176_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeBody::get_auto_disable_flag(void) const
 *******************************************************************/
static PyObject *Dtool_OdeBody_get_auto_disable_flag_177(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int OdeBody::get_auto_disable_flag(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAutoDisableFlag", key_word_list));
        else
            (PyArg_Parse(args, ":getAutoDisableFlag"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const OdeBody*)local_this)->get_auto_disable_flag();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAutoDisableFlag(const OdeBody this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_get_auto_disable_flag_177_comment =
    "C++ Interface:\n"
    "getAutoDisableFlag(const OdeBody this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_get_auto_disable_flag_177_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PyObject *OdeBody::get_data(void) const
 *******************************************************************/
static PyObject *Dtool_OdeBody_get_data_178(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PyObject *OdeBody::get_data(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getData", key_word_list));
        else
            (PyArg_Parse(args, ":getData"));
        if(!PyErr_Occurred())
        {
            PyObject *return_value = ((const OdeBody*)local_this)->get_data();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return  return_value;
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getData(const OdeBody this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_get_data_178_comment =
    "C++ Interface:\n"
    "getData(const OdeBody this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_get_data_178_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f OdeBody::get_position(void) const
 *******************************************************************/
static PyObject *Dtool_OdeBody_get_position_179(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f OdeBody::get_position(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPosition", key_word_list));
        else
            (PyArg_Parse(args, ":getPosition"));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const OdeBody*)local_this)->get_position();
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPosition(const OdeBody this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_get_position_179_comment =
    "C++ Interface:\n"
    "getPosition(const OdeBody this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_get_position_179_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LMatrix3f OdeBody::get_rotation(void) const
 *******************************************************************/
static PyObject *Dtool_OdeBody_get_rotation_180(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LMatrix3f OdeBody::get_rotation(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRotation", key_word_list));
        else
            (PyArg_Parse(args, ":getRotation"));
        if(!PyErr_Occurred())
        {
            LMatrix3f result = ((const OdeBody*)local_this)->get_rotation();
            LMatrix3f *return_value = new LMatrix3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LMatrix3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRotation(const OdeBody this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_get_rotation_180_comment =
    "C++ Interface:\n"
    "getRotation(const OdeBody this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_get_rotation_180_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f OdeBody::get_quaternion(void) const
 *******************************************************************/
static PyObject *Dtool_OdeBody_get_quaternion_181(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f OdeBody::get_quaternion(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getQuaternion", key_word_list));
        else
            (PyArg_Parse(args, ":getQuaternion"));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = ((const OdeBody*)local_this)->get_quaternion();
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getQuaternion(const OdeBody this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_get_quaternion_181_comment =
    "C++ Interface:\n"
    "getQuaternion(const OdeBody this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_get_quaternion_181_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f OdeBody::get_linear_vel(void) const
 *******************************************************************/
static PyObject *Dtool_OdeBody_get_linear_vel_182(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f OdeBody::get_linear_vel(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLinearVel", key_word_list));
        else
            (PyArg_Parse(args, ":getLinearVel"));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const OdeBody*)local_this)->get_linear_vel();
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLinearVel(const OdeBody this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_get_linear_vel_182_comment =
    "C++ Interface:\n"
    "getLinearVel(const OdeBody this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_get_linear_vel_182_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f OdeBody::get_angular_vel(void) const
 *******************************************************************/
static PyObject *Dtool_OdeBody_get_angular_vel_183(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f OdeBody::get_angular_vel(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAngularVel", key_word_list));
        else
            (PyArg_Parse(args, ":getAngularVel"));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const OdeBody*)local_this)->get_angular_vel();
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAngularVel(const OdeBody this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_get_angular_vel_183_comment =
    "C++ Interface:\n"
    "getAngularVel(const OdeBody this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_get_angular_vel_183_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline OdeMass OdeBody::get_mass(void) const
 *******************************************************************/
static PyObject *Dtool_OdeBody_get_mass_184(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline OdeMass OdeBody::get_mass(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMass", key_word_list));
        else
            (PyArg_Parse(args, ":getMass"));
        if(!PyErr_Occurred())
        {
            OdeMass result = ((const OdeBody*)local_this)->get_mass();
            OdeMass *return_value = new OdeMass(result);
            if (return_value != (OdeMass *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeMass,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMass(const OdeBody this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_get_mass_184_comment =
    "C++ Interface:\n"
    "getMass(const OdeBody this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_get_mass_184_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeBody::add_force(LVecBase3f const &f)
 * inline void OdeBody::add_force(float fx, float fy, float fz)
 *******************************************************************/
static PyObject *Dtool_OdeBody_add_force_185(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeBody::add_force(LVecBase3f const &f)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"f", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:addForce", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:addForce", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeBody.addForce", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->add_force(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeBody.addForce() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeBody::add_force(float fx, float fy, float fz)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"fx", (char *)"fy", (char *)"fz", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:addForce", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->add_force((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeBody.addForce() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "addForce() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "addForce(non-const OdeBody this, const VBase3 f)\n"
          "addForce(non-const OdeBody this, float fx, float fy, float fz)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_add_force_185_comment =
    "C++ Interface:\n"
    "addForce(non-const OdeBody this, const VBase3 f)\n"
    "addForce(non-const OdeBody this, float fx, float fy, float fz)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_add_force_185_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeBody::add_torque(LVecBase3f const &f)
 * inline void OdeBody::add_torque(float fx, float fy, float fz)
 *******************************************************************/
static PyObject *Dtool_OdeBody_add_torque_186(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeBody::add_torque(LVecBase3f const &f)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"f", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:addTorque", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:addTorque", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeBody.addTorque", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->add_torque(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeBody.addTorque() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeBody::add_torque(float fx, float fy, float fz)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"fx", (char *)"fy", (char *)"fz", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:addTorque", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->add_torque((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeBody.addTorque() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "addTorque() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "addTorque(non-const OdeBody this, const VBase3 f)\n"
          "addTorque(non-const OdeBody this, float fx, float fy, float fz)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_add_torque_186_comment =
    "C++ Interface:\n"
    "addTorque(non-const OdeBody this, const VBase3 f)\n"
    "addTorque(non-const OdeBody this, float fx, float fy, float fz)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_add_torque_186_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeBody::add_rel_force(LVecBase3f const &f)
 * inline void OdeBody::add_rel_force(float fx, float fy, float fz)
 *******************************************************************/
static PyObject *Dtool_OdeBody_add_rel_force_187(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeBody::add_rel_force(LVecBase3f const &f)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"f", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:addRelForce", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:addRelForce", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeBody.addRelForce", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->add_rel_force(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeBody.addRelForce() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeBody::add_rel_force(float fx, float fy, float fz)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"fx", (char *)"fy", (char *)"fz", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:addRelForce", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->add_rel_force((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeBody.addRelForce() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "addRelForce() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "addRelForce(non-const OdeBody this, const VBase3 f)\n"
          "addRelForce(non-const OdeBody this, float fx, float fy, float fz)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_add_rel_force_187_comment =
    "C++ Interface:\n"
    "addRelForce(non-const OdeBody this, const VBase3 f)\n"
    "addRelForce(non-const OdeBody this, float fx, float fy, float fz)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_add_rel_force_187_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeBody::add_rel_torque(LVecBase3f const &f)
 * inline void OdeBody::add_rel_torque(float fx, float fy, float fz)
 *******************************************************************/
static PyObject *Dtool_OdeBody_add_rel_torque_188(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeBody::add_rel_torque(LVecBase3f const &f)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"f", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:addRelTorque", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:addRelTorque", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeBody.addRelTorque", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->add_rel_torque(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeBody.addRelTorque() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeBody::add_rel_torque(float fx, float fy, float fz)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"fx", (char *)"fy", (char *)"fz", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:addRelTorque", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->add_rel_torque((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeBody.addRelTorque() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "addRelTorque() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "addRelTorque(non-const OdeBody this, const VBase3 f)\n"
          "addRelTorque(non-const OdeBody this, float fx, float fy, float fz)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_add_rel_torque_188_comment =
    "C++ Interface:\n"
    "addRelTorque(non-const OdeBody this, const VBase3 f)\n"
    "addRelTorque(non-const OdeBody this, float fx, float fy, float fz)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_add_rel_torque_188_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeBody::add_force_at_pos(LVecBase3f const &f, LVecBase3f const &pos)
 * inline void OdeBody::add_force_at_pos(float fx, float fy, float fz, float px, float py, float pz)
 *******************************************************************/
static PyObject *Dtool_OdeBody_add_force_at_pos_189(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeBody::add_force_at_pos(LVecBase3f const &f, LVecBase3f const &pos)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"f", (char *)"pos", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:addForceAtPos", key_word_list, &param1, &param2))
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeBody.addForceAtPos", 1, coerced_ptr, report_errors);
LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "OdeBody.addForceAtPos", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        (local_this)->add_force_at_pos(*param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeBody.addForceAtPos() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeBody::add_force_at_pos(float fx, float fy, float fz, float px, float py, float pz)
            double param1;
            double param2;
            double param3;
            double param4;
            double param5;
            double param6;
            static char * key_word_list[] = {(char *)"fx", (char *)"fy", (char *)"fz", (char *)"px", (char *)"py", (char *)"pz", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddddd:addForceAtPos", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6))
            {
                (local_this)->add_force_at_pos((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeBody.addForceAtPos() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "addForceAtPos() takes 3 or 7 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "addForceAtPos(non-const OdeBody this, const VBase3 f, const VBase3 pos)\n"
          "addForceAtPos(non-const OdeBody this, float fx, float fy, float fz, float px, float py, float pz)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_add_force_at_pos_189_comment =
    "C++ Interface:\n"
    "addForceAtPos(non-const OdeBody this, const VBase3 f, const VBase3 pos)\n"
    "addForceAtPos(non-const OdeBody this, float fx, float fy, float fz, float px, float py, float pz)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_add_force_at_pos_189_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeBody::add_force_at_rel_pos(LVecBase3f const &f, LVecBase3f const &pos)
 * inline void OdeBody::add_force_at_rel_pos(float fx, float fy, float fz, float px, float py, float pz)
 *******************************************************************/
static PyObject *Dtool_OdeBody_add_force_at_rel_pos_190(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeBody::add_force_at_rel_pos(LVecBase3f const &f, LVecBase3f const &pos)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"f", (char *)"pos", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:addForceAtRelPos", key_word_list, &param1, &param2))
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeBody.addForceAtRelPos", 1, coerced_ptr, report_errors);
LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "OdeBody.addForceAtRelPos", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        (local_this)->add_force_at_rel_pos(*param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeBody.addForceAtRelPos() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeBody::add_force_at_rel_pos(float fx, float fy, float fz, float px, float py, float pz)
            double param1;
            double param2;
            double param3;
            double param4;
            double param5;
            double param6;
            static char * key_word_list[] = {(char *)"fx", (char *)"fy", (char *)"fz", (char *)"px", (char *)"py", (char *)"pz", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddddd:addForceAtRelPos", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6))
            {
                (local_this)->add_force_at_rel_pos((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeBody.addForceAtRelPos() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "addForceAtRelPos() takes 3 or 7 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "addForceAtRelPos(non-const OdeBody this, const VBase3 f, const VBase3 pos)\n"
          "addForceAtRelPos(non-const OdeBody this, float fx, float fy, float fz, float px, float py, float pz)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_add_force_at_rel_pos_190_comment =
    "C++ Interface:\n"
    "addForceAtRelPos(non-const OdeBody this, const VBase3 f, const VBase3 pos)\n"
    "addForceAtRelPos(non-const OdeBody this, float fx, float fy, float fz, float px, float py, float pz)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_add_force_at_rel_pos_190_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeBody::add_rel_force_at_pos(LVecBase3f const &f, LVecBase3f const &pos)
 * inline void OdeBody::add_rel_force_at_pos(float fx, float fy, float fz, float px, float py, float pz)
 *******************************************************************/
static PyObject *Dtool_OdeBody_add_rel_force_at_pos_191(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeBody::add_rel_force_at_pos(LVecBase3f const &f, LVecBase3f const &pos)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"f", (char *)"pos", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:addRelForceAtPos", key_word_list, &param1, &param2))
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeBody.addRelForceAtPos", 1, coerced_ptr, report_errors);
LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "OdeBody.addRelForceAtPos", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        (local_this)->add_rel_force_at_pos(*param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeBody.addRelForceAtPos() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeBody::add_rel_force_at_pos(float fx, float fy, float fz, float px, float py, float pz)
            double param1;
            double param2;
            double param3;
            double param4;
            double param5;
            double param6;
            static char * key_word_list[] = {(char *)"fx", (char *)"fy", (char *)"fz", (char *)"px", (char *)"py", (char *)"pz", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddddd:addRelForceAtPos", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6))
            {
                (local_this)->add_rel_force_at_pos((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeBody.addRelForceAtPos() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "addRelForceAtPos() takes 3 or 7 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "addRelForceAtPos(non-const OdeBody this, const VBase3 f, const VBase3 pos)\n"
          "addRelForceAtPos(non-const OdeBody this, float fx, float fy, float fz, float px, float py, float pz)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_add_rel_force_at_pos_191_comment =
    "C++ Interface:\n"
    "addRelForceAtPos(non-const OdeBody this, const VBase3 f, const VBase3 pos)\n"
    "addRelForceAtPos(non-const OdeBody this, float fx, float fy, float fz, float px, float py, float pz)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_add_rel_force_at_pos_191_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeBody::add_rel_force_at_rel_pos(LVecBase3f const &f, LVecBase3f const &pos)
 * inline void OdeBody::add_rel_force_at_rel_pos(float fx, float fy, float fz, float px, float py, float pz)
 *******************************************************************/
static PyObject *Dtool_OdeBody_add_rel_force_at_rel_pos_192(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeBody::add_rel_force_at_rel_pos(LVecBase3f const &f, LVecBase3f const &pos)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"f", (char *)"pos", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:addRelForceAtRelPos", key_word_list, &param1, &param2))
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeBody.addRelForceAtRelPos", 1, coerced_ptr, report_errors);
LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "OdeBody.addRelForceAtRelPos", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        (local_this)->add_rel_force_at_rel_pos(*param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeBody.addRelForceAtRelPos() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeBody::add_rel_force_at_rel_pos(float fx, float fy, float fz, float px, float py, float pz)
            double param1;
            double param2;
            double param3;
            double param4;
            double param5;
            double param6;
            static char * key_word_list[] = {(char *)"fx", (char *)"fy", (char *)"fz", (char *)"px", (char *)"py", (char *)"pz", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddddd:addRelForceAtRelPos", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6))
            {
                (local_this)->add_rel_force_at_rel_pos((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeBody.addRelForceAtRelPos() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "addRelForceAtRelPos() takes 3 or 7 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "addRelForceAtRelPos(non-const OdeBody this, const VBase3 f, const VBase3 pos)\n"
          "addRelForceAtRelPos(non-const OdeBody this, float fx, float fy, float fz, float px, float py, float pz)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_add_rel_force_at_rel_pos_192_comment =
    "C++ Interface:\n"
    "addRelForceAtRelPos(non-const OdeBody this, const VBase3 f, const VBase3 pos)\n"
    "addRelForceAtRelPos(non-const OdeBody this, float fx, float fy, float fz, float px, float py, float pz)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_add_rel_force_at_rel_pos_192_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeBody::set_force(LVecBase3f const &f)
 * inline void OdeBody::set_force(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_OdeBody_set_force_193(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeBody::set_force(LVecBase3f const &f)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"f", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setForce", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setForce", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeBody.setForce", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_force(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeBody.setForce() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeBody::set_force(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setForce", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_force((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeBody.setForce() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setForce() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setForce(non-const OdeBody this, const VBase3 f)\n"
          "setForce(non-const OdeBody this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_set_force_193_comment =
    "C++ Interface:\n"
    "setForce(non-const OdeBody this, const VBase3 f)\n"
    "setForce(non-const OdeBody this, float x, float y, float z)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_set_force_193_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeBody::set_torque(LVecBase3f const &f)
 * inline void OdeBody::set_torque(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_OdeBody_set_torque_194(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeBody::set_torque(LVecBase3f const &f)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"f", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setTorque", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setTorque", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeBody.setTorque", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_torque(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeBody.setTorque() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeBody::set_torque(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setTorque", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_torque((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeBody.setTorque() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setTorque() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setTorque(non-const OdeBody this, const VBase3 f)\n"
          "setTorque(non-const OdeBody this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_set_torque_194_comment =
    "C++ Interface:\n"
    "setTorque(non-const OdeBody this, const VBase3 f)\n"
    "setTorque(non-const OdeBody this, float x, float y, float z)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_set_torque_194_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f OdeBody::get_rel_point_pos(LVecBase3f const &pos) const
 * inline LPoint3f OdeBody::get_rel_point_pos(float px, float py, float pz) const
 *******************************************************************/
static PyObject *Dtool_OdeBody_get_rel_point_pos_195(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline LPoint3f OdeBody::get_rel_point_pos(LVecBase3f const &pos) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"pos", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:getRelPointPos", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:getRelPointPos", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeBody.getRelPointPos", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        LPoint3f result = ((const OdeBody*)local_this)->get_rel_point_pos(*param1_this);
                        LPoint3f *return_value = new LPoint3f(result);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          // 1-inline LPoint3f OdeBody::get_rel_point_pos(float px, float py, float pz) const
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"px", (char *)"py", (char *)"pz", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:getRelPointPos", key_word_list, &param1, &param2, &param3))
            {
                LPoint3f result = ((const OdeBody*)local_this)->get_rel_point_pos((float)param1, (float)param2, (float)param3);
                LPoint3f *return_value = new LPoint3f(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getRelPointPos() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getRelPointPos(const OdeBody this, const VBase3 pos)\n"
          "getRelPointPos(const OdeBody this, float px, float py, float pz)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_get_rel_point_pos_195_comment =
    "C++ Interface:\n"
    "getRelPointPos(const OdeBody this, const VBase3 pos)\n"
    "getRelPointPos(const OdeBody this, float px, float py, float pz)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_get_rel_point_pos_195_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f OdeBody::get_rel_point_vel(LVecBase3f const &pos) const
 * inline LPoint3f OdeBody::get_rel_point_vel(float px, float py, float pz) const
 *******************************************************************/
static PyObject *Dtool_OdeBody_get_rel_point_vel_196(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline LPoint3f OdeBody::get_rel_point_vel(LVecBase3f const &pos) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"pos", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:getRelPointVel", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:getRelPointVel", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeBody.getRelPointVel", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        LPoint3f result = ((const OdeBody*)local_this)->get_rel_point_vel(*param1_this);
                        LPoint3f *return_value = new LPoint3f(result);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          // 1-inline LPoint3f OdeBody::get_rel_point_vel(float px, float py, float pz) const
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"px", (char *)"py", (char *)"pz", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:getRelPointVel", key_word_list, &param1, &param2, &param3))
            {
                LPoint3f result = ((const OdeBody*)local_this)->get_rel_point_vel((float)param1, (float)param2, (float)param3);
                LPoint3f *return_value = new LPoint3f(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getRelPointVel() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getRelPointVel(const OdeBody this, const VBase3 pos)\n"
          "getRelPointVel(const OdeBody this, float px, float py, float pz)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_get_rel_point_vel_196_comment =
    "C++ Interface:\n"
    "getRelPointVel(const OdeBody this, const VBase3 pos)\n"
    "getRelPointVel(const OdeBody this, float px, float py, float pz)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_get_rel_point_vel_196_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f OdeBody::get_point_vel(LVecBase3f const &pos) const
 * inline LPoint3f OdeBody::get_point_vel(float px, float py, float pz) const
 *******************************************************************/
static PyObject *Dtool_OdeBody_get_point_vel_197(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline LPoint3f OdeBody::get_point_vel(LVecBase3f const &pos) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"pos", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:getPointVel", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:getPointVel", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeBody.getPointVel", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        LPoint3f result = ((const OdeBody*)local_this)->get_point_vel(*param1_this);
                        LPoint3f *return_value = new LPoint3f(result);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          // 1-inline LPoint3f OdeBody::get_point_vel(float px, float py, float pz) const
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"px", (char *)"py", (char *)"pz", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:getPointVel", key_word_list, &param1, &param2, &param3))
            {
                LPoint3f result = ((const OdeBody*)local_this)->get_point_vel((float)param1, (float)param2, (float)param3);
                LPoint3f *return_value = new LPoint3f(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getPointVel() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getPointVel(const OdeBody this, const VBase3 pos)\n"
          "getPointVel(const OdeBody this, float px, float py, float pz)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_get_point_vel_197_comment =
    "C++ Interface:\n"
    "getPointVel(const OdeBody this, const VBase3 pos)\n"
    "getPointVel(const OdeBody this, float px, float py, float pz)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_get_point_vel_197_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f OdeBody::get_pos_rel_point(LVecBase3f const &pos) const
 * inline LPoint3f OdeBody::get_pos_rel_point(float px, float py, float pz) const
 *******************************************************************/
static PyObject *Dtool_OdeBody_get_pos_rel_point_198(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline LPoint3f OdeBody::get_pos_rel_point(LVecBase3f const &pos) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"pos", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:getPosRelPoint", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:getPosRelPoint", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeBody.getPosRelPoint", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        LPoint3f result = ((const OdeBody*)local_this)->get_pos_rel_point(*param1_this);
                        LPoint3f *return_value = new LPoint3f(result);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          // 1-inline LPoint3f OdeBody::get_pos_rel_point(float px, float py, float pz) const
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"px", (char *)"py", (char *)"pz", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:getPosRelPoint", key_word_list, &param1, &param2, &param3))
            {
                LPoint3f result = ((const OdeBody*)local_this)->get_pos_rel_point((float)param1, (float)param2, (float)param3);
                LPoint3f *return_value = new LPoint3f(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getPosRelPoint() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getPosRelPoint(const OdeBody this, const VBase3 pos)\n"
          "getPosRelPoint(const OdeBody this, float px, float py, float pz)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_get_pos_rel_point_198_comment =
    "C++ Interface:\n"
    "getPosRelPoint(const OdeBody this, const VBase3 pos)\n"
    "getPosRelPoint(const OdeBody this, float px, float py, float pz)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_get_pos_rel_point_198_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f OdeBody::vector_to_world(LVecBase3f const &pos) const
 * inline LVecBase3f OdeBody::vector_to_world(float px, float py, float pz) const
 *******************************************************************/
static PyObject *Dtool_OdeBody_vector_to_world_199(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline LVecBase3f OdeBody::vector_to_world(LVecBase3f const &pos) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"pos", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:vectorToWorld", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:vectorToWorld", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeBody.vectorToWorld", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        LVecBase3f result = ((const OdeBody*)local_this)->vector_to_world(*param1_this);
                        LVecBase3f *return_value = new LVecBase3f(result);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          // 1-inline LVecBase3f OdeBody::vector_to_world(float px, float py, float pz) const
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"px", (char *)"py", (char *)"pz", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:vectorToWorld", key_word_list, &param1, &param2, &param3))
            {
                LVecBase3f result = ((const OdeBody*)local_this)->vector_to_world((float)param1, (float)param2, (float)param3);
                LVecBase3f *return_value = new LVecBase3f(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "vectorToWorld() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "vectorToWorld(const OdeBody this, const VBase3 pos)\n"
          "vectorToWorld(const OdeBody this, float px, float py, float pz)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_vector_to_world_199_comment =
    "C++ Interface:\n"
    "vectorToWorld(const OdeBody this, const VBase3 pos)\n"
    "vectorToWorld(const OdeBody this, float px, float py, float pz)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_vector_to_world_199_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f OdeBody::vector_from_world(LVecBase3f const &pos) const
 * inline LVecBase3f OdeBody::vector_from_world(float px, float py, float pz) const
 *******************************************************************/
static PyObject *Dtool_OdeBody_vector_from_world_200(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline LVecBase3f OdeBody::vector_from_world(LVecBase3f const &pos) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"pos", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:vectorFromWorld", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:vectorFromWorld", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeBody.vectorFromWorld", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        LVecBase3f result = ((const OdeBody*)local_this)->vector_from_world(*param1_this);
                        LVecBase3f *return_value = new LVecBase3f(result);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          // 1-inline LVecBase3f OdeBody::vector_from_world(float px, float py, float pz) const
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"px", (char *)"py", (char *)"pz", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:vectorFromWorld", key_word_list, &param1, &param2, &param3))
            {
                LVecBase3f result = ((const OdeBody*)local_this)->vector_from_world((float)param1, (float)param2, (float)param3);
                LVecBase3f *return_value = new LVecBase3f(result);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "vectorFromWorld() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "vectorFromWorld(const OdeBody this, const VBase3 pos)\n"
          "vectorFromWorld(const OdeBody this, float px, float py, float pz)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_vector_from_world_200_comment =
    "C++ Interface:\n"
    "vectorFromWorld(const OdeBody this, const VBase3 pos)\n"
    "vectorFromWorld(const OdeBody this, float px, float py, float pz)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_vector_from_world_200_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeBody::set_finite_rotation_mode(int mode)
 *******************************************************************/
static PyObject *Dtool_OdeBody_set_finite_rotation_mode_201(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeBody::set_finite_rotation_mode(int mode)
        int param1;
        static char * key_word_list[] = {(char *)"mode", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setFiniteRotationMode", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setFiniteRotationMode", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_finite_rotation_mode((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeBody.setFiniteRotationMode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFiniteRotationMode(non-const OdeBody this, int mode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_set_finite_rotation_mode_201_comment =
    "C++ Interface:\n"
    "setFiniteRotationMode(non-const OdeBody this, int mode)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_set_finite_rotation_mode_201_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeBody::set_finite_rotation_axis(LVecBase3f const &axis)
 * inline void OdeBody::set_finite_rotation_axis(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_OdeBody_set_finite_rotation_axis_202(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeBody::set_finite_rotation_axis(LVecBase3f const &axis)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"axis", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFiniteRotationAxis", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setFiniteRotationAxis", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeBody.setFiniteRotationAxis", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_finite_rotation_axis(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeBody.setFiniteRotationAxis() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeBody::set_finite_rotation_axis(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setFiniteRotationAxis", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_finite_rotation_axis((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeBody.setFiniteRotationAxis() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setFiniteRotationAxis() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setFiniteRotationAxis(non-const OdeBody this, const VBase3 axis)\n"
          "setFiniteRotationAxis(non-const OdeBody this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_set_finite_rotation_axis_202_comment =
    "C++ Interface:\n"
    "setFiniteRotationAxis(non-const OdeBody this, const VBase3 axis)\n"
    "setFiniteRotationAxis(non-const OdeBody this, float x, float y, float z)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_set_finite_rotation_axis_202_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeBody::get_finite_rotation_mode(void) const
 *******************************************************************/
static PyObject *Dtool_OdeBody_get_finite_rotation_mode_203(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int OdeBody::get_finite_rotation_mode(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFiniteRotationMode", key_word_list));
        else
            (PyArg_Parse(args, ":getFiniteRotationMode"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const OdeBody*)local_this)->get_finite_rotation_mode();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFiniteRotationMode(const OdeBody this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_get_finite_rotation_mode_203_comment =
    "C++ Interface:\n"
    "getFiniteRotationMode(const OdeBody this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_get_finite_rotation_mode_203_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f OdeBody::get_finite_rotation_axis(void) const
 *******************************************************************/
static PyObject *Dtool_OdeBody_get_finite_rotation_axis_204(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f OdeBody::get_finite_rotation_axis(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFiniteRotationAxis", key_word_list));
        else
            (PyArg_Parse(args, ":getFiniteRotationAxis"));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const OdeBody*)local_this)->get_finite_rotation_axis();
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFiniteRotationAxis(const OdeBody this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_get_finite_rotation_axis_204_comment =
    "C++ Interface:\n"
    "getFiniteRotationAxis(const OdeBody this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_get_finite_rotation_axis_204_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeBody::get_num_joints(void) const
 *******************************************************************/
static PyObject *Dtool_OdeBody_get_num_joints_205(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int OdeBody::get_num_joints(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumJoints", key_word_list));
        else
            (PyArg_Parse(args, ":getNumJoints"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const OdeBody*)local_this)->get_num_joints();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumJoints(const OdeBody this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_get_num_joints_205_comment =
    "C++ Interface:\n"
    "getNumJoints(const OdeBody this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_get_num_joints_205_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeJoint OdeBody::get_joint(int index) const
 *******************************************************************/
static PyObject *Dtool_OdeBody_get_joint_206(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-OdeJoint OdeBody::get_joint(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getJoint", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getJoint", &param1));
        if(!PyErr_Occurred())
        {
            OdeJoint result = ((const OdeBody*)local_this)->get_joint((int)param1);
            OdeJoint *return_value = new OdeJoint(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeJoint,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getJoint(const OdeBody this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_get_joint_206_comment =
    "C++ Interface:\n"
    "getJoint(const OdeBody this, int index)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_get_joint_206_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeBody::enable(void)
 *******************************************************************/
static PyObject *Dtool_OdeBody_enable_207(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeBody::enable(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":enable", key_word_list));
        else
            (PyArg_Parse(args, ":enable"));
        if(!PyErr_Occurred())
        {
            (local_this)->enable();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeBody.enable() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "enable(non-const OdeBody this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_enable_207_comment =
    "C++ Interface:\n"
    "enable(non-const OdeBody this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_enable_207_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeBody::disable(void)
 *******************************************************************/
static PyObject *Dtool_OdeBody_disable_208(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeBody::disable(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":disable", key_word_list));
        else
            (PyArg_Parse(args, ":disable"));
        if(!PyErr_Occurred())
        {
            (local_this)->disable();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeBody.disable() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "disable(non-const OdeBody this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_disable_208_comment =
    "C++ Interface:\n"
    "disable(non-const OdeBody this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_disable_208_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeBody::is_enabled(void) const
 *******************************************************************/
static PyObject *Dtool_OdeBody_is_enabled_209(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int OdeBody::is_enabled(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isEnabled", key_word_list));
        else
            (PyArg_Parse(args, ":isEnabled"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const OdeBody*)local_this)->is_enabled();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isEnabled(const OdeBody this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_is_enabled_209_comment =
    "C++ Interface:\n"
    "isEnabled(const OdeBody this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_is_enabled_209_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeBody::set_gravity_mode(int mode)
 *******************************************************************/
static PyObject *Dtool_OdeBody_set_gravity_mode_210(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeBody::set_gravity_mode(int mode)
        int param1;
        static char * key_word_list[] = {(char *)"mode", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setGravityMode", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setGravityMode", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_gravity_mode((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeBody.setGravityMode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setGravityMode(non-const OdeBody this, int mode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_set_gravity_mode_210_comment =
    "C++ Interface:\n"
    "setGravityMode(non-const OdeBody this, int mode)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_set_gravity_mode_210_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeBody::get_gravity_mode(void) const
 *******************************************************************/
static PyObject *Dtool_OdeBody_get_gravity_mode_211(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int OdeBody::get_gravity_mode(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getGravityMode", key_word_list));
        else
            (PyArg_Parse(args, ":getGravityMode"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const OdeBody*)local_this)->get_gravity_mode();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGravityMode(const OdeBody this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_get_gravity_mode_211_comment =
    "C++ Interface:\n"
    "getGravityMode(const OdeBody this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_get_gravity_mode_211_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void OdeBody::write(ostream &out, unsigned int indent) const
 * virtual void OdeBody::write(ostream &out, unsigned int indent = (0)) const
 * virtual void OdeBody::write(ostream &out = (cout), unsigned int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_OdeBody_write_212(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-virtual void OdeBody::write(ostream &out = (cout), unsigned int indent = (0)) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":write", key_word_list));
            else
                (PyArg_Parse(args, ":write"));
            if(!PyErr_Occurred())
            {
                ((const OdeBody*)local_this)->write();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void OdeBody::write(ostream &out, unsigned int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "OdeBody.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const OdeBody*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void OdeBody::write(ostream &out, unsigned int indent) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "OdeBody.write", 0, coerced_ptr, report_errors);
 PyObject *param2_uint = PyNumber_Long(param2);
                    if (!((param1_this == NULL)|| (param2_uint == NULL)))
                    {
                        ((const OdeBody*)local_this)->write(*param1_this, PyLong_AsUnsignedLong(param2_uint));
                         Py_XDECREF(param2_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 1, 2, or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const OdeBody this)\n"
          "write(const OdeBody this, non-const Ostream out)\n"
          "write(const OdeBody this, non-const Ostream out, unsigned int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_write_212_comment =
    "C++ Interface:\n"
    "write(const OdeBody this)\n"
    "write(const OdeBody this, non-const Ostream out)\n"
    "write(const OdeBody this, non-const Ostream out, unsigned int indent)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_write_212_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeBody::compare_to(OdeBody const &other) const
 *******************************************************************/
static PyObject *Dtool_OdeBody_compare_to_214(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline int OdeBody::compare_to(OdeBody const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:compareTo", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:compareTo", &param1));
            if(!PyErr_Occurred())
            {
                OdeBody *param1_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeBody, 1, "OdeBody.compareTo", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = ((const OdeBody*)local_this)->compare_to(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "compareTo(const OdeBody this, const OdeBody other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_compare_to_214_comment =
    "C++ Interface:\n"
    "compareTo(const OdeBody this, const OdeBody other)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_compare_to_214_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeBody::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeBody_get_class_type_215(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeBody::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeBody::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_get_class_type_215_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_get_class_type_215_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool OdeBody::operator typecast bool(void) const
 *******************************************************************/
static PyObject *Dtool_OdeBody_operator_typecast_bool_213(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool OdeBody::operator typecast bool(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":__nonzero__", key_word_list));
        else
            (PyArg_Parse(args, ":__nonzero__"));
        if(!PyErr_Occurred())
        {
            bool return_value = (bool)(*(const OdeBody*)local_this);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__nonzero__(const OdeBody this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBody_operator_typecast_bool_213_comment =
    "C++ Interface:\n"
    "__nonzero__(const OdeBody this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBody_operator_typecast_bool_213_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeBody::OdeBody(OdeWorld &world)
 *******************************************************************/
int  Dtool_Init_OdeBody(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-OdeBody::OdeBody(OdeWorld &world)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"world", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:OdeBody", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:OdeBody", &param0));
            if(!PyErr_Occurred())
            {
                OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeWorld, 0, "OdeBody.OdeBody", 0, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    OdeBody *return_value = new OdeBody(*param0_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeBody,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "OdeBody(non-const OdeWorld world)\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_OdeBody_get_joints(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumJoints", "getJoint");
}
inline void  * Dtool_UpcastInterface_OdeBody(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeBody)
    {
        printf("OdeBody ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeBody * local_this = (OdeBody *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeBody)
        return local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeBody(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeBody)
        return from_this;
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeBody*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeSpace 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void OdeSpace::destroy(void)
 *******************************************************************/
static PyObject *Dtool_OdeSpace_destroy_217(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void OdeSpace::destroy(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":destroy", key_word_list));
        else
            (PyArg_Parse(args, ":destroy"));
        if(!PyErr_Occurred())
        {
            (local_this)->destroy();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSpace.destroy() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "destroy(non-const OdeSpace this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_destroy_217_comment =
    "C++ Interface:\n"
    "destroy(non-const OdeSpace this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_destroy_217_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool OdeSpace::is_empty(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSpace_is_empty_218(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool OdeSpace::is_empty(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isEmpty", key_word_list));
        else
            (PyArg_Parse(args, ":isEmpty"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const OdeSpace*)local_this)->is_empty();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isEmpty(const OdeSpace this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_is_empty_218_comment =
    "C++ Interface:\n"
    "isEmpty(const OdeSpace this)\n"
    "\n"
    "// Filename: odeSpace.I\n"
    "// Created by:  joswilso (27Dec06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OdeSpace::is_empty\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the ID is 0, meaning the OdeSpace\n"
    "//               does not point to a valid space. It is an error to\n"
    "//               call a method on an empty space.\n"
    "//               Note that an empty OdeSpace also evaluates to False.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeSpace_is_empty_218_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeSpace::set_cleanup(int mode)
 *******************************************************************/
static PyObject *Dtool_OdeSpace_set_cleanup_219(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeSpace::set_cleanup(int mode)
        int param1;
        static char * key_word_list[] = {(char *)"mode", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setCleanup", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setCleanup", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_cleanup((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSpace.setCleanup() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCleanup(non-const OdeSpace this, int mode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_set_cleanup_219_comment =
    "C++ Interface:\n"
    "setCleanup(non-const OdeSpace this, int mode)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_set_cleanup_219_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeSpace::get_cleanup(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSpace_get_cleanup_220(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int OdeSpace::get_cleanup(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCleanup", key_word_list));
        else
            (PyArg_Parse(args, ":getCleanup"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const OdeSpace*)local_this)->get_cleanup();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCleanup(const OdeSpace this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_get_cleanup_220_comment =
    "C++ Interface:\n"
    "getCleanup(const OdeSpace this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_get_cleanup_220_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int OdeSpace::query(OdeGeom const &geom) const
 * int OdeSpace::query(OdeSpace const &space) const
 *******************************************************************/
static PyObject *Dtool_OdeSpace_query_221(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // -2 int OdeSpace::query(OdeSpace const &space) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"space", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:query", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:query", &param1));
            if(!PyErr_Occurred())
            {
                OdeSpace *param1_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeSpace, 1, "OdeSpace.query", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = ((const OdeSpace*)local_this)->query(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        {
          // -2 int OdeSpace::query(OdeGeom const &geom) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"geom", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:query", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:query", &param1));
            if(!PyErr_Occurred())
            {
                OdeGeom *param1_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeGeom, 1, "OdeSpace.query", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = ((const OdeSpace*)local_this)->query(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "query(const OdeSpace this, const OdeSpace space)\n"
          "query(const OdeSpace this, const OdeGeom geom)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_query_221_comment =
    "C++ Interface:\n"
    "query(const OdeSpace this, const OdeSpace space)\n"
    "query(const OdeSpace this, const OdeGeom geom)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_query_221_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeSpace::get_num_geoms(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSpace_get_num_geoms_222(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int OdeSpace::get_num_geoms(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumGeoms", key_word_list));
        else
            (PyArg_Parse(args, ":getNumGeoms"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const OdeSpace*)local_this)->get_num_geoms();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumGeoms(const OdeSpace this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_get_num_geoms_222_comment =
    "C++ Interface:\n"
    "getNumGeoms(const OdeSpace this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_get_num_geoms_222_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeSpace::get_AABB(LVecBase3f &min, LVecBase3f &max) const
 *******************************************************************/
static PyObject *Dtool_OdeSpace_get_AABB_223(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline void OdeSpace::get_AABB(LVecBase3f &min, LVecBase3f &max) const
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"min", (char *)"max", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getAABB", key_word_list, &param1, &param2))
            {
                LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeSpace.getAABB", 0, coerced_ptr, report_errors);
LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "OdeSpace.getAABB", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    ((const OdeSpace*)local_this)->get_AABB(*param1_this, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAABB(const OdeSpace this, non-const VBase3 min, non-const VBase3 max)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_get_AABB_223_comment =
    "C++ Interface:\n"
    "getAABB(const OdeSpace this, non-const VBase3 min, non-const VBase3 max)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_get_AABB_223_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeSpace::is_space(void)
 *******************************************************************/
static PyObject *Dtool_OdeSpace_is_space_224(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int OdeSpace::is_space(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isSpace", key_word_list));
        else
            (PyArg_Parse(args, ":isSpace"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->is_space();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSpace.isSpace() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isSpace(non-const OdeSpace this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_is_space_224_comment =
    "C++ Interface:\n"
    "isSpace(non-const OdeSpace this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_is_space_224_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeSpace::get_class(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSpace_get_class_225(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int OdeSpace::get_class(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getClass", key_word_list));
        else
            (PyArg_Parse(args, ":getClass"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const OdeSpace*)local_this)->get_class();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClass(const OdeSpace this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_get_class_225_comment =
    "C++ Interface:\n"
    "getClass(const OdeSpace this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_get_class_225_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeSpace::set_category_bits(BitMask< unsigned int, 32 > const &bits)
 *******************************************************************/
static PyObject *Dtool_OdeSpace_set_category_bits_226(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeSpace::set_category_bits(BitMask< unsigned int, 32 > const &bits)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"bits", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCategoryBits", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setCategoryBits", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned int, 32 > *param1_this = (BitMask< unsigned int, 32 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int_32, 1, "OdeSpace.setCategoryBits", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_category_bits(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeSpace.setCategoryBits() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCategoryBits(non-const OdeSpace this, const BitMask bits)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_set_category_bits_226_comment =
    "C++ Interface:\n"
    "setCategoryBits(non-const OdeSpace this, const BitMask bits)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_set_category_bits_226_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeSpace::set_collide_bits(BitMask< unsigned int, 32 > const &bits)
 *******************************************************************/
static PyObject *Dtool_OdeSpace_set_collide_bits_227(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeSpace::set_collide_bits(BitMask< unsigned int, 32 > const &bits)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"bits", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCollideBits", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setCollideBits", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned int, 32 > *param1_this = (BitMask< unsigned int, 32 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int_32, 1, "OdeSpace.setCollideBits", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_collide_bits(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeSpace.setCollideBits() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCollideBits(non-const OdeSpace this, const BitMask bits)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_set_collide_bits_227_comment =
    "C++ Interface:\n"
    "setCollideBits(non-const OdeSpace this, const BitMask bits)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_set_collide_bits_227_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitMask< unsigned int, 32 > OdeSpace::get_category_bits(void)
 *******************************************************************/
static PyObject *Dtool_OdeSpace_get_category_bits_228(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline BitMask< unsigned int, 32 > OdeSpace::get_category_bits(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCategoryBits", key_word_list));
        else
            (PyArg_Parse(args, ":getCategoryBits"));
        if(!PyErr_Occurred())
        {
            BitMask< unsigned int, 32 > result = (local_this)->get_category_bits();
            BitMask< unsigned int, 32 > *return_value = new BitMask< unsigned int, 32 >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int_32,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSpace.getCategoryBits() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCategoryBits(non-const OdeSpace this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_get_category_bits_228_comment =
    "C++ Interface:\n"
    "getCategoryBits(non-const OdeSpace this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_get_category_bits_228_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitMask< unsigned int, 32 > OdeSpace::get_collide_bits(void)
 *******************************************************************/
static PyObject *Dtool_OdeSpace_get_collide_bits_229(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline BitMask< unsigned int, 32 > OdeSpace::get_collide_bits(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCollideBits", key_word_list));
        else
            (PyArg_Parse(args, ":getCollideBits"));
        if(!PyErr_Occurred())
        {
            BitMask< unsigned int, 32 > result = (local_this)->get_collide_bits();
            BitMask< unsigned int, 32 > *return_value = new BitMask< unsigned int, 32 >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int_32,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSpace.getCollideBits() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCollideBits(non-const OdeSpace this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_get_collide_bits_229_comment =
    "C++ Interface:\n"
    "getCollideBits(non-const OdeSpace this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_get_collide_bits_229_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeSpace::enable(void)
 *******************************************************************/
static PyObject *Dtool_OdeSpace_enable_230(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeSpace::enable(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":enable", key_word_list));
        else
            (PyArg_Parse(args, ":enable"));
        if(!PyErr_Occurred())
        {
            (local_this)->enable();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSpace.enable() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "enable(non-const OdeSpace this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_enable_230_comment =
    "C++ Interface:\n"
    "enable(non-const OdeSpace this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_enable_230_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeSpace::disable(void)
 *******************************************************************/
static PyObject *Dtool_OdeSpace_disable_231(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeSpace::disable(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":disable", key_word_list));
        else
            (PyArg_Parse(args, ":disable"));
        if(!PyErr_Occurred())
        {
            (local_this)->disable();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSpace.disable() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "disable(non-const OdeSpace this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_disable_231_comment =
    "C++ Interface:\n"
    "disable(non-const OdeSpace this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_disable_231_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeSpace::is_enabled(void)
 *******************************************************************/
static PyObject *Dtool_OdeSpace_is_enabled_232(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int OdeSpace::is_enabled(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isEnabled", key_word_list));
        else
            (PyArg_Parse(args, ":isEnabled"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->is_enabled();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSpace.isEnabled() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isEnabled(non-const OdeSpace this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_is_enabled_232_comment =
    "C++ Interface:\n"
    "isEnabled(non-const OdeSpace this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_is_enabled_232_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void OdeSpace::set_auto_collide_world(OdeWorld &)
 *******************************************************************/
static PyObject *Dtool_OdeSpace_set_auto_collide_world_233(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void OdeSpace::set_auto_collide_world(OdeWorld &)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAutoCollideWorld", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setAutoCollideWorld", &param1));
            if(!PyErr_Occurred())
            {
                OdeWorld *param1_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeWorld, 1, "OdeSpace.setAutoCollideWorld", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_auto_collide_world(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeSpace.setAutoCollideWorld() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAutoCollideWorld(non-const OdeSpace this, non-const OdeWorld)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_set_auto_collide_world_233_comment =
    "C++ Interface:\n"
    "setAutoCollideWorld(non-const OdeSpace this, non-const OdeWorld)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_set_auto_collide_world_233_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void OdeSpace::set_auto_collide_joint_group(OdeJointGroup &)
 *******************************************************************/
static PyObject *Dtool_OdeSpace_set_auto_collide_joint_group_234(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void OdeSpace::set_auto_collide_joint_group(OdeJointGroup &)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAutoCollideJointGroup", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setAutoCollideJointGroup", &param1));
            if(!PyErr_Occurred())
            {
                OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeJointGroup, 1, "OdeSpace.setAutoCollideJointGroup", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_auto_collide_joint_group(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeSpace.setAutoCollideJointGroup() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAutoCollideJointGroup(non-const OdeSpace this, non-const OdeJointGroup)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_set_auto_collide_joint_group_234_comment =
    "C++ Interface:\n"
    "setAutoCollideJointGroup(non-const OdeSpace this, non-const OdeJointGroup)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_set_auto_collide_joint_group_234_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void OdeSpace::add(OdeGeom &geom)
 * void OdeSpace::add(OdeSpace &space)
 *******************************************************************/
static PyObject *Dtool_OdeSpace_add_235(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 void OdeSpace::add(OdeSpace &space)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"space", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:add", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:add", &param1));
            if(!PyErr_Occurred())
            {
                OdeSpace *param1_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeSpace, 1, "OdeSpace.add", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 void OdeSpace::add(OdeGeom &geom)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"geom", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:add", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:add", &param1));
            if(!PyErr_Occurred())
            {
                OdeGeom *param1_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeGeom, 1, "OdeSpace.add", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "add(non-const OdeSpace this, non-const OdeSpace space)\n"
          "add(non-const OdeSpace this, non-const OdeGeom geom)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_add_235_comment =
    "C++ Interface:\n"
    "add(non-const OdeSpace this, non-const OdeSpace space)\n"
    "add(non-const OdeSpace this, non-const OdeGeom geom)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_add_235_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void OdeSpace::remove(OdeGeom &geom)
 * void OdeSpace::remove(OdeSpace &space)
 *******************************************************************/
static PyObject *Dtool_OdeSpace_remove_236(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 void OdeSpace::remove(OdeGeom &geom)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"geom", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:remove", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:remove", &param1));
            if(!PyErr_Occurred())
            {
                OdeGeom *param1_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeGeom, 1, "OdeSpace.remove", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->remove(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 void OdeSpace::remove(OdeSpace &space)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"space", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:remove", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:remove", &param1));
            if(!PyErr_Occurred())
            {
                OdeSpace *param1_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeSpace, 1, "OdeSpace.remove", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->remove(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "remove(non-const OdeSpace this, non-const OdeGeom geom)\n"
          "remove(non-const OdeSpace this, non-const OdeSpace space)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_remove_236_comment =
    "C++ Interface:\n"
    "remove(non-const OdeSpace this, non-const OdeGeom geom)\n"
    "remove(non-const OdeSpace this, non-const OdeSpace space)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_remove_236_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void OdeSpace::clean(void)
 *******************************************************************/
static PyObject *Dtool_OdeSpace_clean_237(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void OdeSpace::clean(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clean", key_word_list));
        else
            (PyArg_Parse(args, ":clean"));
        if(!PyErr_Occurred())
        {
            (local_this)->clean();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSpace.clean() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clean(non-const OdeSpace this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_clean_237_comment =
    "C++ Interface:\n"
    "clean(non-const OdeSpace this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_clean_237_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeGeom OdeSpace::get_geom(int i)
 *******************************************************************/
static PyObject *Dtool_OdeSpace_get_geom_238(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-OdeGeom OdeSpace::get_geom(int i)
        int param1;
        static char * key_word_list[] = {(char *)"i", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getGeom", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getGeom", &param1));
        if(!PyErr_Occurred())
        {
            OdeGeom result = (local_this)->get_geom((int)param1);
            OdeGeom *return_value = new OdeGeom(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeGeom,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSpace.getGeom() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGeom(non-const OdeSpace this, int i)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_get_geom_238_comment =
    "C++ Interface:\n"
    "getGeom(non-const OdeSpace this, int i)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_get_geom_238_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline OdeSpace OdeSpace::get_space(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSpace_get_space_239(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline OdeSpace OdeSpace::get_space(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSpace", key_word_list));
        else
            (PyArg_Parse(args, ":getSpace"));
        if(!PyErr_Occurred())
        {
            OdeSpace result = ((const OdeSpace*)local_this)->get_space();
            OdeSpace *return_value = new OdeSpace(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeSpace,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSpace(const OdeSpace this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_get_space_239_comment =
    "C++ Interface:\n"
    "getSpace(const OdeSpace this)\n"
    "\n"
    "// Not INLINE because of forward declaration\n"
    "//static int get_surface_type(OdeSpace * self, dGeomID o1);\n"
    "";
#else
static const char * Dtool_OdeSpace_get_space_239_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void OdeSpace::write(ostream &out, unsigned int indent) const
 * virtual void OdeSpace::write(ostream &out, unsigned int indent = (0)) const
 * virtual void OdeSpace::write(ostream &out = (cout), unsigned int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_OdeSpace_write_240(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-virtual void OdeSpace::write(ostream &out = (cout), unsigned int indent = (0)) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":write", key_word_list));
            else
                (PyArg_Parse(args, ":write"));
            if(!PyErr_Occurred())
            {
                ((const OdeSpace*)local_this)->write();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void OdeSpace::write(ostream &out, unsigned int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "OdeSpace.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const OdeSpace*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void OdeSpace::write(ostream &out, unsigned int indent) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "OdeSpace.write", 0, coerced_ptr, report_errors);
 PyObject *param2_uint = PyNumber_Long(param2);
                    if (!((param1_this == NULL)|| (param2_uint == NULL)))
                    {
                        ((const OdeSpace*)local_this)->write(*param1_this, PyLong_AsUnsignedLong(param2_uint));
                         Py_XDECREF(param2_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 1, 2, or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const OdeSpace this)\n"
          "write(const OdeSpace this, non-const Ostream out)\n"
          "write(const OdeSpace this, non-const Ostream out, unsigned int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_write_240_comment =
    "C++ Interface:\n"
    "write(const OdeSpace this)\n"
    "write(const OdeSpace this, non-const Ostream out)\n"
    "write(const OdeSpace this, non-const Ostream out, unsigned int indent)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_write_240_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeSimpleSpace OdeSpace::convert_to_simple_space(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSpace_convert_to_simple_space_242(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-OdeSimpleSpace OdeSpace::convert_to_simple_space(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":convertToSimpleSpace", key_word_list));
        else
            (PyArg_Parse(args, ":convertToSimpleSpace"));
        if(!PyErr_Occurred())
        {
            OdeSimpleSpace result = ((const OdeSpace*)local_this)->convert_to_simple_space();
            OdeSimpleSpace *return_value = new OdeSimpleSpace(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeSimpleSpace,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "convertToSimpleSpace(const OdeSpace this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_convert_to_simple_space_242_comment =
    "C++ Interface:\n"
    "convertToSimpleSpace(const OdeSpace this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_convert_to_simple_space_242_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeHashSpace OdeSpace::convert_to_hash_space(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSpace_convert_to_hash_space_243(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-OdeHashSpace OdeSpace::convert_to_hash_space(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":convertToHashSpace", key_word_list));
        else
            (PyArg_Parse(args, ":convertToHashSpace"));
        if(!PyErr_Occurred())
        {
            OdeHashSpace result = ((const OdeSpace*)local_this)->convert_to_hash_space();
            OdeHashSpace *return_value = new OdeHashSpace(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeHashSpace,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "convertToHashSpace(const OdeSpace this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_convert_to_hash_space_243_comment =
    "C++ Interface:\n"
    "convertToHashSpace(const OdeSpace this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_convert_to_hash_space_243_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeQuadTreeSpace OdeSpace::convert_to_quad_tree_space(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSpace_convert_to_quad_tree_space_244(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-OdeQuadTreeSpace OdeSpace::convert_to_quad_tree_space(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":convertToQuadTreeSpace", key_word_list));
        else
            (PyArg_Parse(args, ":convertToQuadTreeSpace"));
        if(!PyErr_Occurred())
        {
            OdeQuadTreeSpace result = ((const OdeSpace*)local_this)->convert_to_quad_tree_space();
            OdeQuadTreeSpace *return_value = new OdeQuadTreeSpace(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeQuadTreeSpace,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "convertToQuadTreeSpace(const OdeSpace this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_convert_to_quad_tree_space_244_comment =
    "C++ Interface:\n"
    "convertToQuadTreeSpace(const OdeSpace this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_convert_to_quad_tree_space_244_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int OdeSpace::auto_collide(void)
 *******************************************************************/
static PyObject *Dtool_OdeSpace_auto_collide_245(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int OdeSpace::auto_collide(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":autoCollide", key_word_list));
        else
            (PyArg_Parse(args, ":autoCollide"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->auto_collide();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSpace.autoCollide() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "autoCollide(non-const OdeSpace this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_auto_collide_245_comment =
    "C++ Interface:\n"
    "autoCollide(non-const OdeSpace this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_auto_collide_245_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int OdeSpace::collide(PyObject *arg, PyObject *near_callback)
 *******************************************************************/
static PyObject *Dtool_OdeSpace_collide_246(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-int OdeSpace::collide(PyObject *arg, PyObject *near_callback)
        PyObject *param1;
        PyObject *param2;
        static char * key_word_list[] = {(char *)"arg", (char *)"near_callback", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:collide", key_word_list, &param1, &param2))
        {
            int return_value = (local_this)->collide(param1, param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSpace.collide() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "collide(non-const OdeSpace this, any arg, any near_callback)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_collide_246_comment =
    "C++ Interface:\n"
    "collide(non-const OdeSpace this, any arg, any near_callback)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_collide_246_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static double OdeSpace::get_contact_data(int data_index)
 *******************************************************************/
static PyObject *Dtool_OdeSpace_get_contact_data_247(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static double OdeSpace::get_contact_data(int data_index)
        int param0;
        static char * key_word_list[] = {(char *)"data_index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getContactData", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:getContactData", &param0));
        if(!PyErr_Occurred())
        {
            double return_value = OdeSpace::get_contact_data((int)param0);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getContactData(int data_index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_get_contact_data_247_comment =
    "C++ Interface:\n"
    "getContactData(int data_index)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_get_contact_data_247_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int OdeSpace::get_contact_id(int data_index, int first)
 * int OdeSpace::get_contact_id(int data_index, int first = (0))
 *******************************************************************/
static PyObject *Dtool_OdeSpace_get_contact_id_248(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int OdeSpace::get_contact_id(int data_index, int first = (0))
            int param1;
            static char * key_word_list[] = {(char *)"data_index", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:getContactId", key_word_list, &param1));
            else
                (PyArg_Parse(args, "i:getContactId", &param1));
            if(!PyErr_Occurred())
            {
                int return_value = (local_this)->get_contact_id((int)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeSpace.getContactId() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-int OdeSpace::get_contact_id(int data_index, int first)
            int param1;
            int param2;
            static char * key_word_list[] = {(char *)"data_index", (char *)"first", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:getContactId", key_word_list, &param1, &param2))
            {
                int return_value = (local_this)->get_contact_id((int)param1, (int)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeSpace.getContactId() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getContactId() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getContactId(non-const OdeSpace this, int data_index)\n"
          "getContactId(non-const OdeSpace this, int data_index, int first)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_get_contact_id_248_comment =
    "C++ Interface:\n"
    "getContactId(non-const OdeSpace this, int data_index)\n"
    "getContactId(non-const OdeSpace this, int data_index, int first)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_get_contact_id_248_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int OdeSpace::set_collide_id(OdeGeom &geom, int collide_id)
 * int OdeSpace::set_collide_id(int collide_id, dxGeom *id)
 *******************************************************************/
static PyObject *Dtool_OdeSpace_set_collide_id_249(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 int OdeSpace::set_collide_id(OdeGeom &geom, int collide_id)
            PyObject *param1;
            int param2;
            static char * key_word_list[] = {(char *)"geom", (char *)"collide_id", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:setCollideId", key_word_list, &param1, &param2))
            {
                OdeGeom *param1_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeGeom, 1, "OdeSpace.setCollideId", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = (local_this)->set_collide_id(*param1_this, (int)param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 int OdeSpace::set_collide_id(int collide_id, dxGeom *id)
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"collide_id", (char *)"id", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setCollideId", key_word_list, &param1, &param2))
            {
                dxGeom *param2_this = (dxGeom *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_dxGeom, 2, "OdeSpace.setCollideId", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    int return_value = (local_this)->set_collide_id((int)param1, param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCollideId(non-const OdeSpace this, non-const OdeGeom geom, int collide_id)\n"
          "setCollideId(non-const OdeSpace this, int collide_id, non-const DxGeom id)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_set_collide_id_249_comment =
    "C++ Interface:\n"
    "setCollideId(non-const OdeSpace this, non-const OdeGeom geom, int collide_id)\n"
    "setCollideId(non-const OdeSpace this, int collide_id, non-const DxGeom id)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_set_collide_id_249_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void OdeSpace::set_surface_type(OdeGeom &geom, int surface_type)
 * void OdeSpace::set_surface_type(int surface_type, dxGeom *id)
 *******************************************************************/
static PyObject *Dtool_OdeSpace_set_surface_type_250(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 void OdeSpace::set_surface_type(OdeGeom &geom, int surface_type)
            PyObject *param1;
            int param2;
            static char * key_word_list[] = {(char *)"geom", (char *)"surface_type", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "Oi:setSurfaceType", key_word_list, &param1, &param2))
            {
                OdeGeom *param1_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeGeom, 1, "OdeSpace.setSurfaceType", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_surface_type(*param1_this, (int)param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 void OdeSpace::set_surface_type(int surface_type, dxGeom *id)
            int param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"surface_type", (char *)"id", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iO:setSurfaceType", key_word_list, &param1, &param2))
            {
                dxGeom *param2_this = (dxGeom *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_dxGeom, 2, "OdeSpace.setSurfaceType", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)))
                {
                    (local_this)->set_surface_type((int)param1, param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSurfaceType(non-const OdeSpace this, non-const OdeGeom geom, int surface_type)\n"
          "setSurfaceType(non-const OdeSpace this, int surface_type, non-const DxGeom id)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_set_surface_type_250_comment =
    "C++ Interface:\n"
    "setSurfaceType(non-const OdeSpace this, non-const OdeGeom geom, int surface_type)\n"
    "setSurfaceType(non-const OdeSpace this, int surface_type, non-const DxGeom id)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_set_surface_type_250_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int OdeSpace::get_surface_type(OdeGeom &geom)
 * int OdeSpace::get_surface_type(dxGeom *o1)
 *******************************************************************/
static PyObject *Dtool_OdeSpace_get_surface_type_251(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 int OdeSpace::get_surface_type(OdeGeom &geom)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"geom", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getSurfaceType", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getSurfaceType", &param1));
            if(!PyErr_Occurred())
            {
                OdeGeom *param1_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeGeom, 1, "OdeSpace.getSurfaceType", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = (local_this)->get_surface_type(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 int OdeSpace::get_surface_type(dxGeom *o1)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"o1", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getSurfaceType", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getSurfaceType", &param1));
            if(!PyErr_Occurred())
            {
                dxGeom *param1_this = (dxGeom *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_dxGeom, 1, "OdeSpace.getSurfaceType", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = (local_this)->get_surface_type(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSurfaceType(non-const OdeSpace this, non-const OdeGeom geom)\n"
          "getSurfaceType(non-const OdeSpace this, non-const DxGeom o1)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_get_surface_type_251_comment =
    "C++ Interface:\n"
    "getSurfaceType(non-const OdeSpace this, non-const OdeGeom geom)\n"
    "getSurfaceType(non-const OdeSpace this, non-const DxGeom o1)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_get_surface_type_251_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int OdeSpace::get_collide_id(OdeGeom &geom)
 * int OdeSpace::get_collide_id(dxGeom *o1)
 *******************************************************************/
static PyObject *Dtool_OdeSpace_get_collide_id_252(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 int OdeSpace::get_collide_id(OdeGeom &geom)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"geom", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getCollideId", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getCollideId", &param1));
            if(!PyErr_Occurred())
            {
                OdeGeom *param1_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeGeom, 1, "OdeSpace.getCollideId", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = (local_this)->get_collide_id(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // -2 int OdeSpace::get_collide_id(dxGeom *o1)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"o1", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:getCollideId", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:getCollideId", &param1));
            if(!PyErr_Occurred())
            {
                dxGeom *param1_this = (dxGeom *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_dxGeom, 1, "OdeSpace.getCollideId", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = (local_this)->get_collide_id(param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
            PyErr_Clear(); 
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCollideId(non-const OdeSpace this, non-const OdeGeom geom)\n"
          "getCollideId(non-const OdeSpace this, non-const DxGeom o1)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_get_collide_id_252_comment =
    "C++ Interface:\n"
    "getCollideId(non-const OdeSpace this, non-const OdeGeom geom)\n"
    "getCollideId(non-const OdeSpace this, non-const DxGeom o1)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_get_collide_id_252_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeSpace::set_collision_event(basic_string< char > const &event_name)
 *******************************************************************/
static PyObject *Dtool_OdeSpace_set_collision_event_253(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeSpace::set_collision_event(basic_string< char > const &event_name)
        char *param1_str; int param1_len;
        static char * key_word_list[] = {(char *)"event_name", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:setCollisionEvent", key_word_list, &param1_str, &param1_len));
        else
            (PyArg_Parse(args, "s#:setCollisionEvent", &param1_str, &param1_len));
        if(!PyErr_Occurred())
        {
            (local_this)->set_collision_event(basic_string<char>(param1_str, param1_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSpace.setCollisionEvent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCollisionEvent(non-const OdeSpace this, string event_name)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_set_collision_event_253_comment =
    "C++ Interface:\n"
    "setCollisionEvent(non-const OdeSpace this, string event_name)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_set_collision_event_253_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline basic_string< char > OdeSpace::get_collision_event(void)
 *******************************************************************/
static PyObject *Dtool_OdeSpace_get_collision_event_254(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline basic_string< char > OdeSpace::get_collision_event(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCollisionEvent", key_word_list));
        else
            (PyArg_Parse(args, ":getCollisionEvent"));
        if(!PyErr_Occurred())
        {
            basic_string< char > return_value = (local_this)->get_collision_event();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyString_FromStringAndSize(return_value.data(), (int)return_value.length());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSpace.getCollisionEvent() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCollisionEvent(non-const OdeSpace this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_get_collision_event_254_comment =
    "C++ Interface:\n"
    "getCollisionEvent(non-const OdeSpace this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_get_collision_event_254_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeSpace::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeSpace_get_class_type_255(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeSpace::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeSpace::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_get_class_type_255_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_get_class_type_255_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool OdeSpace::operator typecast bool(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSpace_operator_typecast_bool_241(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool OdeSpace::operator typecast bool(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":__nonzero__", key_word_list));
        else
            (PyArg_Parse(args, ":__nonzero__"));
        if(!PyErr_Occurred())
        {
            bool return_value = (bool)(*(const OdeSpace*)local_this);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__nonzero__(const OdeSpace this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSpace_operator_typecast_bool_241_comment =
    "C++ Interface:\n"
    "__nonzero__(const OdeSpace this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSpace_operator_typecast_bool_241_comment = NULL;
#endif

int  Dtool_Init_OdeSpace(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (OdeSpace)");
       return -1;
}
inline void  * Dtool_UpcastInterface_OdeSpace(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeSpace)
    {
        printf("OdeSpace ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeSpace * local_this = (OdeSpace *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeSpace)
        return local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeSpace(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeSpace)
        return from_this;
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeSpace*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeGeom 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void OdeGeom::destroy(void)
 *******************************************************************/
static PyObject *Dtool_OdeGeom_destroy_258(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void OdeGeom::destroy(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":destroy", key_word_list));
        else
            (PyArg_Parse(args, ":destroy"));
        if(!PyErr_Occurred())
        {
            (local_this)->destroy();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeGeom.destroy() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "destroy(non-const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_destroy_258_comment =
    "C++ Interface:\n"
    "destroy(non-const OdeGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_destroy_258_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool OdeGeom::is_empty(void) const
 *******************************************************************/
static PyObject *Dtool_OdeGeom_is_empty_259(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool OdeGeom::is_empty(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isEmpty", key_word_list));
        else
            (PyArg_Parse(args, ":isEmpty"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const OdeGeom*)local_this)->is_empty();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isEmpty(const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_is_empty_259_comment =
    "C++ Interface:\n"
    "isEmpty(const OdeGeom this)\n"
    "\n"
    "// Filename: odeGeom.I\n"
    "// Created by:  joswilso (27Dec06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OdeGeom::is_empty\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the ID is 0, meaning the OdeGeom\n"
    "//               does not point to a valid geom. It is an error to\n"
    "//               call a method on an empty geom.\n"
    "//               Note that an empty OdeGeom also evaluates to False.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeGeom_is_empty_259_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline dxGeom *OdeGeom::get_id(void) const
 *******************************************************************/
static PyObject *Dtool_OdeGeom_get_id_260(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline dxGeom *OdeGeom::get_id(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getId", key_word_list));
        else
            (PyArg_Parse(args, ":getId"));
        if(!PyErr_Occurred())
        {
            dxGeom *return_value = ((const OdeGeom*)local_this)->get_id();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_dxGeom,false, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getId(const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_get_id_260_comment =
    "C++ Interface:\n"
    "getId(const OdeGeom this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OdeGeom::get_id\n"
    "//       Access: Published\n"
    "//  Description: Returns the underlying dGeomID.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeGeom_get_id_260_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeGeom::set_body(OdeBody &body)
 *******************************************************************/
static PyObject *Dtool_OdeGeom_set_body_261(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeGeom::set_body(OdeBody &body)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"body", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setBody", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setBody", &param1));
            if(!PyErr_Occurred())
            {
                OdeBody *param1_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeBody, 1, "OdeGeom.setBody", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_body(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeGeom.setBody() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBody(non-const OdeGeom this, non-const OdeBody body)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_set_body_261_comment =
    "C++ Interface:\n"
    "setBody(non-const OdeGeom this, non-const OdeBody body)\n"
    "\n"
    "//INLINE void set_data(void* data);\n"
    "";
#else
static const char * Dtool_OdeGeom_set_body_261_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool OdeGeom::has_body(void) const
 *******************************************************************/
static PyObject *Dtool_OdeGeom_has_body_262(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool OdeGeom::has_body(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":hasBody", key_word_list));
        else
            (PyArg_Parse(args, ":hasBody"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const OdeGeom*)local_this)->has_body();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasBody(const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_has_body_262_comment =
    "C++ Interface:\n"
    "hasBody(const OdeGeom this)\n"
    "\n"
    "//INLINE void set_data(void* data);\n"
    "";
#else
static const char * Dtool_OdeGeom_has_body_262_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline OdeBody OdeGeom::get_body(void) const
 *******************************************************************/
static PyObject *Dtool_OdeGeom_get_body_263(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline OdeBody OdeGeom::get_body(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBody", key_word_list));
        else
            (PyArg_Parse(args, ":getBody"));
        if(!PyErr_Occurred())
        {
            OdeBody result = ((const OdeGeom*)local_this)->get_body();
            OdeBody *return_value = new OdeBody(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeBody,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBody(const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_get_body_263_comment =
    "C++ Interface:\n"
    "getBody(const OdeGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_get_body_263_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeGeom::set_position(LVecBase3f const &pos)
 * inline void OdeGeom::set_position(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_OdeGeom_set_position_264(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeGeom::set_position(LVecBase3f const &pos)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"pos", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setPosition", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setPosition", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeGeom.setPosition", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_position(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeGeom.setPosition() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeGeom::set_position(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setPosition", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_position((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeGeom.setPosition() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setPosition() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setPosition(non-const OdeGeom this, const VBase3 pos)\n"
          "setPosition(non-const OdeGeom this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_set_position_264_comment =
    "C++ Interface:\n"
    "setPosition(non-const OdeGeom this, const VBase3 pos)\n"
    "setPosition(non-const OdeGeom this, float x, float y, float z)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_set_position_264_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeGeom::set_rotation(LMatrix3f const &r)
 *******************************************************************/
static PyObject *Dtool_OdeGeom_set_rotation_265(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeGeom::set_rotation(LMatrix3f const &r)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"r", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setRotation", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setRotation", &param1));
            if(!PyErr_Occurred())
            {
                LMatrix3f *param1_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LMatrix3f, 1, "OdeGeom.setRotation", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_rotation(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeGeom.setRotation() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRotation(non-const OdeGeom this, const Mat3 r)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_set_rotation_265_comment =
    "C++ Interface:\n"
    "setRotation(non-const OdeGeom this, const Mat3 r)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_set_rotation_265_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeGeom::set_quaternion(LQuaternionf const &q)
 *******************************************************************/
static PyObject *Dtool_OdeGeom_set_quaternion_266(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeGeom::set_quaternion(LQuaternionf const &q)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"q", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setQuaternion", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setQuaternion", &param1));
            if(!PyErr_Occurred())
            {
                LQuaternionf *param1_this = (LQuaternionf *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LQuaternionf, 1, "OdeGeom.setQuaternion", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_quaternion(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeGeom.setQuaternion() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setQuaternion(non-const OdeGeom this, const Quat q)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_set_quaternion_266_comment =
    "C++ Interface:\n"
    "setQuaternion(non-const OdeGeom this, const Quat q)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_set_quaternion_266_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f OdeGeom::get_position(void) const
 *******************************************************************/
static PyObject *Dtool_OdeGeom_get_position_267(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f OdeGeom::get_position(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPosition", key_word_list));
        else
            (PyArg_Parse(args, ":getPosition"));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const OdeGeom*)local_this)->get_position();
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPosition(const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_get_position_267_comment =
    "C++ Interface:\n"
    "getPosition(const OdeGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_get_position_267_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LMatrix3f OdeGeom::get_rotation(void) const
 *******************************************************************/
static PyObject *Dtool_OdeGeom_get_rotation_268(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LMatrix3f OdeGeom::get_rotation(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRotation", key_word_list));
        else
            (PyArg_Parse(args, ":getRotation"));
        if(!PyErr_Occurred())
        {
            LMatrix3f result = ((const OdeGeom*)local_this)->get_rotation();
            LMatrix3f *return_value = new LMatrix3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LMatrix3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRotation(const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_get_rotation_268_comment =
    "C++ Interface:\n"
    "getRotation(const OdeGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_get_rotation_268_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LQuaternionf OdeGeom::get_quaternion(void) const
 *******************************************************************/
static PyObject *Dtool_OdeGeom_get_quaternion_269(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LQuaternionf OdeGeom::get_quaternion(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getQuaternion", key_word_list));
        else
            (PyArg_Parse(args, ":getQuaternion"));
        if(!PyErr_Occurred())
        {
            LQuaternionf result = ((const OdeGeom*)local_this)->get_quaternion();
            LQuaternionf *return_value = new LQuaternionf(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LQuaternionf,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getQuaternion(const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_get_quaternion_269_comment =
    "C++ Interface:\n"
    "getQuaternion(const OdeGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_get_quaternion_269_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeGeom::get_AABB(LVecBase3f &min, LVecBase3f &max) const
 *******************************************************************/
static PyObject *Dtool_OdeGeom_get_AABB_270(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline void OdeGeom::get_AABB(LVecBase3f &min, LVecBase3f &max) const
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"min", (char *)"max", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getAABB", key_word_list, &param1, &param2))
            {
                LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeGeom.getAABB", 0, coerced_ptr, report_errors);
LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "OdeGeom.getAABB", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    ((const OdeGeom*)local_this)->get_AABB(*param1_this, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAABB(const OdeGeom this, non-const VBase3 min, non-const VBase3 max)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_get_AABB_270_comment =
    "C++ Interface:\n"
    "getAABB(const OdeGeom this, non-const VBase3 min, non-const VBase3 max)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_get_AABB_270_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeGeom::is_space(void)
 *******************************************************************/
static PyObject *Dtool_OdeGeom_is_space_271(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int OdeGeom::is_space(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isSpace", key_word_list));
        else
            (PyArg_Parse(args, ":isSpace"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->is_space();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeGeom.isSpace() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isSpace(non-const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_is_space_271_comment =
    "C++ Interface:\n"
    "isSpace(non-const OdeGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_is_space_271_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeGeom::get_class(void) const
 *******************************************************************/
static PyObject *Dtool_OdeGeom_get_class_272(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int OdeGeom::get_class(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getClass", key_word_list));
        else
            (PyArg_Parse(args, ":getClass"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const OdeGeom*)local_this)->get_class();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClass(const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_get_class_272_comment =
    "C++ Interface:\n"
    "getClass(const OdeGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_get_class_272_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeGeom::set_category_bits(BitMask< unsigned int, 32 > const &bits)
 *******************************************************************/
static PyObject *Dtool_OdeGeom_set_category_bits_273(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeGeom::set_category_bits(BitMask< unsigned int, 32 > const &bits)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"bits", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCategoryBits", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setCategoryBits", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned int, 32 > *param1_this = (BitMask< unsigned int, 32 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int_32, 1, "OdeGeom.setCategoryBits", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_category_bits(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeGeom.setCategoryBits() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCategoryBits(non-const OdeGeom this, const BitMask bits)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_set_category_bits_273_comment =
    "C++ Interface:\n"
    "setCategoryBits(non-const OdeGeom this, const BitMask bits)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_set_category_bits_273_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeGeom::set_collide_bits(BitMask< unsigned int, 32 > const &bits)
 *******************************************************************/
static PyObject *Dtool_OdeGeom_set_collide_bits_274(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeGeom::set_collide_bits(BitMask< unsigned int, 32 > const &bits)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"bits", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setCollideBits", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setCollideBits", &param1));
            if(!PyErr_Occurred())
            {
                BitMask< unsigned int, 32 > *param1_this = (BitMask< unsigned int, 32 > *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_BitMask_unsigned_int_32, 1, "OdeGeom.setCollideBits", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_collide_bits(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeGeom.setCollideBits() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setCollideBits(non-const OdeGeom this, const BitMask bits)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_set_collide_bits_274_comment =
    "C++ Interface:\n"
    "setCollideBits(non-const OdeGeom this, const BitMask bits)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_set_collide_bits_274_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitMask< unsigned int, 32 > OdeGeom::get_category_bits(void)
 *******************************************************************/
static PyObject *Dtool_OdeGeom_get_category_bits_275(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline BitMask< unsigned int, 32 > OdeGeom::get_category_bits(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCategoryBits", key_word_list));
        else
            (PyArg_Parse(args, ":getCategoryBits"));
        if(!PyErr_Occurred())
        {
            BitMask< unsigned int, 32 > result = (local_this)->get_category_bits();
            BitMask< unsigned int, 32 > *return_value = new BitMask< unsigned int, 32 >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int_32,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeGeom.getCategoryBits() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCategoryBits(non-const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_get_category_bits_275_comment =
    "C++ Interface:\n"
    "getCategoryBits(non-const OdeGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_get_category_bits_275_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline BitMask< unsigned int, 32 > OdeGeom::get_collide_bits(void)
 *******************************************************************/
static PyObject *Dtool_OdeGeom_get_collide_bits_276(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline BitMask< unsigned int, 32 > OdeGeom::get_collide_bits(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getCollideBits", key_word_list));
        else
            (PyArg_Parse(args, ":getCollideBits"));
        if(!PyErr_Occurred())
        {
            BitMask< unsigned int, 32 > result = (local_this)->get_collide_bits();
            BitMask< unsigned int, 32 > *return_value = new BitMask< unsigned int, 32 >(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_BitMask_unsigned_int_32,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeGeom.getCollideBits() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getCollideBits(non-const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_get_collide_bits_276_comment =
    "C++ Interface:\n"
    "getCollideBits(non-const OdeGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_get_collide_bits_276_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeGeom::enable(void)
 *******************************************************************/
static PyObject *Dtool_OdeGeom_enable_277(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeGeom::enable(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":enable", key_word_list));
        else
            (PyArg_Parse(args, ":enable"));
        if(!PyErr_Occurred())
        {
            (local_this)->enable();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeGeom.enable() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "enable(non-const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_enable_277_comment =
    "C++ Interface:\n"
    "enable(non-const OdeGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_enable_277_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeGeom::disable(void)
 *******************************************************************/
static PyObject *Dtool_OdeGeom_disable_278(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeGeom::disable(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":disable", key_word_list));
        else
            (PyArg_Parse(args, ":disable"));
        if(!PyErr_Occurred())
        {
            (local_this)->disable();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeGeom.disable() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "disable(non-const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_disable_278_comment =
    "C++ Interface:\n"
    "disable(non-const OdeGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_disable_278_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeGeom::is_enabled(void)
 *******************************************************************/
static PyObject *Dtool_OdeGeom_is_enabled_279(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int OdeGeom::is_enabled(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isEnabled", key_word_list));
        else
            (PyArg_Parse(args, ":isEnabled"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->is_enabled();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeGeom.isEnabled() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isEnabled(non-const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_is_enabled_279_comment =
    "C++ Interface:\n"
    "isEnabled(non-const OdeGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_is_enabled_279_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeGeom::set_offset_position(LVecBase3f const &pos)
 * inline void OdeGeom::set_offset_position(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_OdeGeom_set_offset_position_280(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeGeom::set_offset_position(LVecBase3f const &pos)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"pos", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setOffsetPosition", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setOffsetPosition", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeGeom.setOffsetPosition", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_offset_position(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeGeom.setOffsetPosition() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeGeom::set_offset_position(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setOffsetPosition", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_offset_position((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeGeom.setOffsetPosition() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setOffsetPosition() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setOffsetPosition(non-const OdeGeom this, const VBase3 pos)\n"
          "setOffsetPosition(non-const OdeGeom this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_set_offset_position_280_comment =
    "C++ Interface:\n"
    "setOffsetPosition(non-const OdeGeom this, const VBase3 pos)\n"
    "setOffsetPosition(non-const OdeGeom this, float x, float y, float z)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_set_offset_position_280_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeGeom::set_offset_rotation(LMatrix3f const &r)
 *******************************************************************/
static PyObject *Dtool_OdeGeom_set_offset_rotation_281(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeGeom::set_offset_rotation(LMatrix3f const &r)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"r", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setOffsetRotation", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setOffsetRotation", &param1));
            if(!PyErr_Occurred())
            {
                LMatrix3f *param1_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LMatrix3f, 1, "OdeGeom.setOffsetRotation", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_offset_rotation(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeGeom.setOffsetRotation() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setOffsetRotation(non-const OdeGeom this, const Mat3 r)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_set_offset_rotation_281_comment =
    "C++ Interface:\n"
    "setOffsetRotation(non-const OdeGeom this, const Mat3 r)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_set_offset_rotation_281_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeGeom::set_offset_quaternion(LQuaternionf const &q)
 *******************************************************************/
static PyObject *Dtool_OdeGeom_set_offset_quaternion_282(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeGeom::set_offset_quaternion(LQuaternionf const &q)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"q", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setOffsetQuaternion", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setOffsetQuaternion", &param1));
            if(!PyErr_Occurred())
            {
                LQuaternionf *param1_this = (LQuaternionf *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LQuaternionf, 1, "OdeGeom.setOffsetQuaternion", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_offset_quaternion(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeGeom.setOffsetQuaternion() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setOffsetQuaternion(non-const OdeGeom this, const Quat q)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_set_offset_quaternion_282_comment =
    "C++ Interface:\n"
    "setOffsetQuaternion(non-const OdeGeom this, const Quat q)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_set_offset_quaternion_282_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeGeom::set_offset_world_position(LVecBase3f const &pos)
 * inline void OdeGeom::set_offset_world_position(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_OdeGeom_set_offset_world_position_283(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeGeom::set_offset_world_position(LVecBase3f const &pos)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"pos", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setOffsetWorldPosition", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setOffsetWorldPosition", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeGeom.setOffsetWorldPosition", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_offset_world_position(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeGeom.setOffsetWorldPosition() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeGeom::set_offset_world_position(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setOffsetWorldPosition", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_offset_world_position((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeGeom.setOffsetWorldPosition() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setOffsetWorldPosition() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setOffsetWorldPosition(non-const OdeGeom this, const VBase3 pos)\n"
          "setOffsetWorldPosition(non-const OdeGeom this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_set_offset_world_position_283_comment =
    "C++ Interface:\n"
    "setOffsetWorldPosition(non-const OdeGeom this, const VBase3 pos)\n"
    "setOffsetWorldPosition(non-const OdeGeom this, float x, float y, float z)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_set_offset_world_position_283_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeGeom::set_offset_world_rotation(LMatrix3f const &r)
 *******************************************************************/
static PyObject *Dtool_OdeGeom_set_offset_world_rotation_284(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeGeom::set_offset_world_rotation(LMatrix3f const &r)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"r", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setOffsetWorldRotation", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setOffsetWorldRotation", &param1));
            if(!PyErr_Occurred())
            {
                LMatrix3f *param1_this = (LMatrix3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LMatrix3f, 1, "OdeGeom.setOffsetWorldRotation", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_offset_world_rotation(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeGeom.setOffsetWorldRotation() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setOffsetWorldRotation(non-const OdeGeom this, const Mat3 r)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_set_offset_world_rotation_284_comment =
    "C++ Interface:\n"
    "setOffsetWorldRotation(non-const OdeGeom this, const Mat3 r)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_set_offset_world_rotation_284_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeGeom::set_offset_world_quaternion(LQuaternionf const &q)
 *******************************************************************/
static PyObject *Dtool_OdeGeom_set_offset_world_quaternion_285(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeGeom::set_offset_world_quaternion(LQuaternionf const &q)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"q", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setOffsetWorldQuaternion", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setOffsetWorldQuaternion", &param1));
            if(!PyErr_Occurred())
            {
                LQuaternionf *param1_this = (LQuaternionf *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LQuaternionf, 1, "OdeGeom.setOffsetWorldQuaternion", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_offset_world_quaternion(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeGeom.setOffsetWorldQuaternion() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setOffsetWorldQuaternion(non-const OdeGeom this, const Quat q)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_set_offset_world_quaternion_285_comment =
    "C++ Interface:\n"
    "setOffsetWorldQuaternion(non-const OdeGeom this, const Quat q)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_set_offset_world_quaternion_285_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeGeom::clear_offset(void)
 *******************************************************************/
static PyObject *Dtool_OdeGeom_clear_offset_286(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeGeom::clear_offset(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clearOffset", key_word_list));
        else
            (PyArg_Parse(args, ":clearOffset"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear_offset();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeGeom.clearOffset() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearOffset(non-const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_clear_offset_286_comment =
    "C++ Interface:\n"
    "clearOffset(non-const OdeGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_clear_offset_286_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeGeom::is_offset(void)
 *******************************************************************/
static PyObject *Dtool_OdeGeom_is_offset_287(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int OdeGeom::is_offset(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isOffset", key_word_list));
        else
            (PyArg_Parse(args, ":isOffset"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->is_offset();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeGeom.isOffset() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isOffset(non-const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_is_offset_287_comment =
    "C++ Interface:\n"
    "isOffset(non-const OdeGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_is_offset_287_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f OdeGeom::get_offset_position(void) const
 *******************************************************************/
static PyObject *Dtool_OdeGeom_get_offset_position_288(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f OdeGeom::get_offset_position(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOffsetPosition", key_word_list));
        else
            (PyArg_Parse(args, ":getOffsetPosition"));
        if(!PyErr_Occurred())
        {
            LPoint3f result = ((const OdeGeom*)local_this)->get_offset_position();
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOffsetPosition(const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_get_offset_position_288_comment =
    "C++ Interface:\n"
    "getOffsetPosition(const OdeGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_get_offset_position_288_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LMatrix3f OdeGeom::get_offset_rotation(void) const
 *******************************************************************/
static PyObject *Dtool_OdeGeom_get_offset_rotation_289(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LMatrix3f OdeGeom::get_offset_rotation(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOffsetRotation", key_word_list));
        else
            (PyArg_Parse(args, ":getOffsetRotation"));
        if(!PyErr_Occurred())
        {
            LMatrix3f result = ((const OdeGeom*)local_this)->get_offset_rotation();
            LMatrix3f *return_value = new LMatrix3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LMatrix3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOffsetRotation(const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_get_offset_rotation_289_comment =
    "C++ Interface:\n"
    "getOffsetRotation(const OdeGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_get_offset_rotation_289_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LQuaternionf OdeGeom::get_offset_quaternion(void) const
 *******************************************************************/
static PyObject *Dtool_OdeGeom_get_offset_quaternion_290(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LQuaternionf OdeGeom::get_offset_quaternion(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getOffsetQuaternion", key_word_list));
        else
            (PyArg_Parse(args, ":getOffsetQuaternion"));
        if(!PyErr_Occurred())
        {
            LQuaternionf result = ((const OdeGeom*)local_this)->get_offset_quaternion();
            LQuaternionf *return_value = new LQuaternionf(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LQuaternionf,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getOffsetQuaternion(const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_get_offset_quaternion_290_comment =
    "C++ Interface:\n"
    "getOffsetQuaternion(const OdeGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_get_offset_quaternion_290_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeSpace OdeGeom::get_space(void) const
 *******************************************************************/
static PyObject *Dtool_OdeGeom_get_space_291(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-OdeSpace OdeGeom::get_space(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSpace", key_word_list));
        else
            (PyArg_Parse(args, ":getSpace"));
        if(!PyErr_Occurred())
        {
            OdeSpace result = ((const OdeGeom*)local_this)->get_space();
            OdeSpace *return_value = new OdeSpace(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeSpace,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSpace(const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_get_space_291_comment =
    "C++ Interface:\n"
    "getSpace(const OdeGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_get_space_291_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void OdeGeom::write(ostream &out, unsigned int indent) const
 * virtual void OdeGeom::write(ostream &out, unsigned int indent = (0)) const
 * virtual void OdeGeom::write(ostream &out = (cout), unsigned int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_OdeGeom_write_292(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-virtual void OdeGeom::write(ostream &out = (cout), unsigned int indent = (0)) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":write", key_word_list));
            else
                (PyArg_Parse(args, ":write"));
            if(!PyErr_Occurred())
            {
                ((const OdeGeom*)local_this)->write();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void OdeGeom::write(ostream &out, unsigned int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "OdeGeom.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const OdeGeom*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void OdeGeom::write(ostream &out, unsigned int indent) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "OdeGeom.write", 0, coerced_ptr, report_errors);
 PyObject *param2_uint = PyNumber_Long(param2);
                    if (!((param1_this == NULL)|| (param2_uint == NULL)))
                    {
                        ((const OdeGeom*)local_this)->write(*param1_this, PyLong_AsUnsignedLong(param2_uint));
                         Py_XDECREF(param2_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 1, 2, or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const OdeGeom this)\n"
          "write(const OdeGeom this, non-const Ostream out)\n"
          "write(const OdeGeom this, non-const Ostream out, unsigned int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_write_292_comment =
    "C++ Interface:\n"
    "write(const OdeGeom this)\n"
    "write(const OdeGeom this, non-const Ostream out)\n"
    "write(const OdeGeom this, non-const Ostream out, unsigned int indent)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_write_292_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeGeom::compare_to(OdeGeom const &other) const
 *******************************************************************/
static PyObject *Dtool_OdeGeom_compare_to_294(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline int OdeGeom::compare_to(OdeGeom const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:compareTo", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:compareTo", &param1));
            if(!PyErr_Occurred())
            {
                OdeGeom *param1_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeGeom, 1, "OdeGeom.compareTo", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    int return_value = ((const OdeGeom*)local_this)->compare_to(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "compareTo(const OdeGeom this, const OdeGeom other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_compare_to_294_comment =
    "C++ Interface:\n"
    "compareTo(const OdeGeom this, const OdeGeom other)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_compare_to_294_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeBoxGeom OdeGeom::convert_to_box(void) const
 *******************************************************************/
static PyObject *Dtool_OdeGeom_convert_to_box_295(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-OdeBoxGeom OdeGeom::convert_to_box(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":convertToBox", key_word_list));
        else
            (PyArg_Parse(args, ":convertToBox"));
        if(!PyErr_Occurred())
        {
            OdeBoxGeom result = ((const OdeGeom*)local_this)->convert_to_box();
            OdeBoxGeom *return_value = new OdeBoxGeom(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeBoxGeom,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "convertToBox(const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_convert_to_box_295_comment =
    "C++ Interface:\n"
    "convertToBox(const OdeGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_convert_to_box_295_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeCappedCylinderGeom OdeGeom::convert_to_capped_cylinder(void) const
 *******************************************************************/
static PyObject *Dtool_OdeGeom_convert_to_capped_cylinder_296(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-OdeCappedCylinderGeom OdeGeom::convert_to_capped_cylinder(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":convertToCappedCylinder", key_word_list));
        else
            (PyArg_Parse(args, ":convertToCappedCylinder"));
        if(!PyErr_Occurred())
        {
            OdeCappedCylinderGeom result = ((const OdeGeom*)local_this)->convert_to_capped_cylinder();
            OdeCappedCylinderGeom *return_value = new OdeCappedCylinderGeom(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeCappedCylinderGeom,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "convertToCappedCylinder(const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_convert_to_capped_cylinder_296_comment =
    "C++ Interface:\n"
    "convertToCappedCylinder(const OdeGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_convert_to_capped_cylinder_296_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeCylinderGeom OdeGeom::convert_to_cylinder(void) const
 *******************************************************************/
static PyObject *Dtool_OdeGeom_convert_to_cylinder_297(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-OdeCylinderGeom OdeGeom::convert_to_cylinder(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":convertToCylinder", key_word_list));
        else
            (PyArg_Parse(args, ":convertToCylinder"));
        if(!PyErr_Occurred())
        {
            OdeCylinderGeom result = ((const OdeGeom*)local_this)->convert_to_cylinder();
            OdeCylinderGeom *return_value = new OdeCylinderGeom(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeCylinderGeom,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "convertToCylinder(const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_convert_to_cylinder_297_comment =
    "C++ Interface:\n"
    "convertToCylinder(const OdeGeom this)\n"
    "\n"
    "// OdeConvexGeom convert_to_convex() const;\n"
    "";
#else
static const char * Dtool_OdeGeom_convert_to_cylinder_297_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdePlaneGeom OdeGeom::convert_to_plane(void) const
 *******************************************************************/
static PyObject *Dtool_OdeGeom_convert_to_plane_298(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-OdePlaneGeom OdeGeom::convert_to_plane(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":convertToPlane", key_word_list));
        else
            (PyArg_Parse(args, ":convertToPlane"));
        if(!PyErr_Occurred())
        {
            OdePlaneGeom result = ((const OdeGeom*)local_this)->convert_to_plane();
            OdePlaneGeom *return_value = new OdePlaneGeom(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdePlaneGeom,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "convertToPlane(const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_convert_to_plane_298_comment =
    "C++ Interface:\n"
    "convertToPlane(const OdeGeom this)\n"
    "\n"
    "// OdeHeightfieldGeom convert_to_heightfield() const;\n"
    "";
#else
static const char * Dtool_OdeGeom_convert_to_plane_298_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeRayGeom OdeGeom::convert_to_ray(void) const
 *******************************************************************/
static PyObject *Dtool_OdeGeom_convert_to_ray_299(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-OdeRayGeom OdeGeom::convert_to_ray(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":convertToRay", key_word_list));
        else
            (PyArg_Parse(args, ":convertToRay"));
        if(!PyErr_Occurred())
        {
            OdeRayGeom result = ((const OdeGeom*)local_this)->convert_to_ray();
            OdeRayGeom *return_value = new OdeRayGeom(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeRayGeom,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "convertToRay(const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_convert_to_ray_299_comment =
    "C++ Interface:\n"
    "convertToRay(const OdeGeom this)\n"
    "\n"
    "// OdeHeightfieldGeom convert_to_heightfield() const;\n"
    "";
#else
static const char * Dtool_OdeGeom_convert_to_ray_299_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeSphereGeom OdeGeom::convert_to_sphere(void) const
 *******************************************************************/
static PyObject *Dtool_OdeGeom_convert_to_sphere_300(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-OdeSphereGeom OdeGeom::convert_to_sphere(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":convertToSphere", key_word_list));
        else
            (PyArg_Parse(args, ":convertToSphere"));
        if(!PyErr_Occurred())
        {
            OdeSphereGeom result = ((const OdeGeom*)local_this)->convert_to_sphere();
            OdeSphereGeom *return_value = new OdeSphereGeom(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeSphereGeom,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "convertToSphere(const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_convert_to_sphere_300_comment =
    "C++ Interface:\n"
    "convertToSphere(const OdeGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_convert_to_sphere_300_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeTriMeshGeom OdeGeom::convert_to_tri_mesh(void) const
 *******************************************************************/
static PyObject *Dtool_OdeGeom_convert_to_tri_mesh_301(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-OdeTriMeshGeom OdeGeom::convert_to_tri_mesh(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":convertToTriMesh", key_word_list));
        else
            (PyArg_Parse(args, ":convertToTriMesh"));
        if(!PyErr_Occurred())
        {
            OdeTriMeshGeom result = ((const OdeGeom*)local_this)->convert_to_tri_mesh();
            OdeTriMeshGeom *return_value = new OdeTriMeshGeom(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeTriMeshGeom,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "convertToTriMesh(const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_convert_to_tri_mesh_301_comment =
    "C++ Interface:\n"
    "convertToTriMesh(const OdeGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_convert_to_tri_mesh_301_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeSimpleSpace OdeGeom::convert_to_simple_space(void) const
 *******************************************************************/
static PyObject *Dtool_OdeGeom_convert_to_simple_space_302(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-OdeSimpleSpace OdeGeom::convert_to_simple_space(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":convertToSimpleSpace", key_word_list));
        else
            (PyArg_Parse(args, ":convertToSimpleSpace"));
        if(!PyErr_Occurred())
        {
            OdeSimpleSpace result = ((const OdeGeom*)local_this)->convert_to_simple_space();
            OdeSimpleSpace *return_value = new OdeSimpleSpace(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeSimpleSpace,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "convertToSimpleSpace(const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_convert_to_simple_space_302_comment =
    "C++ Interface:\n"
    "convertToSimpleSpace(const OdeGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_convert_to_simple_space_302_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeHashSpace OdeGeom::convert_to_hash_space(void) const
 *******************************************************************/
static PyObject *Dtool_OdeGeom_convert_to_hash_space_303(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-OdeHashSpace OdeGeom::convert_to_hash_space(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":convertToHashSpace", key_word_list));
        else
            (PyArg_Parse(args, ":convertToHashSpace"));
        if(!PyErr_Occurred())
        {
            OdeHashSpace result = ((const OdeGeom*)local_this)->convert_to_hash_space();
            OdeHashSpace *return_value = new OdeHashSpace(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeHashSpace,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "convertToHashSpace(const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_convert_to_hash_space_303_comment =
    "C++ Interface:\n"
    "convertToHashSpace(const OdeGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_convert_to_hash_space_303_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeQuadTreeSpace OdeGeom::convert_to_quad_tree_space(void) const
 *******************************************************************/
static PyObject *Dtool_OdeGeom_convert_to_quad_tree_space_304(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-OdeQuadTreeSpace OdeGeom::convert_to_quad_tree_space(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":convertToQuadTreeSpace", key_word_list));
        else
            (PyArg_Parse(args, ":convertToQuadTreeSpace"));
        if(!PyErr_Occurred())
        {
            OdeQuadTreeSpace result = ((const OdeGeom*)local_this)->convert_to_quad_tree_space();
            OdeQuadTreeSpace *return_value = new OdeQuadTreeSpace(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeQuadTreeSpace,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "convertToQuadTreeSpace(const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_convert_to_quad_tree_space_304_comment =
    "C++ Interface:\n"
    "convertToQuadTreeSpace(const OdeGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_convert_to_quad_tree_space_304_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeGeom::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeGeom_get_class_type_305(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeGeom::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeGeom::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_get_class_type_305_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_get_class_type_305_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool OdeGeom::operator typecast bool(void) const
 *******************************************************************/
static PyObject *Dtool_OdeGeom_operator_typecast_bool_293(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool OdeGeom::operator typecast bool(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":__nonzero__", key_word_list));
        else
            (PyArg_Parse(args, ":__nonzero__"));
        if(!PyErr_Occurred())
        {
            bool return_value = (bool)(*(const OdeGeom*)local_this);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__nonzero__(const OdeGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeGeom_operator_typecast_bool_293_comment =
    "C++ Interface:\n"
    "__nonzero__(const OdeGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeGeom_operator_typecast_bool_293_comment = NULL;
#endif

int  Dtool_Init_OdeGeom(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (OdeGeom)");
       return -1;
}
inline void  * Dtool_UpcastInterface_OdeGeom(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeGeom)
    {
        printf("OdeGeom ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeGeom * local_this = (OdeGeom *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeGeom)
        return local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeGeom(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeGeom)
        return from_this;
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeGeom*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeBoxGeom 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void OdeBoxGeom::set_lengths(LVecBase3f const &size)
 * inline void OdeBoxGeom::set_lengths(float lx, float ly, float lz)
 *******************************************************************/
static PyObject *Dtool_OdeBoxGeom_set_lengths_308(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBoxGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBoxGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeBoxGeom::set_lengths(LVecBase3f const &size)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"size", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setLengths", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setLengths", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeBoxGeom.setLengths", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_lengths(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeBoxGeom.setLengths() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeBoxGeom::set_lengths(float lx, float ly, float lz)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"lx", (char *)"ly", (char *)"lz", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setLengths", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_lengths((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeBoxGeom.setLengths() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setLengths() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setLengths(non-const OdeBoxGeom this, const VBase3 size)\n"
          "setLengths(non-const OdeBoxGeom this, float lx, float ly, float lz)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBoxGeom_set_lengths_308_comment =
    "C++ Interface:\n"
    "setLengths(non-const OdeBoxGeom this, const VBase3 size)\n"
    "setLengths(non-const OdeBoxGeom this, float lx, float ly, float lz)\n"
    "\n"
    "// Filename: odeBoxGeom.I\n"
    "// Created by:  joswilso (27Dec06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeBoxGeom_set_lengths_308_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f OdeBoxGeom::get_lengths(void)
 *******************************************************************/
static PyObject *Dtool_OdeBoxGeom_get_lengths_309(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBoxGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBoxGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline LVecBase3f OdeBoxGeom::get_lengths(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLengths", key_word_list));
        else
            (PyArg_Parse(args, ":getLengths"));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = (local_this)->get_lengths();
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeBoxGeom.getLengths() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLengths(non-const OdeBoxGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBoxGeom_get_lengths_309_comment =
    "C++ Interface:\n"
    "getLengths(non-const OdeBoxGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBoxGeom_get_lengths_309_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeBoxGeom::get_point_depth(LPoint3f const &p)
 * inline float OdeBoxGeom::get_point_depth(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_OdeBoxGeom_get_point_depth_310(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeBoxGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBoxGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline float OdeBoxGeom::get_point_depth(LPoint3f const &p)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"p", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:getPointDepth", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:getPointDepth", &param1));
                if(!PyErr_Occurred())
                {
                    LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "OdeBoxGeom.getPointDepth", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        float return_value = (local_this)->get_point_depth(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyFloat_FromDouble(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeBoxGeom.getPointDepth() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline float OdeBoxGeom::get_point_depth(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:getPointDepth", key_word_list, &param1, &param2, &param3))
            {
                float return_value = (local_this)->get_point_depth((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeBoxGeom.getPointDepth() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getPointDepth() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getPointDepth(non-const OdeBoxGeom this, const Point3 p)\n"
          "getPointDepth(non-const OdeBoxGeom this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBoxGeom_get_point_depth_310_comment =
    "C++ Interface:\n"
    "getPointDepth(non-const OdeBoxGeom this, const Point3 p)\n"
    "getPointDepth(non-const OdeBoxGeom this, float x, float y, float z)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBoxGeom_get_point_depth_310_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeBoxGeom::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeBoxGeom_get_class_type_311(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeBoxGeom::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeBoxGeom::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeBoxGeom_get_class_type_311_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeBoxGeom_get_class_type_311_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeBoxGeom::OdeBoxGeom(OdeSpace &space, LVecBase3f const &size)
 * OdeBoxGeom::OdeBoxGeom(OdeSpace &space, float lx, float ly, float lz)
 * OdeBoxGeom::OdeBoxGeom(float lx, float ly, float lz)
 *******************************************************************/
int  Dtool_Init_OdeBoxGeom(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeBoxGeom::OdeBoxGeom(OdeSpace &space, LVecBase3f const &size)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"space", (char *)"size", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:OdeBoxGeom", key_word_list, &param0, &param1))
                {
                    OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeSpace, 0, "OdeBoxGeom.OdeBoxGeom", 0, coerced_ptr, report_errors);
LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeBoxGeom.OdeBoxGeom", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        OdeBoxGeom *return_value = new OdeBoxGeom(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeBoxGeom,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          // 1-OdeBoxGeom::OdeBoxGeom(float lx, float ly, float lz)
            double param0;
            double param1;
            double param2;
            static char * key_word_list[] = {(char *)"lx", (char *)"ly", (char *)"lz", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:OdeBoxGeom", key_word_list, &param0, &param1, &param2))
            {
                OdeBoxGeom *return_value = new OdeBoxGeom((float)param0, (float)param1, (float)param2);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeBoxGeom,true,false);
                }
            }
        }

        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeBoxGeom::OdeBoxGeom(OdeSpace &space, float lx, float ly, float lz)
                PyObject *param0;
                double param1;
                double param2;
                double param3;
                static char * key_word_list[] = {(char *)"space", (char *)"lx", (char *)"ly", (char *)"lz", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Oddd:OdeBoxGeom", key_word_list, &param0, &param1, &param2, &param3))
                {
                    OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeSpace, 0, "OdeBoxGeom.OdeBoxGeom", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        OdeBoxGeom *return_value = new OdeBoxGeom(*param0_this, (float)param1, (float)param2, (float)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeBoxGeom,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OdeBoxGeom() takes 2, 3, or 4 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OdeBoxGeom(non-const OdeSpace space, const VBase3 size)\n"
          "OdeBoxGeom(float lx, float ly, float lz)\n"
          "OdeBoxGeom(non-const OdeSpace space, float lx, float ly, float lz)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OdeBoxGeom(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeBoxGeom)
    {
        printf("OdeBoxGeom ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeBoxGeom * local_this = (OdeBoxGeom *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeBoxGeom)
        return local_this;
    if(requested_type == &Dtool_OdeGeom)
        return ( OdeGeom *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( OdeGeom *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeBoxGeom(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeBoxGeom)
        return from_this;
    if(from_type == &Dtool_OdeGeom)
    {
          OdeGeom* other_this = (OdeGeom*)from_this;
          return (OdeBoxGeom*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeBoxGeom*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeCappedCylinderGeom 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void OdeCappedCylinderGeom::set_params(float radius, float length)
 *******************************************************************/
static PyObject *Dtool_OdeCappedCylinderGeom_set_params_314(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeCappedCylinderGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeCappedCylinderGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeCappedCylinderGeom::set_params(float radius, float length)
        double param1;
        double param2;
        static char * key_word_list[] = {(char *)"radius", (char *)"length", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:setParams", key_word_list, &param1, &param2))
        {
            (local_this)->set_params((float)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeCappedCylinderGeom.setParams() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParams(non-const OdeCappedCylinderGeom this, float radius, float length)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeCappedCylinderGeom_set_params_314_comment =
    "C++ Interface:\n"
    "setParams(non-const OdeCappedCylinderGeom this, float radius, float length)\n"
    "\n"
    "// Filename: odeCappedCylinderGeom.I\n"
    "// Created by:  joswilso (27Dec06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeCappedCylinderGeom_set_params_314_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeCappedCylinderGeom::get_radius(void) const
 *******************************************************************/
static PyObject *Dtool_OdeCappedCylinderGeom_get_radius_316(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeCappedCylinderGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeCappedCylinderGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeCappedCylinderGeom::get_radius(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRadius", key_word_list));
        else
            (PyArg_Parse(args, ":getRadius"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeCappedCylinderGeom*)local_this)->get_radius();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRadius(const OdeCappedCylinderGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeCappedCylinderGeom_get_radius_316_comment =
    "C++ Interface:\n"
    "getRadius(const OdeCappedCylinderGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeCappedCylinderGeom_get_radius_316_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeCappedCylinderGeom::get_length(void) const
 *******************************************************************/
static PyObject *Dtool_OdeCappedCylinderGeom_get_length_317(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeCappedCylinderGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeCappedCylinderGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeCappedCylinderGeom::get_length(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLength", key_word_list));
        else
            (PyArg_Parse(args, ":getLength"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeCappedCylinderGeom*)local_this)->get_length();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLength(const OdeCappedCylinderGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeCappedCylinderGeom_get_length_317_comment =
    "C++ Interface:\n"
    "getLength(const OdeCappedCylinderGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeCappedCylinderGeom_get_length_317_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeCappedCylinderGeom::get_point_depth(LPoint3f const &p) const
 * inline float OdeCappedCylinderGeom::get_point_depth(float x, float y, float z) const
 *******************************************************************/
static PyObject *Dtool_OdeCappedCylinderGeom_get_point_depth_318(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeCappedCylinderGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeCappedCylinderGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline float OdeCappedCylinderGeom::get_point_depth(LPoint3f const &p) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"p", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:getPointDepth", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:getPointDepth", &param1));
                if(!PyErr_Occurred())
                {
                    LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "OdeCappedCylinderGeom.getPointDepth", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        float return_value = ((const OdeCappedCylinderGeom*)local_this)->get_point_depth(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyFloat_FromDouble(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          // 1-inline float OdeCappedCylinderGeom::get_point_depth(float x, float y, float z) const
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:getPointDepth", key_word_list, &param1, &param2, &param3))
            {
                float return_value = ((const OdeCappedCylinderGeom*)local_this)->get_point_depth((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getPointDepth() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getPointDepth(const OdeCappedCylinderGeom this, const Point3 p)\n"
          "getPointDepth(const OdeCappedCylinderGeom this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeCappedCylinderGeom_get_point_depth_318_comment =
    "C++ Interface:\n"
    "getPointDepth(const OdeCappedCylinderGeom this, const Point3 p)\n"
    "getPointDepth(const OdeCappedCylinderGeom this, float x, float y, float z)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeCappedCylinderGeom_get_point_depth_318_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeCappedCylinderGeom::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeCappedCylinderGeom_get_class_type_319(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeCappedCylinderGeom::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeCappedCylinderGeom::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeCappedCylinderGeom_get_class_type_319_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeCappedCylinderGeom_get_class_type_319_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeCappedCylinderGeom::OdeCappedCylinderGeom(OdeSpace &space, float radius, float length)
 * OdeCappedCylinderGeom::OdeCappedCylinderGeom(float radius, float length)
 *******************************************************************/
int  Dtool_Init_OdeCappedCylinderGeom(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          // 1-OdeCappedCylinderGeom::OdeCappedCylinderGeom(float radius, float length)
            double param0;
            double param1;
            static char * key_word_list[] = {(char *)"radius", (char *)"length", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:OdeCappedCylinderGeom", key_word_list, &param0, &param1))
            {
                OdeCappedCylinderGeom *return_value = new OdeCappedCylinderGeom((float)param0, (float)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeCappedCylinderGeom,true,false);
                }
            }
        }

        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeCappedCylinderGeom::OdeCappedCylinderGeom(OdeSpace &space, float radius, float length)
                PyObject *param0;
                double param1;
                double param2;
                static char * key_word_list[] = {(char *)"space", (char *)"radius", (char *)"length", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Odd:OdeCappedCylinderGeom", key_word_list, &param0, &param1, &param2))
                {
                    OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeSpace, 0, "OdeCappedCylinderGeom.OdeCappedCylinderGeom", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        OdeCappedCylinderGeom *return_value = new OdeCappedCylinderGeom(*param0_this, (float)param1, (float)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeCappedCylinderGeom,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OdeCappedCylinderGeom() takes 2 or 3 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OdeCappedCylinderGeom(float radius, float length)\n"
          "OdeCappedCylinderGeom(non-const OdeSpace space, float radius, float length)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OdeCappedCylinderGeom(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeCappedCylinderGeom)
    {
        printf("OdeCappedCylinderGeom ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeCappedCylinderGeom * local_this = (OdeCappedCylinderGeom *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeCappedCylinderGeom)
        return local_this;
    if(requested_type == &Dtool_OdeGeom)
        return ( OdeGeom *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( OdeGeom *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeCappedCylinderGeom(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeCappedCylinderGeom)
        return from_this;
    if(from_type == &Dtool_OdeGeom)
    {
          OdeGeom* other_this = (OdeGeom*)from_this;
          return (OdeCappedCylinderGeom*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeCappedCylinderGeom*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeContactGeom 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f OdeContactGeom::get_pos(void) const
 *******************************************************************/
static PyObject *Dtool_OdeContactGeom_get_pos_322(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeContactGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeContactGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f OdeContactGeom::get_pos(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPos", key_word_list));
        else
            (PyArg_Parse(args, ":getPos"));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const OdeContactGeom*)local_this)->get_pos();
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPos(const OdeContactGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeContactGeom_get_pos_322_comment =
    "C++ Interface:\n"
    "getPos(const OdeContactGeom this)\n"
    "\n"
    "// Filename: odeContactGeom.I\n"
    "// Created by:  joswilso (27Dec06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeContactGeom_get_pos_322_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f OdeContactGeom::get_normal(void) const
 *******************************************************************/
static PyObject *Dtool_OdeContactGeom_get_normal_323(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeContactGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeContactGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f OdeContactGeom::get_normal(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNormal", key_word_list));
        else
            (PyArg_Parse(args, ":getNormal"));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const OdeContactGeom*)local_this)->get_normal();
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNormal(const OdeContactGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeContactGeom_get_normal_323_comment =
    "C++ Interface:\n"
    "getNormal(const OdeContactGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeContactGeom_get_normal_323_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeContactGeom::get_depth(void) const
 *******************************************************************/
static PyObject *Dtool_OdeContactGeom_get_depth_324(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeContactGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeContactGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeContactGeom::get_depth(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDepth", key_word_list));
        else
            (PyArg_Parse(args, ":getDepth"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeContactGeom*)local_this)->get_depth();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDepth(const OdeContactGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeContactGeom_get_depth_324_comment =
    "C++ Interface:\n"
    "getDepth(const OdeContactGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeContactGeom_get_depth_324_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline OdeGeom OdeContactGeom::get_g1(void) const
 *******************************************************************/
static PyObject *Dtool_OdeContactGeom_get_g1_325(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeContactGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeContactGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline OdeGeom OdeContactGeom::get_g1(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getG1", key_word_list));
        else
            (PyArg_Parse(args, ":getG1"));
        if(!PyErr_Occurred())
        {
            OdeGeom result = ((const OdeContactGeom*)local_this)->get_g1();
            OdeGeom *return_value = new OdeGeom(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeGeom,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getG1(const OdeContactGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeContactGeom_get_g1_325_comment =
    "C++ Interface:\n"
    "getG1(const OdeContactGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeContactGeom_get_g1_325_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline OdeGeom OdeContactGeom::get_g2(void) const
 *******************************************************************/
static PyObject *Dtool_OdeContactGeom_get_g2_326(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeContactGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeContactGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline OdeGeom OdeContactGeom::get_g2(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getG2", key_word_list));
        else
            (PyArg_Parse(args, ":getG2"));
        if(!PyErr_Occurred())
        {
            OdeGeom result = ((const OdeContactGeom*)local_this)->get_g2();
            OdeGeom *return_value = new OdeGeom(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeGeom,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getG2(const OdeContactGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeContactGeom_get_g2_326_comment =
    "C++ Interface:\n"
    "getG2(const OdeContactGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeContactGeom_get_g2_326_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeContactGeom::get_side1(void) const
 *******************************************************************/
static PyObject *Dtool_OdeContactGeom_get_side1_327(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeContactGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeContactGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int OdeContactGeom::get_side1(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSide1", key_word_list));
        else
            (PyArg_Parse(args, ":getSide1"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const OdeContactGeom*)local_this)->get_side1();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSide1(const OdeContactGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeContactGeom_get_side1_327_comment =
    "C++ Interface:\n"
    "getSide1(const OdeContactGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeContactGeom_get_side1_327_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeContactGeom::get_side2(void) const
 *******************************************************************/
static PyObject *Dtool_OdeContactGeom_get_side2_328(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeContactGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeContactGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int OdeContactGeom::get_side2(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSide2", key_word_list));
        else
            (PyArg_Parse(args, ":getSide2"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const OdeContactGeom*)local_this)->get_side2();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSide2(const OdeContactGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeContactGeom_get_side2_328_comment =
    "C++ Interface:\n"
    "getSide2(const OdeContactGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeContactGeom_get_side2_328_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeContactGeom::set_pos(LVecBase3f const &pos)
 *******************************************************************/
static PyObject *Dtool_OdeContactGeom_set_pos_329(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeContactGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeContactGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeContactGeom::set_pos(LVecBase3f const &pos)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"pos", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setPos", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setPos", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeContactGeom.setPos", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_pos(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeContactGeom.setPos() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setPos(non-const OdeContactGeom this, const VBase3 pos)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeContactGeom_set_pos_329_comment =
    "C++ Interface:\n"
    "setPos(non-const OdeContactGeom this, const VBase3 pos)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeContactGeom_set_pos_329_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeContactGeom::set_normal(LVecBase3f const &normal)
 *******************************************************************/
static PyObject *Dtool_OdeContactGeom_set_normal_330(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeContactGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeContactGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeContactGeom::set_normal(LVecBase3f const &normal)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"normal", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setNormal", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setNormal", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeContactGeom.setNormal", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_normal(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeContactGeom.setNormal() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setNormal(non-const OdeContactGeom this, const VBase3 normal)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeContactGeom_set_normal_330_comment =
    "C++ Interface:\n"
    "setNormal(non-const OdeContactGeom this, const VBase3 normal)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeContactGeom_set_normal_330_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeContactGeom::set_depth(float const depth)
 *******************************************************************/
static PyObject *Dtool_OdeContactGeom_set_depth_331(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeContactGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeContactGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeContactGeom::set_depth(float const depth)
        double param1;
        static char * key_word_list[] = {(char *)"depth", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setDepth", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setDepth", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_depth((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeContactGeom.setDepth() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setDepth(non-const OdeContactGeom this, float depth)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeContactGeom_set_depth_331_comment =
    "C++ Interface:\n"
    "setDepth(non-const OdeContactGeom this, float depth)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeContactGeom_set_depth_331_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeContactGeom::set_g1(OdeGeom const &geom)
 *******************************************************************/
static PyObject *Dtool_OdeContactGeom_set_g1_332(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeContactGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeContactGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeContactGeom::set_g1(OdeGeom const &geom)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"geom", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setG1", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setG1", &param1));
            if(!PyErr_Occurred())
            {
                OdeGeom *param1_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeGeom, 1, "OdeContactGeom.setG1", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_g1(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeContactGeom.setG1() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setG1(non-const OdeContactGeom this, const OdeGeom geom)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeContactGeom_set_g1_332_comment =
    "C++ Interface:\n"
    "setG1(non-const OdeContactGeom this, const OdeGeom geom)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeContactGeom_set_g1_332_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeContactGeom::set_g2(OdeGeom const &geom)
 *******************************************************************/
static PyObject *Dtool_OdeContactGeom_set_g2_333(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeContactGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeContactGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeContactGeom::set_g2(OdeGeom const &geom)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"geom", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setG2", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setG2", &param1));
            if(!PyErr_Occurred())
            {
                OdeGeom *param1_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeGeom, 1, "OdeContactGeom.setG2", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_g2(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeContactGeom.setG2() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setG2(non-const OdeContactGeom this, const OdeGeom geom)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeContactGeom_set_g2_333_comment =
    "C++ Interface:\n"
    "setG2(non-const OdeContactGeom this, const OdeGeom geom)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeContactGeom_set_g2_333_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeContactGeom::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeContactGeom_get_class_type_334(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeContactGeom::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeContactGeom::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeContactGeom_get_class_type_334_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeContactGeom_get_class_type_334_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeContactGeom::OdeContactGeom(void)
 * OdeContactGeom::OdeContactGeom(OdeContactGeom const &copy)
 *******************************************************************/
int  Dtool_Init_OdeContactGeom(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-OdeContactGeom::OdeContactGeom(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":OdeContactGeom", key_word_list))
            {
                OdeContactGeom *return_value = new OdeContactGeom();
                return_value->ref();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeContactGeom,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeContactGeom::OdeContactGeom(OdeContactGeom const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:OdeContactGeom", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:OdeContactGeom", &param0));
                if(!PyErr_Occurred())
                {
                    OdeContactGeom *param0_this = (OdeContactGeom *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeContactGeom, 0, "OdeContactGeom.OdeContactGeom", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        OdeContactGeom *return_value = new OdeContactGeom(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeContactGeom,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OdeContactGeom() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OdeContactGeom()\n"
          "OdeContactGeom(const OdeContactGeom copy)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OdeContactGeom(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeContactGeom)
    {
        printf("OdeContactGeom ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeContactGeom * local_this = (OdeContactGeom *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeContactGeom)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeContactGeom(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeContactGeom)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (OdeContactGeom*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeContactGeom*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (OdeContactGeom*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeCollisionEntry 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline OdeGeom const OdeCollisionEntry::get_geom1(void) const
 *******************************************************************/
static PyObject *Dtool_OdeCollisionEntry_get_geom1_336(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeCollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeCollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline OdeGeom const OdeCollisionEntry::get_geom1(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getGeom1", key_word_list));
        else
            (PyArg_Parse(args, ":getGeom1"));
        if(!PyErr_Occurred())
        {
            OdeGeom const result = ((const OdeCollisionEntry*)local_this)->get_geom1();
            OdeGeom const *return_value = new OdeGeom const(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeGeom,true, true, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGeom1(const OdeCollisionEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeCollisionEntry_get_geom1_336_comment =
    "C++ Interface:\n"
    "getGeom1(const OdeCollisionEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OdeCollisionEntry::get_geom1\n"
    "//       Access: Published\n"
    "//  Description: Returns the first geom in the collision.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeCollisionEntry_get_geom1_336_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline OdeGeom const OdeCollisionEntry::get_geom2(void) const
 *******************************************************************/
static PyObject *Dtool_OdeCollisionEntry_get_geom2_337(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeCollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeCollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline OdeGeom const OdeCollisionEntry::get_geom2(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getGeom2", key_word_list));
        else
            (PyArg_Parse(args, ":getGeom2"));
        if(!PyErr_Occurred())
        {
            OdeGeom const result = ((const OdeCollisionEntry*)local_this)->get_geom2();
            OdeGeom const *return_value = new OdeGeom const(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeGeom,true, true, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGeom2(const OdeCollisionEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeCollisionEntry_get_geom2_337_comment =
    "C++ Interface:\n"
    "getGeom2(const OdeCollisionEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OdeCollisionEntry::get_geom2\n"
    "//       Access: Published\n"
    "//  Description: Returns the second geom in the collision.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeCollisionEntry_get_geom2_337_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline OdeBody const OdeCollisionEntry::get_body1(void) const
 *******************************************************************/
static PyObject *Dtool_OdeCollisionEntry_get_body1_338(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeCollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeCollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline OdeBody const OdeCollisionEntry::get_body1(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBody1", key_word_list));
        else
            (PyArg_Parse(args, ":getBody1"));
        if(!PyErr_Occurred())
        {
            OdeBody const result = ((const OdeCollisionEntry*)local_this)->get_body1();
            OdeBody const *return_value = new OdeBody const(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeBody,true, true, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBody1(const OdeCollisionEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeCollisionEntry_get_body1_338_comment =
    "C++ Interface:\n"
    "getBody1(const OdeCollisionEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OdeCollisionEntry::get_body1\n"
    "//       Access: Published\n"
    "//  Description: Returns the first body in the collision.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeCollisionEntry_get_body1_338_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline OdeBody const OdeCollisionEntry::get_body2(void) const
 *******************************************************************/
static PyObject *Dtool_OdeCollisionEntry_get_body2_339(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeCollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeCollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline OdeBody const OdeCollisionEntry::get_body2(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBody2", key_word_list));
        else
            (PyArg_Parse(args, ":getBody2"));
        if(!PyErr_Occurred())
        {
            OdeBody const result = ((const OdeCollisionEntry*)local_this)->get_body2();
            OdeBody const *return_value = new OdeBody const(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeBody,true, true, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBody2(const OdeCollisionEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeCollisionEntry_get_body2_339_comment =
    "C++ Interface:\n"
    "getBody2(const OdeCollisionEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OdeCollisionEntry::get_body2\n"
    "//       Access: Published\n"
    "//  Description: Returns the second body in the collision.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeCollisionEntry_get_body2_339_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline unsigned int const OdeCollisionEntry::get_num_contacts(void) const
 *******************************************************************/
static PyObject *Dtool_OdeCollisionEntry_get_num_contacts_340(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeCollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeCollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline unsigned int const OdeCollisionEntry::get_num_contacts(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumContacts", key_word_list));
        else
            (PyArg_Parse(args, ":getNumContacts"));
        if(!PyErr_Occurred())
        {
            unsigned int return_value = ((const OdeCollisionEntry*)local_this)->get_num_contacts();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyLongOrInt_FromUnsignedLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumContacts(const OdeCollisionEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeCollisionEntry_get_num_contacts_340_comment =
    "C++ Interface:\n"
    "getNumContacts(const OdeCollisionEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OdeCollisionEntry::get_num_contacts\n"
    "//       Access: Published\n"
    "//  Description: Returns the number of contacts in the collision.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeCollisionEntry_get_num_contacts_340_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f const OdeCollisionEntry::get_contact_point(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_OdeCollisionEntry_get_contact_point_341(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeCollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeCollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f const OdeCollisionEntry::get_contact_point(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getContactPoint", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getContactPoint", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                LPoint3f const result = ((const OdeCollisionEntry*)local_this)->get_contact_point(PyLong_AsUnsignedLong(param1_uint));
                LPoint3f const *return_value = new LPoint3f const(result);
                 Py_XDECREF(param1_uint);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, true);
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getContactPoint(const OdeCollisionEntry this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeCollisionEntry_get_contact_point_341_comment =
    "C++ Interface:\n"
    "getContactPoint(const OdeCollisionEntry this, unsigned int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OdeCollisionEntry::get_contact_point\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth contact point in the collision.\n"
    "//               This does exactly the same as\n"
    "//               get_contact_geom(n).get_pos().\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeCollisionEntry_get_contact_point_341_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline OdeContactGeom const OdeCollisionEntry::get_contact_geom(unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_OdeCollisionEntry_get_contact_geom_342(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeCollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeCollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline OdeContactGeom const OdeCollisionEntry::get_contact_geom(unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:getContactGeom", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:getContactGeom", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                OdeContactGeom const result = ((const OdeCollisionEntry*)local_this)->get_contact_geom(PyLong_AsUnsignedLong(param1_uint));
                OdeContactGeom const *return_value = new OdeContactGeom const(result);
                 Py_XDECREF(param1_uint);
                if (return_value != (OdeContactGeom const *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeContactGeom,true, true, (return_value)->as_typed_object()->get_type_index());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getContactGeom(const OdeCollisionEntry this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeCollisionEntry_get_contact_geom_342_comment =
    "C++ Interface:\n"
    "getContactGeom(const OdeCollisionEntry this, unsigned int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OdeCollisionEntry::get_contact_geom\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth contact geom in the collision.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeCollisionEntry_get_contact_geom_342_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline OdeContactGeom const OdeCollisionEntry::operator [](unsigned int n) const
 *******************************************************************/
static PyObject *Dtool_OdeCollisionEntry_operator_343(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeCollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeCollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline OdeContactGeom const OdeCollisionEntry::operator [](unsigned int n) const
        PyObject *param1;
        static char * key_word_list[] = {(char *)"n", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "O:__getitem__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "O:__getitem__", &param1));
        if(!PyErr_Occurred())
        {
             PyObject *param1_uint = PyNumber_Long(param1);
            if (!((param1_uint == NULL)))
            {
                OdeContactGeom const result = ((const OdeCollisionEntry*)local_this)->operator [](PyLong_AsUnsignedLong(param1_uint));
                OdeContactGeom const *return_value = new OdeContactGeom const(result);
                 Py_XDECREF(param1_uint);
                if (return_value != (OdeContactGeom const *)0) {
                  return_value->ref();
                }
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  if(return_value == NULL)
                  {
                      Py_INCREF(Py_None);
                      return Py_None;
                  }
                  return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeContactGeom,true, true, (return_value)->as_typed_object()->get_type_index());
                }
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__getitem__(const OdeCollisionEntry this, unsigned int n)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeCollisionEntry_operator_343_comment =
    "C++ Interface:\n"
    "__getitem__(const OdeCollisionEntry this, unsigned int n)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OdeCollisionEntry::operator []\n"
    "//       Access: Published\n"
    "//  Description: Returns the nth contact geom in the collision.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeCollisionEntry_operator_343_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool OdeCollisionEntry::is_empty(void) const
 *******************************************************************/
static PyObject *Dtool_OdeCollisionEntry_is_empty_345(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeCollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeCollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool OdeCollisionEntry::is_empty(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isEmpty", key_word_list));
        else
            (PyArg_Parse(args, ":isEmpty"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const OdeCollisionEntry*)local_this)->is_empty();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isEmpty(const OdeCollisionEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeCollisionEntry_is_empty_345_comment =
    "C++ Interface:\n"
    "isEmpty(const OdeCollisionEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OdeCollisionEntry::is_empty\n"
    "//       Access: Published\n"
    "//  Description: Returns true if the entry holds no contacts.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeCollisionEntry_is_empty_345_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeCollisionEntry::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeCollisionEntry_get_class_type_346(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeCollisionEntry::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeCollisionEntry::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeCollisionEntry_get_class_type_346_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeCollisionEntry_get_class_type_346_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool OdeCollisionEntry::operator typecast bool(void) const
 *******************************************************************/
static PyObject *Dtool_OdeCollisionEntry_operator_typecast_bool_344(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeCollisionEntry * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeCollisionEntry,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline bool OdeCollisionEntry::operator typecast bool(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":__nonzero__", key_word_list));
        else
            (PyArg_Parse(args, ":__nonzero__"));
        if(!PyErr_Occurred())
        {
            bool return_value = (bool)(*(const OdeCollisionEntry*)local_this);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__nonzero__(const OdeCollisionEntry this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeCollisionEntry_operator_typecast_bool_344_comment =
    "C++ Interface:\n"
    "__nonzero__(const OdeCollisionEntry this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OdeCollisionEntry::operator bool\n"
    "//       Access: Published\n"
    "//  Description: An OdeCollisionEntry evaluates to False if it\n"
    "//               holds no contacts.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeCollisionEntry_operator_typecast_bool_344_comment = NULL;
#endif

int  Dtool_Init_OdeCollisionEntry(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (OdeCollisionEntry)");
       return -1;
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_OdeCollisionEntry_get_contact_points(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumContacts", "getContactPoint");
}
/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_OdeCollisionEntry_get_contact_geoms(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumContacts", "getContactGeom");
}
inline void  * Dtool_UpcastInterface_OdeCollisionEntry(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeCollisionEntry)
    {
        printf("OdeCollisionEntry ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeCollisionEntry * local_this = (OdeCollisionEntry *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeCollisionEntry)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeCollisionEntry(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeCollisionEntry)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (OdeCollisionEntry*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeCollisionEntry*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (OdeCollisionEntry*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeSurfaceParameters 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void OdeSurfaceParameters::set_mode(int mode)
 *******************************************************************/
static PyObject *Dtool_OdeSurfaceParameters_set_mode_350(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSurfaceParameters * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSurfaceParameters,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeSurfaceParameters::set_mode(int mode)
        int param1;
        static char * key_word_list[] = {(char *)"mode", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setMode", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setMode", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_mode((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSurfaceParameters.setMode() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMode(non-const OdeSurfaceParameters this, int mode)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSurfaceParameters_set_mode_350_comment =
    "C++ Interface:\n"
    "setMode(non-const OdeSurfaceParameters this, int mode)\n"
    "\n"
    "// Filename: odeSurfaceParameters.I\n"
    "// Created by:  joswilso (27Dec06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeSurfaceParameters_set_mode_350_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeSurfaceParameters::set_mu(float mu)
 *******************************************************************/
static PyObject *Dtool_OdeSurfaceParameters_set_mu_351(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSurfaceParameters * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSurfaceParameters,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeSurfaceParameters::set_mu(float mu)
        double param1;
        static char * key_word_list[] = {(char *)"mu", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setMu", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setMu", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_mu((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSurfaceParameters.setMu() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMu(non-const OdeSurfaceParameters this, float mu)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSurfaceParameters_set_mu_351_comment =
    "C++ Interface:\n"
    "setMu(non-const OdeSurfaceParameters this, float mu)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSurfaceParameters_set_mu_351_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeSurfaceParameters::set_mu2(float mu2)
 *******************************************************************/
static PyObject *Dtool_OdeSurfaceParameters_set_mu2_352(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSurfaceParameters * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSurfaceParameters,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeSurfaceParameters::set_mu2(float mu2)
        double param1;
        static char * key_word_list[] = {(char *)"mu2", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setMu2", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setMu2", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_mu2((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSurfaceParameters.setMu2() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMu2(non-const OdeSurfaceParameters this, float mu2)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSurfaceParameters_set_mu2_352_comment =
    "C++ Interface:\n"
    "setMu2(non-const OdeSurfaceParameters this, float mu2)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSurfaceParameters_set_mu2_352_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeSurfaceParameters::set_bounce(float bounce)
 *******************************************************************/
static PyObject *Dtool_OdeSurfaceParameters_set_bounce_353(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSurfaceParameters * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSurfaceParameters,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeSurfaceParameters::set_bounce(float bounce)
        double param1;
        static char * key_word_list[] = {(char *)"bounce", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setBounce", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setBounce", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_bounce((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSurfaceParameters.setBounce() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBounce(non-const OdeSurfaceParameters this, float bounce)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSurfaceParameters_set_bounce_353_comment =
    "C++ Interface:\n"
    "setBounce(non-const OdeSurfaceParameters this, float bounce)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSurfaceParameters_set_bounce_353_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeSurfaceParameters::set_bounce_vel(float bounce_vel)
 *******************************************************************/
static PyObject *Dtool_OdeSurfaceParameters_set_bounce_vel_354(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSurfaceParameters * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSurfaceParameters,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeSurfaceParameters::set_bounce_vel(float bounce_vel)
        double param1;
        static char * key_word_list[] = {(char *)"bounce_vel", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setBounceVel", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setBounceVel", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_bounce_vel((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSurfaceParameters.setBounceVel() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setBounceVel(non-const OdeSurfaceParameters this, float bounce_vel)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSurfaceParameters_set_bounce_vel_354_comment =
    "C++ Interface:\n"
    "setBounceVel(non-const OdeSurfaceParameters this, float bounce_vel)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSurfaceParameters_set_bounce_vel_354_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeSurfaceParameters::set_soft_erp(float soft_erp)
 *******************************************************************/
static PyObject *Dtool_OdeSurfaceParameters_set_soft_erp_355(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSurfaceParameters * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSurfaceParameters,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeSurfaceParameters::set_soft_erp(float soft_erp)
        double param1;
        static char * key_word_list[] = {(char *)"soft_erp", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setSoftErp", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setSoftErp", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_soft_erp((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSurfaceParameters.setSoftErp() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSoftErp(non-const OdeSurfaceParameters this, float soft_erp)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSurfaceParameters_set_soft_erp_355_comment =
    "C++ Interface:\n"
    "setSoftErp(non-const OdeSurfaceParameters this, float soft_erp)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSurfaceParameters_set_soft_erp_355_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeSurfaceParameters::set_soft_cfm(float soft_cfm)
 *******************************************************************/
static PyObject *Dtool_OdeSurfaceParameters_set_soft_cfm_356(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSurfaceParameters * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSurfaceParameters,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeSurfaceParameters::set_soft_cfm(float soft_cfm)
        double param1;
        static char * key_word_list[] = {(char *)"soft_cfm", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setSoftCfm", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setSoftCfm", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_soft_cfm((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSurfaceParameters.setSoftCfm() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSoftCfm(non-const OdeSurfaceParameters this, float soft_cfm)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSurfaceParameters_set_soft_cfm_356_comment =
    "C++ Interface:\n"
    "setSoftCfm(non-const OdeSurfaceParameters this, float soft_cfm)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSurfaceParameters_set_soft_cfm_356_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeSurfaceParameters::set_motion1(float motion)
 *******************************************************************/
static PyObject *Dtool_OdeSurfaceParameters_set_motion1_357(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSurfaceParameters * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSurfaceParameters,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeSurfaceParameters::set_motion1(float motion)
        double param1;
        static char * key_word_list[] = {(char *)"motion", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setMotion1", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setMotion1", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_motion1((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSurfaceParameters.setMotion1() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMotion1(non-const OdeSurfaceParameters this, float motion)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSurfaceParameters_set_motion1_357_comment =
    "C++ Interface:\n"
    "setMotion1(non-const OdeSurfaceParameters this, float motion)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSurfaceParameters_set_motion1_357_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeSurfaceParameters::set_motion2(float motion)
 *******************************************************************/
static PyObject *Dtool_OdeSurfaceParameters_set_motion2_358(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSurfaceParameters * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSurfaceParameters,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeSurfaceParameters::set_motion2(float motion)
        double param1;
        static char * key_word_list[] = {(char *)"motion", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setMotion2", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setMotion2", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_motion2((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSurfaceParameters.setMotion2() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setMotion2(non-const OdeSurfaceParameters this, float motion)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSurfaceParameters_set_motion2_358_comment =
    "C++ Interface:\n"
    "setMotion2(non-const OdeSurfaceParameters this, float motion)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSurfaceParameters_set_motion2_358_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeSurfaceParameters::set_slip1(float slip)
 *******************************************************************/
static PyObject *Dtool_OdeSurfaceParameters_set_slip1_359(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSurfaceParameters * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSurfaceParameters,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeSurfaceParameters::set_slip1(float slip)
        double param1;
        static char * key_word_list[] = {(char *)"slip", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setSlip1", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setSlip1", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_slip1((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSurfaceParameters.setSlip1() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSlip1(non-const OdeSurfaceParameters this, float slip)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSurfaceParameters_set_slip1_359_comment =
    "C++ Interface:\n"
    "setSlip1(non-const OdeSurfaceParameters this, float slip)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSurfaceParameters_set_slip1_359_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeSurfaceParameters::set_slip2(float slip)
 *******************************************************************/
static PyObject *Dtool_OdeSurfaceParameters_set_slip2_360(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSurfaceParameters * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSurfaceParameters,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeSurfaceParameters::set_slip2(float slip)
        double param1;
        static char * key_word_list[] = {(char *)"slip", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setSlip2", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setSlip2", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_slip2((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSurfaceParameters.setSlip2() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSlip2(non-const OdeSurfaceParameters this, float slip)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSurfaceParameters_set_slip2_360_comment =
    "C++ Interface:\n"
    "setSlip2(non-const OdeSurfaceParameters this, float slip)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSurfaceParameters_set_slip2_360_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeSurfaceParameters::get_mode(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSurfaceParameters_get_mode_361(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSurfaceParameters * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSurfaceParameters,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int OdeSurfaceParameters::get_mode(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMode", key_word_list));
        else
            (PyArg_Parse(args, ":getMode"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const OdeSurfaceParameters*)local_this)->get_mode();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMode(const OdeSurfaceParameters this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSurfaceParameters_get_mode_361_comment =
    "C++ Interface:\n"
    "getMode(const OdeSurfaceParameters this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSurfaceParameters_get_mode_361_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeSurfaceParameters::get_mu(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSurfaceParameters_get_mu_362(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSurfaceParameters * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSurfaceParameters,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeSurfaceParameters::get_mu(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMu", key_word_list));
        else
            (PyArg_Parse(args, ":getMu"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeSurfaceParameters*)local_this)->get_mu();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMu(const OdeSurfaceParameters this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSurfaceParameters_get_mu_362_comment =
    "C++ Interface:\n"
    "getMu(const OdeSurfaceParameters this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSurfaceParameters_get_mu_362_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeSurfaceParameters::get_mu2(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSurfaceParameters_get_mu2_363(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSurfaceParameters * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSurfaceParameters,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeSurfaceParameters::get_mu2(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMu2", key_word_list));
        else
            (PyArg_Parse(args, ":getMu2"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeSurfaceParameters*)local_this)->get_mu2();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMu2(const OdeSurfaceParameters this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSurfaceParameters_get_mu2_363_comment =
    "C++ Interface:\n"
    "getMu2(const OdeSurfaceParameters this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSurfaceParameters_get_mu2_363_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeSurfaceParameters::get_bounce(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSurfaceParameters_get_bounce_364(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSurfaceParameters * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSurfaceParameters,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeSurfaceParameters::get_bounce(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBounce", key_word_list));
        else
            (PyArg_Parse(args, ":getBounce"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeSurfaceParameters*)local_this)->get_bounce();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBounce(const OdeSurfaceParameters this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSurfaceParameters_get_bounce_364_comment =
    "C++ Interface:\n"
    "getBounce(const OdeSurfaceParameters this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSurfaceParameters_get_bounce_364_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeSurfaceParameters::get_bounce_vel(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSurfaceParameters_get_bounce_vel_365(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSurfaceParameters * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSurfaceParameters,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeSurfaceParameters::get_bounce_vel(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBounceVel", key_word_list));
        else
            (PyArg_Parse(args, ":getBounceVel"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeSurfaceParameters*)local_this)->get_bounce_vel();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBounceVel(const OdeSurfaceParameters this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSurfaceParameters_get_bounce_vel_365_comment =
    "C++ Interface:\n"
    "getBounceVel(const OdeSurfaceParameters this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSurfaceParameters_get_bounce_vel_365_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeSurfaceParameters::get_soft_erp(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSurfaceParameters_get_soft_erp_366(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSurfaceParameters * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSurfaceParameters,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeSurfaceParameters::get_soft_erp(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSoftErp", key_word_list));
        else
            (PyArg_Parse(args, ":getSoftErp"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeSurfaceParameters*)local_this)->get_soft_erp();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSoftErp(const OdeSurfaceParameters this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSurfaceParameters_get_soft_erp_366_comment =
    "C++ Interface:\n"
    "getSoftErp(const OdeSurfaceParameters this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSurfaceParameters_get_soft_erp_366_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeSurfaceParameters::get_soft_cfm(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSurfaceParameters_get_soft_cfm_367(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSurfaceParameters * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSurfaceParameters,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeSurfaceParameters::get_soft_cfm(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSoftCfm", key_word_list));
        else
            (PyArg_Parse(args, ":getSoftCfm"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeSurfaceParameters*)local_this)->get_soft_cfm();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSoftCfm(const OdeSurfaceParameters this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSurfaceParameters_get_soft_cfm_367_comment =
    "C++ Interface:\n"
    "getSoftCfm(const OdeSurfaceParameters this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSurfaceParameters_get_soft_cfm_367_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeSurfaceParameters::get_motion1(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSurfaceParameters_get_motion1_368(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSurfaceParameters * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSurfaceParameters,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeSurfaceParameters::get_motion1(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMotion1", key_word_list));
        else
            (PyArg_Parse(args, ":getMotion1"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeSurfaceParameters*)local_this)->get_motion1();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMotion1(const OdeSurfaceParameters this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSurfaceParameters_get_motion1_368_comment =
    "C++ Interface:\n"
    "getMotion1(const OdeSurfaceParameters this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSurfaceParameters_get_motion1_368_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeSurfaceParameters::get_motion2(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSurfaceParameters_get_motion2_369(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSurfaceParameters * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSurfaceParameters,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeSurfaceParameters::get_motion2(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMotion2", key_word_list));
        else
            (PyArg_Parse(args, ":getMotion2"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeSurfaceParameters*)local_this)->get_motion2();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMotion2(const OdeSurfaceParameters this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSurfaceParameters_get_motion2_369_comment =
    "C++ Interface:\n"
    "getMotion2(const OdeSurfaceParameters this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSurfaceParameters_get_motion2_369_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeSurfaceParameters::get_slip1(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSurfaceParameters_get_slip1_370(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSurfaceParameters * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSurfaceParameters,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeSurfaceParameters::get_slip1(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSlip1", key_word_list));
        else
            (PyArg_Parse(args, ":getSlip1"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeSurfaceParameters*)local_this)->get_slip1();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSlip1(const OdeSurfaceParameters this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSurfaceParameters_get_slip1_370_comment =
    "C++ Interface:\n"
    "getSlip1(const OdeSurfaceParameters this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSurfaceParameters_get_slip1_370_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeSurfaceParameters::get_slip2(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSurfaceParameters_get_slip2_371(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSurfaceParameters * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSurfaceParameters,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeSurfaceParameters::get_slip2(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSlip2", key_word_list));
        else
            (PyArg_Parse(args, ":getSlip2"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeSurfaceParameters*)local_this)->get_slip2();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSlip2(const OdeSurfaceParameters this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSurfaceParameters_get_slip2_371_comment =
    "C++ Interface:\n"
    "getSlip2(const OdeSurfaceParameters this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSurfaceParameters_get_slip2_371_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeSurfaceParameters::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeSurfaceParameters_get_class_type_372(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeSurfaceParameters::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeSurfaceParameters::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSurfaceParameters_get_class_type_372_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSurfaceParameters_get_class_type_372_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeSurfaceParameters::OdeSurfaceParameters(int mode, float mu)
 * OdeSurfaceParameters::OdeSurfaceParameters(int mode, float mu = (0))
 * OdeSurfaceParameters::OdeSurfaceParameters(int mode = (0), float mu = (0))
 *******************************************************************/
int  Dtool_Init_OdeSurfaceParameters(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-OdeSurfaceParameters::OdeSurfaceParameters(int mode = (0), float mu = (0))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":OdeSurfaceParameters", key_word_list))
            {
                OdeSurfaceParameters *return_value = new OdeSurfaceParameters();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeSurfaceParameters,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-OdeSurfaceParameters::OdeSurfaceParameters(int mode, float mu = (0))
            int param0;
            static char * key_word_list[] = {(char *)"mode", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "i:OdeSurfaceParameters", key_word_list, &param0));
            else
                (PyArg_Parse(args, "i:OdeSurfaceParameters", &param0));
            if(!PyErr_Occurred())
            {
                OdeSurfaceParameters *return_value = new OdeSurfaceParameters((int)param0);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeSurfaceParameters,true,false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-OdeSurfaceParameters::OdeSurfaceParameters(int mode, float mu)
            int param0;
            double param1;
            static char * key_word_list[] = {(char *)"mode", (char *)"mu", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "id:OdeSurfaceParameters", key_word_list, &param0, &param1))
            {
                OdeSurfaceParameters *return_value = new OdeSurfaceParameters((int)param0, (float)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeSurfaceParameters,true,false);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OdeSurfaceParameters() takes 0, 1, or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OdeSurfaceParameters()\n"
          "OdeSurfaceParameters(int mode)\n"
          "OdeSurfaceParameters(int mode, float mu)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OdeSurfaceParameters(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeSurfaceParameters)
    {
        printf("OdeSurfaceParameters ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeSurfaceParameters * local_this = (OdeSurfaceParameters *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeSurfaceParameters)
        return local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeSurfaceParameters(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeSurfaceParameters)
        return from_this;
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeSurfaceParameters*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeContact 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline OdeSurfaceParameters OdeContact::get_surface(void) const
 *******************************************************************/
static PyObject *Dtool_OdeContact_get_surface_375(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeContact * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeContact,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline OdeSurfaceParameters OdeContact::get_surface(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getSurface", key_word_list));
        else
            (PyArg_Parse(args, ":getSurface"));
        if(!PyErr_Occurred())
        {
            OdeSurfaceParameters result = ((const OdeContact*)local_this)->get_surface();
            OdeSurfaceParameters *return_value = new OdeSurfaceParameters(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeSurfaceParameters,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getSurface(const OdeContact this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeContact_get_surface_375_comment =
    "C++ Interface:\n"
    "getSurface(const OdeContact this)\n"
    "\n"
    "// Filename: odeContact.I\n"
    "// Created by:  joswilso (27Dec06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeContact_get_surface_375_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline OdeContactGeom OdeContact::get_geom(void)
 *******************************************************************/
static PyObject *Dtool_OdeContact_get_geom_376(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeContact * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeContact,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline OdeContactGeom OdeContact::get_geom(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getGeom", key_word_list));
        else
            (PyArg_Parse(args, ":getGeom"));
        if(!PyErr_Occurred())
        {
            OdeContactGeom result = (local_this)->get_geom();
            OdeContactGeom *return_value = new OdeContactGeom(result);
            if (return_value != (OdeContactGeom *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeContactGeom,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeContact.getGeom() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getGeom(non-const OdeContact this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeContact_get_geom_376_comment =
    "C++ Interface:\n"
    "getGeom(non-const OdeContact this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeContact_get_geom_376_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f OdeContact::get_fdir1(void) const
 *******************************************************************/
static PyObject *Dtool_OdeContact_get_fdir1_377(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeContact * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeContact,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f OdeContact::get_fdir1(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFdir1", key_word_list));
        else
            (PyArg_Parse(args, ":getFdir1"));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const OdeContact*)local_this)->get_fdir1();
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFdir1(const OdeContact this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeContact_get_fdir1_377_comment =
    "C++ Interface:\n"
    "getFdir1(const OdeContact this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeContact_get_fdir1_377_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeContact::set_surface(OdeSurfaceParameters const &surface_parameters)
 *******************************************************************/
static PyObject *Dtool_OdeContact_set_surface_378(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeContact * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeContact,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeContact::set_surface(OdeSurfaceParameters const &surface_parameters)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"surface_parameters", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setSurface", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setSurface", &param1));
            if(!PyErr_Occurred())
            {
                OdeSurfaceParameters *param1_this = (OdeSurfaceParameters *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeSurfaceParameters, 1, "OdeContact.setSurface", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_surface(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeContact.setSurface() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setSurface(non-const OdeContact this, const OdeSurfaceParameters surface_parameters)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeContact_set_surface_378_comment =
    "C++ Interface:\n"
    "setSurface(non-const OdeContact this, const OdeSurfaceParameters surface_parameters)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeContact_set_surface_378_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeContact::set_geom(OdeContactGeom const &contact_geom)
 *******************************************************************/
static PyObject *Dtool_OdeContact_set_geom_379(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeContact * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeContact,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeContact::set_geom(OdeContactGeom const &contact_geom)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"contact_geom", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setGeom", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setGeom", &param1));
            if(!PyErr_Occurred())
            {
                OdeContactGeom *param1_this = (OdeContactGeom *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeContactGeom, 1, "OdeContact.setGeom", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_geom(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeContact.setGeom() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setGeom(non-const OdeContact this, const OdeContactGeom contact_geom)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeContact_set_geom_379_comment =
    "C++ Interface:\n"
    "setGeom(non-const OdeContact this, const OdeContactGeom contact_geom)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeContact_set_geom_379_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeContact::set_fdir1(LVecBase3f const &fdir1)
 *******************************************************************/
static PyObject *Dtool_OdeContact_set_fdir1_380(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeContact * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeContact,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeContact::set_fdir1(LVecBase3f const &fdir1)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"fdir1", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setFdir1", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setFdir1", &param1));
            if(!PyErr_Occurred())
            {
                LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeContact.setFdir1", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_fdir1(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeContact.setFdir1() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setFdir1(non-const OdeContact this, const VBase3 fdir1)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeContact_set_fdir1_380_comment =
    "C++ Interface:\n"
    "setFdir1(non-const OdeContact this, const VBase3 fdir1)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeContact_set_fdir1_380_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeContact::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeContact_get_class_type_381(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeContact::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeContact::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeContact_get_class_type_381_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeContact_get_class_type_381_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeContact::OdeContact(void)
 * Rejected Remap [OdeContact::OdeContact(dContact const &contact)]
 *******************************************************************/
int  Dtool_Init_OdeContact(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      // 1-OdeContact::OdeContact(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":OdeContact", key_word_list))
        {
            OdeContact *return_value = new OdeContact();
            return_value->ref();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
              delete return_value;
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                delete return_value;
                return -1;
              }
#endif
              if (PyErr_Occurred()) {
                delete return_value;
                return -1;
              }
              return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeContact,true,false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "OdeContact()\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OdeContact(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeContact)
    {
        printf("OdeContact ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeContact * local_this = (OdeContact *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeContact)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeContact(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeContact)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (OdeContact*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeContact*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (OdeContact*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeContactJoint 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeContactJoint::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeContactJoint_get_class_type_384(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeContactJoint::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeContactJoint::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeContactJoint_get_class_type_384_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeContactJoint_get_class_type_384_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeContactJoint::OdeContactJoint(OdeWorld &world, OdeContact const &contact)
 * OdeContactJoint::OdeContactJoint(OdeWorld &world, OdeJointGroup &joint_group, OdeContact const &contact)
 *******************************************************************/
int  Dtool_Init_OdeContactJoint(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeContactJoint::OdeContactJoint(OdeWorld &world, OdeContact const &contact)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"world", (char *)"contact", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:OdeContactJoint", key_word_list, &param0, &param1))
                {
                    OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeWorld, 0, "OdeContactJoint.OdeContactJoint", 0, coerced_ptr, report_errors);
OdeContact *param1_this = (OdeContact *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeContact, 1, "OdeContactJoint.OdeContactJoint", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        OdeContactJoint *return_value = new OdeContactJoint(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeContactJoint,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeContactJoint::OdeContactJoint(OdeWorld &world, OdeJointGroup &joint_group, OdeContact const &contact)
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"world", (char *)"joint_group", (char *)"contact", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOO:OdeContactJoint", key_word_list, &param0, &param1, &param2))
                {
                    OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeWorld, 0, "OdeContactJoint.OdeContactJoint", 0, coerced_ptr, report_errors);
OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeJointGroup, 1, "OdeContactJoint.OdeContactJoint", 0, coerced_ptr, report_errors);
OdeContact *param2_this = (OdeContact *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_OdeContact, 2, "OdeContactJoint.OdeContactJoint", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        OdeContactJoint *return_value = new OdeContactJoint(*param0_this, *param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeContactJoint,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OdeContactJoint() takes 2 or 3 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OdeContactJoint(non-const OdeWorld world, const OdeContact contact)\n"
          "OdeContactJoint(non-const OdeWorld world, non-const OdeJointGroup joint_group, const OdeContact contact)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OdeContactJoint(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeContactJoint)
    {
        printf("OdeContactJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeContactJoint * local_this = (OdeContactJoint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeContactJoint)
        return local_this;
    if(requested_type == &Dtool_OdeJoint)
        return ( OdeJoint *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( OdeJoint *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeContactJoint(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeContactJoint)
        return from_this;
    if(from_type == &Dtool_OdeJoint)
    {
          OdeJoint* other_this = (OdeJoint*)from_this;
          return (OdeContactJoint*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeContactJoint*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeCylinderGeom 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void OdeCylinderGeom::set_params(float radius, float length)
 *******************************************************************/
static PyObject *Dtool_OdeCylinderGeom_set_params_387(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeCylinderGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeCylinderGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeCylinderGeom::set_params(float radius, float length)
        double param1;
        double param2;
        static char * key_word_list[] = {(char *)"radius", (char *)"length", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:setParams", key_word_list, &param1, &param2))
        {
            (local_this)->set_params((float)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeCylinderGeom.setParams() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParams(non-const OdeCylinderGeom this, float radius, float length)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeCylinderGeom_set_params_387_comment =
    "C++ Interface:\n"
    "setParams(non-const OdeCylinderGeom this, float radius, float length)\n"
    "\n"
    "// Filename: odeCylinderGeom.I\n"
    "// Created by:  joswilso (27Dec06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeCylinderGeom_set_params_387_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeCylinderGeom::get_radius(void) const
 *******************************************************************/
static PyObject *Dtool_OdeCylinderGeom_get_radius_389(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeCylinderGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeCylinderGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeCylinderGeom::get_radius(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRadius", key_word_list));
        else
            (PyArg_Parse(args, ":getRadius"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeCylinderGeom*)local_this)->get_radius();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRadius(const OdeCylinderGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeCylinderGeom_get_radius_389_comment =
    "C++ Interface:\n"
    "getRadius(const OdeCylinderGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeCylinderGeom_get_radius_389_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeCylinderGeom::get_length(void) const
 *******************************************************************/
static PyObject *Dtool_OdeCylinderGeom_get_length_390(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeCylinderGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeCylinderGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeCylinderGeom::get_length(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLength", key_word_list));
        else
            (PyArg_Parse(args, ":getLength"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeCylinderGeom*)local_this)->get_length();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLength(const OdeCylinderGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeCylinderGeom_get_length_390_comment =
    "C++ Interface:\n"
    "getLength(const OdeCylinderGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeCylinderGeom_get_length_390_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeCylinderGeom::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeCylinderGeom_get_class_type_391(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeCylinderGeom::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeCylinderGeom::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeCylinderGeom_get_class_type_391_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeCylinderGeom_get_class_type_391_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeCylinderGeom::OdeCylinderGeom(OdeSpace &space, float radius, float length)
 * OdeCylinderGeom::OdeCylinderGeom(float radius, float length)
 *******************************************************************/
int  Dtool_Init_OdeCylinderGeom(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          // 1-OdeCylinderGeom::OdeCylinderGeom(float radius, float length)
            double param0;
            double param1;
            static char * key_word_list[] = {(char *)"radius", (char *)"length", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:OdeCylinderGeom", key_word_list, &param0, &param1))
            {
                OdeCylinderGeom *return_value = new OdeCylinderGeom((float)param0, (float)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeCylinderGeom,true,false);
                }
            }
        }

        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeCylinderGeom::OdeCylinderGeom(OdeSpace &space, float radius, float length)
                PyObject *param0;
                double param1;
                double param2;
                static char * key_word_list[] = {(char *)"space", (char *)"radius", (char *)"length", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Odd:OdeCylinderGeom", key_word_list, &param0, &param1, &param2))
                {
                    OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeSpace, 0, "OdeCylinderGeom.OdeCylinderGeom", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        OdeCylinderGeom *return_value = new OdeCylinderGeom(*param0_this, (float)param1, (float)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeCylinderGeom,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OdeCylinderGeom() takes 2 or 3 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OdeCylinderGeom(float radius, float length)\n"
          "OdeCylinderGeom(non-const OdeSpace space, float radius, float length)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OdeCylinderGeom(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeCylinderGeom)
    {
        printf("OdeCylinderGeom ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeCylinderGeom * local_this = (OdeCylinderGeom *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeCylinderGeom)
        return local_this;
    if(requested_type == &Dtool_OdeGeom)
        return ( OdeGeom *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( OdeGeom *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeCylinderGeom(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeCylinderGeom)
        return from_this;
    if(from_type == &Dtool_OdeGeom)
    {
          OdeGeom* other_this = (OdeGeom*)from_this;
          return (OdeCylinderGeom*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeCylinderGeom*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeFixedJoint 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void OdeFixedJoint::set(void)
 *******************************************************************/
static PyObject *Dtool_OdeFixedJoint_set_394(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeFixedJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeFixedJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeFixedJoint::set(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":set", key_word_list));
        else
            (PyArg_Parse(args, ":set"));
        if(!PyErr_Occurred())
        {
            (local_this)->set();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeFixedJoint.set() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "set(non-const OdeFixedJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeFixedJoint_set_394_comment =
    "C++ Interface:\n"
    "set(non-const OdeFixedJoint this)\n"
    "\n"
    "// Filename: odeFixedJoint.I\n"
    "// Created by:  joswilso (27Dec06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeFixedJoint_set_394_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeFixedJoint::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeFixedJoint_get_class_type_395(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeFixedJoint::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeFixedJoint::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeFixedJoint_get_class_type_395_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeFixedJoint_get_class_type_395_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeFixedJoint::OdeFixedJoint(OdeWorld &world)
 * OdeFixedJoint::OdeFixedJoint(OdeWorld &world, OdeJointGroup &joint_group)
 *******************************************************************/
int  Dtool_Init_OdeFixedJoint(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeFixedJoint::OdeFixedJoint(OdeWorld &world)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"world", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:OdeFixedJoint", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:OdeFixedJoint", &param0));
                if(!PyErr_Occurred())
                {
                    OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeWorld, 0, "OdeFixedJoint.OdeFixedJoint", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        OdeFixedJoint *return_value = new OdeFixedJoint(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeFixedJoint,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeFixedJoint::OdeFixedJoint(OdeWorld &world, OdeJointGroup &joint_group)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"world", (char *)"joint_group", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:OdeFixedJoint", key_word_list, &param0, &param1))
                {
                    OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeWorld, 0, "OdeFixedJoint.OdeFixedJoint", 0, coerced_ptr, report_errors);
OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeJointGroup, 1, "OdeFixedJoint.OdeFixedJoint", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        OdeFixedJoint *return_value = new OdeFixedJoint(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeFixedJoint,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OdeFixedJoint() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OdeFixedJoint(non-const OdeWorld world)\n"
          "OdeFixedJoint(non-const OdeWorld world, non-const OdeJointGroup joint_group)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OdeFixedJoint(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeFixedJoint)
    {
        printf("OdeFixedJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeFixedJoint * local_this = (OdeFixedJoint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeFixedJoint)
        return local_this;
    if(requested_type == &Dtool_OdeJoint)
        return ( OdeJoint *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( OdeJoint *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeFixedJoint(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeFixedJoint)
        return from_this;
    if(from_type == &Dtool_OdeJoint)
    {
          OdeJoint* other_this = (OdeJoint*)from_this;
          return (OdeFixedJoint*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeFixedJoint*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeHashSpace 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void OdeHashSpace::set_levels(int minlevel, int maxlevel)
 *******************************************************************/
static PyObject *Dtool_OdeHashSpace_set_levels_398(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHashSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHashSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeHashSpace::set_levels(int minlevel, int maxlevel)
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"minlevel", (char *)"maxlevel", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:setLevels", key_word_list, &param1, &param2))
        {
            (local_this)->set_levels((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeHashSpace.setLevels() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setLevels(non-const OdeHashSpace this, int minlevel, int maxlevel)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHashSpace_set_levels_398_comment =
    "C++ Interface:\n"
    "setLevels(non-const OdeHashSpace this, int minlevel, int maxlevel)\n"
    "\n"
    "// Filename: odeHashSpace.I\n"
    "// Created by:  joswilso (27Dec06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeHashSpace_set_levels_398_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeHashSpace::get_min_level(void) const
 *******************************************************************/
static PyObject *Dtool_OdeHashSpace_get_min_level_399(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHashSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHashSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int OdeHashSpace::get_min_level(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMinLevel", key_word_list));
        else
            (PyArg_Parse(args, ":getMinLevel"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const OdeHashSpace*)local_this)->get_min_level();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMinLevel(const OdeHashSpace this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHashSpace_get_min_level_399_comment =
    "C++ Interface:\n"
    "getMinLevel(const OdeHashSpace this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHashSpace_get_min_level_399_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeHashSpace::get_max_level(void) const
 *******************************************************************/
static PyObject *Dtool_OdeHashSpace_get_max_level_400(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHashSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHashSpace,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int OdeHashSpace::get_max_level(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getMaxLevel", key_word_list));
        else
            (PyArg_Parse(args, ":getMaxLevel"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const OdeHashSpace*)local_this)->get_max_level();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getMaxLevel(const OdeHashSpace this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHashSpace_get_max_level_400_comment =
    "C++ Interface:\n"
    "getMaxLevel(const OdeHashSpace this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHashSpace_get_max_level_400_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeHashSpace::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeHashSpace_get_class_type_401(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeHashSpace::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeHashSpace::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHashSpace_get_class_type_401_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHashSpace_get_class_type_401_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeHashSpace::OdeHashSpace(void)
 * OdeHashSpace::OdeHashSpace(OdeSpace &space)
 *******************************************************************/
int  Dtool_Init_OdeHashSpace(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-OdeHashSpace::OdeHashSpace(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":OdeHashSpace", key_word_list))
            {
                OdeHashSpace *return_value = new OdeHashSpace();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeHashSpace,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeHashSpace::OdeHashSpace(OdeSpace &space)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"space", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:OdeHashSpace", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:OdeHashSpace", &param0));
                if(!PyErr_Occurred())
                {
                    OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeSpace, 0, "OdeHashSpace.OdeHashSpace", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        OdeHashSpace *return_value = new OdeHashSpace(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeHashSpace,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OdeHashSpace() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OdeHashSpace()\n"
          "OdeHashSpace(non-const OdeSpace space)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OdeHashSpace(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeHashSpace)
    {
        printf("OdeHashSpace ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeHashSpace * local_this = (OdeHashSpace *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeHashSpace)
        return local_this;
    if(requested_type == &Dtool_OdeSpace)
        return ( OdeSpace *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( OdeSpace *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeHashSpace(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeHashSpace)
        return from_this;
    if(from_type == &Dtool_OdeSpace)
    {
          OdeSpace* other_this = (OdeSpace*)from_this;
          return (OdeHashSpace*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeHashSpace*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeHinge2Joint 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void OdeHinge2Joint::set_anchor(LVecBase3f const &anchor)
 * inline void OdeHinge2Joint::set_anchor(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_set_anchor_404(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeHinge2Joint::set_anchor(LVecBase3f const &anchor)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"anchor", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAnchor", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setAnchor", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeHinge2Joint.setAnchor", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_anchor(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeHinge2Joint.setAnchor() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeHinge2Joint::set_anchor(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setAnchor", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_anchor((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeHinge2Joint.setAnchor() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setAnchor() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setAnchor(non-const OdeHinge2Joint this, const VBase3 anchor)\n"
          "setAnchor(non-const OdeHinge2Joint this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_set_anchor_404_comment =
    "C++ Interface:\n"
    "setAnchor(non-const OdeHinge2Joint this, const VBase3 anchor)\n"
    "setAnchor(non-const OdeHinge2Joint this, float x, float y, float z)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_set_anchor_404_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeHinge2Joint::set_axis1(LVecBase3f const &axis)
 * inline void OdeHinge2Joint::set_axis1(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_set_axis1_405(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeHinge2Joint::set_axis1(LVecBase3f const &axis)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"axis", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAxis1", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setAxis1", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeHinge2Joint.setAxis1", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_axis1(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeHinge2Joint.setAxis1() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeHinge2Joint::set_axis1(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setAxis1", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_axis1((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeHinge2Joint.setAxis1() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setAxis1() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setAxis1(non-const OdeHinge2Joint this, const VBase3 axis)\n"
          "setAxis1(non-const OdeHinge2Joint this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_set_axis1_405_comment =
    "C++ Interface:\n"
    "setAxis1(non-const OdeHinge2Joint this, const VBase3 axis)\n"
    "setAxis1(non-const OdeHinge2Joint this, float x, float y, float z)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_set_axis1_405_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeHinge2Joint::set_axis2(LVecBase3f const &axis)
 * inline void OdeHinge2Joint::set_axis2(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_set_axis2_406(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeHinge2Joint::set_axis2(LVecBase3f const &axis)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"axis", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAxis2", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setAxis2", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeHinge2Joint.setAxis2", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_axis2(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeHinge2Joint.setAxis2() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeHinge2Joint::set_axis2(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setAxis2", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_axis2((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeHinge2Joint.setAxis2() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setAxis2() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setAxis2(non-const OdeHinge2Joint this, const VBase3 axis)\n"
          "setAxis2(non-const OdeHinge2Joint this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_set_axis2_406_comment =
    "C++ Interface:\n"
    "setAxis2(non-const OdeHinge2Joint this, const VBase3 axis)\n"
    "setAxis2(non-const OdeHinge2Joint this, float x, float y, float z)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_set_axis2_406_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeHinge2Joint::add_torques(float torque1, float torque2)
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_add_torques_407(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeHinge2Joint::add_torques(float torque1, float torque2)
        double param1;
        double param2;
        static char * key_word_list[] = {(char *)"torque1", (char *)"torque2", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:addTorques", key_word_list, &param1, &param2))
        {
            (local_this)->add_torques((float)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeHinge2Joint.addTorques() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addTorques(non-const OdeHinge2Joint this, float torque1, float torque2)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_add_torques_407_comment =
    "C++ Interface:\n"
    "addTorques(non-const OdeHinge2Joint this, float torque1, float torque2)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_add_torques_407_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f OdeHinge2Joint::get_anchor(void) const
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_get_anchor_408(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f OdeHinge2Joint::get_anchor(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAnchor", key_word_list));
        else
            (PyArg_Parse(args, ":getAnchor"));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const OdeHinge2Joint*)local_this)->get_anchor();
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAnchor(const OdeHinge2Joint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_get_anchor_408_comment =
    "C++ Interface:\n"
    "getAnchor(const OdeHinge2Joint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_get_anchor_408_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f OdeHinge2Joint::get_anchor2(void) const
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_get_anchor2_409(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f OdeHinge2Joint::get_anchor2(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAnchor2", key_word_list));
        else
            (PyArg_Parse(args, ":getAnchor2"));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const OdeHinge2Joint*)local_this)->get_anchor2();
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAnchor2(const OdeHinge2Joint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_get_anchor2_409_comment =
    "C++ Interface:\n"
    "getAnchor2(const OdeHinge2Joint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_get_anchor2_409_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f OdeHinge2Joint::get_axis1(void) const
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_get_axis1_410(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f OdeHinge2Joint::get_axis1(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAxis1", key_word_list));
        else
            (PyArg_Parse(args, ":getAxis1"));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const OdeHinge2Joint*)local_this)->get_axis1();
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAxis1(const OdeHinge2Joint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_get_axis1_410_comment =
    "C++ Interface:\n"
    "getAxis1(const OdeHinge2Joint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_get_axis1_410_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f OdeHinge2Joint::get_axis2(void) const
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_get_axis2_411(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f OdeHinge2Joint::get_axis2(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAxis2", key_word_list));
        else
            (PyArg_Parse(args, ":getAxis2"));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const OdeHinge2Joint*)local_this)->get_axis2();
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAxis2(const OdeHinge2Joint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_get_axis2_411_comment =
    "C++ Interface:\n"
    "getAxis2(const OdeHinge2Joint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_get_axis2_411_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeHinge2Joint::get_angle1(void) const
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_get_angle1_412(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeHinge2Joint::get_angle1(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAngle1", key_word_list));
        else
            (PyArg_Parse(args, ":getAngle1"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeHinge2Joint*)local_this)->get_angle1();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAngle1(const OdeHinge2Joint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_get_angle1_412_comment =
    "C++ Interface:\n"
    "getAngle1(const OdeHinge2Joint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_get_angle1_412_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeHinge2Joint::get_angle1_rate(void) const
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_get_angle1_rate_413(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeHinge2Joint::get_angle1_rate(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAngle1Rate", key_word_list));
        else
            (PyArg_Parse(args, ":getAngle1Rate"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeHinge2Joint*)local_this)->get_angle1_rate();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAngle1Rate(const OdeHinge2Joint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_get_angle1_rate_413_comment =
    "C++ Interface:\n"
    "getAngle1Rate(const OdeHinge2Joint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_get_angle1_rate_413_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeHinge2Joint::get_angle2_rate(void) const
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_get_angle2_rate_414(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeHinge2Joint::get_angle2_rate(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAngle2Rate", key_word_list));
        else
            (PyArg_Parse(args, ":getAngle2Rate"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeHinge2Joint*)local_this)->get_angle2_rate();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAngle2Rate(const OdeHinge2Joint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_get_angle2_rate_414_comment =
    "C++ Interface:\n"
    "getAngle2Rate(const OdeHinge2Joint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_get_angle2_rate_414_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeHinge2Joint::set_param_lo_stop(int axis, float val)
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_set_param_lo_stop_415(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeHinge2Joint::set_param_lo_stop(int axis, float val)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"axis", (char *)"val", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setParamLoStop", key_word_list, &param1, &param2))
        {
            (local_this)->set_param_lo_stop((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeHinge2Joint.setParamLoStop() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamLoStop(non-const OdeHinge2Joint this, int axis, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_set_param_lo_stop_415_comment =
    "C++ Interface:\n"
    "setParamLoStop(non-const OdeHinge2Joint this, int axis, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_set_param_lo_stop_415_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeHinge2Joint::set_param_hi_stop(int axis, float val)
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_set_param_hi_stop_416(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeHinge2Joint::set_param_hi_stop(int axis, float val)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"axis", (char *)"val", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setParamHiStop", key_word_list, &param1, &param2))
        {
            (local_this)->set_param_hi_stop((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeHinge2Joint.setParamHiStop() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamHiStop(non-const OdeHinge2Joint this, int axis, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_set_param_hi_stop_416_comment =
    "C++ Interface:\n"
    "setParamHiStop(non-const OdeHinge2Joint this, int axis, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_set_param_hi_stop_416_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeHinge2Joint::set_param_vel(int axis, float val)
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_set_param_vel_417(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeHinge2Joint::set_param_vel(int axis, float val)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"axis", (char *)"val", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setParamVel", key_word_list, &param1, &param2))
        {
            (local_this)->set_param_vel((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeHinge2Joint.setParamVel() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamVel(non-const OdeHinge2Joint this, int axis, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_set_param_vel_417_comment =
    "C++ Interface:\n"
    "setParamVel(non-const OdeHinge2Joint this, int axis, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_set_param_vel_417_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeHinge2Joint::set_param_f_max(int axis, float val)
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_set_param_f_max_418(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeHinge2Joint::set_param_f_max(int axis, float val)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"axis", (char *)"val", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setParamFMax", key_word_list, &param1, &param2))
        {
            (local_this)->set_param_f_max((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeHinge2Joint.setParamFMax() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamFMax(non-const OdeHinge2Joint this, int axis, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_set_param_f_max_418_comment =
    "C++ Interface:\n"
    "setParamFMax(non-const OdeHinge2Joint this, int axis, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_set_param_f_max_418_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeHinge2Joint::set_param_fudge_factor(int axis, float val)
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_set_param_fudge_factor_419(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeHinge2Joint::set_param_fudge_factor(int axis, float val)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"axis", (char *)"val", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setParamFudgeFactor", key_word_list, &param1, &param2))
        {
            (local_this)->set_param_fudge_factor((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeHinge2Joint.setParamFudgeFactor() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamFudgeFactor(non-const OdeHinge2Joint this, int axis, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_set_param_fudge_factor_419_comment =
    "C++ Interface:\n"
    "setParamFudgeFactor(non-const OdeHinge2Joint this, int axis, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_set_param_fudge_factor_419_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeHinge2Joint::set_param_bounce(int axis, float val)
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_set_param_bounce_420(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeHinge2Joint::set_param_bounce(int axis, float val)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"axis", (char *)"val", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setParamBounce", key_word_list, &param1, &param2))
        {
            (local_this)->set_param_bounce((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeHinge2Joint.setParamBounce() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamBounce(non-const OdeHinge2Joint this, int axis, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_set_param_bounce_420_comment =
    "C++ Interface:\n"
    "setParamBounce(non-const OdeHinge2Joint this, int axis, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_set_param_bounce_420_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeHinge2Joint::set_param_CFM(int axis, float val)
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_set_param_CFM_421(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeHinge2Joint::set_param_CFM(int axis, float val)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"axis", (char *)"val", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setParamCFM", key_word_list, &param1, &param2))
        {
            (local_this)->set_param_CFM((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeHinge2Joint.setParamCFM() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamCFM(non-const OdeHinge2Joint this, int axis, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_set_param_CFM_421_comment =
    "C++ Interface:\n"
    "setParamCFM(non-const OdeHinge2Joint this, int axis, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_set_param_CFM_421_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeHinge2Joint::set_param_stop_ERP(int axis, float val)
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_set_param_stop_ERP_422(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeHinge2Joint::set_param_stop_ERP(int axis, float val)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"axis", (char *)"val", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setParamStopERP", key_word_list, &param1, &param2))
        {
            (local_this)->set_param_stop_ERP((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeHinge2Joint.setParamStopERP() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamStopERP(non-const OdeHinge2Joint this, int axis, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_set_param_stop_ERP_422_comment =
    "C++ Interface:\n"
    "setParamStopERP(non-const OdeHinge2Joint this, int axis, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_set_param_stop_ERP_422_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeHinge2Joint::set_param_stop_CFM(int axis, float val)
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_set_param_stop_CFM_423(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeHinge2Joint::set_param_stop_CFM(int axis, float val)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"axis", (char *)"val", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setParamStopCFM", key_word_list, &param1, &param2))
        {
            (local_this)->set_param_stop_CFM((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeHinge2Joint.setParamStopCFM() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamStopCFM(non-const OdeHinge2Joint this, int axis, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_set_param_stop_CFM_423_comment =
    "C++ Interface:\n"
    "setParamStopCFM(non-const OdeHinge2Joint this, int axis, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_set_param_stop_CFM_423_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeHinge2Joint::set_param_suspension_ERP(int axis, float val)
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_set_param_suspension_ERP_424(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeHinge2Joint::set_param_suspension_ERP(int axis, float val)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"axis", (char *)"val", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setParamSuspensionERP", key_word_list, &param1, &param2))
        {
            (local_this)->set_param_suspension_ERP((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeHinge2Joint.setParamSuspensionERP() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamSuspensionERP(non-const OdeHinge2Joint this, int axis, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_set_param_suspension_ERP_424_comment =
    "C++ Interface:\n"
    "setParamSuspensionERP(non-const OdeHinge2Joint this, int axis, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_set_param_suspension_ERP_424_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeHinge2Joint::set_param_suspension_CFM(int axis, float val)
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_set_param_suspension_CFM_425(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeHinge2Joint::set_param_suspension_CFM(int axis, float val)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"axis", (char *)"val", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setParamSuspensionCFM", key_word_list, &param1, &param2))
        {
            (local_this)->set_param_suspension_CFM((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeHinge2Joint.setParamSuspensionCFM() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamSuspensionCFM(non-const OdeHinge2Joint this, int axis, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_set_param_suspension_CFM_425_comment =
    "C++ Interface:\n"
    "setParamSuspensionCFM(non-const OdeHinge2Joint this, int axis, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_set_param_suspension_CFM_425_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeHinge2Joint::get_param_lo_stop(int axis) const
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_get_param_lo_stop_426(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeHinge2Joint::get_param_lo_stop(int axis) const
        int param1;
        static char * key_word_list[] = {(char *)"axis", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParamLoStop", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParamLoStop", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeHinge2Joint*)local_this)->get_param_lo_stop((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamLoStop(const OdeHinge2Joint this, int axis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_get_param_lo_stop_426_comment =
    "C++ Interface:\n"
    "getParamLoStop(const OdeHinge2Joint this, int axis)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_get_param_lo_stop_426_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeHinge2Joint::get_param_hi_stop(int axis) const
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_get_param_hi_stop_427(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeHinge2Joint::get_param_hi_stop(int axis) const
        int param1;
        static char * key_word_list[] = {(char *)"axis", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParamHiStop", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParamHiStop", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeHinge2Joint*)local_this)->get_param_hi_stop((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamHiStop(const OdeHinge2Joint this, int axis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_get_param_hi_stop_427_comment =
    "C++ Interface:\n"
    "getParamHiStop(const OdeHinge2Joint this, int axis)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_get_param_hi_stop_427_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeHinge2Joint::get_param_vel(int axis) const
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_get_param_vel_428(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeHinge2Joint::get_param_vel(int axis) const
        int param1;
        static char * key_word_list[] = {(char *)"axis", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParamVel", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParamVel", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeHinge2Joint*)local_this)->get_param_vel((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamVel(const OdeHinge2Joint this, int axis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_get_param_vel_428_comment =
    "C++ Interface:\n"
    "getParamVel(const OdeHinge2Joint this, int axis)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_get_param_vel_428_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeHinge2Joint::get_param_f_max(int axis) const
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_get_param_f_max_429(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeHinge2Joint::get_param_f_max(int axis) const
        int param1;
        static char * key_word_list[] = {(char *)"axis", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParamFMax", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParamFMax", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeHinge2Joint*)local_this)->get_param_f_max((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamFMax(const OdeHinge2Joint this, int axis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_get_param_f_max_429_comment =
    "C++ Interface:\n"
    "getParamFMax(const OdeHinge2Joint this, int axis)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_get_param_f_max_429_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeHinge2Joint::get_param_fudge_factor(int axis) const
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_get_param_fudge_factor_430(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeHinge2Joint::get_param_fudge_factor(int axis) const
        int param1;
        static char * key_word_list[] = {(char *)"axis", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParamFudgeFactor", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParamFudgeFactor", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeHinge2Joint*)local_this)->get_param_fudge_factor((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamFudgeFactor(const OdeHinge2Joint this, int axis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_get_param_fudge_factor_430_comment =
    "C++ Interface:\n"
    "getParamFudgeFactor(const OdeHinge2Joint this, int axis)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_get_param_fudge_factor_430_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeHinge2Joint::get_param_bounce(int axis) const
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_get_param_bounce_431(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeHinge2Joint::get_param_bounce(int axis) const
        int param1;
        static char * key_word_list[] = {(char *)"axis", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParamBounce", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParamBounce", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeHinge2Joint*)local_this)->get_param_bounce((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamBounce(const OdeHinge2Joint this, int axis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_get_param_bounce_431_comment =
    "C++ Interface:\n"
    "getParamBounce(const OdeHinge2Joint this, int axis)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_get_param_bounce_431_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeHinge2Joint::get_param_CFM(int axis) const
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_get_param_CFM_432(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeHinge2Joint::get_param_CFM(int axis) const
        int param1;
        static char * key_word_list[] = {(char *)"axis", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParamCFM", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParamCFM", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeHinge2Joint*)local_this)->get_param_CFM((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamCFM(const OdeHinge2Joint this, int axis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_get_param_CFM_432_comment =
    "C++ Interface:\n"
    "getParamCFM(const OdeHinge2Joint this, int axis)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_get_param_CFM_432_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeHinge2Joint::get_param_stop_ERP(int axis) const
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_get_param_stop_ERP_433(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeHinge2Joint::get_param_stop_ERP(int axis) const
        int param1;
        static char * key_word_list[] = {(char *)"axis", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParamStopERP", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParamStopERP", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeHinge2Joint*)local_this)->get_param_stop_ERP((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamStopERP(const OdeHinge2Joint this, int axis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_get_param_stop_ERP_433_comment =
    "C++ Interface:\n"
    "getParamStopERP(const OdeHinge2Joint this, int axis)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_get_param_stop_ERP_433_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeHinge2Joint::get_param_stop_CFM(int axis) const
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_get_param_stop_CFM_434(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeHinge2Joint::get_param_stop_CFM(int axis) const
        int param1;
        static char * key_word_list[] = {(char *)"axis", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParamStopCFM", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParamStopCFM", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeHinge2Joint*)local_this)->get_param_stop_CFM((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamStopCFM(const OdeHinge2Joint this, int axis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_get_param_stop_CFM_434_comment =
    "C++ Interface:\n"
    "getParamStopCFM(const OdeHinge2Joint this, int axis)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_get_param_stop_CFM_434_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeHinge2Joint::get_param_suspension_ERP(int axis) const
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_get_param_suspension_ERP_435(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeHinge2Joint::get_param_suspension_ERP(int axis) const
        int param1;
        static char * key_word_list[] = {(char *)"axis", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParamSuspensionERP", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParamSuspensionERP", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeHinge2Joint*)local_this)->get_param_suspension_ERP((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamSuspensionERP(const OdeHinge2Joint this, int axis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_get_param_suspension_ERP_435_comment =
    "C++ Interface:\n"
    "getParamSuspensionERP(const OdeHinge2Joint this, int axis)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_get_param_suspension_ERP_435_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeHinge2Joint::get_param_suspension_CFM(int axis) const
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_get_param_suspension_CFM_436(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHinge2Joint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHinge2Joint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeHinge2Joint::get_param_suspension_CFM(int axis) const
        int param1;
        static char * key_word_list[] = {(char *)"axis", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParamSuspensionCFM", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParamSuspensionCFM", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeHinge2Joint*)local_this)->get_param_suspension_CFM((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamSuspensionCFM(const OdeHinge2Joint this, int axis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_get_param_suspension_CFM_436_comment =
    "C++ Interface:\n"
    "getParamSuspensionCFM(const OdeHinge2Joint this, int axis)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_get_param_suspension_CFM_436_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeHinge2Joint::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeHinge2Joint_get_class_type_437(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeHinge2Joint::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeHinge2Joint::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHinge2Joint_get_class_type_437_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHinge2Joint_get_class_type_437_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeHinge2Joint::OdeHinge2Joint(OdeWorld &world)
 * OdeHinge2Joint::OdeHinge2Joint(OdeWorld &world, OdeJointGroup &joint_group)
 *******************************************************************/
int  Dtool_Init_OdeHinge2Joint(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeHinge2Joint::OdeHinge2Joint(OdeWorld &world)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"world", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:OdeHinge2Joint", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:OdeHinge2Joint", &param0));
                if(!PyErr_Occurred())
                {
                    OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeWorld, 0, "OdeHinge2Joint.OdeHinge2Joint", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        OdeHinge2Joint *return_value = new OdeHinge2Joint(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeHinge2Joint,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeHinge2Joint::OdeHinge2Joint(OdeWorld &world, OdeJointGroup &joint_group)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"world", (char *)"joint_group", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:OdeHinge2Joint", key_word_list, &param0, &param1))
                {
                    OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeWorld, 0, "OdeHinge2Joint.OdeHinge2Joint", 0, coerced_ptr, report_errors);
OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeJointGroup, 1, "OdeHinge2Joint.OdeHinge2Joint", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        OdeHinge2Joint *return_value = new OdeHinge2Joint(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeHinge2Joint,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OdeHinge2Joint() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OdeHinge2Joint(non-const OdeWorld world)\n"
          "OdeHinge2Joint(non-const OdeWorld world, non-const OdeJointGroup joint_group)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OdeHinge2Joint(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeHinge2Joint)
    {
        printf("OdeHinge2Joint ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeHinge2Joint * local_this = (OdeHinge2Joint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeHinge2Joint)
        return local_this;
    if(requested_type == &Dtool_OdeJoint)
        return ( OdeJoint *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( OdeJoint *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeHinge2Joint(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeHinge2Joint)
        return from_this;
    if(from_type == &Dtool_OdeJoint)
    {
          OdeJoint* other_this = (OdeJoint*)from_this;
          return (OdeHinge2Joint*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeHinge2Joint*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeHingeJoint 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void OdeHingeJoint::set_anchor(LVecBase3f const &anchor)
 * inline void OdeHingeJoint::set_anchor(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_OdeHingeJoint_set_anchor_440(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHingeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHingeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeHingeJoint::set_anchor(LVecBase3f const &anchor)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"anchor", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAnchor", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setAnchor", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeHingeJoint.setAnchor", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_anchor(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeHingeJoint.setAnchor() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeHingeJoint::set_anchor(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setAnchor", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_anchor((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeHingeJoint.setAnchor() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setAnchor() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setAnchor(non-const OdeHingeJoint this, const VBase3 anchor)\n"
          "setAnchor(non-const OdeHingeJoint this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHingeJoint_set_anchor_440_comment =
    "C++ Interface:\n"
    "setAnchor(non-const OdeHingeJoint this, const VBase3 anchor)\n"
    "setAnchor(non-const OdeHingeJoint this, float x, float y, float z)\n"
    "\n"
    "// Filename: odeHingeJoint.I\n"
    "// Created by:  joswilso (27Dec06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeHingeJoint_set_anchor_440_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeHingeJoint::set_anchor_delta(LVecBase3f const &anchor, LVecBase3f const &vec)
 * inline void OdeHingeJoint::set_anchor_delta(float x, float y, float z, float ax, float ay, float az)
 *******************************************************************/
static PyObject *Dtool_OdeHingeJoint_set_anchor_delta_441(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHingeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHingeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeHingeJoint::set_anchor_delta(LVecBase3f const &anchor, LVecBase3f const &vec)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"anchor", (char *)"vec", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:setAnchorDelta", key_word_list, &param1, &param2))
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeHingeJoint.setAnchorDelta", 1, coerced_ptr, report_errors);
LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "OdeHingeJoint.setAnchorDelta", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        (local_this)->set_anchor_delta(*param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeHingeJoint.setAnchorDelta() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeHingeJoint::set_anchor_delta(float x, float y, float z, float ax, float ay, float az)
            double param1;
            double param2;
            double param3;
            double param4;
            double param5;
            double param6;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", (char *)"ax", (char *)"ay", (char *)"az", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddddd:setAnchorDelta", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6))
            {
                (local_this)->set_anchor_delta((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeHingeJoint.setAnchorDelta() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setAnchorDelta() takes 3 or 7 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setAnchorDelta(non-const OdeHingeJoint this, const VBase3 anchor, const VBase3 vec)\n"
          "setAnchorDelta(non-const OdeHingeJoint this, float x, float y, float z, float ax, float ay, float az)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHingeJoint_set_anchor_delta_441_comment =
    "C++ Interface:\n"
    "setAnchorDelta(non-const OdeHingeJoint this, const VBase3 anchor, const VBase3 vec)\n"
    "setAnchorDelta(non-const OdeHingeJoint this, float x, float y, float z, float ax, float ay, float az)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHingeJoint_set_anchor_delta_441_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeHingeJoint::set_axis(LVecBase3f const &axis)
 * inline void OdeHingeJoint::set_axis(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_OdeHingeJoint_set_axis_442(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHingeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHingeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeHingeJoint::set_axis(LVecBase3f const &axis)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"axis", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAxis", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setAxis", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeHingeJoint.setAxis", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_axis(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeHingeJoint.setAxis() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeHingeJoint::set_axis(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setAxis", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_axis((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeHingeJoint.setAxis() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setAxis() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setAxis(non-const OdeHingeJoint this, const VBase3 axis)\n"
          "setAxis(non-const OdeHingeJoint this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHingeJoint_set_axis_442_comment =
    "C++ Interface:\n"
    "setAxis(non-const OdeHingeJoint this, const VBase3 axis)\n"
    "setAxis(non-const OdeHingeJoint this, float x, float y, float z)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHingeJoint_set_axis_442_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeHingeJoint::add_torque(float torque)
 *******************************************************************/
static PyObject *Dtool_OdeHingeJoint_add_torque_443(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHingeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHingeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeHingeJoint::add_torque(float torque)
        double param1;
        static char * key_word_list[] = {(char *)"torque", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:addTorque", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:addTorque", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->add_torque((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeHingeJoint.addTorque() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addTorque(non-const OdeHingeJoint this, float torque)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHingeJoint_add_torque_443_comment =
    "C++ Interface:\n"
    "addTorque(non-const OdeHingeJoint this, float torque)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHingeJoint_add_torque_443_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f OdeHingeJoint::get_anchor(void) const
 *******************************************************************/
static PyObject *Dtool_OdeHingeJoint_get_anchor_444(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHingeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHingeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f OdeHingeJoint::get_anchor(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAnchor", key_word_list));
        else
            (PyArg_Parse(args, ":getAnchor"));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const OdeHingeJoint*)local_this)->get_anchor();
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAnchor(const OdeHingeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHingeJoint_get_anchor_444_comment =
    "C++ Interface:\n"
    "getAnchor(const OdeHingeJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHingeJoint_get_anchor_444_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f OdeHingeJoint::get_anchor2(void) const
 *******************************************************************/
static PyObject *Dtool_OdeHingeJoint_get_anchor2_445(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHingeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHingeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f OdeHingeJoint::get_anchor2(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAnchor2", key_word_list));
        else
            (PyArg_Parse(args, ":getAnchor2"));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const OdeHingeJoint*)local_this)->get_anchor2();
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAnchor2(const OdeHingeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHingeJoint_get_anchor2_445_comment =
    "C++ Interface:\n"
    "getAnchor2(const OdeHingeJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHingeJoint_get_anchor2_445_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f OdeHingeJoint::get_axis(void) const
 *******************************************************************/
static PyObject *Dtool_OdeHingeJoint_get_axis_446(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHingeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHingeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f OdeHingeJoint::get_axis(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAxis", key_word_list));
        else
            (PyArg_Parse(args, ":getAxis"));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const OdeHingeJoint*)local_this)->get_axis();
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAxis(const OdeHingeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHingeJoint_get_axis_446_comment =
    "C++ Interface:\n"
    "getAxis(const OdeHingeJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHingeJoint_get_axis_446_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeHingeJoint::get_angle(void) const
 *******************************************************************/
static PyObject *Dtool_OdeHingeJoint_get_angle_447(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHingeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHingeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeHingeJoint::get_angle(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAngle", key_word_list));
        else
            (PyArg_Parse(args, ":getAngle"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeHingeJoint*)local_this)->get_angle();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAngle(const OdeHingeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHingeJoint_get_angle_447_comment =
    "C++ Interface:\n"
    "getAngle(const OdeHingeJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHingeJoint_get_angle_447_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeHingeJoint::get_angle_rate(void) const
 *******************************************************************/
static PyObject *Dtool_OdeHingeJoint_get_angle_rate_448(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHingeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHingeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeHingeJoint::get_angle_rate(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAngleRate", key_word_list));
        else
            (PyArg_Parse(args, ":getAngleRate"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeHingeJoint*)local_this)->get_angle_rate();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAngleRate(const OdeHingeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHingeJoint_get_angle_rate_448_comment =
    "C++ Interface:\n"
    "getAngleRate(const OdeHingeJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHingeJoint_get_angle_rate_448_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeHingeJoint::set_param_lo_stop(float val)
 *******************************************************************/
static PyObject *Dtool_OdeHingeJoint_set_param_lo_stop_449(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHingeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHingeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeHingeJoint::set_param_lo_stop(float val)
        double param1;
        static char * key_word_list[] = {(char *)"val", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setParamLoStop", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setParamLoStop", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_param_lo_stop((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeHingeJoint.setParamLoStop() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamLoStop(non-const OdeHingeJoint this, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHingeJoint_set_param_lo_stop_449_comment =
    "C++ Interface:\n"
    "setParamLoStop(non-const OdeHingeJoint this, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHingeJoint_set_param_lo_stop_449_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeHingeJoint::set_param_hi_stop(float val)
 *******************************************************************/
static PyObject *Dtool_OdeHingeJoint_set_param_hi_stop_450(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHingeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHingeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeHingeJoint::set_param_hi_stop(float val)
        double param1;
        static char * key_word_list[] = {(char *)"val", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setParamHiStop", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setParamHiStop", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_param_hi_stop((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeHingeJoint.setParamHiStop() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamHiStop(non-const OdeHingeJoint this, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHingeJoint_set_param_hi_stop_450_comment =
    "C++ Interface:\n"
    "setParamHiStop(non-const OdeHingeJoint this, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHingeJoint_set_param_hi_stop_450_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeHingeJoint::set_param_vel(float val)
 *******************************************************************/
static PyObject *Dtool_OdeHingeJoint_set_param_vel_451(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHingeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHingeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeHingeJoint::set_param_vel(float val)
        double param1;
        static char * key_word_list[] = {(char *)"val", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setParamVel", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setParamVel", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_param_vel((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeHingeJoint.setParamVel() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamVel(non-const OdeHingeJoint this, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHingeJoint_set_param_vel_451_comment =
    "C++ Interface:\n"
    "setParamVel(non-const OdeHingeJoint this, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHingeJoint_set_param_vel_451_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeHingeJoint::set_param_f_max(float val)
 *******************************************************************/
static PyObject *Dtool_OdeHingeJoint_set_param_f_max_452(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHingeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHingeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeHingeJoint::set_param_f_max(float val)
        double param1;
        static char * key_word_list[] = {(char *)"val", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setParamFMax", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setParamFMax", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_param_f_max((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeHingeJoint.setParamFMax() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamFMax(non-const OdeHingeJoint this, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHingeJoint_set_param_f_max_452_comment =
    "C++ Interface:\n"
    "setParamFMax(non-const OdeHingeJoint this, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHingeJoint_set_param_f_max_452_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeHingeJoint::set_param_fudge_factor(float val)
 *******************************************************************/
static PyObject *Dtool_OdeHingeJoint_set_param_fudge_factor_453(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHingeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHingeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeHingeJoint::set_param_fudge_factor(float val)
        double param1;
        static char * key_word_list[] = {(char *)"val", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setParamFudgeFactor", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setParamFudgeFactor", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_param_fudge_factor((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeHingeJoint.setParamFudgeFactor() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamFudgeFactor(non-const OdeHingeJoint this, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHingeJoint_set_param_fudge_factor_453_comment =
    "C++ Interface:\n"
    "setParamFudgeFactor(non-const OdeHingeJoint this, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHingeJoint_set_param_fudge_factor_453_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeHingeJoint::set_param_bounce(float val)
 *******************************************************************/
static PyObject *Dtool_OdeHingeJoint_set_param_bounce_454(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHingeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHingeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeHingeJoint::set_param_bounce(float val)
        double param1;
        static char * key_word_list[] = {(char *)"val", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setParamBounce", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setParamBounce", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_param_bounce((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeHingeJoint.setParamBounce() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamBounce(non-const OdeHingeJoint this, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHingeJoint_set_param_bounce_454_comment =
    "C++ Interface:\n"
    "setParamBounce(non-const OdeHingeJoint this, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHingeJoint_set_param_bounce_454_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeHingeJoint::set_param_CFM(float val)
 *******************************************************************/
static PyObject *Dtool_OdeHingeJoint_set_param_CFM_455(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHingeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHingeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeHingeJoint::set_param_CFM(float val)
        double param1;
        static char * key_word_list[] = {(char *)"val", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setParamCFM", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setParamCFM", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_param_CFM((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeHingeJoint.setParamCFM() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamCFM(non-const OdeHingeJoint this, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHingeJoint_set_param_CFM_455_comment =
    "C++ Interface:\n"
    "setParamCFM(non-const OdeHingeJoint this, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHingeJoint_set_param_CFM_455_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeHingeJoint::set_param_stop_ERP(float val)
 *******************************************************************/
static PyObject *Dtool_OdeHingeJoint_set_param_stop_ERP_456(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHingeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHingeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeHingeJoint::set_param_stop_ERP(float val)
        double param1;
        static char * key_word_list[] = {(char *)"val", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setParamStopERP", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setParamStopERP", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_param_stop_ERP((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeHingeJoint.setParamStopERP() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamStopERP(non-const OdeHingeJoint this, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHingeJoint_set_param_stop_ERP_456_comment =
    "C++ Interface:\n"
    "setParamStopERP(non-const OdeHingeJoint this, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHingeJoint_set_param_stop_ERP_456_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeHingeJoint::set_param_stop_CFM(float val)
 *******************************************************************/
static PyObject *Dtool_OdeHingeJoint_set_param_stop_CFM_457(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHingeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHingeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeHingeJoint::set_param_stop_CFM(float val)
        double param1;
        static char * key_word_list[] = {(char *)"val", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setParamStopCFM", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setParamStopCFM", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_param_stop_CFM((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeHingeJoint.setParamStopCFM() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamStopCFM(non-const OdeHingeJoint this, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHingeJoint_set_param_stop_CFM_457_comment =
    "C++ Interface:\n"
    "setParamStopCFM(non-const OdeHingeJoint this, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHingeJoint_set_param_stop_CFM_457_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeHingeJoint::get_param_lo_stop(void) const
 *******************************************************************/
static PyObject *Dtool_OdeHingeJoint_get_param_lo_stop_458(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHingeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHingeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeHingeJoint::get_param_lo_stop(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getParamLoStop", key_word_list));
        else
            (PyArg_Parse(args, ":getParamLoStop"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeHingeJoint*)local_this)->get_param_lo_stop();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamLoStop(const OdeHingeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHingeJoint_get_param_lo_stop_458_comment =
    "C++ Interface:\n"
    "getParamLoStop(const OdeHingeJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHingeJoint_get_param_lo_stop_458_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeHingeJoint::get_param_hi_stop(void) const
 *******************************************************************/
static PyObject *Dtool_OdeHingeJoint_get_param_hi_stop_459(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHingeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHingeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeHingeJoint::get_param_hi_stop(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getParamHiStop", key_word_list));
        else
            (PyArg_Parse(args, ":getParamHiStop"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeHingeJoint*)local_this)->get_param_hi_stop();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamHiStop(const OdeHingeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHingeJoint_get_param_hi_stop_459_comment =
    "C++ Interface:\n"
    "getParamHiStop(const OdeHingeJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHingeJoint_get_param_hi_stop_459_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeHingeJoint::get_param_vel(void) const
 *******************************************************************/
static PyObject *Dtool_OdeHingeJoint_get_param_vel_460(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHingeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHingeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeHingeJoint::get_param_vel(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getParamVel", key_word_list));
        else
            (PyArg_Parse(args, ":getParamVel"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeHingeJoint*)local_this)->get_param_vel();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamVel(const OdeHingeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHingeJoint_get_param_vel_460_comment =
    "C++ Interface:\n"
    "getParamVel(const OdeHingeJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHingeJoint_get_param_vel_460_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeHingeJoint::get_param_f_max(void) const
 *******************************************************************/
static PyObject *Dtool_OdeHingeJoint_get_param_f_max_461(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHingeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHingeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeHingeJoint::get_param_f_max(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getParamFMax", key_word_list));
        else
            (PyArg_Parse(args, ":getParamFMax"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeHingeJoint*)local_this)->get_param_f_max();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamFMax(const OdeHingeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHingeJoint_get_param_f_max_461_comment =
    "C++ Interface:\n"
    "getParamFMax(const OdeHingeJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHingeJoint_get_param_f_max_461_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeHingeJoint::get_param_fudge_factor(void) const
 *******************************************************************/
static PyObject *Dtool_OdeHingeJoint_get_param_fudge_factor_462(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHingeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHingeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeHingeJoint::get_param_fudge_factor(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getParamFudgeFactor", key_word_list));
        else
            (PyArg_Parse(args, ":getParamFudgeFactor"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeHingeJoint*)local_this)->get_param_fudge_factor();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamFudgeFactor(const OdeHingeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHingeJoint_get_param_fudge_factor_462_comment =
    "C++ Interface:\n"
    "getParamFudgeFactor(const OdeHingeJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHingeJoint_get_param_fudge_factor_462_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeHingeJoint::get_param_bounce(void) const
 *******************************************************************/
static PyObject *Dtool_OdeHingeJoint_get_param_bounce_463(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHingeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHingeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeHingeJoint::get_param_bounce(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getParamBounce", key_word_list));
        else
            (PyArg_Parse(args, ":getParamBounce"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeHingeJoint*)local_this)->get_param_bounce();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamBounce(const OdeHingeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHingeJoint_get_param_bounce_463_comment =
    "C++ Interface:\n"
    "getParamBounce(const OdeHingeJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHingeJoint_get_param_bounce_463_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeHingeJoint::get_param_CFM(void) const
 *******************************************************************/
static PyObject *Dtool_OdeHingeJoint_get_param_CFM_464(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHingeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHingeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeHingeJoint::get_param_CFM(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getParamCFM", key_word_list));
        else
            (PyArg_Parse(args, ":getParamCFM"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeHingeJoint*)local_this)->get_param_CFM();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamCFM(const OdeHingeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHingeJoint_get_param_CFM_464_comment =
    "C++ Interface:\n"
    "getParamCFM(const OdeHingeJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHingeJoint_get_param_CFM_464_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeHingeJoint::get_param_stop_ERP(void) const
 *******************************************************************/
static PyObject *Dtool_OdeHingeJoint_get_param_stop_ERP_465(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHingeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHingeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeHingeJoint::get_param_stop_ERP(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getParamStopERP", key_word_list));
        else
            (PyArg_Parse(args, ":getParamStopERP"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeHingeJoint*)local_this)->get_param_stop_ERP();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamStopERP(const OdeHingeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHingeJoint_get_param_stop_ERP_465_comment =
    "C++ Interface:\n"
    "getParamStopERP(const OdeHingeJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHingeJoint_get_param_stop_ERP_465_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeHingeJoint::get_param_stop_CFM(void) const
 *******************************************************************/
static PyObject *Dtool_OdeHingeJoint_get_param_stop_CFM_466(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeHingeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeHingeJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeHingeJoint::get_param_stop_CFM(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getParamStopCFM", key_word_list));
        else
            (PyArg_Parse(args, ":getParamStopCFM"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeHingeJoint*)local_this)->get_param_stop_CFM();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamStopCFM(const OdeHingeJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHingeJoint_get_param_stop_CFM_466_comment =
    "C++ Interface:\n"
    "getParamStopCFM(const OdeHingeJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHingeJoint_get_param_stop_CFM_466_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeHingeJoint::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeHingeJoint_get_class_type_467(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeHingeJoint::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeHingeJoint::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeHingeJoint_get_class_type_467_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeHingeJoint_get_class_type_467_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeHingeJoint::OdeHingeJoint(OdeWorld &world)
 * OdeHingeJoint::OdeHingeJoint(OdeWorld &world, OdeJointGroup &joint_group)
 *******************************************************************/
int  Dtool_Init_OdeHingeJoint(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeHingeJoint::OdeHingeJoint(OdeWorld &world)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"world", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:OdeHingeJoint", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:OdeHingeJoint", &param0));
                if(!PyErr_Occurred())
                {
                    OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeWorld, 0, "OdeHingeJoint.OdeHingeJoint", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        OdeHingeJoint *return_value = new OdeHingeJoint(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeHingeJoint,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeHingeJoint::OdeHingeJoint(OdeWorld &world, OdeJointGroup &joint_group)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"world", (char *)"joint_group", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:OdeHingeJoint", key_word_list, &param0, &param1))
                {
                    OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeWorld, 0, "OdeHingeJoint.OdeHingeJoint", 0, coerced_ptr, report_errors);
OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeJointGroup, 1, "OdeHingeJoint.OdeHingeJoint", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        OdeHingeJoint *return_value = new OdeHingeJoint(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeHingeJoint,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OdeHingeJoint() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OdeHingeJoint(non-const OdeWorld world)\n"
          "OdeHingeJoint(non-const OdeWorld world, non-const OdeJointGroup joint_group)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OdeHingeJoint(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeHingeJoint)
    {
        printf("OdeHingeJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeHingeJoint * local_this = (OdeHingeJoint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeHingeJoint)
        return local_this;
    if(requested_type == &Dtool_OdeJoint)
        return ( OdeJoint *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( OdeJoint *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeHingeJoint(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeHingeJoint)
        return from_this;
    if(from_type == &Dtool_OdeJoint)
    {
          OdeJoint* other_this = (OdeJoint*)from_this;
          return (OdeHingeJoint*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeHingeJoint*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeJointCollection 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void OdeJointCollection::operator =(OdeJointCollection const &copy)
 *******************************************************************/
static PyObject *Dtool_OdeJointCollection_operator_470(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJointCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJointCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void OdeJointCollection::operator =(OdeJointCollection const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                OdeJointCollection *param1_this = (OdeJointCollection *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeJointCollection, 1, "OdeJointCollection.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    OdeJointCollection *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_OdeJointCollection,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeJointCollection.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const OdeJointCollection this, const OdeJointCollection copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJointCollection_operator_470_comment =
    "C++ Interface:\n"
    "assign(non-const OdeJointCollection this, const OdeJointCollection copy)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJointCollection_operator_470_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void OdeJointCollection::add_joint(OdeJoint const &joint)
 *******************************************************************/
static PyObject *Dtool_OdeJointCollection_add_joint_472(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJointCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJointCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void OdeJointCollection::add_joint(OdeJoint const &joint)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"joint", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addJoint", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addJoint", &param1));
            if(!PyErr_Occurred())
            {
                OdeJoint *param1_this = (OdeJoint *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeJoint, 1, "OdeJointCollection.addJoint", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_joint(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeJointCollection.addJoint() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addJoint(non-const OdeJointCollection this, const OdeJoint joint)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJointCollection_add_joint_472_comment =
    "C++ Interface:\n"
    "addJoint(non-const OdeJointCollection this, const OdeJoint joint)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJointCollection_add_joint_472_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool OdeJointCollection::remove_joint(OdeJoint const &joint)
 *******************************************************************/
static PyObject *Dtool_OdeJointCollection_remove_joint_473(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJointCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJointCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-bool OdeJointCollection::remove_joint(OdeJoint const &joint)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"joint", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeJoint", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeJoint", &param1));
            if(!PyErr_Occurred())
            {
                OdeJoint *param1_this = (OdeJoint *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeJoint, 1, "OdeJointCollection.removeJoint", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = (local_this)->remove_joint(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeJointCollection.removeJoint() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeJoint(non-const OdeJointCollection this, const OdeJoint joint)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJointCollection_remove_joint_473_comment =
    "C++ Interface:\n"
    "removeJoint(non-const OdeJointCollection this, const OdeJoint joint)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJointCollection_remove_joint_473_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void OdeJointCollection::add_joints_from(OdeJointCollection const &other)
 *******************************************************************/
static PyObject *Dtool_OdeJointCollection_add_joints_from_474(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJointCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJointCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void OdeJointCollection::add_joints_from(OdeJointCollection const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:addJointsFrom", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:addJointsFrom", &param1));
            if(!PyErr_Occurred())
            {
                OdeJointCollection *param1_this = (OdeJointCollection *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeJointCollection, 1, "OdeJointCollection.addJointsFrom", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->add_joints_from(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeJointCollection.addJointsFrom() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addJointsFrom(non-const OdeJointCollection this, const OdeJointCollection other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJointCollection_add_joints_from_474_comment =
    "C++ Interface:\n"
    "addJointsFrom(non-const OdeJointCollection this, const OdeJointCollection other)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJointCollection_add_joints_from_474_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void OdeJointCollection::remove_joints_from(OdeJointCollection const &other)
 *******************************************************************/
static PyObject *Dtool_OdeJointCollection_remove_joints_from_475(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJointCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJointCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-void OdeJointCollection::remove_joints_from(OdeJointCollection const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:removeJointsFrom", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:removeJointsFrom", &param1));
            if(!PyErr_Occurred())
            {
                OdeJointCollection *param1_this = (OdeJointCollection *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeJointCollection, 1, "OdeJointCollection.removeJointsFrom", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->remove_joints_from(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeJointCollection.removeJointsFrom() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeJointsFrom(non-const OdeJointCollection this, const OdeJointCollection other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJointCollection_remove_joints_from_475_comment =
    "C++ Interface:\n"
    "removeJointsFrom(non-const OdeJointCollection this, const OdeJointCollection other)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJointCollection_remove_joints_from_475_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void OdeJointCollection::remove_duplicate_joints(void)
 *******************************************************************/
static PyObject *Dtool_OdeJointCollection_remove_duplicate_joints_476(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJointCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJointCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void OdeJointCollection::remove_duplicate_joints(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":removeDuplicateJoints", key_word_list));
        else
            (PyArg_Parse(args, ":removeDuplicateJoints"));
        if(!PyErr_Occurred())
        {
            (local_this)->remove_duplicate_joints();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeJointCollection.removeDuplicateJoints() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "removeDuplicateJoints(non-const OdeJointCollection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJointCollection_remove_duplicate_joints_476_comment =
    "C++ Interface:\n"
    "removeDuplicateJoints(non-const OdeJointCollection this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJointCollection_remove_duplicate_joints_476_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool OdeJointCollection::has_joint(OdeJoint const &joint) const
 *******************************************************************/
static PyObject *Dtool_OdeJointCollection_has_joint_477(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJointCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJointCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-bool OdeJointCollection::has_joint(OdeJoint const &joint) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"joint", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:hasJoint", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:hasJoint", &param1));
            if(!PyErr_Occurred())
            {
                OdeJoint *param1_this = (OdeJoint *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeJoint, 1, "OdeJointCollection.hasJoint", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    bool return_value = ((const OdeJointCollection*)local_this)->has_joint(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "hasJoint(const OdeJointCollection this, const OdeJoint joint)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJointCollection_has_joint_477_comment =
    "C++ Interface:\n"
    "hasJoint(const OdeJointCollection this, const OdeJoint joint)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJointCollection_has_joint_477_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void OdeJointCollection::clear(void)
 *******************************************************************/
static PyObject *Dtool_OdeJointCollection_clear_478(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJointCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJointCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void OdeJointCollection::clear(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":clear", key_word_list));
        else
            (PyArg_Parse(args, ":clear"));
        if(!PyErr_Occurred())
        {
            (local_this)->clear();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeJointCollection.clear() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clear(non-const OdeJointCollection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJointCollection_clear_478_comment =
    "C++ Interface:\n"
    "clear(non-const OdeJointCollection this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJointCollection_clear_478_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * bool OdeJointCollection::is_empty(void) const
 *******************************************************************/
static PyObject *Dtool_OdeJointCollection_is_empty_479(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJointCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJointCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-bool OdeJointCollection::is_empty(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isEmpty", key_word_list));
        else
            (PyArg_Parse(args, ":isEmpty"));
        if(!PyErr_Occurred())
        {
            bool return_value = ((const OdeJointCollection*)local_this)->is_empty();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isEmpty(const OdeJointCollection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJointCollection_is_empty_479_comment =
    "C++ Interface:\n"
    "isEmpty(const OdeJointCollection this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJointCollection_is_empty_479_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int OdeJointCollection::get_num_joints(void) const
 *******************************************************************/
static PyObject *Dtool_OdeJointCollection_get_num_joints_480(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJointCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJointCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int OdeJointCollection::get_num_joints(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumJoints", key_word_list));
        else
            (PyArg_Parse(args, ":getNumJoints"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const OdeJointCollection*)local_this)->get_num_joints();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumJoints(const OdeJointCollection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJointCollection_get_num_joints_480_comment =
    "C++ Interface:\n"
    "getNumJoints(const OdeJointCollection this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJointCollection_get_num_joints_480_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeJoint OdeJointCollection::get_joint(int index) const
 *******************************************************************/
static PyObject *Dtool_OdeJointCollection_get_joint_481(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJointCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJointCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-OdeJoint OdeJointCollection::get_joint(int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getJoint", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getJoint", &param1));
        if(!PyErr_Occurred())
        {
            OdeJoint result = ((const OdeJointCollection*)local_this)->get_joint((int)param1);
            OdeJoint *return_value = new OdeJoint(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeJoint,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getJoint(const OdeJointCollection this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJointCollection_get_joint_481_comment =
    "C++ Interface:\n"
    "getJoint(const OdeJointCollection this, int index)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJointCollection_get_joint_481_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeJoint OdeJointCollection::operator [](int index) const
 *******************************************************************/
static PyObject *Dtool_OdeJointCollection_operator_482(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJointCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJointCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-OdeJoint OdeJointCollection::operator [](int index) const
        int param1;
        static char * key_word_list[] = {(char *)"index", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:__getitem__", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:__getitem__", &param1));
        if(!PyErr_Occurred())
        {
            if (((int)param1) < 0 || ((int)param1) >= ((const OdeJointCollection*)local_this)->size()) {
              PyErr_SetString(PyExc_IndexError, "Out of bounds.");
              return NULL;
            }
            OdeJoint result = ((const OdeJointCollection*)local_this)->operator []((int)param1);
            OdeJoint *return_value = new OdeJoint(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeJoint,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__getitem__(const OdeJointCollection this, int index)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJointCollection_operator_482_comment =
    "C++ Interface:\n"
    "__getitem__(const OdeJointCollection this, int index)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJointCollection_operator_482_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * int OdeJointCollection::size(void) const
 *******************************************************************/
static PyObject *Dtool_OdeJointCollection_size_483(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJointCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJointCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-int OdeJointCollection::size(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":size", key_word_list));
        else
            (PyArg_Parse(args, ":size"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const OdeJointCollection*)local_this)->size();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "size(const OdeJointCollection this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJointCollection_size_483_comment =
    "C++ Interface:\n"
    "size(const OdeJointCollection this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeJointCollection_size_483_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeJointCollection::operator +=(OdeJointCollection const &other)
 *******************************************************************/
static PyObject *Dtool_OdeJointCollection_operator_484(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJointCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJointCollection,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeJointCollection::operator +=(OdeJointCollection const &other)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__iadd__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__iadd__", &param1));
            if(!PyErr_Occurred())
            {
                OdeJointCollection *param1_this = (OdeJointCollection *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeJointCollection, 1, "OdeJointCollection.__iadd__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator +=(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      Py_INCREF(self);
                      return self;
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeJointCollection.__iadd__() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__iadd__(non-const OdeJointCollection this, const OdeJointCollection other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJointCollection_operator_484_comment =
    "C++ Interface:\n"
    "__iadd__(non-const OdeJointCollection this, const OdeJointCollection other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OdeJointCollection::operator +=\n"
    "//       Access: Published\n"
    "//  Description: Appends the other list onto the end of this one.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeJointCollection_operator_484_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline OdeJointCollection OdeJointCollection::operator +(OdeJointCollection const &other) const
 *******************************************************************/
static PyObject *Dtool_OdeJointCollection_operator_485(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeJointCollection * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJointCollection,(void **)&local_this);
    if(local_this == NULL) {
       Py_INCREF(Py_NotImplemented);
       return Py_NotImplemented;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline OdeJointCollection OdeJointCollection::operator +(OdeJointCollection const &other) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"other", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:__add__", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:__add__", &param1));
            if(!PyErr_Occurred())
            {
                OdeJointCollection *param1_this = (OdeJointCollection *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeJointCollection, 1, "OdeJointCollection.__add__", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    OdeJointCollection result = ((const OdeJointCollection*)local_this)->operator +(*param1_this);
                    OdeJointCollection *return_value = new OdeJointCollection(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_OdeJointCollection,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "__add__(const OdeJointCollection this, const OdeJointCollection other)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeJointCollection_operator_485_comment =
    "C++ Interface:\n"
    "__add__(const OdeJointCollection this, const OdeJointCollection other)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: OdeJointCollection::operator +\n"
    "//       Access: Published\n"
    "//  Description: Returns a OdeJointCollection representing the\n"
    "//               concatenation of the two lists.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeJointCollection_operator_485_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeJointCollection::OdeJointCollection(void)
 * OdeJointCollection::OdeJointCollection(OdeJointCollection const &copy)
 *******************************************************************/
int  Dtool_Init_OdeJointCollection(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-OdeJointCollection::OdeJointCollection(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":OdeJointCollection", key_word_list))
            {
                OdeJointCollection *return_value = new OdeJointCollection();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeJointCollection,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeJointCollection::OdeJointCollection(OdeJointCollection const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:OdeJointCollection", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:OdeJointCollection", &param0));
                if(!PyErr_Occurred())
                {
                    OdeJointCollection *param0_this = (OdeJointCollection *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeJointCollection, 0, "OdeJointCollection.OdeJointCollection", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        OdeJointCollection *return_value = new OdeJointCollection(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeJointCollection,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OdeJointCollection() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OdeJointCollection()\n"
          "OdeJointCollection(const OdeJointCollection copy)\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_OdeJointCollection_get_joints(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumJoints", "getJoint");
}
inline void  * Dtool_UpcastInterface_OdeJointCollection(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeJointCollection)
    {
        printf("OdeJointCollection ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeJointCollection * local_this = (OdeJointCollection *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeJointCollection)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeJointCollection(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeJointCollection)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeLMotorJoint 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void OdeLMotorJoint::set_num_axes(int num)
 *******************************************************************/
static PyObject *Dtool_OdeLMotorJoint_set_num_axes_488(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeLMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeLMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeLMotorJoint::set_num_axes(int num)
        int param1;
        static char * key_word_list[] = {(char *)"num", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setNumAxes", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setNumAxes", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_num_axes((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeLMotorJoint.setNumAxes() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setNumAxes(non-const OdeLMotorJoint this, int num)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeLMotorJoint_set_num_axes_488_comment =
    "C++ Interface:\n"
    "setNumAxes(non-const OdeLMotorJoint this, int num)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeLMotorJoint_set_num_axes_488_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeLMotorJoint::set_axis(int anum, int rel, LVecBase3f const &axis)
 * inline void OdeLMotorJoint::set_axis(int anum, int rel, float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_OdeLMotorJoint_set_axis_489(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeLMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeLMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeLMotorJoint::set_axis(int anum, int rel, LVecBase3f const &axis)
                int param1;
                int param2;
                PyObject *param3;
                static char * key_word_list[] = {(char *)"anum", (char *)"rel", (char *)"axis", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "iiO:setAxis", key_word_list, &param1, &param2, &param3))
                {
                    LVecBase3f *param3_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LVecBase3f, 3, "OdeLMotorJoint.setAxis", 1, coerced_ptr, report_errors);

                    if (!((param3_this == NULL)))
                    {
                        (local_this)->set_axis((int)param1, (int)param2, *param3_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeLMotorJoint.setAxis() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(5):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeLMotorJoint::set_axis(int anum, int rel, float x, float y, float z)
            int param1;
            int param2;
            double param3;
            double param4;
            double param5;
            static char * key_word_list[] = {(char *)"anum", (char *)"rel", (char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iiddd:setAxis", key_word_list, &param1, &param2, &param3, &param4, &param5))
            {
                (local_this)->set_axis((int)param1, (int)param2, (float)param3, (float)param4, (float)param5);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeLMotorJoint.setAxis() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setAxis() takes 4 or 6 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setAxis(non-const OdeLMotorJoint this, int anum, int rel, const VBase3 axis)\n"
          "setAxis(non-const OdeLMotorJoint this, int anum, int rel, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeLMotorJoint_set_axis_489_comment =
    "C++ Interface:\n"
    "setAxis(non-const OdeLMotorJoint this, int anum, int rel, const VBase3 axis)\n"
    "setAxis(non-const OdeLMotorJoint this, int anum, int rel, float x, float y, float z)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeLMotorJoint_set_axis_489_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeLMotorJoint::set_param(int parameter, float value)
 *******************************************************************/
static PyObject *Dtool_OdeLMotorJoint_set_param_490(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeLMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeLMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeLMotorJoint::set_param(int parameter, float value)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"parameter", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setParam", key_word_list, &param1, &param2))
        {
            (local_this)->set_param((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeLMotorJoint.setParam() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParam(non-const OdeLMotorJoint this, int parameter, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeLMotorJoint_set_param_490_comment =
    "C++ Interface:\n"
    "setParam(non-const OdeLMotorJoint this, int parameter, float value)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeLMotorJoint_set_param_490_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeLMotorJoint::get_num_axes(void) const
 *******************************************************************/
static PyObject *Dtool_OdeLMotorJoint_get_num_axes_491(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeLMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeLMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int OdeLMotorJoint::get_num_axes(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumAxes", key_word_list));
        else
            (PyArg_Parse(args, ":getNumAxes"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const OdeLMotorJoint*)local_this)->get_num_axes();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumAxes(const OdeLMotorJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeLMotorJoint_get_num_axes_491_comment =
    "C++ Interface:\n"
    "getNumAxes(const OdeLMotorJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeLMotorJoint_get_num_axes_491_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f OdeLMotorJoint::get_axis(int anum) const
 *******************************************************************/
static PyObject *Dtool_OdeLMotorJoint_get_axis_492(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeLMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeLMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f OdeLMotorJoint::get_axis(int anum) const
        int param1;
        static char * key_word_list[] = {(char *)"anum", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getAxis", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getAxis", &param1));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const OdeLMotorJoint*)local_this)->get_axis((int)param1);
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAxis(const OdeLMotorJoint this, int anum)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeLMotorJoint_get_axis_492_comment =
    "C++ Interface:\n"
    "getAxis(const OdeLMotorJoint this, int anum)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeLMotorJoint_get_axis_492_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeLMotorJoint::get_param(int parameter) const
 *******************************************************************/
static PyObject *Dtool_OdeLMotorJoint_get_param_493(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeLMotorJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeLMotorJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeLMotorJoint::get_param(int parameter) const
        int param1;
        static char * key_word_list[] = {(char *)"parameter", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParam", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParam", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeLMotorJoint*)local_this)->get_param((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParam(const OdeLMotorJoint this, int parameter)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeLMotorJoint_get_param_493_comment =
    "C++ Interface:\n"
    "getParam(const OdeLMotorJoint this, int parameter)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeLMotorJoint_get_param_493_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeLMotorJoint::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeLMotorJoint_get_class_type_494(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeLMotorJoint::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeLMotorJoint::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeLMotorJoint_get_class_type_494_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeLMotorJoint_get_class_type_494_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeLMotorJoint::OdeLMotorJoint(OdeWorld &world)
 * OdeLMotorJoint::OdeLMotorJoint(OdeWorld &world, OdeJointGroup &joint_group)
 *******************************************************************/
int  Dtool_Init_OdeLMotorJoint(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeLMotorJoint::OdeLMotorJoint(OdeWorld &world)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"world", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:OdeLMotorJoint", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:OdeLMotorJoint", &param0));
                if(!PyErr_Occurred())
                {
                    OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeWorld, 0, "OdeLMotorJoint.OdeLMotorJoint", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        OdeLMotorJoint *return_value = new OdeLMotorJoint(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeLMotorJoint,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeLMotorJoint::OdeLMotorJoint(OdeWorld &world, OdeJointGroup &joint_group)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"world", (char *)"joint_group", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:OdeLMotorJoint", key_word_list, &param0, &param1))
                {
                    OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeWorld, 0, "OdeLMotorJoint.OdeLMotorJoint", 0, coerced_ptr, report_errors);
OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeJointGroup, 1, "OdeLMotorJoint.OdeLMotorJoint", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        OdeLMotorJoint *return_value = new OdeLMotorJoint(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeLMotorJoint,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OdeLMotorJoint() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OdeLMotorJoint(non-const OdeWorld world)\n"
          "OdeLMotorJoint(non-const OdeWorld world, non-const OdeJointGroup joint_group)\n"
          "");
    return -1;
}


/******************************************************************
 * Python make_seq wrapper
 *******************************************************************/
static PyObject *MakeSeq_OdeLMotorJoint_get_axes(PyObject *self, PyObject *) {
  return make_list_for_item(self, "getNumAxes", "getAxis");
}
inline void  * Dtool_UpcastInterface_OdeLMotorJoint(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeLMotorJoint)
    {
        printf("OdeLMotorJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeLMotorJoint * local_this = (OdeLMotorJoint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeLMotorJoint)
        return local_this;
    if(requested_type == &Dtool_OdeJoint)
        return ( OdeJoint *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( OdeJoint *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeLMotorJoint(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeLMotorJoint)
        return from_this;
    if(from_type == &Dtool_OdeJoint)
    {
          OdeJoint* other_this = (OdeJoint*)from_this;
          return (OdeLMotorJoint*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeLMotorJoint*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeNullJoint 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeNullJoint::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeNullJoint_get_class_type_497(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeNullJoint::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeNullJoint::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeNullJoint_get_class_type_497_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeNullJoint_get_class_type_497_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeNullJoint::OdeNullJoint(OdeWorld &world)
 * OdeNullJoint::OdeNullJoint(OdeWorld &world, OdeJointGroup &joint_group)
 *******************************************************************/
int  Dtool_Init_OdeNullJoint(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeNullJoint::OdeNullJoint(OdeWorld &world)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"world", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:OdeNullJoint", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:OdeNullJoint", &param0));
                if(!PyErr_Occurred())
                {
                    OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeWorld, 0, "OdeNullJoint.OdeNullJoint", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        OdeNullJoint *return_value = new OdeNullJoint(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeNullJoint,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeNullJoint::OdeNullJoint(OdeWorld &world, OdeJointGroup &joint_group)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"world", (char *)"joint_group", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:OdeNullJoint", key_word_list, &param0, &param1))
                {
                    OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeWorld, 0, "OdeNullJoint.OdeNullJoint", 0, coerced_ptr, report_errors);
OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeJointGroup, 1, "OdeNullJoint.OdeNullJoint", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        OdeNullJoint *return_value = new OdeNullJoint(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeNullJoint,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OdeNullJoint() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OdeNullJoint(non-const OdeWorld world)\n"
          "OdeNullJoint(non-const OdeWorld world, non-const OdeJointGroup joint_group)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OdeNullJoint(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeNullJoint)
    {
        printf("OdeNullJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeNullJoint * local_this = (OdeNullJoint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeNullJoint)
        return local_this;
    if(requested_type == &Dtool_OdeJoint)
        return ( OdeJoint *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( OdeJoint *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeNullJoint(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeNullJoint)
        return from_this;
    if(from_type == &Dtool_OdeJoint)
    {
          OdeJoint* other_this = (OdeJoint*)from_this;
          return (OdeNullJoint*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeNullJoint*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdePlane2dJoint 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void OdePlane2dJoint::set_x_param(int parameter, float value)
 *******************************************************************/
static PyObject *Dtool_OdePlane2dJoint_set_x_param_500(PyObject *self, PyObject *args,PyObject *kwds) {
    OdePlane2dJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdePlane2dJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdePlane2dJoint::set_x_param(int parameter, float value)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"parameter", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setXParam", key_word_list, &param1, &param2))
        {
            (local_this)->set_x_param((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdePlane2dJoint.setXParam() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setXParam(non-const OdePlane2dJoint this, int parameter, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdePlane2dJoint_set_x_param_500_comment =
    "C++ Interface:\n"
    "setXParam(non-const OdePlane2dJoint this, int parameter, float value)\n"
    "\n"
    "// Filename: odePlane2dJoint.I\n"
    "// Created by:  joswilso (27Dec06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdePlane2dJoint_set_x_param_500_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdePlane2dJoint::set_y_param(int parameter, float value)
 *******************************************************************/
static PyObject *Dtool_OdePlane2dJoint_set_y_param_501(PyObject *self, PyObject *args,PyObject *kwds) {
    OdePlane2dJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdePlane2dJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdePlane2dJoint::set_y_param(int parameter, float value)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"parameter", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setYParam", key_word_list, &param1, &param2))
        {
            (local_this)->set_y_param((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdePlane2dJoint.setYParam() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setYParam(non-const OdePlane2dJoint this, int parameter, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdePlane2dJoint_set_y_param_501_comment =
    "C++ Interface:\n"
    "setYParam(non-const OdePlane2dJoint this, int parameter, float value)\n"
    "\n"
    "";
#else
static const char * Dtool_OdePlane2dJoint_set_y_param_501_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdePlane2dJoint::set_angle_param(int parameter, float value)
 *******************************************************************/
static PyObject *Dtool_OdePlane2dJoint_set_angle_param_502(PyObject *self, PyObject *args,PyObject *kwds) {
    OdePlane2dJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdePlane2dJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdePlane2dJoint::set_angle_param(int parameter, float value)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"parameter", (char *)"value", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setAngleParam", key_word_list, &param1, &param2))
        {
            (local_this)->set_angle_param((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdePlane2dJoint.setAngleParam() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setAngleParam(non-const OdePlane2dJoint this, int parameter, float value)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdePlane2dJoint_set_angle_param_502_comment =
    "C++ Interface:\n"
    "setAngleParam(non-const OdePlane2dJoint this, int parameter, float value)\n"
    "\n"
    "";
#else
static const char * Dtool_OdePlane2dJoint_set_angle_param_502_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdePlane2dJoint::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdePlane2dJoint_get_class_type_503(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdePlane2dJoint::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdePlane2dJoint::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdePlane2dJoint_get_class_type_503_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdePlane2dJoint_get_class_type_503_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdePlane2dJoint::OdePlane2dJoint(OdeWorld &world)
 * OdePlane2dJoint::OdePlane2dJoint(OdeWorld &world, OdeJointGroup &joint_group)
 *******************************************************************/
int  Dtool_Init_OdePlane2dJoint(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdePlane2dJoint::OdePlane2dJoint(OdeWorld &world)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"world", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:OdePlane2dJoint", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:OdePlane2dJoint", &param0));
                if(!PyErr_Occurred())
                {
                    OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeWorld, 0, "OdePlane2dJoint.OdePlane2dJoint", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        OdePlane2dJoint *return_value = new OdePlane2dJoint(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdePlane2dJoint,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdePlane2dJoint::OdePlane2dJoint(OdeWorld &world, OdeJointGroup &joint_group)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"world", (char *)"joint_group", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:OdePlane2dJoint", key_word_list, &param0, &param1))
                {
                    OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeWorld, 0, "OdePlane2dJoint.OdePlane2dJoint", 0, coerced_ptr, report_errors);
OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeJointGroup, 1, "OdePlane2dJoint.OdePlane2dJoint", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        OdePlane2dJoint *return_value = new OdePlane2dJoint(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdePlane2dJoint,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OdePlane2dJoint() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OdePlane2dJoint(non-const OdeWorld world)\n"
          "OdePlane2dJoint(non-const OdeWorld world, non-const OdeJointGroup joint_group)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OdePlane2dJoint(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdePlane2dJoint)
    {
        printf("OdePlane2dJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdePlane2dJoint * local_this = (OdePlane2dJoint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdePlane2dJoint)
        return local_this;
    if(requested_type == &Dtool_OdeJoint)
        return ( OdeJoint *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( OdeJoint *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdePlane2dJoint(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdePlane2dJoint)
        return from_this;
    if(from_type == &Dtool_OdeJoint)
    {
          OdeJoint* other_this = (OdeJoint*)from_this;
          return (OdePlane2dJoint*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdePlane2dJoint*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdePlaneGeom 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void OdePlaneGeom::set_params(LVecBase4f const &params)
 * inline void OdePlaneGeom::set_params(float a, float b, float c, float d)
 *******************************************************************/
static PyObject *Dtool_OdePlaneGeom_set_params_506(PyObject *self, PyObject *args,PyObject *kwds) {
    OdePlaneGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdePlaneGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdePlaneGeom::set_params(LVecBase4f const &params)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"params", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setParams", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setParams", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "OdePlaneGeom.setParams", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_params(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdePlaneGeom.setParams() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdePlaneGeom::set_params(float a, float b, float c, float d)
            double param1;
            double param2;
            double param3;
            double param4;
            static char * key_word_list[] = {(char *)"a", (char *)"b", (char *)"c", (char *)"d", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:setParams", key_word_list, &param1, &param2, &param3, &param4))
            {
                (local_this)->set_params((float)param1, (float)param2, (float)param3, (float)param4);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdePlaneGeom.setParams() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setParams() takes 2 or 5 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setParams(non-const OdePlaneGeom this, const VBase4 params)\n"
          "setParams(non-const OdePlaneGeom this, float a, float b, float c, float d)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdePlaneGeom_set_params_506_comment =
    "C++ Interface:\n"
    "setParams(non-const OdePlaneGeom this, const VBase4 params)\n"
    "setParams(non-const OdePlaneGeom this, float a, float b, float c, float d)\n"
    "\n"
    "// Filename: odePlaneGeom.I\n"
    "// Created by:  joswilso (27Dec06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdePlaneGeom_set_params_506_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase4f OdePlaneGeom::get_params(void) const
 *******************************************************************/
static PyObject *Dtool_OdePlaneGeom_get_params_507(PyObject *self, PyObject *args,PyObject *kwds) {
    OdePlaneGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdePlaneGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase4f OdePlaneGeom::get_params(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getParams", key_word_list));
        else
            (PyArg_Parse(args, ":getParams"));
        if(!PyErr_Occurred())
        {
            LVecBase4f result = ((const OdePlaneGeom*)local_this)->get_params();
            LVecBase4f *return_value = new LVecBase4f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase4f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParams(const OdePlaneGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdePlaneGeom_get_params_507_comment =
    "C++ Interface:\n"
    "getParams(const OdePlaneGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdePlaneGeom_get_params_507_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdePlaneGeom::get_point_depth(LPoint3f const &p) const
 * inline float OdePlaneGeom::get_point_depth(float x, float y, float z) const
 *******************************************************************/
static PyObject *Dtool_OdePlaneGeom_get_point_depth_508(PyObject *self, PyObject *args,PyObject *kwds) {
    OdePlaneGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdePlaneGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline float OdePlaneGeom::get_point_depth(LPoint3f const &p) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"p", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:getPointDepth", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:getPointDepth", &param1));
                if(!PyErr_Occurred())
                {
                    LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "OdePlaneGeom.getPointDepth", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        float return_value = ((const OdePlaneGeom*)local_this)->get_point_depth(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyFloat_FromDouble(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          // 1-inline float OdePlaneGeom::get_point_depth(float x, float y, float z) const
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:getPointDepth", key_word_list, &param1, &param2, &param3))
            {
                float return_value = ((const OdePlaneGeom*)local_this)->get_point_depth((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getPointDepth() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getPointDepth(const OdePlaneGeom this, const Point3 p)\n"
          "getPointDepth(const OdePlaneGeom this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdePlaneGeom_get_point_depth_508_comment =
    "C++ Interface:\n"
    "getPointDepth(const OdePlaneGeom this, const Point3 p)\n"
    "getPointDepth(const OdePlaneGeom this, float x, float y, float z)\n"
    "\n"
    "";
#else
static const char * Dtool_OdePlaneGeom_get_point_depth_508_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdePlaneGeom::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdePlaneGeom_get_class_type_509(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdePlaneGeom::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdePlaneGeom::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdePlaneGeom_get_class_type_509_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdePlaneGeom_get_class_type_509_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdePlaneGeom::OdePlaneGeom(LVecBase4f const &params)
 * OdePlaneGeom::OdePlaneGeom(OdeSpace &space, LVecBase4f const &params)
 * OdePlaneGeom::OdePlaneGeom(OdeSpace &space, float a, float b, float c, float d)
 * OdePlaneGeom::OdePlaneGeom(float a, float b, float c, float d)
 *******************************************************************/
int  Dtool_Init_OdePlaneGeom(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdePlaneGeom::OdePlaneGeom(LVecBase4f const &params)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"params", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:OdePlaneGeom", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:OdePlaneGeom", &param0));
                if(!PyErr_Occurred())
                {
                    LVecBase4f *param0_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LVecBase4f, 0, "OdePlaneGeom.OdePlaneGeom", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        OdePlaneGeom *return_value = new OdePlaneGeom(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdePlaneGeom,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdePlaneGeom::OdePlaneGeom(OdeSpace &space, LVecBase4f const &params)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"space", (char *)"params", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:OdePlaneGeom", key_word_list, &param0, &param1))
                {
                    OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeSpace, 0, "OdePlaneGeom.OdePlaneGeom", 0, coerced_ptr, report_errors);
LVecBase4f *param1_this = (LVecBase4f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase4f, 1, "OdePlaneGeom.OdePlaneGeom", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        OdePlaneGeom *return_value = new OdePlaneGeom(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdePlaneGeom,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          // 1-OdePlaneGeom::OdePlaneGeom(float a, float b, float c, float d)
            double param0;
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"a", (char *)"b", (char *)"c", (char *)"d", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddd:OdePlaneGeom", key_word_list, &param0, &param1, &param2, &param3))
            {
                OdePlaneGeom *return_value = new OdePlaneGeom((float)param0, (float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_OdePlaneGeom,true,false);
                }
            }
        }

        }
        break;
    case(5):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdePlaneGeom::OdePlaneGeom(OdeSpace &space, float a, float b, float c, float d)
                PyObject *param0;
                double param1;
                double param2;
                double param3;
                double param4;
                static char * key_word_list[] = {(char *)"space", (char *)"a", (char *)"b", (char *)"c", (char *)"d", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Odddd:OdePlaneGeom", key_word_list, &param0, &param1, &param2, &param3, &param4))
                {
                    OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeSpace, 0, "OdePlaneGeom.OdePlaneGeom", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        OdePlaneGeom *return_value = new OdePlaneGeom(*param0_this, (float)param1, (float)param2, (float)param3, (float)param4);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdePlaneGeom,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OdePlaneGeom() takes 1, 2, 4, or 5 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OdePlaneGeom(const VBase4 params)\n"
          "OdePlaneGeom(non-const OdeSpace space, const VBase4 params)\n"
          "OdePlaneGeom(float a, float b, float c, float d)\n"
          "OdePlaneGeom(non-const OdeSpace space, float a, float b, float c, float d)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OdePlaneGeom(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdePlaneGeom)
    {
        printf("OdePlaneGeom ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdePlaneGeom * local_this = (OdePlaneGeom *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdePlaneGeom)
        return local_this;
    if(requested_type == &Dtool_OdeGeom)
        return ( OdeGeom *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( OdeGeom *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdePlaneGeom(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdePlaneGeom)
        return from_this;
    if(from_type == &Dtool_OdeGeom)
    {
          OdeGeom* other_this = (OdeGeom*)from_this;
          return (OdePlaneGeom*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdePlaneGeom*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeQuadTreeSpace 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeQuadTreeSpace::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeQuadTreeSpace_get_class_type_512(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeQuadTreeSpace::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeQuadTreeSpace::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeQuadTreeSpace_get_class_type_512_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeQuadTreeSpace_get_class_type_512_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeQuadTreeSpace::OdeQuadTreeSpace(LPoint3f const &center, LVecBase3f const &extents, int const depth)
 * OdeQuadTreeSpace::OdeQuadTreeSpace(OdeSpace &space, LPoint3f const &center, LVecBase3f const &extents, int const depth)
 *******************************************************************/
int  Dtool_Init_OdeQuadTreeSpace(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeQuadTreeSpace::OdeQuadTreeSpace(LPoint3f const &center, LVecBase3f const &extents, int const depth)
                PyObject *param0;
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"center", (char *)"extents", (char *)"depth", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:OdeQuadTreeSpace", key_word_list, &param0, &param1, &param2))
                {
                    LPoint3f *param0_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_LPoint3f, 0, "OdeQuadTreeSpace.OdeQuadTreeSpace", 1, coerced_ptr, report_errors);
LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeQuadTreeSpace.OdeQuadTreeSpace", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        OdeQuadTreeSpace *return_value = new OdeQuadTreeSpace(*param0_this, *param1_this, (int)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeQuadTreeSpace,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(4):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeQuadTreeSpace::OdeQuadTreeSpace(OdeSpace &space, LPoint3f const &center, LVecBase3f const &extents, int const depth)
                PyObject *param0;
                PyObject *param1;
                PyObject *param2;
                int param3;
                static char * key_word_list[] = {(char *)"space", (char *)"center", (char *)"extents", (char *)"depth", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOi:OdeQuadTreeSpace", key_word_list, &param0, &param1, &param2, &param3))
                {
                    OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeSpace, 0, "OdeQuadTreeSpace.OdeQuadTreeSpace", 0, coerced_ptr, report_errors);
LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "OdeQuadTreeSpace.OdeQuadTreeSpace", 1, coerced_ptr, report_errors);
LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "OdeQuadTreeSpace.OdeQuadTreeSpace", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)|| (param2_this == NULL)))
                    {
                        OdeQuadTreeSpace *return_value = new OdeQuadTreeSpace(*param0_this, *param1_this, *param2_this, (int)param3);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeQuadTreeSpace,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OdeQuadTreeSpace() takes 3 or 4 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OdeQuadTreeSpace(const Point3 center, const VBase3 extents, int depth)\n"
          "OdeQuadTreeSpace(non-const OdeSpace space, const Point3 center, const VBase3 extents, int depth)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OdeQuadTreeSpace(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeQuadTreeSpace)
    {
        printf("OdeQuadTreeSpace ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeQuadTreeSpace * local_this = (OdeQuadTreeSpace *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeQuadTreeSpace)
        return local_this;
    if(requested_type == &Dtool_OdeSpace)
        return ( OdeSpace *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( OdeSpace *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeQuadTreeSpace(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeQuadTreeSpace)
        return from_this;
    if(from_type == &Dtool_OdeSpace)
    {
          OdeSpace* other_this = (OdeSpace*)from_this;
          return (OdeQuadTreeSpace*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeQuadTreeSpace*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeRayGeom 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void OdeRayGeom::set_length(float length)
 *******************************************************************/
static PyObject *Dtool_OdeRayGeom_set_length_515(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeRayGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeRayGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeRayGeom::set_length(float length)
        double param1;
        static char * key_word_list[] = {(char *)"length", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setLength", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setLength", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_length((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeRayGeom.setLength() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setLength(non-const OdeRayGeom this, float length)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeRayGeom_set_length_515_comment =
    "C++ Interface:\n"
    "setLength(non-const OdeRayGeom this, float length)\n"
    "\n"
    "// Filename: odeRayGeom.I\n"
    "// Created by:  joswilso (27Dec06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeRayGeom_set_length_515_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeRayGeom::get_length(void)
 *******************************************************************/
static PyObject *Dtool_OdeRayGeom_get_length_516(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeRayGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeRayGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline float OdeRayGeom::get_length(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getLength", key_word_list));
        else
            (PyArg_Parse(args, ":getLength"));
        if(!PyErr_Occurred())
        {
            float return_value = (local_this)->get_length();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeRayGeom.getLength() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getLength(non-const OdeRayGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeRayGeom_get_length_516_comment =
    "C++ Interface:\n"
    "getLength(non-const OdeRayGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeRayGeom_get_length_516_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeRayGeom::set(LVecBase3f const &start, LVecBase3f const &dir)
 * inline void OdeRayGeom::set(float px, float py, float pz, float dx, float dy, float dz)
 *******************************************************************/
static PyObject *Dtool_OdeRayGeom_set_517(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeRayGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeRayGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeRayGeom::set(LVecBase3f const &start, LVecBase3f const &dir)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"start", (char *)"dir", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:set", key_word_list, &param1, &param2))
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeRayGeom.set", 1, coerced_ptr, report_errors);
LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "OdeRayGeom.set", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        (local_this)->set(*param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeRayGeom.set() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeRayGeom::set(float px, float py, float pz, float dx, float dy, float dz)
            double param1;
            double param2;
            double param3;
            double param4;
            double param5;
            double param6;
            static char * key_word_list[] = {(char *)"px", (char *)"py", (char *)"pz", (char *)"dx", (char *)"dy", (char *)"dz", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddddd:set", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6))
            {
                (local_this)->set((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeRayGeom.set() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "set() takes 3 or 7 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "set(non-const OdeRayGeom this, const VBase3 start, const VBase3 dir)\n"
          "set(non-const OdeRayGeom this, float px, float py, float pz, float dx, float dy, float dz)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeRayGeom_set_517_comment =
    "C++ Interface:\n"
    "set(non-const OdeRayGeom this, const VBase3 start, const VBase3 dir)\n"
    "set(non-const OdeRayGeom this, float px, float py, float pz, float dx, float dy, float dz)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeRayGeom_set_517_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeRayGeom::get(LVecBase3f &start, LVecBase3f &dir) const
 *******************************************************************/
static PyObject *Dtool_OdeRayGeom_get_518(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeRayGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeRayGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline void OdeRayGeom::get(LVecBase3f &start, LVecBase3f &dir) const
            PyObject *param1;
            PyObject *param2;
            static char * key_word_list[] = {(char *)"start", (char *)"dir", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:get", key_word_list, &param1, &param2))
            {
                LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeRayGeom.get", 0, coerced_ptr, report_errors);
LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "OdeRayGeom.get", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)|| (param2_this == NULL)))
                {
                    ((const OdeRayGeom*)local_this)->get(*param1_this, *param2_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "get(const OdeRayGeom this, non-const VBase3 start, non-const VBase3 dir)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeRayGeom_get_518_comment =
    "C++ Interface:\n"
    "get(const OdeRayGeom this, non-const VBase3 start, non-const VBase3 dir)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeRayGeom_get_518_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f OdeRayGeom::get_start(void) const
 *******************************************************************/
static PyObject *Dtool_OdeRayGeom_get_start_519(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeRayGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeRayGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f OdeRayGeom::get_start(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getStart", key_word_list));
        else
            (PyArg_Parse(args, ":getStart"));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const OdeRayGeom*)local_this)->get_start();
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getStart(const OdeRayGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeRayGeom_get_start_519_comment =
    "C++ Interface:\n"
    "getStart(const OdeRayGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeRayGeom_get_start_519_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f OdeRayGeom::get_direction(void) const
 *******************************************************************/
static PyObject *Dtool_OdeRayGeom_get_direction_520(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeRayGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeRayGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f OdeRayGeom::get_direction(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getDirection", key_word_list));
        else
            (PyArg_Parse(args, ":getDirection"));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const OdeRayGeom*)local_this)->get_direction();
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getDirection(const OdeRayGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeRayGeom_get_direction_520_comment =
    "C++ Interface:\n"
    "getDirection(const OdeRayGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeRayGeom_get_direction_520_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeRayGeom::set_params(int first_contact, int backface_cull)
 *******************************************************************/
static PyObject *Dtool_OdeRayGeom_set_params_521(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeRayGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeRayGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeRayGeom::set_params(int first_contact, int backface_cull)
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"first_contact", (char *)"backface_cull", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:setParams", key_word_list, &param1, &param2))
        {
            (local_this)->set_params((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeRayGeom.setParams() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParams(non-const OdeRayGeom this, int first_contact, int backface_cull)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeRayGeom_set_params_521_comment =
    "C++ Interface:\n"
    "setParams(non-const OdeRayGeom this, int first_contact, int backface_cull)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeRayGeom_set_params_521_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeRayGeom::get_first_contact(void) const
 *******************************************************************/
static PyObject *Dtool_OdeRayGeom_get_first_contact_523(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeRayGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeRayGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int OdeRayGeom::get_first_contact(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getFirstContact", key_word_list));
        else
            (PyArg_Parse(args, ":getFirstContact"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const OdeRayGeom*)local_this)->get_first_contact();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getFirstContact(const OdeRayGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeRayGeom_get_first_contact_523_comment =
    "C++ Interface:\n"
    "getFirstContact(const OdeRayGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeRayGeom_get_first_contact_523_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeRayGeom::get_backface_cull(void) const
 *******************************************************************/
static PyObject *Dtool_OdeRayGeom_get_backface_cull_524(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeRayGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeRayGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int OdeRayGeom::get_backface_cull(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getBackfaceCull", key_word_list));
        else
            (PyArg_Parse(args, ":getBackfaceCull"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const OdeRayGeom*)local_this)->get_backface_cull();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getBackfaceCull(const OdeRayGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeRayGeom_get_backface_cull_524_comment =
    "C++ Interface:\n"
    "getBackfaceCull(const OdeRayGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeRayGeom_get_backface_cull_524_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeRayGeom::set_closest_hit(int closest_hit)
 *******************************************************************/
static PyObject *Dtool_OdeRayGeom_set_closest_hit_525(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeRayGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeRayGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeRayGeom::set_closest_hit(int closest_hit)
        int param1;
        static char * key_word_list[] = {(char *)"closest_hit", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:setClosestHit", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:setClosestHit", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_closest_hit((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeRayGeom.setClosestHit() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setClosestHit(non-const OdeRayGeom this, int closest_hit)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeRayGeom_set_closest_hit_525_comment =
    "C++ Interface:\n"
    "setClosestHit(non-const OdeRayGeom this, int closest_hit)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeRayGeom_set_closest_hit_525_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeRayGeom::get_closest_hit(void)
 *******************************************************************/
static PyObject *Dtool_OdeRayGeom_get_closest_hit_526(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeRayGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeRayGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline int OdeRayGeom::get_closest_hit(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getClosestHit", key_word_list));
        else
            (PyArg_Parse(args, ":getClosestHit"));
        if(!PyErr_Occurred())
        {
            int return_value = (local_this)->get_closest_hit();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeRayGeom.getClosestHit() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClosestHit(non-const OdeRayGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeRayGeom_get_closest_hit_526_comment =
    "C++ Interface:\n"
    "getClosestHit(non-const OdeRayGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeRayGeom_get_closest_hit_526_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeRayGeom::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeRayGeom_get_class_type_527(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeRayGeom::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeRayGeom::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeRayGeom_get_class_type_527_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeRayGeom_get_class_type_527_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeRayGeom::OdeRayGeom(OdeSpace &space, float length)
 * OdeRayGeom::OdeRayGeom(float length)
 *******************************************************************/
int  Dtool_Init_OdeRayGeom(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-OdeRayGeom::OdeRayGeom(float length)
            double param0;
            static char * key_word_list[] = {(char *)"length", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:OdeRayGeom", key_word_list, &param0));
            else
                (PyArg_Parse(args, "d:OdeRayGeom", &param0));
            if(!PyErr_Occurred())
            {
                OdeRayGeom *return_value = new OdeRayGeom((float)param0);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeRayGeom,true,false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeRayGeom::OdeRayGeom(OdeSpace &space, float length)
                PyObject *param0;
                double param1;
                static char * key_word_list[] = {(char *)"space", (char *)"length", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Od:OdeRayGeom", key_word_list, &param0, &param1))
                {
                    OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeSpace, 0, "OdeRayGeom.OdeRayGeom", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        OdeRayGeom *return_value = new OdeRayGeom(*param0_this, (float)param1);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeRayGeom,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OdeRayGeom() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OdeRayGeom(float length)\n"
          "OdeRayGeom(non-const OdeSpace space, float length)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OdeRayGeom(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeRayGeom)
    {
        printf("OdeRayGeom ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeRayGeom * local_this = (OdeRayGeom *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeRayGeom)
        return local_this;
    if(requested_type == &Dtool_OdeGeom)
        return ( OdeGeom *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( OdeGeom *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeRayGeom(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeRayGeom)
        return from_this;
    if(from_type == &Dtool_OdeGeom)
    {
          OdeGeom* other_this = (OdeGeom*)from_this;
          return (OdeRayGeom*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeRayGeom*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeSimpleSpace 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeSimpleSpace::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeSimpleSpace_get_class_type_530(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeSimpleSpace::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeSimpleSpace::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSimpleSpace_get_class_type_530_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSimpleSpace_get_class_type_530_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeSimpleSpace::OdeSimpleSpace(void)
 * OdeSimpleSpace::OdeSimpleSpace(OdeSpace &space)
 *******************************************************************/
int  Dtool_Init_OdeSimpleSpace(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-OdeSimpleSpace::OdeSimpleSpace(void)
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":OdeSimpleSpace", key_word_list))
            {
                OdeSimpleSpace *return_value = new OdeSimpleSpace();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeSimpleSpace,true,false);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeSimpleSpace::OdeSimpleSpace(OdeSpace &space)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"space", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:OdeSimpleSpace", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:OdeSimpleSpace", &param0));
                if(!PyErr_Occurred())
                {
                    OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeSpace, 0, "OdeSimpleSpace.OdeSimpleSpace", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        OdeSimpleSpace *return_value = new OdeSimpleSpace(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeSimpleSpace,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OdeSimpleSpace() takes 0 or 1 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OdeSimpleSpace()\n"
          "OdeSimpleSpace(non-const OdeSpace space)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OdeSimpleSpace(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeSimpleSpace)
    {
        printf("OdeSimpleSpace ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeSimpleSpace * local_this = (OdeSimpleSpace *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeSimpleSpace)
        return local_this;
    if(requested_type == &Dtool_OdeSpace)
        return ( OdeSpace *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( OdeSpace *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeSimpleSpace(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeSimpleSpace)
        return from_this;
    if(from_type == &Dtool_OdeSpace)
    {
          OdeSpace* other_this = (OdeSpace*)from_this;
          return (OdeSimpleSpace*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeSimpleSpace*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeSliderJoint 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void OdeSliderJoint::set_axis(LVecBase3f const &axis)
 * inline void OdeSliderJoint::set_axis(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_OdeSliderJoint_set_axis_533(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSliderJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSliderJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeSliderJoint::set_axis(LVecBase3f const &axis)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"axis", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAxis", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setAxis", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeSliderJoint.setAxis", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_axis(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeSliderJoint.setAxis() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeSliderJoint::set_axis(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setAxis", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_axis((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeSliderJoint.setAxis() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setAxis() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setAxis(non-const OdeSliderJoint this, const VBase3 axis)\n"
          "setAxis(non-const OdeSliderJoint this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSliderJoint_set_axis_533_comment =
    "C++ Interface:\n"
    "setAxis(non-const OdeSliderJoint this, const VBase3 axis)\n"
    "setAxis(non-const OdeSliderJoint this, float x, float y, float z)\n"
    "\n"
    "// Filename: odeSliderJoint.I\n"
    "// Created by:  joswilso (27Dec06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeSliderJoint_set_axis_533_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeSliderJoint::set_axis_delta(LVecBase3f const &axis, LVecBase3f const &vec)
 * inline void OdeSliderJoint::set_axis_delta(float x, float y, float z, float ax, float ay, float az)
 *******************************************************************/
static PyObject *Dtool_OdeSliderJoint_set_axis_delta_534(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSliderJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSliderJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeSliderJoint::set_axis_delta(LVecBase3f const &axis, LVecBase3f const &vec)
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"axis", (char *)"vec", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:setAxisDelta", key_word_list, &param1, &param2))
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeSliderJoint.setAxisDelta", 1, coerced_ptr, report_errors);
LVecBase3f *param2_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LVecBase3f, 2, "OdeSliderJoint.setAxisDelta", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)|| (param2_this == NULL)))
                    {
                        (local_this)->set_axis_delta(*param1_this, *param2_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeSliderJoint.setAxisDelta() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(6):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeSliderJoint::set_axis_delta(float x, float y, float z, float ax, float ay, float az)
            double param1;
            double param2;
            double param3;
            double param4;
            double param5;
            double param6;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", (char *)"ax", (char *)"ay", (char *)"az", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "dddddd:setAxisDelta", key_word_list, &param1, &param2, &param3, &param4, &param5, &param6))
            {
                (local_this)->set_axis_delta((float)param1, (float)param2, (float)param3, (float)param4, (float)param5, (float)param6);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeSliderJoint.setAxisDelta() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setAxisDelta() takes 3 or 7 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setAxisDelta(non-const OdeSliderJoint this, const VBase3 axis, const VBase3 vec)\n"
          "setAxisDelta(non-const OdeSliderJoint this, float x, float y, float z, float ax, float ay, float az)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSliderJoint_set_axis_delta_534_comment =
    "C++ Interface:\n"
    "setAxisDelta(non-const OdeSliderJoint this, const VBase3 axis, const VBase3 vec)\n"
    "setAxisDelta(non-const OdeSliderJoint this, float x, float y, float z, float ax, float ay, float az)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSliderJoint_set_axis_delta_534_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeSliderJoint::add_force(float force)
 *******************************************************************/
static PyObject *Dtool_OdeSliderJoint_add_force_535(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSliderJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSliderJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeSliderJoint::add_force(float force)
        double param1;
        static char * key_word_list[] = {(char *)"force", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:addForce", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:addForce", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->add_force((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSliderJoint.addForce() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addForce(non-const OdeSliderJoint this, float force)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSliderJoint_add_force_535_comment =
    "C++ Interface:\n"
    "addForce(non-const OdeSliderJoint this, float force)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSliderJoint_add_force_535_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeSliderJoint::get_position(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSliderJoint_get_position_536(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSliderJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSliderJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeSliderJoint::get_position(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPosition", key_word_list));
        else
            (PyArg_Parse(args, ":getPosition"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeSliderJoint*)local_this)->get_position();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPosition(const OdeSliderJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSliderJoint_get_position_536_comment =
    "C++ Interface:\n"
    "getPosition(const OdeSliderJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSliderJoint_get_position_536_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeSliderJoint::get_position_rate(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSliderJoint_get_position_rate_537(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSliderJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSliderJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeSliderJoint::get_position_rate(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getPositionRate", key_word_list));
        else
            (PyArg_Parse(args, ":getPositionRate"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeSliderJoint*)local_this)->get_position_rate();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPositionRate(const OdeSliderJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSliderJoint_get_position_rate_537_comment =
    "C++ Interface:\n"
    "getPositionRate(const OdeSliderJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSliderJoint_get_position_rate_537_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f OdeSliderJoint::get_axis(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSliderJoint_get_axis_538(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSliderJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSliderJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f OdeSliderJoint::get_axis(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAxis", key_word_list));
        else
            (PyArg_Parse(args, ":getAxis"));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const OdeSliderJoint*)local_this)->get_axis();
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAxis(const OdeSliderJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSliderJoint_get_axis_538_comment =
    "C++ Interface:\n"
    "getAxis(const OdeSliderJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSliderJoint_get_axis_538_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeSliderJoint::set_param_lo_stop(float val)
 *******************************************************************/
static PyObject *Dtool_OdeSliderJoint_set_param_lo_stop_539(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSliderJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSliderJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeSliderJoint::set_param_lo_stop(float val)
        double param1;
        static char * key_word_list[] = {(char *)"val", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setParamLoStop", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setParamLoStop", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_param_lo_stop((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSliderJoint.setParamLoStop() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamLoStop(non-const OdeSliderJoint this, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSliderJoint_set_param_lo_stop_539_comment =
    "C++ Interface:\n"
    "setParamLoStop(non-const OdeSliderJoint this, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSliderJoint_set_param_lo_stop_539_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeSliderJoint::set_param_hi_stop(float val)
 *******************************************************************/
static PyObject *Dtool_OdeSliderJoint_set_param_hi_stop_540(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSliderJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSliderJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeSliderJoint::set_param_hi_stop(float val)
        double param1;
        static char * key_word_list[] = {(char *)"val", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setParamHiStop", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setParamHiStop", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_param_hi_stop((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSliderJoint.setParamHiStop() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamHiStop(non-const OdeSliderJoint this, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSliderJoint_set_param_hi_stop_540_comment =
    "C++ Interface:\n"
    "setParamHiStop(non-const OdeSliderJoint this, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSliderJoint_set_param_hi_stop_540_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeSliderJoint::set_param_vel(float val)
 *******************************************************************/
static PyObject *Dtool_OdeSliderJoint_set_param_vel_541(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSliderJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSliderJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeSliderJoint::set_param_vel(float val)
        double param1;
        static char * key_word_list[] = {(char *)"val", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setParamVel", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setParamVel", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_param_vel((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSliderJoint.setParamVel() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamVel(non-const OdeSliderJoint this, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSliderJoint_set_param_vel_541_comment =
    "C++ Interface:\n"
    "setParamVel(non-const OdeSliderJoint this, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSliderJoint_set_param_vel_541_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeSliderJoint::set_param_f_max(float val)
 *******************************************************************/
static PyObject *Dtool_OdeSliderJoint_set_param_f_max_542(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSliderJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSliderJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeSliderJoint::set_param_f_max(float val)
        double param1;
        static char * key_word_list[] = {(char *)"val", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setParamFMax", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setParamFMax", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_param_f_max((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSliderJoint.setParamFMax() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamFMax(non-const OdeSliderJoint this, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSliderJoint_set_param_f_max_542_comment =
    "C++ Interface:\n"
    "setParamFMax(non-const OdeSliderJoint this, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSliderJoint_set_param_f_max_542_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeSliderJoint::set_param_fudge_factor(float val)
 *******************************************************************/
static PyObject *Dtool_OdeSliderJoint_set_param_fudge_factor_543(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSliderJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSliderJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeSliderJoint::set_param_fudge_factor(float val)
        double param1;
        static char * key_word_list[] = {(char *)"val", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setParamFudgeFactor", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setParamFudgeFactor", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_param_fudge_factor((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSliderJoint.setParamFudgeFactor() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamFudgeFactor(non-const OdeSliderJoint this, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSliderJoint_set_param_fudge_factor_543_comment =
    "C++ Interface:\n"
    "setParamFudgeFactor(non-const OdeSliderJoint this, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSliderJoint_set_param_fudge_factor_543_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeSliderJoint::set_param_bounce(float val)
 *******************************************************************/
static PyObject *Dtool_OdeSliderJoint_set_param_bounce_544(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSliderJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSliderJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeSliderJoint::set_param_bounce(float val)
        double param1;
        static char * key_word_list[] = {(char *)"val", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setParamBounce", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setParamBounce", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_param_bounce((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSliderJoint.setParamBounce() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamBounce(non-const OdeSliderJoint this, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSliderJoint_set_param_bounce_544_comment =
    "C++ Interface:\n"
    "setParamBounce(non-const OdeSliderJoint this, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSliderJoint_set_param_bounce_544_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeSliderJoint::set_param_CFM(float val)
 *******************************************************************/
static PyObject *Dtool_OdeSliderJoint_set_param_CFM_545(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSliderJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSliderJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeSliderJoint::set_param_CFM(float val)
        double param1;
        static char * key_word_list[] = {(char *)"val", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setParamCFM", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setParamCFM", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_param_CFM((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSliderJoint.setParamCFM() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamCFM(non-const OdeSliderJoint this, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSliderJoint_set_param_CFM_545_comment =
    "C++ Interface:\n"
    "setParamCFM(non-const OdeSliderJoint this, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSliderJoint_set_param_CFM_545_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeSliderJoint::set_param_stop_ERP(float val)
 *******************************************************************/
static PyObject *Dtool_OdeSliderJoint_set_param_stop_ERP_546(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSliderJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSliderJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeSliderJoint::set_param_stop_ERP(float val)
        double param1;
        static char * key_word_list[] = {(char *)"val", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setParamStopERP", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setParamStopERP", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_param_stop_ERP((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSliderJoint.setParamStopERP() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamStopERP(non-const OdeSliderJoint this, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSliderJoint_set_param_stop_ERP_546_comment =
    "C++ Interface:\n"
    "setParamStopERP(non-const OdeSliderJoint this, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSliderJoint_set_param_stop_ERP_546_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeSliderJoint::set_param_stop_CFM(float val)
 *******************************************************************/
static PyObject *Dtool_OdeSliderJoint_set_param_stop_CFM_547(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSliderJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSliderJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeSliderJoint::set_param_stop_CFM(float val)
        double param1;
        static char * key_word_list[] = {(char *)"val", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setParamStopCFM", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setParamStopCFM", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_param_stop_CFM((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSliderJoint.setParamStopCFM() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamStopCFM(non-const OdeSliderJoint this, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSliderJoint_set_param_stop_CFM_547_comment =
    "C++ Interface:\n"
    "setParamStopCFM(non-const OdeSliderJoint this, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSliderJoint_set_param_stop_CFM_547_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeSliderJoint::get_param_lo_stop(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSliderJoint_get_param_lo_stop_548(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSliderJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSliderJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeSliderJoint::get_param_lo_stop(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getParamLoStop", key_word_list));
        else
            (PyArg_Parse(args, ":getParamLoStop"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeSliderJoint*)local_this)->get_param_lo_stop();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamLoStop(const OdeSliderJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSliderJoint_get_param_lo_stop_548_comment =
    "C++ Interface:\n"
    "getParamLoStop(const OdeSliderJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSliderJoint_get_param_lo_stop_548_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeSliderJoint::get_param_hi_stop(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSliderJoint_get_param_hi_stop_549(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSliderJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSliderJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeSliderJoint::get_param_hi_stop(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getParamHiStop", key_word_list));
        else
            (PyArg_Parse(args, ":getParamHiStop"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeSliderJoint*)local_this)->get_param_hi_stop();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamHiStop(const OdeSliderJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSliderJoint_get_param_hi_stop_549_comment =
    "C++ Interface:\n"
    "getParamHiStop(const OdeSliderJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSliderJoint_get_param_hi_stop_549_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeSliderJoint::get_param_vel(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSliderJoint_get_param_vel_550(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSliderJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSliderJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeSliderJoint::get_param_vel(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getParamVel", key_word_list));
        else
            (PyArg_Parse(args, ":getParamVel"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeSliderJoint*)local_this)->get_param_vel();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamVel(const OdeSliderJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSliderJoint_get_param_vel_550_comment =
    "C++ Interface:\n"
    "getParamVel(const OdeSliderJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSliderJoint_get_param_vel_550_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeSliderJoint::get_param_f_max(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSliderJoint_get_param_f_max_551(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSliderJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSliderJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeSliderJoint::get_param_f_max(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getParamFMax", key_word_list));
        else
            (PyArg_Parse(args, ":getParamFMax"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeSliderJoint*)local_this)->get_param_f_max();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamFMax(const OdeSliderJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSliderJoint_get_param_f_max_551_comment =
    "C++ Interface:\n"
    "getParamFMax(const OdeSliderJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSliderJoint_get_param_f_max_551_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeSliderJoint::get_param_fudge_factor(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSliderJoint_get_param_fudge_factor_552(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSliderJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSliderJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeSliderJoint::get_param_fudge_factor(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getParamFudgeFactor", key_word_list));
        else
            (PyArg_Parse(args, ":getParamFudgeFactor"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeSliderJoint*)local_this)->get_param_fudge_factor();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamFudgeFactor(const OdeSliderJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSliderJoint_get_param_fudge_factor_552_comment =
    "C++ Interface:\n"
    "getParamFudgeFactor(const OdeSliderJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSliderJoint_get_param_fudge_factor_552_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeSliderJoint::get_param_bounce(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSliderJoint_get_param_bounce_553(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSliderJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSliderJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeSliderJoint::get_param_bounce(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getParamBounce", key_word_list));
        else
            (PyArg_Parse(args, ":getParamBounce"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeSliderJoint*)local_this)->get_param_bounce();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamBounce(const OdeSliderJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSliderJoint_get_param_bounce_553_comment =
    "C++ Interface:\n"
    "getParamBounce(const OdeSliderJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSliderJoint_get_param_bounce_553_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeSliderJoint::get_param_CFM(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSliderJoint_get_param_CFM_554(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSliderJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSliderJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeSliderJoint::get_param_CFM(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getParamCFM", key_word_list));
        else
            (PyArg_Parse(args, ":getParamCFM"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeSliderJoint*)local_this)->get_param_CFM();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamCFM(const OdeSliderJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSliderJoint_get_param_CFM_554_comment =
    "C++ Interface:\n"
    "getParamCFM(const OdeSliderJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSliderJoint_get_param_CFM_554_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeSliderJoint::get_param_stop_ERP(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSliderJoint_get_param_stop_ERP_555(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSliderJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSliderJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeSliderJoint::get_param_stop_ERP(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getParamStopERP", key_word_list));
        else
            (PyArg_Parse(args, ":getParamStopERP"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeSliderJoint*)local_this)->get_param_stop_ERP();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamStopERP(const OdeSliderJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSliderJoint_get_param_stop_ERP_555_comment =
    "C++ Interface:\n"
    "getParamStopERP(const OdeSliderJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSliderJoint_get_param_stop_ERP_555_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeSliderJoint::get_param_stop_CFM(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSliderJoint_get_param_stop_CFM_556(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSliderJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSliderJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeSliderJoint::get_param_stop_CFM(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getParamStopCFM", key_word_list));
        else
            (PyArg_Parse(args, ":getParamStopCFM"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeSliderJoint*)local_this)->get_param_stop_CFM();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamStopCFM(const OdeSliderJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSliderJoint_get_param_stop_CFM_556_comment =
    "C++ Interface:\n"
    "getParamStopCFM(const OdeSliderJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSliderJoint_get_param_stop_CFM_556_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeSliderJoint::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeSliderJoint_get_class_type_557(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeSliderJoint::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeSliderJoint::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSliderJoint_get_class_type_557_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSliderJoint_get_class_type_557_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeSliderJoint::OdeSliderJoint(OdeWorld &world)
 * OdeSliderJoint::OdeSliderJoint(OdeWorld &world, OdeJointGroup &joint_group)
 *******************************************************************/
int  Dtool_Init_OdeSliderJoint(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeSliderJoint::OdeSliderJoint(OdeWorld &world)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"world", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:OdeSliderJoint", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:OdeSliderJoint", &param0));
                if(!PyErr_Occurred())
                {
                    OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeWorld, 0, "OdeSliderJoint.OdeSliderJoint", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        OdeSliderJoint *return_value = new OdeSliderJoint(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeSliderJoint,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeSliderJoint::OdeSliderJoint(OdeWorld &world, OdeJointGroup &joint_group)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"world", (char *)"joint_group", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:OdeSliderJoint", key_word_list, &param0, &param1))
                {
                    OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeWorld, 0, "OdeSliderJoint.OdeSliderJoint", 0, coerced_ptr, report_errors);
OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeJointGroup, 1, "OdeSliderJoint.OdeSliderJoint", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        OdeSliderJoint *return_value = new OdeSliderJoint(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeSliderJoint,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OdeSliderJoint() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OdeSliderJoint(non-const OdeWorld world)\n"
          "OdeSliderJoint(non-const OdeWorld world, non-const OdeJointGroup joint_group)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OdeSliderJoint(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeSliderJoint)
    {
        printf("OdeSliderJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeSliderJoint * local_this = (OdeSliderJoint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeSliderJoint)
        return local_this;
    if(requested_type == &Dtool_OdeJoint)
        return ( OdeJoint *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( OdeJoint *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeSliderJoint(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeSliderJoint)
        return from_this;
    if(from_type == &Dtool_OdeJoint)
    {
          OdeJoint* other_this = (OdeJoint*)from_this;
          return (OdeSliderJoint*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeSliderJoint*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeSphereGeom 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void OdeSphereGeom::set_radius(float radius)
 *******************************************************************/
static PyObject *Dtool_OdeSphereGeom_set_radius_560(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSphereGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSphereGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeSphereGeom::set_radius(float radius)
        double param1;
        static char * key_word_list[] = {(char *)"radius", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:setRadius", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:setRadius", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->set_radius((float)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeSphereGeom.setRadius() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setRadius(non-const OdeSphereGeom this, float radius)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSphereGeom_set_radius_560_comment =
    "C++ Interface:\n"
    "setRadius(non-const OdeSphereGeom this, float radius)\n"
    "\n"
    "// Filename: odeSphereGeom.I\n"
    "// Created by:  joswilso (27Dec06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeSphereGeom_set_radius_560_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeSphereGeom::get_radius(void) const
 *******************************************************************/
static PyObject *Dtool_OdeSphereGeom_get_radius_561(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSphereGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSphereGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeSphereGeom::get_radius(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getRadius", key_word_list));
        else
            (PyArg_Parse(args, ":getRadius"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeSphereGeom*)local_this)->get_radius();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getRadius(const OdeSphereGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSphereGeom_get_radius_561_comment =
    "C++ Interface:\n"
    "getRadius(const OdeSphereGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSphereGeom_get_radius_561_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeSphereGeom::get_point_depth(LPoint3f const &p) const
 * inline float OdeSphereGeom::get_point_depth(float x, float y, float z) const
 *******************************************************************/
static PyObject *Dtool_OdeSphereGeom_get_point_depth_562(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeSphereGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSphereGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline float OdeSphereGeom::get_point_depth(LPoint3f const &p) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"p", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:getPointDepth", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:getPointDepth", &param1));
                if(!PyErr_Occurred())
                {
                    LPoint3f *param1_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LPoint3f, 1, "OdeSphereGeom.getPointDepth", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        float return_value = ((const OdeSphereGeom*)local_this)->get_point_depth(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyFloat_FromDouble(return_value);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          // 1-inline float OdeSphereGeom::get_point_depth(float x, float y, float z) const
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:getPointDepth", key_word_list, &param1, &param2, &param3))
            {
                float return_value = ((const OdeSphereGeom*)local_this)->get_point_depth((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getPointDepth() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getPointDepth(const OdeSphereGeom this, const Point3 p)\n"
          "getPointDepth(const OdeSphereGeom this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSphereGeom_get_point_depth_562_comment =
    "C++ Interface:\n"
    "getPointDepth(const OdeSphereGeom this, const Point3 p)\n"
    "getPointDepth(const OdeSphereGeom this, float x, float y, float z)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSphereGeom_get_point_depth_562_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeSphereGeom::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeSphereGeom_get_class_type_563(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeSphereGeom::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeSphereGeom::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeSphereGeom_get_class_type_563_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeSphereGeom_get_class_type_563_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeSphereGeom::OdeSphereGeom(OdeGeom &geom)
 * OdeSphereGeom::OdeSphereGeom(OdeSpace &space, float radius)
 * OdeSphereGeom::OdeSphereGeom(float radius)
 *******************************************************************/
int  Dtool_Init_OdeSphereGeom(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 OdeSphereGeom::OdeSphereGeom(OdeGeom &geom)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"geom", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:OdeSphereGeom", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:OdeSphereGeom", &param0));
                if(!PyErr_Occurred())
                {
                    OdeGeom *param0_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeGeom, 0, "OdeSphereGeom.OdeSphereGeom", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        OdeSphereGeom *return_value = new OdeSphereGeom(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeSphereGeom,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 OdeSphereGeom::OdeSphereGeom(float radius)
                double param0;
                static char * key_word_list[] = {(char *)"radius", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "d:OdeSphereGeom", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "d:OdeSphereGeom", &param0));
                if(!PyErr_Occurred())
                {
                    OdeSphereGeom *return_value = new OdeSphereGeom((float)param0);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeSphereGeom,true,false);
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeSphereGeom::OdeSphereGeom(OdeSpace &space, float radius)
                PyObject *param0;
                double param1;
                static char * key_word_list[] = {(char *)"space", (char *)"radius", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Od:OdeSphereGeom", key_word_list, &param0, &param1))
                {
                    OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeSpace, 0, "OdeSphereGeom.OdeSphereGeom", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        OdeSphereGeom *return_value = new OdeSphereGeom(*param0_this, (float)param1);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeSphereGeom,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OdeSphereGeom() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OdeSphereGeom(non-const OdeGeom geom)\n"
          "OdeSphereGeom(float radius)\n"
          "OdeSphereGeom(non-const OdeSpace space, float radius)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OdeSphereGeom(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeSphereGeom)
    {
        printf("OdeSphereGeom ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeSphereGeom * local_this = (OdeSphereGeom *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeSphereGeom)
        return local_this;
    if(requested_type == &Dtool_OdeGeom)
        return ( OdeGeom *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( OdeGeom *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeSphereGeom(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeSphereGeom)
        return from_this;
    if(from_type == &Dtool_OdeGeom)
    {
          OdeGeom* other_this = (OdeGeom*)from_this;
          return (OdeSphereGeom*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeSphereGeom*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeTriMeshData 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void OdeTriMeshData::destroy(void)
 *******************************************************************/
static PyObject *Dtool_OdeTriMeshData_destroy_567(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeTriMeshData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeTriMeshData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void OdeTriMeshData::destroy(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":destroy", key_word_list));
        else
            (PyArg_Parse(args, ":destroy"));
        if(!PyErr_Occurred())
        {
            (local_this)->destroy();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeTriMeshData.destroy() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "destroy(non-const OdeTriMeshData this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeTriMeshData_destroy_567_comment =
    "C++ Interface:\n"
    "destroy(non-const OdeTriMeshData this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeTriMeshData_destroy_567_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * virtual void OdeTriMeshData::write(ostream &out, unsigned int indent) const
 * virtual void OdeTriMeshData::write(ostream &out, unsigned int indent = (0)) const
 * virtual void OdeTriMeshData::write(ostream &out = (cout), unsigned int indent = (0)) const
 *******************************************************************/
static PyObject *Dtool_OdeTriMeshData_write_568(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeTriMeshData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeTriMeshData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-virtual void OdeTriMeshData::write(ostream &out = (cout), unsigned int indent = (0)) const
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":write", key_word_list));
            else
                (PyArg_Parse(args, ":write"));
            if(!PyErr_Occurred())
            {
                ((const OdeTriMeshData*)local_this)->write();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void OdeTriMeshData::write(ostream &out, unsigned int indent = (0)) const
                PyObject *param1;
                static char * key_word_list[] = {(char *)"out", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:write", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:write", &param1));
                if(!PyErr_Occurred())
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "OdeTriMeshData.write", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        ((const OdeTriMeshData*)local_this)->write(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-virtual void OdeTriMeshData::write(ostream &out, unsigned int indent) const
                PyObject *param1;
                PyObject *param2;
                static char * key_word_list[] = {(char *)"out", (char *)"indent", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:write", key_word_list, &param1, &param2))
                {
                    ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "OdeTriMeshData.write", 0, coerced_ptr, report_errors);
 PyObject *param2_uint = PyNumber_Long(param2);
                    if (!((param1_this == NULL)|| (param2_uint == NULL)))
                    {
                        ((const OdeTriMeshData*)local_this)->write(*param1_this, PyLong_AsUnsignedLong(param2_uint));
                         Py_XDECREF(param2_uint);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "write() takes 1, 2, or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "write(const OdeTriMeshData this)\n"
          "write(const OdeTriMeshData this, non-const Ostream out)\n"
          "write(const OdeTriMeshData this, non-const Ostream out, unsigned int indent)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeTriMeshData_write_568_comment =
    "C++ Interface:\n"
    "write(const OdeTriMeshData this)\n"
    "write(const OdeTriMeshData this, non-const Ostream out)\n"
    "write(const OdeTriMeshData this, non-const Ostream out, unsigned int indent)\n"
    "\n"
    "// INLINE void set(int data_id, void* in_data);\n"
    "// INLINE void* get(int data_id);\n"
    "// INLINE void get_buffer(unsigned char** buf, int* buf_len) const;\n"
    "// INLINE void set_buffer(unsigned char* buf);\n"
    "// INLINE void update();\n"
    "";
#else
static const char * Dtool_OdeTriMeshData_write_568_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * void OdeTriMeshData::write_faces(ostream &out) const
 *******************************************************************/
static PyObject *Dtool_OdeTriMeshData_write_faces_569(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeTriMeshData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeTriMeshData,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-void OdeTriMeshData::write_faces(ostream &out) const
            PyObject *param1;
            static char * key_word_list[] = {(char *)"out", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:writeFaces", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:writeFaces", &param1));
            if(!PyErr_Occurred())
            {
                ostream *param1_this = (ostream *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_ostream, 1, "OdeTriMeshData.writeFaces", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    ((const OdeTriMeshData*)local_this)->write_faces(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "writeFaces(const OdeTriMeshData this, non-const Ostream out)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeTriMeshData_write_faces_569_comment =
    "C++ Interface:\n"
    "writeFaces(const OdeTriMeshData this, non-const Ostream out)\n"
    "\n"
    "// INLINE void set(int data_id, void* in_data);\n"
    "// INLINE void* get(int data_id);\n"
    "// INLINE void get_buffer(unsigned char** buf, int* buf_len) const;\n"
    "// INLINE void set_buffer(unsigned char* buf);\n"
    "// INLINE void update();\n"
    "";
#else
static const char * Dtool_OdeTriMeshData_write_faces_569_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeTriMeshData::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeTriMeshData_get_class_type_570(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeTriMeshData::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeTriMeshData::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeTriMeshData_get_class_type_570_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeTriMeshData_get_class_type_570_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeTriMeshData::OdeTriMeshData(NodePath const &model, bool use_normals)
 * OdeTriMeshData::OdeTriMeshData(NodePath const &model, bool use_normals = (0))
 *******************************************************************/
int  Dtool_Init_OdeTriMeshData(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeTriMeshData::OdeTriMeshData(NodePath const &model, bool use_normals = (0))
                PyObject *param0;
                static char * key_word_list[] = {(char *)"model", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:OdeTriMeshData", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:OdeTriMeshData", &param0));
                if(!PyErr_Occurred())
                {
                    NodePath *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_NodePath, 0, "OdeTriMeshData.OdeTriMeshData", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        OdeTriMeshData *return_value = new OdeTriMeshData(*param0_this);
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeTriMeshData,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeTriMeshData::OdeTriMeshData(NodePath const &model, bool use_normals)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"model", (char *)"use_normals", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:OdeTriMeshData", key_word_list, &param0, &param1))
                {
                    NodePath *param0_this = (NodePath *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_NodePath, 0, "OdeTriMeshData.OdeTriMeshData", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        OdeTriMeshData *return_value = new OdeTriMeshData(*param0_this, (PyObject_IsTrue(param1)!=0));
                        return_value->ref();
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeTriMeshData,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OdeTriMeshData() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OdeTriMeshData(const NodePath model)\n"
          "OdeTriMeshData(const NodePath model, bool use_normals)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OdeTriMeshData(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeTriMeshData)
    {
        printf("OdeTriMeshData ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeTriMeshData * local_this = (OdeTriMeshData *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeTriMeshData)
        return local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( TypedReferenceCount *) local_this;
    if(requested_type == &Dtool_TypedReferenceCount)
        return ( TypedReferenceCount *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeTriMeshData(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeTriMeshData)
        return from_this;
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (OdeTriMeshData*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeTriMeshData*)other_this;
    }
    if(from_type == &Dtool_TypedReferenceCount)
    {
          TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
          return (OdeTriMeshData*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeTriMeshGeom 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * void OdeTriMeshGeom::destroy(void)
 *******************************************************************/
static PyObject *Dtool_OdeTriMeshGeom_destroy_573(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeTriMeshGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeTriMeshGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-void OdeTriMeshGeom::destroy(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":destroy", key_word_list));
        else
            (PyArg_Parse(args, ":destroy"));
        if(!PyErr_Occurred())
        {
            (local_this)->destroy();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeTriMeshGeom.destroy() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "destroy(non-const OdeTriMeshGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeTriMeshGeom_destroy_573_comment =
    "C++ Interface:\n"
    "destroy(non-const OdeTriMeshGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeTriMeshGeom_destroy_573_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeTriMeshGeom::set_tri_mesh_data(OdeTriMeshData &data)
 *******************************************************************/
static PyObject *Dtool_OdeTriMeshGeom_set_tri_mesh_data_574(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeTriMeshGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeTriMeshGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeTriMeshGeom::set_tri_mesh_data(OdeTriMeshData &data)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"data", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setTriMeshData", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setTriMeshData", &param1));
            if(!PyErr_Occurred())
            {
                OdeTriMeshData *param1_this = (OdeTriMeshData *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeTriMeshData, 1, "OdeTriMeshGeom.setTriMeshData", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_tri_mesh_data(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeTriMeshGeom.setTriMeshData() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setTriMeshData(non-const OdeTriMeshGeom this, non-const OdeTriMeshData data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeTriMeshGeom_set_tri_mesh_data_574_comment =
    "C++ Interface:\n"
    "setTriMeshData(non-const OdeTriMeshGeom this, non-const OdeTriMeshData data)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeTriMeshGeom_set_tri_mesh_data_574_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PointerTo< OdeTriMeshData > OdeTriMeshGeom::get_tri_mesh_data(void) const
 *******************************************************************/
static PyObject *Dtool_OdeTriMeshGeom_get_tri_mesh_data_575(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeTriMeshGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeTriMeshGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PointerTo< OdeTriMeshData > OdeTriMeshGeom::get_tri_mesh_data(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getTriMeshData", key_word_list));
        else
            (PyArg_Parse(args, ":getTriMeshData"));
        if(!PyErr_Occurred())
        {
            PointerTo< OdeTriMeshData > return_value = ((const OdeTriMeshGeom*)local_this)->get_tri_mesh_data();
            if (return_value != (OdeTriMeshData *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_OdeTriMeshData,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTriMeshData(const OdeTriMeshGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeTriMeshGeom_get_tri_mesh_data_575_comment =
    "C++ Interface:\n"
    "getTriMeshData(const OdeTriMeshGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeTriMeshGeom_get_tri_mesh_data_575_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeTriMeshGeom::set_data(OdeTriMeshData &data)
 *******************************************************************/
static PyObject *Dtool_OdeTriMeshGeom_set_data_576(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeTriMeshGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeTriMeshGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeTriMeshGeom::set_data(OdeTriMeshData &data)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"data", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:setData", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:setData", &param1));
            if(!PyErr_Occurred())
            {
                OdeTriMeshData *param1_this = (OdeTriMeshData *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeTriMeshData, 1, "OdeTriMeshGeom.setData", 0, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->set_data(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeTriMeshGeom.setData() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setData(non-const OdeTriMeshGeom this, non-const OdeTriMeshData data)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeTriMeshGeom_set_data_576_comment =
    "C++ Interface:\n"
    "setData(non-const OdeTriMeshGeom this, non-const OdeTriMeshData data)\n"
    "\n"
    "// Filename: odeTriMeshGeom.I\n"
    "// Created by:  joswilso (27Dec06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeTriMeshGeom_set_data_576_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PointerTo< OdeTriMeshData > OdeTriMeshGeom::get_data(void) const
 *******************************************************************/
static PyObject *Dtool_OdeTriMeshGeom_get_data_577(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeTriMeshGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeTriMeshGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline PointerTo< OdeTriMeshData > OdeTriMeshGeom::get_data(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getData", key_word_list));
        else
            (PyArg_Parse(args, ":getData"));
        if(!PyErr_Occurred())
        {
            PointerTo< OdeTriMeshData > return_value = ((const OdeTriMeshGeom*)local_this)->get_data();
            if (return_value != (OdeTriMeshData *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value.p() == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_OdeTriMeshData,true, false, (return_value.p())->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getData(const OdeTriMeshGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeTriMeshGeom_get_data_577_comment =
    "C++ Interface:\n"
    "getData(const OdeTriMeshGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeTriMeshGeom_get_data_577_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeTriMeshGeom::enable_TC(int geom_class, int enable)
 *******************************************************************/
static PyObject *Dtool_OdeTriMeshGeom_enable_TC_578(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeTriMeshGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeTriMeshGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeTriMeshGeom::enable_TC(int geom_class, int enable)
        int param1;
        int param2;
        static char * key_word_list[] = {(char *)"geom_class", (char *)"enable", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "ii:enableTC", key_word_list, &param1, &param2))
        {
            (local_this)->enable_TC((int)param1, (int)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeTriMeshGeom.enableTC() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "enableTC(non-const OdeTriMeshGeom this, int geom_class, int enable)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeTriMeshGeom_enable_TC_578_comment =
    "C++ Interface:\n"
    "enableTC(non-const OdeTriMeshGeom this, int geom_class, int enable)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeTriMeshGeom_enable_TC_578_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeTriMeshGeom::is_TC_enabled(int geom_class) const
 *******************************************************************/
static PyObject *Dtool_OdeTriMeshGeom_is_TC_enabled_579(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeTriMeshGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeTriMeshGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int OdeTriMeshGeom::is_TC_enabled(int geom_class) const
        int param1;
        static char * key_word_list[] = {(char *)"geom_class", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:isTCEnabled", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:isTCEnabled", &param1));
        if(!PyErr_Occurred())
        {
            int return_value = ((const OdeTriMeshGeom*)local_this)->is_TC_enabled((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isTCEnabled(const OdeTriMeshGeom this, int geom_class)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeTriMeshGeom_is_TC_enabled_579_comment =
    "C++ Interface:\n"
    "isTCEnabled(const OdeTriMeshGeom this, int geom_class)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeTriMeshGeom_is_TC_enabled_579_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeTriMeshGeom::clear_TC_cache(OdeGeom const &geom)
 *******************************************************************/
static PyObject *Dtool_OdeTriMeshGeom_clear_TC_cache_580(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeTriMeshGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeTriMeshGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeTriMeshGeom::clear_TC_cache(OdeGeom const &geom)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"geom", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:clearTCCache", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:clearTCCache", &param1));
            if(!PyErr_Occurred())
            {
                OdeGeom *param1_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeGeom, 1, "OdeTriMeshGeom.clearTCCache", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->clear_TC_cache(*param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeTriMeshGeom.clearTCCache() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "clearTCCache(non-const OdeTriMeshGeom this, const OdeGeom geom)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeTriMeshGeom_clear_TC_cache_580_comment =
    "C++ Interface:\n"
    "clearTCCache(non-const OdeTriMeshGeom this, const OdeGeom geom)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeTriMeshGeom_clear_TC_cache_580_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeTriMeshGeom::get_triangle(int face_index, LPoint3f &v0, LPoint3f &v1, LPoint3f &v2) const
 *******************************************************************/
static PyObject *Dtool_OdeTriMeshGeom_get_triangle_581(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeTriMeshGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeTriMeshGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline void OdeTriMeshGeom::get_triangle(int face_index, LPoint3f &v0, LPoint3f &v1, LPoint3f &v2) const
            int param1;
            PyObject *param2;
            PyObject *param3;
            PyObject *param4;
            static char * key_word_list[] = {(char *)"face_index", (char *)"v0", (char *)"v1", (char *)"v2", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "iOOO:getTriangle", key_word_list, &param1, &param2, &param3, &param4))
            {
                LPoint3f *param2_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param2, &Dtool_LPoint3f, 2, "OdeTriMeshGeom.getTriangle", 0, coerced_ptr, report_errors);
LPoint3f *param3_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param3, &Dtool_LPoint3f, 3, "OdeTriMeshGeom.getTriangle", 0, coerced_ptr, report_errors);
LPoint3f *param4_this = (LPoint3f *)DTOOL_Call_GetPointerThisClass(param4, &Dtool_LPoint3f, 4, "OdeTriMeshGeom.getTriangle", 0, coerced_ptr, report_errors);

                if (!((param2_this == NULL)|| (param3_this == NULL)|| (param4_this == NULL)))
                {
                    ((const OdeTriMeshGeom*)local_this)->get_triangle((int)param1, *param2_this, *param3_this, *param4_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return Py_BuildValue("");
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getTriangle(const OdeTriMeshGeom this, int face_index, non-const Point3 v0, non-const Point3 v1, non-const Point3 v2)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeTriMeshGeom_get_triangle_581_comment =
    "C++ Interface:\n"
    "getTriangle(const OdeTriMeshGeom this, int face_index, non-const Point3 v0, non-const Point3 v1, non-const Point3 v2)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeTriMeshGeom_get_triangle_581_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LPoint3f OdeTriMeshGeom::get_point(int face_index, float u, float v) const
 *******************************************************************/
static PyObject *Dtool_OdeTriMeshGeom_get_point_582(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeTriMeshGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeTriMeshGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LPoint3f OdeTriMeshGeom::get_point(int face_index, float u, float v) const
        int param1;
        double param2;
        double param3;
        static char * key_word_list[] = {(char *)"face_index", (char *)"u", (char *)"v", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "idd:getPoint", key_word_list, &param1, &param2, &param3))
        {
            LPoint3f result = ((const OdeTriMeshGeom*)local_this)->get_point((int)param1, (float)param2, (float)param3);
            LPoint3f *return_value = new LPoint3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LPoint3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getPoint(const OdeTriMeshGeom this, int face_index, float u, float v)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeTriMeshGeom_get_point_582_comment =
    "C++ Interface:\n"
    "getPoint(const OdeTriMeshGeom this, int face_index, float u, float v)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeTriMeshGeom_get_point_582_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int OdeTriMeshGeom::get_num_triangles(void) const
 *******************************************************************/
static PyObject *Dtool_OdeTriMeshGeom_get_num_triangles_583(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeTriMeshGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeTriMeshGeom,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int OdeTriMeshGeom::get_num_triangles(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getNumTriangles", key_word_list));
        else
            (PyArg_Parse(args, ":getNumTriangles"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const OdeTriMeshGeom*)local_this)->get_num_triangles();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getNumTriangles(const OdeTriMeshGeom this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeTriMeshGeom_get_num_triangles_583_comment =
    "C++ Interface:\n"
    "getNumTriangles(const OdeTriMeshGeom this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeTriMeshGeom_get_num_triangles_583_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeTriMeshGeom::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeTriMeshGeom_get_class_type_584(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeTriMeshGeom::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeTriMeshGeom::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeTriMeshGeom_get_class_type_584_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeTriMeshGeom_get_class_type_584_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeTriMeshGeom::OdeTriMeshGeom(OdeSpace &space, OdeTriMeshData &data)
 * OdeTriMeshGeom::OdeTriMeshGeom(OdeTriMeshData &data)
 * OdeTriMeshGeom::OdeTriMeshGeom(OdeTriMeshGeom const &copy)
 *******************************************************************/
int  Dtool_Init_OdeTriMeshGeom(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 OdeTriMeshGeom::OdeTriMeshGeom(OdeTriMeshGeom const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:OdeTriMeshGeom", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:OdeTriMeshGeom", &param0));
                if(!PyErr_Occurred())
                {
                    OdeTriMeshGeom *param0_this = (OdeTriMeshGeom *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeTriMeshGeom, 0, "OdeTriMeshGeom.OdeTriMeshGeom", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        OdeTriMeshGeom *return_value = new OdeTriMeshGeom(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeTriMeshGeom,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 OdeTriMeshGeom::OdeTriMeshGeom(OdeTriMeshData &data)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"data", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:OdeTriMeshGeom", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:OdeTriMeshGeom", &param0));
                if(!PyErr_Occurred())
                {
                    OdeTriMeshData *param0_this = (OdeTriMeshData *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeTriMeshData, 0, "OdeTriMeshGeom.OdeTriMeshGeom", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        OdeTriMeshGeom *return_value = new OdeTriMeshGeom(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeTriMeshGeom,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeTriMeshGeom::OdeTriMeshGeom(OdeSpace &space, OdeTriMeshData &data)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"space", (char *)"data", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:OdeTriMeshGeom", key_word_list, &param0, &param1))
                {
                    OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeSpace, 0, "OdeTriMeshGeom.OdeTriMeshGeom", 0, coerced_ptr, report_errors);
OdeTriMeshData *param1_this = (OdeTriMeshData *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeTriMeshData, 1, "OdeTriMeshGeom.OdeTriMeshGeom", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        OdeTriMeshGeom *return_value = new OdeTriMeshGeom(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeTriMeshGeom,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OdeTriMeshGeom() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OdeTriMeshGeom(const OdeTriMeshGeom copy)\n"
          "OdeTriMeshGeom(non-const OdeTriMeshData data)\n"
          "OdeTriMeshGeom(non-const OdeSpace space, non-const OdeTriMeshData data)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OdeTriMeshGeom(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeTriMeshGeom)
    {
        printf("OdeTriMeshGeom ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeTriMeshGeom * local_this = (OdeTriMeshGeom *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeTriMeshGeom)
        return local_this;
    if(requested_type == &Dtool_OdeGeom)
        return ( OdeGeom *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( OdeGeom *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeTriMeshGeom(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeTriMeshGeom)
        return from_this;
    if(from_type == &Dtool_OdeGeom)
    {
          OdeGeom* other_this = (OdeGeom*)from_this;
          return (OdeTriMeshGeom*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeTriMeshGeom*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeUniversalJoint 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void OdeUniversalJoint::set_anchor(LVecBase3f const &anchor)
 * inline void OdeUniversalJoint::set_anchor(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_set_anchor_587(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeUniversalJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeUniversalJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeUniversalJoint::set_anchor(LVecBase3f const &anchor)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"anchor", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAnchor", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setAnchor", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeUniversalJoint.setAnchor", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_anchor(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeUniversalJoint.setAnchor() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeUniversalJoint::set_anchor(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setAnchor", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_anchor((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeUniversalJoint.setAnchor() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setAnchor() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setAnchor(non-const OdeUniversalJoint this, const VBase3 anchor)\n"
          "setAnchor(non-const OdeUniversalJoint this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_set_anchor_587_comment =
    "C++ Interface:\n"
    "setAnchor(non-const OdeUniversalJoint this, const VBase3 anchor)\n"
    "setAnchor(non-const OdeUniversalJoint this, float x, float y, float z)\n"
    "\n"
    "// Filename: odeUniversalJoint.I\n"
    "// Created by:  joswilso (27Dec06)\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//\n"
    "// PANDA 3D SOFTWARE\n"
    "// Copyright (c) Carnegie Mellon University.  All rights reserved.\n"
    "//\n"
    "// All use of this software is subject to the terms of the revised BSD\n"
    "// license.  You should have received a copy of this license along\n"
    "// with this source code in a file named \"LICENSE.\"\n"
    "//\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_set_anchor_587_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeUniversalJoint::set_axis1(LVecBase3f const &axis)
 * inline void OdeUniversalJoint::set_axis1(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_set_axis1_588(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeUniversalJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeUniversalJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeUniversalJoint::set_axis1(LVecBase3f const &axis)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"axis", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAxis1", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setAxis1", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeUniversalJoint.setAxis1", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_axis1(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeUniversalJoint.setAxis1() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeUniversalJoint::set_axis1(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setAxis1", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_axis1((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeUniversalJoint.setAxis1() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setAxis1() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setAxis1(non-const OdeUniversalJoint this, const VBase3 axis)\n"
          "setAxis1(non-const OdeUniversalJoint this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_set_axis1_588_comment =
    "C++ Interface:\n"
    "setAxis1(non-const OdeUniversalJoint this, const VBase3 axis)\n"
    "setAxis1(non-const OdeUniversalJoint this, float x, float y, float z)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_set_axis1_588_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeUniversalJoint::set_axis2(LVecBase3f const &axis)
 * inline void OdeUniversalJoint::set_axis2(float x, float y, float z)
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_set_axis2_589(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeUniversalJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeUniversalJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void OdeUniversalJoint::set_axis2(LVecBase3f const &axis)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"axis", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:setAxis2", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:setAxis2", &param1));
                if(!PyErr_Occurred())
                {
                    LVecBase3f *param1_this = (LVecBase3f *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_LVecBase3f, 1, "OdeUniversalJoint.setAxis2", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_axis2(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call OdeUniversalJoint.setAxis2() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void OdeUniversalJoint::set_axis2(float x, float y, float z)
            double param1;
            double param2;
            double param3;
            static char * key_word_list[] = {(char *)"x", (char *)"y", (char *)"z", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "ddd:setAxis2", key_word_list, &param1, &param2, &param3))
            {
                (local_this)->set_axis2((float)param1, (float)param2, (float)param3);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call OdeUniversalJoint.setAxis2() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setAxis2() takes 2 or 4 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setAxis2(non-const OdeUniversalJoint this, const VBase3 axis)\n"
          "setAxis2(non-const OdeUniversalJoint this, float x, float y, float z)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_set_axis2_589_comment =
    "C++ Interface:\n"
    "setAxis2(non-const OdeUniversalJoint this, const VBase3 axis)\n"
    "setAxis2(non-const OdeUniversalJoint this, float x, float y, float z)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_set_axis2_589_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeUniversalJoint::add_torques(float torque1, float torque2)
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_add_torques_590(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeUniversalJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeUniversalJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeUniversalJoint::add_torques(float torque1, float torque2)
        double param1;
        double param2;
        static char * key_word_list[] = {(char *)"torque1", (char *)"torque2", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "dd:addTorques", key_word_list, &param1, &param2))
        {
            (local_this)->add_torques((float)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeUniversalJoint.addTorques() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addTorques(non-const OdeUniversalJoint this, float torque1, float torque2)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_add_torques_590_comment =
    "C++ Interface:\n"
    "addTorques(non-const OdeUniversalJoint this, float torque1, float torque2)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_add_torques_590_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f OdeUniversalJoint::get_anchor(void) const
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_get_anchor_591(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeUniversalJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeUniversalJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f OdeUniversalJoint::get_anchor(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAnchor", key_word_list));
        else
            (PyArg_Parse(args, ":getAnchor"));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const OdeUniversalJoint*)local_this)->get_anchor();
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAnchor(const OdeUniversalJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_get_anchor_591_comment =
    "C++ Interface:\n"
    "getAnchor(const OdeUniversalJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_get_anchor_591_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f OdeUniversalJoint::get_anchor2(void) const
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_get_anchor2_592(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeUniversalJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeUniversalJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f OdeUniversalJoint::get_anchor2(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAnchor2", key_word_list));
        else
            (PyArg_Parse(args, ":getAnchor2"));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const OdeUniversalJoint*)local_this)->get_anchor2();
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAnchor2(const OdeUniversalJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_get_anchor2_592_comment =
    "C++ Interface:\n"
    "getAnchor2(const OdeUniversalJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_get_anchor2_592_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f OdeUniversalJoint::get_axis1(void) const
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_get_axis1_593(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeUniversalJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeUniversalJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f OdeUniversalJoint::get_axis1(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAxis1", key_word_list));
        else
            (PyArg_Parse(args, ":getAxis1"));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const OdeUniversalJoint*)local_this)->get_axis1();
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAxis1(const OdeUniversalJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_get_axis1_593_comment =
    "C++ Interface:\n"
    "getAxis1(const OdeUniversalJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_get_axis1_593_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline LVecBase3f OdeUniversalJoint::get_axis2(void) const
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_get_axis2_594(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeUniversalJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeUniversalJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline LVecBase3f OdeUniversalJoint::get_axis2(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAxis2", key_word_list));
        else
            (PyArg_Parse(args, ":getAxis2"));
        if(!PyErr_Occurred())
        {
            LVecBase3f result = ((const OdeUniversalJoint*)local_this)->get_axis2();
            LVecBase3f *return_value = new LVecBase3f(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_LVecBase3f,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAxis2(const OdeUniversalJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_get_axis2_594_comment =
    "C++ Interface:\n"
    "getAxis2(const OdeUniversalJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_get_axis2_594_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeUniversalJoint::get_angle1(void) const
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_get_angle1_595(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeUniversalJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeUniversalJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeUniversalJoint::get_angle1(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAngle1", key_word_list));
        else
            (PyArg_Parse(args, ":getAngle1"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeUniversalJoint*)local_this)->get_angle1();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAngle1(const OdeUniversalJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_get_angle1_595_comment =
    "C++ Interface:\n"
    "getAngle1(const OdeUniversalJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_get_angle1_595_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeUniversalJoint::get_angle2(void) const
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_get_angle2_596(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeUniversalJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeUniversalJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeUniversalJoint::get_angle2(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAngle2", key_word_list));
        else
            (PyArg_Parse(args, ":getAngle2"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeUniversalJoint*)local_this)->get_angle2();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAngle2(const OdeUniversalJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_get_angle2_596_comment =
    "C++ Interface:\n"
    "getAngle2(const OdeUniversalJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_get_angle2_596_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeUniversalJoint::get_angle1_rate(void) const
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_get_angle1_rate_597(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeUniversalJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeUniversalJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeUniversalJoint::get_angle1_rate(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAngle1Rate", key_word_list));
        else
            (PyArg_Parse(args, ":getAngle1Rate"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeUniversalJoint*)local_this)->get_angle1_rate();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAngle1Rate(const OdeUniversalJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_get_angle1_rate_597_comment =
    "C++ Interface:\n"
    "getAngle1Rate(const OdeUniversalJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_get_angle1_rate_597_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeUniversalJoint::get_angle2_rate(void) const
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_get_angle2_rate_598(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeUniversalJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeUniversalJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeUniversalJoint::get_angle2_rate(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getAngle2Rate", key_word_list));
        else
            (PyArg_Parse(args, ":getAngle2Rate"));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeUniversalJoint*)local_this)->get_angle2_rate();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getAngle2Rate(const OdeUniversalJoint this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_get_angle2_rate_598_comment =
    "C++ Interface:\n"
    "getAngle2Rate(const OdeUniversalJoint this)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_get_angle2_rate_598_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeUniversalJoint::set_param_lo_stop(int axis, float val)
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_set_param_lo_stop_599(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeUniversalJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeUniversalJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeUniversalJoint::set_param_lo_stop(int axis, float val)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"axis", (char *)"val", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setParamLoStop", key_word_list, &param1, &param2))
        {
            (local_this)->set_param_lo_stop((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeUniversalJoint.setParamLoStop() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamLoStop(non-const OdeUniversalJoint this, int axis, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_set_param_lo_stop_599_comment =
    "C++ Interface:\n"
    "setParamLoStop(non-const OdeUniversalJoint this, int axis, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_set_param_lo_stop_599_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeUniversalJoint::set_param_hi_stop(int axis, float val)
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_set_param_hi_stop_600(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeUniversalJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeUniversalJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeUniversalJoint::set_param_hi_stop(int axis, float val)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"axis", (char *)"val", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setParamHiStop", key_word_list, &param1, &param2))
        {
            (local_this)->set_param_hi_stop((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeUniversalJoint.setParamHiStop() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamHiStop(non-const OdeUniversalJoint this, int axis, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_set_param_hi_stop_600_comment =
    "C++ Interface:\n"
    "setParamHiStop(non-const OdeUniversalJoint this, int axis, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_set_param_hi_stop_600_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeUniversalJoint::set_param_vel(int axis, float val)
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_set_param_vel_601(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeUniversalJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeUniversalJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeUniversalJoint::set_param_vel(int axis, float val)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"axis", (char *)"val", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setParamVel", key_word_list, &param1, &param2))
        {
            (local_this)->set_param_vel((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeUniversalJoint.setParamVel() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamVel(non-const OdeUniversalJoint this, int axis, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_set_param_vel_601_comment =
    "C++ Interface:\n"
    "setParamVel(non-const OdeUniversalJoint this, int axis, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_set_param_vel_601_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeUniversalJoint::set_param_f_max(int axis, float val)
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_set_param_f_max_602(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeUniversalJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeUniversalJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeUniversalJoint::set_param_f_max(int axis, float val)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"axis", (char *)"val", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setParamFMax", key_word_list, &param1, &param2))
        {
            (local_this)->set_param_f_max((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeUniversalJoint.setParamFMax() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamFMax(non-const OdeUniversalJoint this, int axis, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_set_param_f_max_602_comment =
    "C++ Interface:\n"
    "setParamFMax(non-const OdeUniversalJoint this, int axis, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_set_param_f_max_602_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeUniversalJoint::set_param_fudge_factor(int axis, float val)
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_set_param_fudge_factor_603(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeUniversalJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeUniversalJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeUniversalJoint::set_param_fudge_factor(int axis, float val)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"axis", (char *)"val", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setParamFudgeFactor", key_word_list, &param1, &param2))
        {
            (local_this)->set_param_fudge_factor((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeUniversalJoint.setParamFudgeFactor() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamFudgeFactor(non-const OdeUniversalJoint this, int axis, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_set_param_fudge_factor_603_comment =
    "C++ Interface:\n"
    "setParamFudgeFactor(non-const OdeUniversalJoint this, int axis, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_set_param_fudge_factor_603_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeUniversalJoint::set_param_bounce(int axis, float val)
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_set_param_bounce_604(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeUniversalJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeUniversalJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeUniversalJoint::set_param_bounce(int axis, float val)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"axis", (char *)"val", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setParamBounce", key_word_list, &param1, &param2))
        {
            (local_this)->set_param_bounce((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeUniversalJoint.setParamBounce() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamBounce(non-const OdeUniversalJoint this, int axis, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_set_param_bounce_604_comment =
    "C++ Interface:\n"
    "setParamBounce(non-const OdeUniversalJoint this, int axis, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_set_param_bounce_604_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeUniversalJoint::set_param_CFM(int axis, float val)
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_set_param_CFM_605(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeUniversalJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeUniversalJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeUniversalJoint::set_param_CFM(int axis, float val)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"axis", (char *)"val", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setParamCFM", key_word_list, &param1, &param2))
        {
            (local_this)->set_param_CFM((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeUniversalJoint.setParamCFM() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamCFM(non-const OdeUniversalJoint this, int axis, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_set_param_CFM_605_comment =
    "C++ Interface:\n"
    "setParamCFM(non-const OdeUniversalJoint this, int axis, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_set_param_CFM_605_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeUniversalJoint::set_param_stop_ERP(int axis, float val)
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_set_param_stop_ERP_606(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeUniversalJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeUniversalJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeUniversalJoint::set_param_stop_ERP(int axis, float val)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"axis", (char *)"val", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setParamStopERP", key_word_list, &param1, &param2))
        {
            (local_this)->set_param_stop_ERP((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeUniversalJoint.setParamStopERP() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamStopERP(non-const OdeUniversalJoint this, int axis, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_set_param_stop_ERP_606_comment =
    "C++ Interface:\n"
    "setParamStopERP(non-const OdeUniversalJoint this, int axis, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_set_param_stop_ERP_606_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void OdeUniversalJoint::set_param_stop_CFM(int axis, float val)
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_set_param_stop_CFM_607(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeUniversalJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeUniversalJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void OdeUniversalJoint::set_param_stop_CFM(int axis, float val)
        int param1;
        double param2;
        static char * key_word_list[] = {(char *)"axis", (char *)"val", NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, "id:setParamStopCFM", key_word_list, &param1, &param2))
        {
            (local_this)->set_param_stop_CFM((int)param1, (float)param2);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call OdeUniversalJoint.setParamStopCFM() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "setParamStopCFM(non-const OdeUniversalJoint this, int axis, float val)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_set_param_stop_CFM_607_comment =
    "C++ Interface:\n"
    "setParamStopCFM(non-const OdeUniversalJoint this, int axis, float val)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_set_param_stop_CFM_607_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeUniversalJoint::get_param_lo_stop(int axis) const
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_get_param_lo_stop_608(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeUniversalJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeUniversalJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeUniversalJoint::get_param_lo_stop(int axis) const
        int param1;
        static char * key_word_list[] = {(char *)"axis", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParamLoStop", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParamLoStop", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeUniversalJoint*)local_this)->get_param_lo_stop((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamLoStop(const OdeUniversalJoint this, int axis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_get_param_lo_stop_608_comment =
    "C++ Interface:\n"
    "getParamLoStop(const OdeUniversalJoint this, int axis)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_get_param_lo_stop_608_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeUniversalJoint::get_param_hi_stop(int axis) const
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_get_param_hi_stop_609(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeUniversalJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeUniversalJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeUniversalJoint::get_param_hi_stop(int axis) const
        int param1;
        static char * key_word_list[] = {(char *)"axis", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParamHiStop", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParamHiStop", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeUniversalJoint*)local_this)->get_param_hi_stop((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamHiStop(const OdeUniversalJoint this, int axis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_get_param_hi_stop_609_comment =
    "C++ Interface:\n"
    "getParamHiStop(const OdeUniversalJoint this, int axis)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_get_param_hi_stop_609_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeUniversalJoint::get_param_vel(int axis) const
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_get_param_vel_610(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeUniversalJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeUniversalJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeUniversalJoint::get_param_vel(int axis) const
        int param1;
        static char * key_word_list[] = {(char *)"axis", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParamVel", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParamVel", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeUniversalJoint*)local_this)->get_param_vel((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamVel(const OdeUniversalJoint this, int axis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_get_param_vel_610_comment =
    "C++ Interface:\n"
    "getParamVel(const OdeUniversalJoint this, int axis)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_get_param_vel_610_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeUniversalJoint::get_param_f_max(int axis) const
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_get_param_f_max_611(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeUniversalJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeUniversalJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeUniversalJoint::get_param_f_max(int axis) const
        int param1;
        static char * key_word_list[] = {(char *)"axis", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParamFMax", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParamFMax", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeUniversalJoint*)local_this)->get_param_f_max((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamFMax(const OdeUniversalJoint this, int axis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_get_param_f_max_611_comment =
    "C++ Interface:\n"
    "getParamFMax(const OdeUniversalJoint this, int axis)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_get_param_f_max_611_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeUniversalJoint::get_param_fudge_factor(int axis) const
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_get_param_fudge_factor_612(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeUniversalJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeUniversalJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeUniversalJoint::get_param_fudge_factor(int axis) const
        int param1;
        static char * key_word_list[] = {(char *)"axis", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParamFudgeFactor", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParamFudgeFactor", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeUniversalJoint*)local_this)->get_param_fudge_factor((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamFudgeFactor(const OdeUniversalJoint this, int axis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_get_param_fudge_factor_612_comment =
    "C++ Interface:\n"
    "getParamFudgeFactor(const OdeUniversalJoint this, int axis)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_get_param_fudge_factor_612_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeUniversalJoint::get_param_bounce(int axis) const
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_get_param_bounce_613(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeUniversalJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeUniversalJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeUniversalJoint::get_param_bounce(int axis) const
        int param1;
        static char * key_word_list[] = {(char *)"axis", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParamBounce", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParamBounce", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeUniversalJoint*)local_this)->get_param_bounce((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamBounce(const OdeUniversalJoint this, int axis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_get_param_bounce_613_comment =
    "C++ Interface:\n"
    "getParamBounce(const OdeUniversalJoint this, int axis)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_get_param_bounce_613_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeUniversalJoint::get_param_CFM(int axis) const
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_get_param_CFM_614(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeUniversalJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeUniversalJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeUniversalJoint::get_param_CFM(int axis) const
        int param1;
        static char * key_word_list[] = {(char *)"axis", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParamCFM", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParamCFM", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeUniversalJoint*)local_this)->get_param_CFM((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamCFM(const OdeUniversalJoint this, int axis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_get_param_CFM_614_comment =
    "C++ Interface:\n"
    "getParamCFM(const OdeUniversalJoint this, int axis)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_get_param_CFM_614_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeUniversalJoint::get_param_stop_ERP(int axis) const
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_get_param_stop_ERP_615(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeUniversalJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeUniversalJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeUniversalJoint::get_param_stop_ERP(int axis) const
        int param1;
        static char * key_word_list[] = {(char *)"axis", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParamStopERP", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParamStopERP", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeUniversalJoint*)local_this)->get_param_stop_ERP((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamStopERP(const OdeUniversalJoint this, int axis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_get_param_stop_ERP_615_comment =
    "C++ Interface:\n"
    "getParamStopERP(const OdeUniversalJoint this, int axis)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_get_param_stop_ERP_615_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline float OdeUniversalJoint::get_param_stop_CFM(int axis) const
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_get_param_stop_CFM_616(PyObject *self, PyObject *args,PyObject *kwds) {
    OdeUniversalJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeUniversalJoint,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline float OdeUniversalJoint::get_param_stop_CFM(int axis) const
        int param1;
        static char * key_word_list[] = {(char *)"axis", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:getParamStopCFM", key_word_list, &param1));
        else
            (PyArg_Parse(args, "i:getParamStopCFM", &param1));
        if(!PyErr_Occurred())
        {
            float return_value = ((const OdeUniversalJoint*)local_this)->get_param_stop_CFM((int)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getParamStopCFM(const OdeUniversalJoint this, int axis)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_get_param_stop_CFM_616_comment =
    "C++ Interface:\n"
    "getParamStopCFM(const OdeUniversalJoint this, int axis)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_get_param_stop_CFM_616_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static TypeHandle OdeUniversalJoint::get_class_type(void)
 *******************************************************************/
static PyObject *Dtool_OdeUniversalJoint_get_class_type_617(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static TypeHandle OdeUniversalJoint::get_class_type(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getClassType", key_word_list))
        {
            TypeHandle result = OdeUniversalJoint::get_class_type();
            TypeHandle *return_value = new TypeHandle(result);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstance((void *)return_value,Dtool_TypeHandle,true, false);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getClassType()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUniversalJoint_get_class_type_617_comment =
    "C++ Interface:\n"
    "getClassType()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUniversalJoint_get_class_type_617_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * OdeUniversalJoint::OdeUniversalJoint(OdeWorld &world)
 * OdeUniversalJoint::OdeUniversalJoint(OdeWorld &world, OdeJointGroup &joint_group)
 *******************************************************************/
int  Dtool_Init_OdeUniversalJoint(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeUniversalJoint::OdeUniversalJoint(OdeWorld &world)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"world", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:OdeUniversalJoint", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:OdeUniversalJoint", &param0));
                if(!PyErr_Occurred())
                {
                    OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeWorld, 0, "OdeUniversalJoint.OdeUniversalJoint", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        OdeUniversalJoint *return_value = new OdeUniversalJoint(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeUniversalJoint,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-OdeUniversalJoint::OdeUniversalJoint(OdeWorld &world, OdeJointGroup &joint_group)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"world", (char *)"joint_group", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:OdeUniversalJoint", key_word_list, &param0, &param1))
                {
                    OdeWorld *param0_this = (OdeWorld *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeWorld, 0, "OdeUniversalJoint.OdeUniversalJoint", 0, coerced_ptr, report_errors);
OdeJointGroup *param1_this = (OdeJointGroup *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeJointGroup, 1, "OdeUniversalJoint.OdeUniversalJoint", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        OdeUniversalJoint *return_value = new OdeUniversalJoint(*param0_this, *param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_OdeUniversalJoint,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "OdeUniversalJoint() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "OdeUniversalJoint(non-const OdeWorld world)\n"
          "OdeUniversalJoint(non-const OdeWorld world, non-const OdeJointGroup joint_group)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_OdeUniversalJoint(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeUniversalJoint)
    {
        printf("OdeUniversalJoint ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeUniversalJoint * local_this = (OdeUniversalJoint *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeUniversalJoint)
        return local_this;
    if(requested_type == &Dtool_OdeJoint)
        return ( OdeJoint *) local_this;
    if(requested_type == &Dtool_TypedObject)
        return ( TypedObject *)( OdeJoint *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeUniversalJoint(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeUniversalJoint)
        return from_this;
    if(from_type == &Dtool_OdeJoint)
    {
          OdeJoint* other_this = (OdeJoint*)from_this;
          return (OdeUniversalJoint*)other_this;
    }
    if(from_type == &Dtool_TypedObject)
    {
          TypedObject* other_this = (TypedObject*)from_this;
          return (OdeUniversalJoint*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. OdeUtil 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static OdeJoint OdeUtil::get_connecting_joint(OdeBody const &body1, OdeBody const &body2)
 *******************************************************************/
static PyObject *Dtool_OdeUtil_get_connecting_joint_619(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static OdeJoint OdeUtil::get_connecting_joint(OdeBody const &body1, OdeBody const &body2)
            PyObject *param0;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"body1", (char *)"body2", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getConnectingJoint", key_word_list, &param0, &param1))
            {
                OdeBody *param0_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeBody, 0, "OdeUtil.getConnectingJoint", 1, coerced_ptr, report_errors);
OdeBody *param1_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeBody, 1, "OdeUtil.getConnectingJoint", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)|| (param1_this == NULL)))
                {
                    OdeJoint result = OdeUtil::get_connecting_joint(*param0_this, *param1_this);
                    OdeJoint *return_value = new OdeJoint(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeJoint,true, false, (return_value)->as_typed_object()->get_type_index());
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getConnectingJoint(const OdeBody body1, const OdeBody body2)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUtil_get_connecting_joint_619_comment =
    "C++ Interface:\n"
    "getConnectingJoint(const OdeBody body1, const OdeBody body2)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUtil_get_connecting_joint_619_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static OdeJointCollection OdeUtil::get_connecting_joint_list(OdeBody const &body1, OdeBody const &body2)
 *******************************************************************/
static PyObject *Dtool_OdeUtil_get_connecting_joint_list_620(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static OdeJointCollection OdeUtil::get_connecting_joint_list(OdeBody const &body1, OdeBody const &body2)
            PyObject *param0;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"body1", (char *)"body2", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:getConnectingJointList", key_word_list, &param0, &param1))
            {
                OdeBody *param0_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeBody, 0, "OdeUtil.getConnectingJointList", 1, coerced_ptr, report_errors);
OdeBody *param1_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeBody, 1, "OdeUtil.getConnectingJointList", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)|| (param1_this == NULL)))
                {
                    OdeJointCollection result = OdeUtil::get_connecting_joint_list(*param0_this, *param1_this);
                    OdeJointCollection *return_value = new OdeJointCollection(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_OdeJointCollection,true, false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getConnectingJointList(const OdeBody body1, const OdeBody body2)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUtil_get_connecting_joint_list_620_comment =
    "C++ Interface:\n"
    "getConnectingJointList(const OdeBody body1, const OdeBody body2)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUtil_get_connecting_joint_list_620_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static int OdeUtil::are_connected(OdeBody const &body1, OdeBody const &body2)
 *******************************************************************/
static PyObject *Dtool_OdeUtil_are_connected_621(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static int OdeUtil::are_connected(OdeBody const &body1, OdeBody const &body2)
            PyObject *param0;
            PyObject *param1;
            static char * key_word_list[] = {(char *)"body1", (char *)"body2", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:areConnected", key_word_list, &param0, &param1))
            {
                OdeBody *param0_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeBody, 0, "OdeUtil.areConnected", 1, coerced_ptr, report_errors);
OdeBody *param1_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeBody, 1, "OdeUtil.areConnected", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)|| (param1_this == NULL)))
                {
                    int return_value = OdeUtil::are_connected(*param0_this, *param1_this);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "areConnected(const OdeBody body1, const OdeBody body2)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUtil_are_connected_621_comment =
    "C++ Interface:\n"
    "areConnected(const OdeBody body1, const OdeBody body2)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUtil_are_connected_621_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static int OdeUtil::are_connected_excluding(OdeBody const &body1, OdeBody const &body2, int const joint_type)
 *******************************************************************/
static PyObject *Dtool_OdeUtil_are_connected_excluding_622(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static int OdeUtil::are_connected_excluding(OdeBody const &body1, OdeBody const &body2, int const joint_type)
            PyObject *param0;
            PyObject *param1;
            int param2;
            static char * key_word_list[] = {(char *)"body1", (char *)"body2", (char *)"joint_type", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:areConnectedExcluding", key_word_list, &param0, &param1, &param2))
            {
                OdeBody *param0_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeBody, 0, "OdeUtil.areConnectedExcluding", 1, coerced_ptr, report_errors);
OdeBody *param1_this = (OdeBody *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeBody, 1, "OdeUtil.areConnectedExcluding", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)|| (param1_this == NULL)))
                {
                    int return_value = OdeUtil::are_connected_excluding(*param0_this, *param1_this, (int)param2);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "areConnectedExcluding(const OdeBody body1, const OdeBody body2, int joint_type)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUtil_are_connected_excluding_622_comment =
    "C++ Interface:\n"
    "areConnectedExcluding(const OdeBody body1, const OdeBody body2, int joint_type)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUtil_are_connected_excluding_622_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static PointerTo< OdeCollisionEntry > OdeUtil::collide(OdeGeom const &geom1, OdeGeom const &geom2, short int const max_contacts)
 * static PointerTo< OdeCollisionEntry > OdeUtil::collide(OdeGeom const &geom1, OdeGeom const &geom2, short int const max_contacts = (150))
 *******************************************************************/
static PyObject *Dtool_OdeUtil_collide_623(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-static PointerTo< OdeCollisionEntry > OdeUtil::collide(OdeGeom const &geom1, OdeGeom const &geom2, short int const max_contacts = (150))
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"geom1", (char *)"geom2", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:collide", key_word_list, &param0, &param1))
                {
                    OdeGeom *param0_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeGeom, 0, "OdeUtil.collide", 1, coerced_ptr, report_errors);
OdeGeom *param1_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeGeom, 1, "OdeUtil.collide", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        PointerTo< OdeCollisionEntry > return_value = OdeUtil::collide(*param0_this, *param1_this);
                        if (return_value != (OdeCollisionEntry *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_OdeCollisionEntry,true, false, (return_value.p())->as_typed_object()->get_type_index());
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(3):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-static PointerTo< OdeCollisionEntry > OdeUtil::collide(OdeGeom const &geom1, OdeGeom const &geom2, short int const max_contacts)
                PyObject *param0;
                PyObject *param1;
                int param2;
                static char * key_word_list[] = {(char *)"geom1", (char *)"geom2", (char *)"max_contacts", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OOi:collide", key_word_list, &param0, &param1, &param2))
                {
                    OdeGeom *param0_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeGeom, 0, "OdeUtil.collide", 1, coerced_ptr, report_errors);
OdeGeom *param1_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeGeom, 1, "OdeUtil.collide", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        PointerTo< OdeCollisionEntry > return_value = OdeUtil::collide(*param0_this, *param1_this, (short int)param2);
                        if (return_value != (OdeCollisionEntry *)0) {
                          return_value->ref();
                        }
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          if(return_value.p() == NULL)
                          {
                              Py_INCREF(Py_None);
                              return Py_None;
                          }
                          return DTool_CreatePyInstanceTyped((void *)return_value.p(),Dtool_OdeCollisionEntry,true, false, (return_value.p())->as_typed_object()->get_type_index());
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "collide() takes 2 or 3 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "collide(const OdeGeom geom1, const OdeGeom geom2)\n"
          "collide(const OdeGeom geom1, const OdeGeom geom2, int max_contacts)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUtil_collide_623_comment =
    "C++ Interface:\n"
    "collide(const OdeGeom geom1, const OdeGeom geom2)\n"
    "collide(const OdeGeom geom1, const OdeGeom geom2, int max_contacts)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUtil_collide_623_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static int OdeUtil::collide2(OdeGeom const &geom1, OdeGeom const &geom2, PyObject *arg, PyObject *callback)
 *******************************************************************/
static PyObject *Dtool_OdeUtil_collide2_624(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static int OdeUtil::collide2(OdeGeom const &geom1, OdeGeom const &geom2, PyObject *arg, PyObject *callback)
            PyObject *param0;
            PyObject *param1;
            PyObject *param2;
            PyObject *param3;
            static char * key_word_list[] = {(char *)"geom1", (char *)"geom2", (char *)"arg", (char *)"callback", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "OOOO:collide2", key_word_list, &param0, &param1, &param2, &param3))
            {
                OdeGeom *param0_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeGeom, 0, "OdeUtil.collide2", 1, coerced_ptr, report_errors);
OdeGeom *param1_this = (OdeGeom *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_OdeGeom, 1, "OdeUtil.collide2", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)|| (param1_this == NULL)))
                {
                    int return_value = OdeUtil::collide2(*param0_this, *param1_this, param2, param3);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      return PyInt_FromLong(return_value);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "collide2(const OdeGeom geom1, const OdeGeom geom2, any arg, any callback)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUtil_collide2_624_comment =
    "C++ Interface:\n"
    "collide2(const OdeGeom geom1, const OdeGeom geom2, any arg, any callback)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUtil_collide2_624_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static OdeGeom OdeUtil::space_to_geom(OdeSpace const &space)
 *******************************************************************/
static PyObject *Dtool_OdeUtil_space_to_geom_625(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-static OdeGeom OdeUtil::space_to_geom(OdeSpace const &space)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"space", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:spaceToGeom", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:spaceToGeom", &param0));
            if(!PyErr_Occurred())
            {
                OdeSpace *param0_this = (OdeSpace *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_OdeSpace, 0, "OdeUtil.spaceToGeom", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    OdeGeom result = OdeUtil::space_to_geom(*param0_this);
                    OdeGeom *return_value = new OdeGeom(result);
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_OdeGeom,true, false, (return_value)->as_typed_object()->get_type_index());
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "spaceToGeom(const OdeSpace space)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUtil_space_to_geom_625_comment =
    "C++ Interface:\n"
    "spaceToGeom(const OdeSpace space)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUtil_space_to_geom_625_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static float OdeUtil::get_infinity(void)
 *******************************************************************/
static PyObject *Dtool_OdeUtil_get_infinity_626(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static float OdeUtil::get_infinity(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":getInfinity", key_word_list))
        {
            float return_value = OdeUtil::get_infinity();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyFloat_FromDouble(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getInfinity()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUtil_get_infinity_626_comment =
    "C++ Interface:\n"
    "getInfinity()\n"
    "\n"
    "// RAU we can't access OC_infinity as constants are not exposed in python\n"
    "";
#else
static const char * Dtool_OdeUtil_get_infinity_626_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static int OdeUtil::rand_get_seed(void)
 *******************************************************************/
static PyObject *Dtool_OdeUtil_rand_get_seed_627(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static int OdeUtil::rand_get_seed(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":randGetSeed", key_word_list))
        {
            int return_value = OdeUtil::rand_get_seed();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "randGetSeed()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUtil_rand_get_seed_627_comment =
    "C++ Interface:\n"
    "randGetSeed()\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUtil_rand_get_seed_627_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static void OdeUtil::rand_set_seed(int s)
 *******************************************************************/
static PyObject *Dtool_OdeUtil_rand_set_seed_628(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static void OdeUtil::rand_set_seed(int s)
        int param0;
        static char * key_word_list[] = {(char *)"s", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "i:randSetSeed", key_word_list, &param0));
        else
            (PyArg_Parse(args, "i:randSetSeed", &param0));
        if(!PyErr_Occurred())
        {
            OdeUtil::rand_set_seed((int)param0);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "randSetSeed(int s)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_OdeUtil_rand_set_seed_628_comment =
    "C++ Interface:\n"
    "randSetSeed(int s)\n"
    "\n"
    "";
#else
static const char * Dtool_OdeUtil_rand_set_seed_628_comment = NULL;
#endif

int  Dtool_Init_OdeUtil(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (OdeUtil)");
       return -1;
}
inline void  * Dtool_UpcastInterface_OdeUtil(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_OdeUtil)
    {
        printf("OdeUtil ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    OdeUtil * local_this = (OdeUtil *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_OdeUtil)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_OdeUtil(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_OdeUtil)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. dxBody | DxBody
//********************************************************************
PyMethodDef Dtool_Methods_dxBody[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_dxBody(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_dxBody.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_dxBody.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_dxBody.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_dxBody.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_dxBody.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(dxBody)");
             printf(" Error In PyType_ReadydxBody");
             return;
        }
        Py_INCREF(&Dtool_dxBody.As_PyTypeObject());
        PyDict_SetItemString(Dtool_dxBody.As_PyTypeObject().tp_dict,"DxBody",&Dtool_dxBody.As_PyObject());
        RegisterRuntimeClass(&Dtool_dxBody,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_dxBody.As_PyTypeObject());
        PyModule_AddObject(module, "DxBody",(PyObject *)&Dtool_dxBody.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. dxGeom | DxGeom
//********************************************************************
PyMethodDef Dtool_Methods_dxGeom[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_dxGeom(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_dxGeom.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_dxGeom.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_dxGeom.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_dxGeom.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_dxGeom.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(dxGeom)");
             printf(" Error In PyType_ReadydxGeom");
             return;
        }
        Py_INCREF(&Dtool_dxGeom.As_PyTypeObject());
        PyDict_SetItemString(Dtool_dxGeom.As_PyTypeObject().tp_dict,"DxGeom",&Dtool_dxGeom.As_PyObject());
        RegisterRuntimeClass(&Dtool_dxGeom,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_dxGeom.As_PyTypeObject());
        PyModule_AddObject(module, "DxGeom",(PyObject *)&Dtool_dxGeom.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. dxJoint | DxJoint
//********************************************************************
PyMethodDef Dtool_Methods_dxJoint[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_dxJoint(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_dxJoint.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_dxJoint.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_dxJoint.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_dxJoint.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_dxJoint.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(dxJoint)");
             printf(" Error In PyType_ReadydxJoint");
             return;
        }
        Py_INCREF(&Dtool_dxJoint.As_PyTypeObject());
        PyDict_SetItemString(Dtool_dxJoint.As_PyTypeObject().tp_dict,"DxJoint",&Dtool_dxJoint.As_PyObject());
        RegisterRuntimeClass(&Dtool_dxJoint,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_dxJoint.As_PyTypeObject());
        PyModule_AddObject(module, "DxJoint",(PyObject *)&Dtool_dxJoint.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. dxJointGroup | DxJointGroup
//********************************************************************
PyMethodDef Dtool_Methods_dxJointGroup[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_dxJointGroup(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_dxJointGroup.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_dxJointGroup.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_dxJointGroup.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_dxJointGroup.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_dxJointGroup.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(dxJointGroup)");
             printf(" Error In PyType_ReadydxJointGroup");
             return;
        }
        Py_INCREF(&Dtool_dxJointGroup.As_PyTypeObject());
        PyDict_SetItemString(Dtool_dxJointGroup.As_PyTypeObject().tp_dict,"DxJointGroup",&Dtool_dxJointGroup.As_PyObject());
        RegisterRuntimeClass(&Dtool_dxJointGroup,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_dxJointGroup.As_PyTypeObject());
        PyModule_AddObject(module, "DxJointGroup",(PyObject *)&Dtool_dxJointGroup.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. dxSpace | DxSpace
//********************************************************************
PyMethodDef Dtool_Methods_dxSpace[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_dxSpace(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_dxSpace.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_dxSpace.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_dxSpace.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_dxSpace.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_dxSpace.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(dxSpace)");
             printf(" Error In PyType_ReadydxSpace");
             return;
        }
        Py_INCREF(&Dtool_dxSpace.As_PyTypeObject());
        PyDict_SetItemString(Dtool_dxSpace.As_PyTypeObject().tp_dict,"DxSpace",&Dtool_dxSpace.As_PyObject());
        RegisterRuntimeClass(&Dtool_dxSpace,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_dxSpace.As_PyTypeObject());
        PyModule_AddObject(module, "DxSpace",(PyObject *)&Dtool_dxSpace.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. dxTriMeshData | DxTriMeshData
//********************************************************************
PyMethodDef Dtool_Methods_dxTriMeshData[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_dxTriMeshData(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_dxTriMeshData.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_dxTriMeshData.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_dxTriMeshData.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_dxTriMeshData.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_dxTriMeshData.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(dxTriMeshData)");
             printf(" Error In PyType_ReadydxTriMeshData");
             return;
        }
        Py_INCREF(&Dtool_dxTriMeshData.As_PyTypeObject());
        PyDict_SetItemString(Dtool_dxTriMeshData.As_PyTypeObject().tp_dict,"DxTriMeshData",&Dtool_dxTriMeshData.As_PyObject());
        RegisterRuntimeClass(&Dtool_dxTriMeshData,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_dxTriMeshData.As_PyTypeObject());
        PyModule_AddObject(module, "DxTriMeshData",(PyObject *)&Dtool_dxTriMeshData.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. dxWorld | DxWorld
//********************************************************************
PyMethodDef Dtool_Methods_dxWorld[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_dxWorld(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_dxWorld.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_dxWorld.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_dxWorld.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_dxWorld.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_dxWorld.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(dxWorld)");
             printf(" Error In PyType_ReadydxWorld");
             return;
        }
        Py_INCREF(&Dtool_dxWorld.As_PyTypeObject());
        PyDict_SetItemString(Dtool_dxWorld.As_PyTypeObject().tp_dict,"DxWorld",&Dtool_dxWorld.As_PyObject());
        RegisterRuntimeClass(&Dtool_dxWorld,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_dxWorld.As_PyTypeObject());
        PyModule_AddObject(module, "DxWorld",(PyObject *)&Dtool_dxWorld.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeWorld | OdeWorld
//********************************************************************
PyMethodDef Dtool_Methods_OdeWorld[]= {
  { "destroy",(PyCFunction ) &Dtool_OdeWorld_destroy_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_destroy_11_comment},
  { "isEmpty",(PyCFunction ) &Dtool_OdeWorld_is_empty_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_is_empty_12_comment},
  { "getId",(PyCFunction ) &Dtool_OdeWorld_get_id_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_get_id_13_comment},
  { "setGravity",(PyCFunction ) &Dtool_OdeWorld_set_gravity_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_set_gravity_14_comment},
  { "setErp",(PyCFunction ) &Dtool_OdeWorld_set_erp_15, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_set_erp_15_comment},
  { "setCfm",(PyCFunction ) &Dtool_OdeWorld_set_cfm_16, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_set_cfm_16_comment},
  { "setQuickStepNumIterations",(PyCFunction ) &Dtool_OdeWorld_set_quick_step_num_iterations_17, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_set_quick_step_num_iterations_17_comment},
  { "setQuickStepW",(PyCFunction ) &Dtool_OdeWorld_set_quick_step_w_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_set_quick_step_w_18_comment},
  { "setContactMaxCorrectingVel",(PyCFunction ) &Dtool_OdeWorld_set_contact_max_correcting_vel_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_set_contact_max_correcting_vel_19_comment},
  { "setContactSurfaceLayer",(PyCFunction ) &Dtool_OdeWorld_set_contact_surface_layer_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_set_contact_surface_layer_20_comment},
  { "setAutoEnableDepthSf1",(PyCFunction ) &Dtool_OdeWorld_set_auto_enable_depth_sf1_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_set_auto_enable_depth_sf1_21_comment},
  { "setAutoDisableLinearThreshold",(PyCFunction ) &Dtool_OdeWorld_set_auto_disable_linear_threshold_22, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_set_auto_disable_linear_threshold_22_comment},
  { "setAutoDisableAngularThreshold",(PyCFunction ) &Dtool_OdeWorld_set_auto_disable_angular_threshold_23, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_set_auto_disable_angular_threshold_23_comment},
  { "setAutoDisableSteps",(PyCFunction ) &Dtool_OdeWorld_set_auto_disable_steps_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_set_auto_disable_steps_24_comment},
  { "setAutoDisableTime",(PyCFunction ) &Dtool_OdeWorld_set_auto_disable_time_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_set_auto_disable_time_25_comment},
  { "setAutoDisableFlag",(PyCFunction ) &Dtool_OdeWorld_set_auto_disable_flag_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_set_auto_disable_flag_26_comment},
  { "getGravity",(PyCFunction ) &Dtool_OdeWorld_get_gravity_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_get_gravity_27_comment},
  { "getErp",(PyCFunction ) &Dtool_OdeWorld_get_erp_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_get_erp_28_comment},
  { "getCfm",(PyCFunction ) &Dtool_OdeWorld_get_cfm_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_get_cfm_29_comment},
  { "getQuickStepNumIterations",(PyCFunction ) &Dtool_OdeWorld_get_quick_step_num_iterations_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_get_quick_step_num_iterations_30_comment},
  { "getQuickStepW",(PyCFunction ) &Dtool_OdeWorld_get_quick_step_w_31, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_get_quick_step_w_31_comment},
  { "getContactMaxCorrectingVel",(PyCFunction ) &Dtool_OdeWorld_get_contact_max_correcting_vel_32, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_get_contact_max_correcting_vel_32_comment},
  { "getContactSurfaceLayer",(PyCFunction ) &Dtool_OdeWorld_get_contact_surface_layer_33, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_get_contact_surface_layer_33_comment},
  { "getAutoEnableDepthSf1",(PyCFunction ) &Dtool_OdeWorld_get_auto_enable_depth_sf1_34, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_get_auto_enable_depth_sf1_34_comment},
  { "getAutoDisableLinearThreshold",(PyCFunction ) &Dtool_OdeWorld_get_auto_disable_linear_threshold_35, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_get_auto_disable_linear_threshold_35_comment},
  { "getAutoDisableAngularThreshold",(PyCFunction ) &Dtool_OdeWorld_get_auto_disable_angular_threshold_36, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_get_auto_disable_angular_threshold_36_comment},
  { "getAutoDisableSteps",(PyCFunction ) &Dtool_OdeWorld_get_auto_disable_steps_37, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_get_auto_disable_steps_37_comment},
  { "getAutoDisableTime",(PyCFunction ) &Dtool_OdeWorld_get_auto_disable_time_38, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_get_auto_disable_time_38_comment},
  { "getAutoDisableFlag",(PyCFunction ) &Dtool_OdeWorld_get_auto_disable_flag_39, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_get_auto_disable_flag_39_comment},
  { "impulseToForce",(PyCFunction ) &Dtool_OdeWorld_impulse_to_force_40, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_impulse_to_force_40_comment},
  { "step",(PyCFunction ) &Dtool_OdeWorld_step_41, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_step_41_comment},
  { "quickStep",(PyCFunction ) &Dtool_OdeWorld_quick_step_42, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_quick_step_42_comment},
  { "stepFast1",(PyCFunction ) &Dtool_OdeWorld_step_fast1_43, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_step_fast1_43_comment},
  { "compareTo",(PyCFunction ) &Dtool_OdeWorld_compare_to_44, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_compare_to_44_comment},
  { "initSurfaceTable",(PyCFunction ) &Dtool_OdeWorld_init_surface_table_45, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_init_surface_table_45_comment},
  { "addBodyDampening",(PyCFunction ) &Dtool_OdeWorld_add_body_dampening_46, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_add_body_dampening_46_comment},
  { "setSurfaceEntry",(PyCFunction ) &Dtool_OdeWorld_set_surface_entry_47, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_set_surface_entry_47_comment},
  { "applyDampening",(PyCFunction ) &Dtool_OdeWorld_apply_dampening_48, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_apply_dampening_48_comment},
  { "getClassType",(PyCFunction ) &Dtool_OdeWorld_get_class_type_50, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_get_class_type_50_comment},
  { "__nonzero__",(PyCFunction ) &Dtool_OdeWorld_operator_typecast_bool_49, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeWorld_operator_typecast_bool_49_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     OdeWorld ...tp_as_number->nb_nonzero = __nonzero__
//////////////////
static int Dtool_OdeWorld_operator_typecast_bool_49__nonzero__(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_OdeWorld_operator_typecast_bool_49(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    int iresult = PyInt_AsLong(result);
    Py_DECREF(result);
    return iresult;
}

void   Dtool_PyModuleClassInit_OdeWorld(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeWorld.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeWorld\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedObject._Dtool_ClassInit(NULL);
        Dtool_OdeWorld.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedObject.As_PyTypeObject());
        Dtool_OdeWorld.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeWorld.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeWorld.As_PyTypeObject().tp_dict);
        // tp_as_number->nb_nonzero = __nonzero__
        Dtool_OdeWorld.As_PyTypeObject().tp_as_number->nb_nonzero = &Dtool_OdeWorld_operator_typecast_bool_49__nonzero__;
        if(PyType_Ready(&Dtool_OdeWorld.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeWorld)");
             printf(" Error In PyType_ReadyOdeWorld");
             return;
        }
        Py_INCREF(&Dtool_OdeWorld.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeWorld.As_PyTypeObject().tp_dict,"OdeWorld",&Dtool_OdeWorld.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeWorld.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeWorld[38],&Dtool_OdeWorld.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeWorld,OdeWorld::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeWorld.As_PyTypeObject());
        PyModule_AddObject(module, "OdeWorld",(PyObject *)&Dtool_OdeWorld.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeJointGroup | OdeJointGroup
//********************************************************************
PyMethodDef Dtool_Methods_OdeJointGroup[]= {
  { "destroy",(PyCFunction ) &Dtool_OdeJointGroup_destroy_53, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJointGroup_destroy_53_comment},
  { "getId",(PyCFunction ) &Dtool_OdeJointGroup_get_id_54, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJointGroup_get_id_54_comment},
  { "empty",(PyCFunction ) &Dtool_OdeJointGroup_empty_55, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJointGroup_empty_55_comment},
  { "compareTo",(PyCFunction ) &Dtool_OdeJointGroup_compare_to_56, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJointGroup_compare_to_56_comment},
  { "getClassType",(PyCFunction ) &Dtool_OdeJointGroup_get_class_type_57, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJointGroup_get_class_type_57_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OdeJointGroup(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeJointGroup.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeJointGroup\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedObject._Dtool_ClassInit(NULL);
        Dtool_OdeJointGroup.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedObject.As_PyTypeObject());
        Dtool_OdeJointGroup.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeJointGroup.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeJointGroup.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OdeJointGroup.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeJointGroup)");
             printf(" Error In PyType_ReadyOdeJointGroup");
             return;
        }
        Py_INCREF(&Dtool_OdeJointGroup.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeJointGroup.As_PyTypeObject().tp_dict,"OdeJointGroup",&Dtool_OdeJointGroup.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeJointGroup.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeJointGroup[4],&Dtool_OdeJointGroup.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeJointGroup,OdeJointGroup::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeJointGroup.As_PyTypeObject());
        PyModule_AddObject(module, "OdeJointGroup",(PyObject *)&Dtool_OdeJointGroup.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeJointFeedback | OdeJointFeedback
//********************************************************************
PyMethodDef Dtool_Methods_OdeJointFeedback[]= {
  { "getForce1",(PyCFunction ) &Dtool_OdeJointFeedback_get_force1_60, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJointFeedback_get_force1_60_comment},
  { "getForce2",(PyCFunction ) &Dtool_OdeJointFeedback_get_force2_61, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJointFeedback_get_force2_61_comment},
  { "getTorque1",(PyCFunction ) &Dtool_OdeJointFeedback_get_torque1_62, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJointFeedback_get_torque1_62_comment},
  { "getTorque2",(PyCFunction ) &Dtool_OdeJointFeedback_get_torque2_63, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJointFeedback_get_torque2_63_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OdeJointFeedback(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_OdeJointFeedback.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_OdeJointFeedback.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeJointFeedback.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeJointFeedback.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OdeJointFeedback.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeJointFeedback)");
             printf(" Error In PyType_ReadyOdeJointFeedback");
             return;
        }
        Py_INCREF(&Dtool_OdeJointFeedback.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeJointFeedback.As_PyTypeObject().tp_dict,"OdeJointFeedback",&Dtool_OdeJointFeedback.As_PyObject());
        RegisterRuntimeClass(&Dtool_OdeJointFeedback,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeJointFeedback.As_PyTypeObject());
        PyModule_AddObject(module, "OdeJointFeedback",(PyObject *)&Dtool_OdeJointFeedback.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeJoint | OdeJoint
//********************************************************************
PyMethodDef Dtool_Methods_OdeJoint[]= {
  { "destroy",(PyCFunction ) &Dtool_OdeJoint_destroy_67, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJoint_destroy_67_comment},
  { "isEmpty",(PyCFunction ) &Dtool_OdeJoint_is_empty_68, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJoint_is_empty_68_comment},
  { "getId",(PyCFunction ) &Dtool_OdeJoint_get_id_69, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJoint_get_id_69_comment},
  { "getJointType",(PyCFunction ) &Dtool_OdeJoint_get_joint_type_70, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJoint_get_joint_type_70_comment},
  { "getBody",(PyCFunction ) &Dtool_OdeJoint_get_body_71, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJoint_get_body_71_comment},
  { "setFeedback",(PyCFunction ) &Dtool_OdeJoint_set_feedback_72, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJoint_set_feedback_72_comment},
  { "getFeedback",(PyCFunction ) &Dtool_OdeJoint_get_feedback_73, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJoint_get_feedback_73_comment},
  { "attachBodies",(PyCFunction ) &Dtool_OdeJoint_attach_bodies_74, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJoint_attach_bodies_74_comment},
  { "attachBody",(PyCFunction ) &Dtool_OdeJoint_attach_body_75, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJoint_attach_body_75_comment},
  { "detach",(PyCFunction ) &Dtool_OdeJoint_detach_76, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJoint_detach_76_comment},
  { "write",(PyCFunction ) &Dtool_OdeJoint_write_77, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJoint_write_77_comment},
  { "compareTo",(PyCFunction ) &Dtool_OdeJoint_compare_to_78, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJoint_compare_to_78_comment},
  { "eq",(PyCFunction ) &Dtool_OdeJoint_operator_79, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJoint_operator_79_comment},
  { "convertToBall",(PyCFunction ) &Dtool_OdeJoint_convert_to_ball_81, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJoint_convert_to_ball_81_comment},
  { "convertToHinge",(PyCFunction ) &Dtool_OdeJoint_convert_to_hinge_82, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJoint_convert_to_hinge_82_comment},
  { "convertToSlider",(PyCFunction ) &Dtool_OdeJoint_convert_to_slider_83, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJoint_convert_to_slider_83_comment},
  { "convertToContact",(PyCFunction ) &Dtool_OdeJoint_convert_to_contact_84, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJoint_convert_to_contact_84_comment},
  { "convertToUniversal",(PyCFunction ) &Dtool_OdeJoint_convert_to_universal_85, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJoint_convert_to_universal_85_comment},
  { "convertToHinge2",(PyCFunction ) &Dtool_OdeJoint_convert_to_hinge2_86, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJoint_convert_to_hinge2_86_comment},
  { "convertToFixed",(PyCFunction ) &Dtool_OdeJoint_convert_to_fixed_87, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJoint_convert_to_fixed_87_comment},
  { "convertToNull",(PyCFunction ) &Dtool_OdeJoint_convert_to_null_88, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJoint_convert_to_null_88_comment},
  { "convertToAMotor",(PyCFunction ) &Dtool_OdeJoint_convert_to_a_motor_89, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJoint_convert_to_a_motor_89_comment},
  { "convertToLMotor",(PyCFunction ) &Dtool_OdeJoint_convert_to_l_motor_90, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJoint_convert_to_l_motor_90_comment},
  { "convertToPlane2d",(PyCFunction ) &Dtool_OdeJoint_convert_to_plane2d_91, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJoint_convert_to_plane2d_91_comment},
  { "getClassType",(PyCFunction ) &Dtool_OdeJoint_get_class_type_92, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJoint_get_class_type_92_comment},
  { "__nonzero__",(PyCFunction ) &Dtool_OdeJoint_operator_typecast_bool_80, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJoint_operator_typecast_bool_80_comment},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     OdeJoint ...tp_as_number->nb_nonzero = __nonzero__
//////////////////
static int Dtool_OdeJoint_operator_typecast_bool_80__nonzero__(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_OdeJoint_operator_typecast_bool_80(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    int iresult = PyInt_AsLong(result);
    Py_DECREF(result);
    return iresult;
}

//////////////////
//  A __str__ Function
//     OdeJoint
//////////////////
static PyObject *  Dtool_Str_OdeJoint(PyObject * self)
{
    OdeJoint * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeJoint,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_OdeJoint(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeJoint.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeJoint\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedObject._Dtool_ClassInit(NULL);
        Dtool_OdeJoint.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedObject.As_PyTypeObject());
        Dtool_OdeJoint.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeJoint.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeJoint.As_PyTypeObject().tp_dict);
        // tp_as_number->nb_nonzero = __nonzero__
        Dtool_OdeJoint.As_PyTypeObject().tp_as_number->nb_nonzero = &Dtool_OdeJoint_operator_typecast_bool_80__nonzero__;
        // __str__
        Dtool_OdeJoint.As_PyTypeObject().tp_str = & Dtool_Str_OdeJoint;
        // Enum  OdeJoint::JointType;
        PyDict_SetItemString(Dtool_OdeJoint.As_PyTypeObject().tp_dict,"JTNone",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_OdeJoint.As_PyTypeObject().tp_dict,"JTBall",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_OdeJoint.As_PyTypeObject().tp_dict,"JTHinge",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_OdeJoint.As_PyTypeObject().tp_dict,"JTSlider",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_OdeJoint.As_PyTypeObject().tp_dict,"JTContact",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_OdeJoint.As_PyTypeObject().tp_dict,"JTUniversal",PyInt_FromLong(5));
        PyDict_SetItemString(Dtool_OdeJoint.As_PyTypeObject().tp_dict,"JTHinge2",PyInt_FromLong(6));
        PyDict_SetItemString(Dtool_OdeJoint.As_PyTypeObject().tp_dict,"JTFixed",PyInt_FromLong(7));
        PyDict_SetItemString(Dtool_OdeJoint.As_PyTypeObject().tp_dict,"JTNull",PyInt_FromLong(8));
        PyDict_SetItemString(Dtool_OdeJoint.As_PyTypeObject().tp_dict,"JTAMotor",PyInt_FromLong(9));
        PyDict_SetItemString(Dtool_OdeJoint.As_PyTypeObject().tp_dict,"JTLMotor",PyInt_FromLong(10));
        PyDict_SetItemString(Dtool_OdeJoint.As_PyTypeObject().tp_dict,"JTPlane2d",PyInt_FromLong(11));
        if(PyType_Ready(&Dtool_OdeJoint.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeJoint)");
             printf(" Error In PyType_ReadyOdeJoint");
             return;
        }
        Py_INCREF(&Dtool_OdeJoint.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeJoint.As_PyTypeObject().tp_dict,"OdeJoint",&Dtool_OdeJoint.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeJoint.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeJoint[24],&Dtool_OdeJoint.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeJoint,OdeJoint::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeJoint.As_PyTypeObject());
        PyModule_AddObject(module, "OdeJoint",(PyObject *)&Dtool_OdeJoint.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeAMotorJoint | OdeAMotorJoint
//********************************************************************
PyMethodDef Dtool_Methods_OdeAMotorJoint[]= {
  { "setNumAxes",(PyCFunction ) &Dtool_OdeAMotorJoint_set_num_axes_95, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeAMotorJoint_set_num_axes_95_comment},
  { "setAxis",(PyCFunction ) &Dtool_OdeAMotorJoint_set_axis_96, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeAMotorJoint_set_axis_96_comment},
  { "setAngle",(PyCFunction ) &Dtool_OdeAMotorJoint_set_angle_97, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeAMotorJoint_set_angle_97_comment},
  { "setMode",(PyCFunction ) &Dtool_OdeAMotorJoint_set_mode_98, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeAMotorJoint_set_mode_98_comment},
  { "addTorques",(PyCFunction ) &Dtool_OdeAMotorJoint_add_torques_99, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeAMotorJoint_add_torques_99_comment},
  { "getNumAxes",(PyCFunction ) &Dtool_OdeAMotorJoint_get_num_axes_100, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeAMotorJoint_get_num_axes_100_comment},
  { "getAxis",(PyCFunction ) &Dtool_OdeAMotorJoint_get_axis_101, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeAMotorJoint_get_axis_101_comment},
  { "getAxisRel",(PyCFunction ) &Dtool_OdeAMotorJoint_get_axis_rel_102, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeAMotorJoint_get_axis_rel_102_comment},
  { "getAngle",(PyCFunction ) &Dtool_OdeAMotorJoint_get_angle_103, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeAMotorJoint_get_angle_103_comment},
  { "getAngleRate",(PyCFunction ) &Dtool_OdeAMotorJoint_get_angle_rate_104, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeAMotorJoint_get_angle_rate_104_comment},
  { "getMode",(PyCFunction ) &Dtool_OdeAMotorJoint_get_mode_105, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeAMotorJoint_get_mode_105_comment},
  { "setParamLoStop",(PyCFunction ) &Dtool_OdeAMotorJoint_set_param_lo_stop_106, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeAMotorJoint_set_param_lo_stop_106_comment},
  { "setParamHiStop",(PyCFunction ) &Dtool_OdeAMotorJoint_set_param_hi_stop_107, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeAMotorJoint_set_param_hi_stop_107_comment},
  { "setParamVel",(PyCFunction ) &Dtool_OdeAMotorJoint_set_param_vel_108, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeAMotorJoint_set_param_vel_108_comment},
  { "setParamFMax",(PyCFunction ) &Dtool_OdeAMotorJoint_set_param_f_max_109, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeAMotorJoint_set_param_f_max_109_comment},
  { "setParamFudgeFactor",(PyCFunction ) &Dtool_OdeAMotorJoint_set_param_fudge_factor_110, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeAMotorJoint_set_param_fudge_factor_110_comment},
  { "setParamBounce",(PyCFunction ) &Dtool_OdeAMotorJoint_set_param_bounce_111, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeAMotorJoint_set_param_bounce_111_comment},
  { "setParamCFM",(PyCFunction ) &Dtool_OdeAMotorJoint_set_param_CFM_112, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeAMotorJoint_set_param_CFM_112_comment},
  { "setParamStopERP",(PyCFunction ) &Dtool_OdeAMotorJoint_set_param_stop_ERP_113, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeAMotorJoint_set_param_stop_ERP_113_comment},
  { "setParamStopCFM",(PyCFunction ) &Dtool_OdeAMotorJoint_set_param_stop_CFM_114, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeAMotorJoint_set_param_stop_CFM_114_comment},
  { "getParamLoStop",(PyCFunction ) &Dtool_OdeAMotorJoint_get_param_lo_stop_115, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeAMotorJoint_get_param_lo_stop_115_comment},
  { "getParamHiStop",(PyCFunction ) &Dtool_OdeAMotorJoint_get_param_hi_stop_116, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeAMotorJoint_get_param_hi_stop_116_comment},
  { "getParamVel",(PyCFunction ) &Dtool_OdeAMotorJoint_get_param_vel_117, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeAMotorJoint_get_param_vel_117_comment},
  { "getParamFMax",(PyCFunction ) &Dtool_OdeAMotorJoint_get_param_f_max_118, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeAMotorJoint_get_param_f_max_118_comment},
  { "getParamFudgeFactor",(PyCFunction ) &Dtool_OdeAMotorJoint_get_param_fudge_factor_119, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeAMotorJoint_get_param_fudge_factor_119_comment},
  { "getParamBounce",(PyCFunction ) &Dtool_OdeAMotorJoint_get_param_bounce_120, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeAMotorJoint_get_param_bounce_120_comment},
  { "getParamCFM",(PyCFunction ) &Dtool_OdeAMotorJoint_get_param_CFM_121, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeAMotorJoint_get_param_CFM_121_comment},
  { "getParamStopERP",(PyCFunction ) &Dtool_OdeAMotorJoint_get_param_stop_ERP_122, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeAMotorJoint_get_param_stop_ERP_122_comment},
  { "getParamStopCFM",(PyCFunction ) &Dtool_OdeAMotorJoint_get_param_stop_CFM_123, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeAMotorJoint_get_param_stop_CFM_123_comment},
  { "getClassType",(PyCFunction ) &Dtool_OdeAMotorJoint_get_class_type_124, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeAMotorJoint_get_class_type_124_comment},
  { "getAxes",(PyCFunction) &MakeSeq_OdeAMotorJoint_get_axes, METH_NOARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OdeAMotorJoint(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeAMotorJoint.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeAMotorJoint\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_OdeJoint._Dtool_ClassInit(NULL);
        Dtool_OdeAMotorJoint.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_OdeJoint.As_PyTypeObject());
        Dtool_OdeAMotorJoint.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeAMotorJoint.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeAMotorJoint.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OdeAMotorJoint.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeAMotorJoint)");
             printf(" Error In PyType_ReadyOdeAMotorJoint");
             return;
        }
        Py_INCREF(&Dtool_OdeAMotorJoint.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeAMotorJoint.As_PyTypeObject().tp_dict,"OdeAMotorJoint",&Dtool_OdeAMotorJoint.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeAMotorJoint.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeAMotorJoint[29],&Dtool_OdeAMotorJoint.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeAMotorJoint,OdeAMotorJoint::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeAMotorJoint.As_PyTypeObject());
        PyModule_AddObject(module, "OdeAMotorJoint",(PyObject *)&Dtool_OdeAMotorJoint.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeBallJoint | OdeBallJoint
//********************************************************************
PyMethodDef Dtool_Methods_OdeBallJoint[]= {
  { "setAnchor",(PyCFunction ) &Dtool_OdeBallJoint_set_anchor_127, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBallJoint_set_anchor_127_comment},
  { "setAnchor2",(PyCFunction ) &Dtool_OdeBallJoint_set_anchor2_128, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBallJoint_set_anchor2_128_comment},
  { "getAnchor",(PyCFunction ) &Dtool_OdeBallJoint_get_anchor_129, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBallJoint_get_anchor_129_comment},
  { "getAnchor2",(PyCFunction ) &Dtool_OdeBallJoint_get_anchor2_130, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBallJoint_get_anchor2_130_comment},
  { "getClassType",(PyCFunction ) &Dtool_OdeBallJoint_get_class_type_131, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBallJoint_get_class_type_131_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OdeBallJoint(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeBallJoint.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeBallJoint\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_OdeJoint._Dtool_ClassInit(NULL);
        Dtool_OdeBallJoint.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_OdeJoint.As_PyTypeObject());
        Dtool_OdeBallJoint.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeBallJoint.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeBallJoint.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OdeBallJoint.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeBallJoint)");
             printf(" Error In PyType_ReadyOdeBallJoint");
             return;
        }
        Py_INCREF(&Dtool_OdeBallJoint.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeBallJoint.As_PyTypeObject().tp_dict,"OdeBallJoint",&Dtool_OdeBallJoint.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeBallJoint.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeBallJoint[4],&Dtool_OdeBallJoint.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeBallJoint,OdeBallJoint::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeBallJoint.As_PyTypeObject());
        PyModule_AddObject(module, "OdeBallJoint",(PyObject *)&Dtool_OdeBallJoint.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeMass | OdeMass
//********************************************************************
PyMethodDef Dtool_Methods_OdeMass[]= {
  { "check",(PyCFunction ) &Dtool_OdeMass_check_135, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeMass_check_135_comment},
  { "setZero",(PyCFunction ) &Dtool_OdeMass_set_zero_136, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeMass_set_zero_136_comment},
  { "setParameters",(PyCFunction ) &Dtool_OdeMass_set_parameters_137, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeMass_set_parameters_137_comment},
  { "setSphere",(PyCFunction ) &Dtool_OdeMass_set_sphere_138, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeMass_set_sphere_138_comment},
  { "setSphereTotal",(PyCFunction ) &Dtool_OdeMass_set_sphere_total_139, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeMass_set_sphere_total_139_comment},
  { "setCapsule",(PyCFunction ) &Dtool_OdeMass_set_capsule_140, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeMass_set_capsule_140_comment},
  { "setCapsuleTotal",(PyCFunction ) &Dtool_OdeMass_set_capsule_total_141, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeMass_set_capsule_total_141_comment},
  { "setCylinder",(PyCFunction ) &Dtool_OdeMass_set_cylinder_142, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeMass_set_cylinder_142_comment},
  { "setCylinderTotal",(PyCFunction ) &Dtool_OdeMass_set_cylinder_total_143, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeMass_set_cylinder_total_143_comment},
  { "setBox",(PyCFunction ) &Dtool_OdeMass_set_box_144, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeMass_set_box_144_comment},
  { "setBoxTotal",(PyCFunction ) &Dtool_OdeMass_set_box_total_145, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeMass_set_box_total_145_comment},
  { "adjust",(PyCFunction ) &Dtool_OdeMass_adjust_146, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeMass_adjust_146_comment},
  { "translate",(PyCFunction ) &Dtool_OdeMass_translate_147, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeMass_translate_147_comment},
  { "rotate",(PyCFunction ) &Dtool_OdeMass_rotate_148, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeMass_rotate_148_comment},
  { "add",(PyCFunction ) &Dtool_OdeMass_add_149, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeMass_add_149_comment},
  { "getMagnitude",(PyCFunction ) &Dtool_OdeMass_get_magnitude_150, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeMass_get_magnitude_150_comment},
  { "getCenter",(PyCFunction ) &Dtool_OdeMass_get_center_151, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeMass_get_center_151_comment},
  { "getInertialTensor",(PyCFunction ) &Dtool_OdeMass_get_inertial_tensor_152, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeMass_get_inertial_tensor_152_comment},
  { "write",(PyCFunction ) &Dtool_OdeMass_write_153, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeMass_write_153_comment},
  { "getClassType",(PyCFunction ) &Dtool_OdeMass_get_class_type_154, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeMass_get_class_type_154_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A __str__ Function
//     OdeMass
//////////////////
static PyObject *  Dtool_Str_OdeMass(PyObject * self)
{
    OdeMass * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeMass,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_OdeMass(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeMass.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeMass\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_OdeMass.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_OdeMass.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeMass.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeMass.As_PyTypeObject().tp_dict);
        // __str__
        Dtool_OdeMass.As_PyTypeObject().tp_str = & Dtool_Str_OdeMass;
        if(PyType_Ready(&Dtool_OdeMass.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeMass)");
             printf(" Error In PyType_ReadyOdeMass");
             return;
        }
        Py_INCREF(&Dtool_OdeMass.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeMass.As_PyTypeObject().tp_dict,"OdeMass",&Dtool_OdeMass.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeMass.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeMass[19],&Dtool_OdeMass.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeMass,OdeMass::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeMass.As_PyTypeObject());
        PyModule_AddObject(module, "OdeMass",(PyObject *)&Dtool_OdeMass.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeBody | OdeBody
//********************************************************************
PyMethodDef Dtool_Methods_OdeBody[]= {
  { "destroy",(PyCFunction ) &Dtool_OdeBody_destroy_157, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_destroy_157_comment},
  { "isEmpty",(PyCFunction ) &Dtool_OdeBody_is_empty_158, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_is_empty_158_comment},
  { "getId",(PyCFunction ) &Dtool_OdeBody_get_id_159, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_get_id_159_comment},
  { "setAutoDisableLinearThreshold",(PyCFunction ) &Dtool_OdeBody_set_auto_disable_linear_threshold_160, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_set_auto_disable_linear_threshold_160_comment},
  { "setAutoDisableAngularThreshold",(PyCFunction ) &Dtool_OdeBody_set_auto_disable_angular_threshold_161, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_set_auto_disable_angular_threshold_161_comment},
  { "setAutoDisableSteps",(PyCFunction ) &Dtool_OdeBody_set_auto_disable_steps_162, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_set_auto_disable_steps_162_comment},
  { "setAutoDisableTime",(PyCFunction ) &Dtool_OdeBody_set_auto_disable_time_163, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_set_auto_disable_time_163_comment},
  { "setAutoDisableFlag",(PyCFunction ) &Dtool_OdeBody_set_auto_disable_flag_164, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_set_auto_disable_flag_164_comment},
  { "setAutoDisableDefaults",(PyCFunction ) &Dtool_OdeBody_set_auto_disable_defaults_165, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_set_auto_disable_defaults_165_comment},
  { "setData",(PyCFunction ) &Dtool_OdeBody_set_data_166, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_set_data_166_comment},
  { "setPosition",(PyCFunction ) &Dtool_OdeBody_set_position_167, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_set_position_167_comment},
  { "setRotation",(PyCFunction ) &Dtool_OdeBody_set_rotation_168, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_set_rotation_168_comment},
  { "setQuaternion",(PyCFunction ) &Dtool_OdeBody_set_quaternion_169, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_set_quaternion_169_comment},
  { "setLinearVel",(PyCFunction ) &Dtool_OdeBody_set_linear_vel_170, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_set_linear_vel_170_comment},
  { "setAngularVel",(PyCFunction ) &Dtool_OdeBody_set_angular_vel_171, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_set_angular_vel_171_comment},
  { "setMass",(PyCFunction ) &Dtool_OdeBody_set_mass_172, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_set_mass_172_comment},
  { "getAutoDisableLinearThreshold",(PyCFunction ) &Dtool_OdeBody_get_auto_disable_linear_threshold_173, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_get_auto_disable_linear_threshold_173_comment},
  { "getAutoDisableAngularThreshold",(PyCFunction ) &Dtool_OdeBody_get_auto_disable_angular_threshold_174, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_get_auto_disable_angular_threshold_174_comment},
  { "getAutoDisableSteps",(PyCFunction ) &Dtool_OdeBody_get_auto_disable_steps_175, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_get_auto_disable_steps_175_comment},
  { "getAutoDisableTime",(PyCFunction ) &Dtool_OdeBody_get_auto_disable_time_176, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_get_auto_disable_time_176_comment},
  { "getAutoDisableFlag",(PyCFunction ) &Dtool_OdeBody_get_auto_disable_flag_177, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_get_auto_disable_flag_177_comment},
  { "getData",(PyCFunction ) &Dtool_OdeBody_get_data_178, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_get_data_178_comment},
  { "getPosition",(PyCFunction ) &Dtool_OdeBody_get_position_179, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_get_position_179_comment},
  { "getRotation",(PyCFunction ) &Dtool_OdeBody_get_rotation_180, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_get_rotation_180_comment},
  { "getQuaternion",(PyCFunction ) &Dtool_OdeBody_get_quaternion_181, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_get_quaternion_181_comment},
  { "getLinearVel",(PyCFunction ) &Dtool_OdeBody_get_linear_vel_182, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_get_linear_vel_182_comment},
  { "getAngularVel",(PyCFunction ) &Dtool_OdeBody_get_angular_vel_183, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_get_angular_vel_183_comment},
  { "getMass",(PyCFunction ) &Dtool_OdeBody_get_mass_184, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_get_mass_184_comment},
  { "addForce",(PyCFunction ) &Dtool_OdeBody_add_force_185, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_add_force_185_comment},
  { "addTorque",(PyCFunction ) &Dtool_OdeBody_add_torque_186, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_add_torque_186_comment},
  { "addRelForce",(PyCFunction ) &Dtool_OdeBody_add_rel_force_187, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_add_rel_force_187_comment},
  { "addRelTorque",(PyCFunction ) &Dtool_OdeBody_add_rel_torque_188, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_add_rel_torque_188_comment},
  { "addForceAtPos",(PyCFunction ) &Dtool_OdeBody_add_force_at_pos_189, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_add_force_at_pos_189_comment},
  { "addForceAtRelPos",(PyCFunction ) &Dtool_OdeBody_add_force_at_rel_pos_190, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_add_force_at_rel_pos_190_comment},
  { "addRelForceAtPos",(PyCFunction ) &Dtool_OdeBody_add_rel_force_at_pos_191, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_add_rel_force_at_pos_191_comment},
  { "addRelForceAtRelPos",(PyCFunction ) &Dtool_OdeBody_add_rel_force_at_rel_pos_192, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_add_rel_force_at_rel_pos_192_comment},
  { "setForce",(PyCFunction ) &Dtool_OdeBody_set_force_193, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_set_force_193_comment},
  { "setTorque",(PyCFunction ) &Dtool_OdeBody_set_torque_194, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_set_torque_194_comment},
  { "getRelPointPos",(PyCFunction ) &Dtool_OdeBody_get_rel_point_pos_195, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_get_rel_point_pos_195_comment},
  { "getRelPointVel",(PyCFunction ) &Dtool_OdeBody_get_rel_point_vel_196, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_get_rel_point_vel_196_comment},
  { "getPointVel",(PyCFunction ) &Dtool_OdeBody_get_point_vel_197, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_get_point_vel_197_comment},
  { "getPosRelPoint",(PyCFunction ) &Dtool_OdeBody_get_pos_rel_point_198, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_get_pos_rel_point_198_comment},
  { "vectorToWorld",(PyCFunction ) &Dtool_OdeBody_vector_to_world_199, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_vector_to_world_199_comment},
  { "vectorFromWorld",(PyCFunction ) &Dtool_OdeBody_vector_from_world_200, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_vector_from_world_200_comment},
  { "setFiniteRotationMode",(PyCFunction ) &Dtool_OdeBody_set_finite_rotation_mode_201, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_set_finite_rotation_mode_201_comment},
  { "setFiniteRotationAxis",(PyCFunction ) &Dtool_OdeBody_set_finite_rotation_axis_202, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_set_finite_rotation_axis_202_comment},
  { "getFiniteRotationMode",(PyCFunction ) &Dtool_OdeBody_get_finite_rotation_mode_203, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_get_finite_rotation_mode_203_comment},
  { "getFiniteRotationAxis",(PyCFunction ) &Dtool_OdeBody_get_finite_rotation_axis_204, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_get_finite_rotation_axis_204_comment},
  { "getNumJoints",(PyCFunction ) &Dtool_OdeBody_get_num_joints_205, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_get_num_joints_205_comment},
  { "getJoint",(PyCFunction ) &Dtool_OdeBody_get_joint_206, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_get_joint_206_comment},
  { "enable",(PyCFunction ) &Dtool_OdeBody_enable_207, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_enable_207_comment},
  { "disable",(PyCFunction ) &Dtool_OdeBody_disable_208, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_disable_208_comment},
  { "isEnabled",(PyCFunction ) &Dtool_OdeBody_is_enabled_209, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_is_enabled_209_comment},
  { "setGravityMode",(PyCFunction ) &Dtool_OdeBody_set_gravity_mode_210, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_set_gravity_mode_210_comment},
  { "getGravityMode",(PyCFunction ) &Dtool_OdeBody_get_gravity_mode_211, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_get_gravity_mode_211_comment},
  { "write",(PyCFunction ) &Dtool_OdeBody_write_212, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_write_212_comment},
  { "compareTo",(PyCFunction ) &Dtool_OdeBody_compare_to_214, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_compare_to_214_comment},
  { "getClassType",(PyCFunction ) &Dtool_OdeBody_get_class_type_215, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_get_class_type_215_comment},
  { "__nonzero__",(PyCFunction ) &Dtool_OdeBody_operator_typecast_bool_213, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBody_operator_typecast_bool_213_comment},
  { "getJoints",(PyCFunction) &MakeSeq_OdeBody_get_joints, METH_NOARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     OdeBody ...tp_as_number->nb_nonzero = __nonzero__
//////////////////
static int Dtool_OdeBody_operator_typecast_bool_213__nonzero__(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_OdeBody_operator_typecast_bool_213(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    int iresult = PyInt_AsLong(result);
    Py_DECREF(result);
    return iresult;
}

//////////////////
//  A __str__ Function
//     OdeBody
//////////////////
static PyObject *  Dtool_Str_OdeBody(PyObject * self)
{
    OdeBody * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeBody,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_OdeBody(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeBody.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeBody\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedObject._Dtool_ClassInit(NULL);
        Dtool_OdeBody.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedObject.As_PyTypeObject());
        Dtool_OdeBody.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeBody.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeBody.As_PyTypeObject().tp_dict);
        // tp_as_number->nb_nonzero = __nonzero__
        Dtool_OdeBody.As_PyTypeObject().tp_as_number->nb_nonzero = &Dtool_OdeBody_operator_typecast_bool_213__nonzero__;
        // __str__
        Dtool_OdeBody.As_PyTypeObject().tp_str = & Dtool_Str_OdeBody;
        if(PyType_Ready(&Dtool_OdeBody.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeBody)");
             printf(" Error In PyType_ReadyOdeBody");
             return;
        }
        Py_INCREF(&Dtool_OdeBody.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeBody.As_PyTypeObject().tp_dict,"OdeBody",&Dtool_OdeBody.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeBody.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeBody[57],&Dtool_OdeBody.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeBody,OdeBody::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeBody.As_PyTypeObject());
        PyModule_AddObject(module, "OdeBody",(PyObject *)&Dtool_OdeBody.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeSpace | OdeSpace
//********************************************************************
PyMethodDef Dtool_Methods_OdeSpace[]= {
  { "destroy",(PyCFunction ) &Dtool_OdeSpace_destroy_217, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_destroy_217_comment},
  { "isEmpty",(PyCFunction ) &Dtool_OdeSpace_is_empty_218, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_is_empty_218_comment},
  { "setCleanup",(PyCFunction ) &Dtool_OdeSpace_set_cleanup_219, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_set_cleanup_219_comment},
  { "getCleanup",(PyCFunction ) &Dtool_OdeSpace_get_cleanup_220, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_get_cleanup_220_comment},
  { "query",(PyCFunction ) &Dtool_OdeSpace_query_221, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_query_221_comment},
  { "getNumGeoms",(PyCFunction ) &Dtool_OdeSpace_get_num_geoms_222, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_get_num_geoms_222_comment},
  { "getAABB",(PyCFunction ) &Dtool_OdeSpace_get_AABB_223, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_get_AABB_223_comment},
  { "isSpace",(PyCFunction ) &Dtool_OdeSpace_is_space_224, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_is_space_224_comment},
  { "getClass",(PyCFunction ) &Dtool_OdeSpace_get_class_225, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_get_class_225_comment},
  { "setCategoryBits",(PyCFunction ) &Dtool_OdeSpace_set_category_bits_226, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_set_category_bits_226_comment},
  { "setCollideBits",(PyCFunction ) &Dtool_OdeSpace_set_collide_bits_227, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_set_collide_bits_227_comment},
  { "getCategoryBits",(PyCFunction ) &Dtool_OdeSpace_get_category_bits_228, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_get_category_bits_228_comment},
  { "getCollideBits",(PyCFunction ) &Dtool_OdeSpace_get_collide_bits_229, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_get_collide_bits_229_comment},
  { "enable",(PyCFunction ) &Dtool_OdeSpace_enable_230, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_enable_230_comment},
  { "disable",(PyCFunction ) &Dtool_OdeSpace_disable_231, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_disable_231_comment},
  { "isEnabled",(PyCFunction ) &Dtool_OdeSpace_is_enabled_232, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_is_enabled_232_comment},
  { "setAutoCollideWorld",(PyCFunction ) &Dtool_OdeSpace_set_auto_collide_world_233, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_set_auto_collide_world_233_comment},
  { "setAutoCollideJointGroup",(PyCFunction ) &Dtool_OdeSpace_set_auto_collide_joint_group_234, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_set_auto_collide_joint_group_234_comment},
  { "add",(PyCFunction ) &Dtool_OdeSpace_add_235, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_add_235_comment},
  { "remove",(PyCFunction ) &Dtool_OdeSpace_remove_236, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_remove_236_comment},
  { "clean",(PyCFunction ) &Dtool_OdeSpace_clean_237, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_clean_237_comment},
  { "getGeom",(PyCFunction ) &Dtool_OdeSpace_get_geom_238, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_get_geom_238_comment},
  { "getSpace",(PyCFunction ) &Dtool_OdeSpace_get_space_239, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_get_space_239_comment},
  { "write",(PyCFunction ) &Dtool_OdeSpace_write_240, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_write_240_comment},
  { "convertToSimpleSpace",(PyCFunction ) &Dtool_OdeSpace_convert_to_simple_space_242, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_convert_to_simple_space_242_comment},
  { "convertToHashSpace",(PyCFunction ) &Dtool_OdeSpace_convert_to_hash_space_243, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_convert_to_hash_space_243_comment},
  { "convertToQuadTreeSpace",(PyCFunction ) &Dtool_OdeSpace_convert_to_quad_tree_space_244, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_convert_to_quad_tree_space_244_comment},
  { "autoCollide",(PyCFunction ) &Dtool_OdeSpace_auto_collide_245, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_auto_collide_245_comment},
  { "collide",(PyCFunction ) &Dtool_OdeSpace_collide_246, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_collide_246_comment},
  { "getContactData",(PyCFunction ) &Dtool_OdeSpace_get_contact_data_247, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_get_contact_data_247_comment},
  { "getContactId",(PyCFunction ) &Dtool_OdeSpace_get_contact_id_248, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_get_contact_id_248_comment},
  { "setCollideId",(PyCFunction ) &Dtool_OdeSpace_set_collide_id_249, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_set_collide_id_249_comment},
  { "setSurfaceType",(PyCFunction ) &Dtool_OdeSpace_set_surface_type_250, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_set_surface_type_250_comment},
  { "getSurfaceType",(PyCFunction ) &Dtool_OdeSpace_get_surface_type_251, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_get_surface_type_251_comment},
  { "getCollideId",(PyCFunction ) &Dtool_OdeSpace_get_collide_id_252, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_get_collide_id_252_comment},
  { "setCollisionEvent",(PyCFunction ) &Dtool_OdeSpace_set_collision_event_253, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_set_collision_event_253_comment},
  { "getCollisionEvent",(PyCFunction ) &Dtool_OdeSpace_get_collision_event_254, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_get_collision_event_254_comment},
  { "getClassType",(PyCFunction ) &Dtool_OdeSpace_get_class_type_255, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_get_class_type_255_comment},
  { "__nonzero__",(PyCFunction ) &Dtool_OdeSpace_operator_typecast_bool_241, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSpace_operator_typecast_bool_241_comment},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     OdeSpace ...tp_as_number->nb_nonzero = __nonzero__
//////////////////
static int Dtool_OdeSpace_operator_typecast_bool_241__nonzero__(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_OdeSpace_operator_typecast_bool_241(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    int iresult = PyInt_AsLong(result);
    Py_DECREF(result);
    return iresult;
}

//////////////////
//  A __str__ Function
//     OdeSpace
//////////////////
static PyObject *  Dtool_Str_OdeSpace(PyObject * self)
{
    OdeSpace * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeSpace,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_OdeSpace(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeSpace.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeSpace\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedObject._Dtool_ClassInit(NULL);
        Dtool_OdeSpace.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedObject.As_PyTypeObject());
        Dtool_OdeSpace.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeSpace.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeSpace.As_PyTypeObject().tp_dict);
        // tp_as_number->nb_nonzero = __nonzero__
        Dtool_OdeSpace.As_PyTypeObject().tp_as_number->nb_nonzero = &Dtool_OdeSpace_operator_typecast_bool_241__nonzero__;
        // __str__
        Dtool_OdeSpace.As_PyTypeObject().tp_str = & Dtool_Str_OdeSpace;
        if(PyType_Ready(&Dtool_OdeSpace.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeSpace)");
             printf(" Error In PyType_ReadyOdeSpace");
             return;
        }
        Py_INCREF(&Dtool_OdeSpace.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeSpace.As_PyTypeObject().tp_dict,"OdeSpace",&Dtool_OdeSpace.As_PyObject());
        //  Static Method getContactData
        PyDict_SetItemString(Dtool_OdeSpace.As_PyTypeObject().tp_dict,"getContactData",PyCFunction_New(&Dtool_Methods_OdeSpace[29],&Dtool_OdeSpace.As_PyObject()));
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeSpace.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeSpace[37],&Dtool_OdeSpace.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeSpace,OdeSpace::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeSpace.As_PyTypeObject());
        PyModule_AddObject(module, "OdeSpace",(PyObject *)&Dtool_OdeSpace.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeGeom | OdeGeom
//********************************************************************
PyMethodDef Dtool_Methods_OdeGeom[]= {
  { "destroy",(PyCFunction ) &Dtool_OdeGeom_destroy_258, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_destroy_258_comment},
  { "isEmpty",(PyCFunction ) &Dtool_OdeGeom_is_empty_259, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_is_empty_259_comment},
  { "getId",(PyCFunction ) &Dtool_OdeGeom_get_id_260, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_get_id_260_comment},
  { "setBody",(PyCFunction ) &Dtool_OdeGeom_set_body_261, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_set_body_261_comment},
  { "hasBody",(PyCFunction ) &Dtool_OdeGeom_has_body_262, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_has_body_262_comment},
  { "getBody",(PyCFunction ) &Dtool_OdeGeom_get_body_263, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_get_body_263_comment},
  { "setPosition",(PyCFunction ) &Dtool_OdeGeom_set_position_264, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_set_position_264_comment},
  { "setRotation",(PyCFunction ) &Dtool_OdeGeom_set_rotation_265, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_set_rotation_265_comment},
  { "setQuaternion",(PyCFunction ) &Dtool_OdeGeom_set_quaternion_266, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_set_quaternion_266_comment},
  { "getPosition",(PyCFunction ) &Dtool_OdeGeom_get_position_267, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_get_position_267_comment},
  { "getRotation",(PyCFunction ) &Dtool_OdeGeom_get_rotation_268, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_get_rotation_268_comment},
  { "getQuaternion",(PyCFunction ) &Dtool_OdeGeom_get_quaternion_269, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_get_quaternion_269_comment},
  { "getAABB",(PyCFunction ) &Dtool_OdeGeom_get_AABB_270, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_get_AABB_270_comment},
  { "isSpace",(PyCFunction ) &Dtool_OdeGeom_is_space_271, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_is_space_271_comment},
  { "getClass",(PyCFunction ) &Dtool_OdeGeom_get_class_272, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_get_class_272_comment},
  { "setCategoryBits",(PyCFunction ) &Dtool_OdeGeom_set_category_bits_273, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_set_category_bits_273_comment},
  { "setCollideBits",(PyCFunction ) &Dtool_OdeGeom_set_collide_bits_274, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_set_collide_bits_274_comment},
  { "getCategoryBits",(PyCFunction ) &Dtool_OdeGeom_get_category_bits_275, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_get_category_bits_275_comment},
  { "getCollideBits",(PyCFunction ) &Dtool_OdeGeom_get_collide_bits_276, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_get_collide_bits_276_comment},
  { "enable",(PyCFunction ) &Dtool_OdeGeom_enable_277, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_enable_277_comment},
  { "disable",(PyCFunction ) &Dtool_OdeGeom_disable_278, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_disable_278_comment},
  { "isEnabled",(PyCFunction ) &Dtool_OdeGeom_is_enabled_279, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_is_enabled_279_comment},
  { "setOffsetPosition",(PyCFunction ) &Dtool_OdeGeom_set_offset_position_280, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_set_offset_position_280_comment},
  { "setOffsetRotation",(PyCFunction ) &Dtool_OdeGeom_set_offset_rotation_281, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_set_offset_rotation_281_comment},
  { "setOffsetQuaternion",(PyCFunction ) &Dtool_OdeGeom_set_offset_quaternion_282, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_set_offset_quaternion_282_comment},
  { "setOffsetWorldPosition",(PyCFunction ) &Dtool_OdeGeom_set_offset_world_position_283, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_set_offset_world_position_283_comment},
  { "setOffsetWorldRotation",(PyCFunction ) &Dtool_OdeGeom_set_offset_world_rotation_284, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_set_offset_world_rotation_284_comment},
  { "setOffsetWorldQuaternion",(PyCFunction ) &Dtool_OdeGeom_set_offset_world_quaternion_285, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_set_offset_world_quaternion_285_comment},
  { "clearOffset",(PyCFunction ) &Dtool_OdeGeom_clear_offset_286, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_clear_offset_286_comment},
  { "isOffset",(PyCFunction ) &Dtool_OdeGeom_is_offset_287, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_is_offset_287_comment},
  { "getOffsetPosition",(PyCFunction ) &Dtool_OdeGeom_get_offset_position_288, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_get_offset_position_288_comment},
  { "getOffsetRotation",(PyCFunction ) &Dtool_OdeGeom_get_offset_rotation_289, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_get_offset_rotation_289_comment},
  { "getOffsetQuaternion",(PyCFunction ) &Dtool_OdeGeom_get_offset_quaternion_290, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_get_offset_quaternion_290_comment},
  { "getSpace",(PyCFunction ) &Dtool_OdeGeom_get_space_291, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_get_space_291_comment},
  { "write",(PyCFunction ) &Dtool_OdeGeom_write_292, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_write_292_comment},
  { "compareTo",(PyCFunction ) &Dtool_OdeGeom_compare_to_294, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_compare_to_294_comment},
  { "convertToBox",(PyCFunction ) &Dtool_OdeGeom_convert_to_box_295, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_convert_to_box_295_comment},
  { "convertToCappedCylinder",(PyCFunction ) &Dtool_OdeGeom_convert_to_capped_cylinder_296, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_convert_to_capped_cylinder_296_comment},
  { "convertToCylinder",(PyCFunction ) &Dtool_OdeGeom_convert_to_cylinder_297, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_convert_to_cylinder_297_comment},
  { "convertToPlane",(PyCFunction ) &Dtool_OdeGeom_convert_to_plane_298, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_convert_to_plane_298_comment},
  { "convertToRay",(PyCFunction ) &Dtool_OdeGeom_convert_to_ray_299, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_convert_to_ray_299_comment},
  { "convertToSphere",(PyCFunction ) &Dtool_OdeGeom_convert_to_sphere_300, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_convert_to_sphere_300_comment},
  { "convertToTriMesh",(PyCFunction ) &Dtool_OdeGeom_convert_to_tri_mesh_301, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_convert_to_tri_mesh_301_comment},
  { "convertToSimpleSpace",(PyCFunction ) &Dtool_OdeGeom_convert_to_simple_space_302, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_convert_to_simple_space_302_comment},
  { "convertToHashSpace",(PyCFunction ) &Dtool_OdeGeom_convert_to_hash_space_303, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_convert_to_hash_space_303_comment},
  { "convertToQuadTreeSpace",(PyCFunction ) &Dtool_OdeGeom_convert_to_quad_tree_space_304, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_convert_to_quad_tree_space_304_comment},
  { "getClassType",(PyCFunction ) &Dtool_OdeGeom_get_class_type_305, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_get_class_type_305_comment},
  { "__nonzero__",(PyCFunction ) &Dtool_OdeGeom_operator_typecast_bool_293, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeGeom_operator_typecast_bool_293_comment},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     OdeGeom ...tp_as_number->nb_nonzero = __nonzero__
//////////////////
static int Dtool_OdeGeom_operator_typecast_bool_293__nonzero__(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_OdeGeom_operator_typecast_bool_293(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    int iresult = PyInt_AsLong(result);
    Py_DECREF(result);
    return iresult;
}

//////////////////
//  A __str__ Function
//     OdeGeom
//////////////////
static PyObject *  Dtool_Str_OdeGeom(PyObject * self)
{
    OdeGeom * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeGeom,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_OdeGeom(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeGeom.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeGeom\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedObject._Dtool_ClassInit(NULL);
        Dtool_OdeGeom.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedObject.As_PyTypeObject());
        Dtool_OdeGeom.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeGeom.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeGeom.As_PyTypeObject().tp_dict);
        // tp_as_number->nb_nonzero = __nonzero__
        Dtool_OdeGeom.As_PyTypeObject().tp_as_number->nb_nonzero = &Dtool_OdeGeom_operator_typecast_bool_293__nonzero__;
        // __str__
        Dtool_OdeGeom.As_PyTypeObject().tp_str = & Dtool_Str_OdeGeom;
        // Enum  OdeGeom::GeomClass;
        PyDict_SetItemString(Dtool_OdeGeom.As_PyTypeObject().tp_dict,"GCSphere",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_OdeGeom.As_PyTypeObject().tp_dict,"GCBox",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_OdeGeom.As_PyTypeObject().tp_dict,"GCCappedCylinder",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_OdeGeom.As_PyTypeObject().tp_dict,"GCCylinder",PyInt_FromLong(3));
        PyDict_SetItemString(Dtool_OdeGeom.As_PyTypeObject().tp_dict,"GCPlane",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_OdeGeom.As_PyTypeObject().tp_dict,"GCRay",PyInt_FromLong(5));
        PyDict_SetItemString(Dtool_OdeGeom.As_PyTypeObject().tp_dict,"GCTriMesh",PyInt_FromLong(8));
        PyDict_SetItemString(Dtool_OdeGeom.As_PyTypeObject().tp_dict,"GCSimpleSpace",PyInt_FromLong(10));
        PyDict_SetItemString(Dtool_OdeGeom.As_PyTypeObject().tp_dict,"GCHashSpace",PyInt_FromLong(11));
        PyDict_SetItemString(Dtool_OdeGeom.As_PyTypeObject().tp_dict,"GCQuadTreeSpace",PyInt_FromLong(12));
        if(PyType_Ready(&Dtool_OdeGeom.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeGeom)");
             printf(" Error In PyType_ReadyOdeGeom");
             return;
        }
        Py_INCREF(&Dtool_OdeGeom.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeGeom.As_PyTypeObject().tp_dict,"OdeGeom",&Dtool_OdeGeom.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeGeom.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeGeom[46],&Dtool_OdeGeom.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeGeom,OdeGeom::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeGeom.As_PyTypeObject());
        PyModule_AddObject(module, "OdeGeom",(PyObject *)&Dtool_OdeGeom.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeBoxGeom | OdeBoxGeom
//********************************************************************
PyMethodDef Dtool_Methods_OdeBoxGeom[]= {
  { "setLengths",(PyCFunction ) &Dtool_OdeBoxGeom_set_lengths_308, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBoxGeom_set_lengths_308_comment},
  { "getLengths",(PyCFunction ) &Dtool_OdeBoxGeom_get_lengths_309, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBoxGeom_get_lengths_309_comment},
  { "getPointDepth",(PyCFunction ) &Dtool_OdeBoxGeom_get_point_depth_310, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBoxGeom_get_point_depth_310_comment},
  { "getClassType",(PyCFunction ) &Dtool_OdeBoxGeom_get_class_type_311, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeBoxGeom_get_class_type_311_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OdeBoxGeom(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeBoxGeom.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeBoxGeom\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_OdeGeom._Dtool_ClassInit(NULL);
        Dtool_OdeBoxGeom.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_OdeGeom.As_PyTypeObject());
        Dtool_OdeBoxGeom.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeBoxGeom.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeBoxGeom.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OdeBoxGeom.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeBoxGeom)");
             printf(" Error In PyType_ReadyOdeBoxGeom");
             return;
        }
        Py_INCREF(&Dtool_OdeBoxGeom.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeBoxGeom.As_PyTypeObject().tp_dict,"OdeBoxGeom",&Dtool_OdeBoxGeom.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeBoxGeom.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeBoxGeom[3],&Dtool_OdeBoxGeom.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeBoxGeom,OdeBoxGeom::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeBoxGeom.As_PyTypeObject());
        PyModule_AddObject(module, "OdeBoxGeom",(PyObject *)&Dtool_OdeBoxGeom.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeCappedCylinderGeom | OdeCappedCylinderGeom
//********************************************************************
PyMethodDef Dtool_Methods_OdeCappedCylinderGeom[]= {
  { "setParams",(PyCFunction ) &Dtool_OdeCappedCylinderGeom_set_params_314, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeCappedCylinderGeom_set_params_314_comment},
  { "getRadius",(PyCFunction ) &Dtool_OdeCappedCylinderGeom_get_radius_316, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeCappedCylinderGeom_get_radius_316_comment},
  { "getLength",(PyCFunction ) &Dtool_OdeCappedCylinderGeom_get_length_317, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeCappedCylinderGeom_get_length_317_comment},
  { "getPointDepth",(PyCFunction ) &Dtool_OdeCappedCylinderGeom_get_point_depth_318, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeCappedCylinderGeom_get_point_depth_318_comment},
  { "getClassType",(PyCFunction ) &Dtool_OdeCappedCylinderGeom_get_class_type_319, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeCappedCylinderGeom_get_class_type_319_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OdeCappedCylinderGeom(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeCappedCylinderGeom.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeCappedCylinderGeom\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_OdeGeom._Dtool_ClassInit(NULL);
        Dtool_OdeCappedCylinderGeom.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_OdeGeom.As_PyTypeObject());
        Dtool_OdeCappedCylinderGeom.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeCappedCylinderGeom.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeCappedCylinderGeom.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OdeCappedCylinderGeom.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeCappedCylinderGeom)");
             printf(" Error In PyType_ReadyOdeCappedCylinderGeom");
             return;
        }
        Py_INCREF(&Dtool_OdeCappedCylinderGeom.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeCappedCylinderGeom.As_PyTypeObject().tp_dict,"OdeCappedCylinderGeom",&Dtool_OdeCappedCylinderGeom.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeCappedCylinderGeom.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeCappedCylinderGeom[4],&Dtool_OdeCappedCylinderGeom.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeCappedCylinderGeom,OdeCappedCylinderGeom::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeCappedCylinderGeom.As_PyTypeObject());
        PyModule_AddObject(module, "OdeCappedCylinderGeom",(PyObject *)&Dtool_OdeCappedCylinderGeom.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeContactGeom | OdeContactGeom
//********************************************************************
PyMethodDef Dtool_Methods_OdeContactGeom[]= {
  { "getPos",(PyCFunction ) &Dtool_OdeContactGeom_get_pos_322, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeContactGeom_get_pos_322_comment},
  { "getNormal",(PyCFunction ) &Dtool_OdeContactGeom_get_normal_323, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeContactGeom_get_normal_323_comment},
  { "getDepth",(PyCFunction ) &Dtool_OdeContactGeom_get_depth_324, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeContactGeom_get_depth_324_comment},
  { "getG1",(PyCFunction ) &Dtool_OdeContactGeom_get_g1_325, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeContactGeom_get_g1_325_comment},
  { "getG2",(PyCFunction ) &Dtool_OdeContactGeom_get_g2_326, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeContactGeom_get_g2_326_comment},
  { "getSide1",(PyCFunction ) &Dtool_OdeContactGeom_get_side1_327, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeContactGeom_get_side1_327_comment},
  { "getSide2",(PyCFunction ) &Dtool_OdeContactGeom_get_side2_328, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeContactGeom_get_side2_328_comment},
  { "setPos",(PyCFunction ) &Dtool_OdeContactGeom_set_pos_329, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeContactGeom_set_pos_329_comment},
  { "setNormal",(PyCFunction ) &Dtool_OdeContactGeom_set_normal_330, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeContactGeom_set_normal_330_comment},
  { "setDepth",(PyCFunction ) &Dtool_OdeContactGeom_set_depth_331, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeContactGeom_set_depth_331_comment},
  { "setG1",(PyCFunction ) &Dtool_OdeContactGeom_set_g1_332, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeContactGeom_set_g1_332_comment},
  { "setG2",(PyCFunction ) &Dtool_OdeContactGeom_set_g2_333, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeContactGeom_set_g2_333_comment},
  { "getClassType",(PyCFunction ) &Dtool_OdeContactGeom_get_class_type_334, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeContactGeom_get_class_type_334_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OdeContactGeom(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeContactGeom.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeContactGeom\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_OdeContactGeom.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_OdeContactGeom.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeContactGeom.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeContactGeom.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OdeContactGeom.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeContactGeom)");
             printf(" Error In PyType_ReadyOdeContactGeom");
             return;
        }
        Py_INCREF(&Dtool_OdeContactGeom.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeContactGeom.As_PyTypeObject().tp_dict,"OdeContactGeom",&Dtool_OdeContactGeom.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeContactGeom.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeContactGeom[12],&Dtool_OdeContactGeom.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeContactGeom,OdeContactGeom::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeContactGeom.As_PyTypeObject());
        PyModule_AddObject(module, "OdeContactGeom",(PyObject *)&Dtool_OdeContactGeom.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeCollisionEntry | OdeCollisionEntry
//********************************************************************
PyMethodDef Dtool_Methods_OdeCollisionEntry[]= {
  { "getGeom1",(PyCFunction ) &Dtool_OdeCollisionEntry_get_geom1_336, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeCollisionEntry_get_geom1_336_comment},
  { "getGeom2",(PyCFunction ) &Dtool_OdeCollisionEntry_get_geom2_337, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeCollisionEntry_get_geom2_337_comment},
  { "getBody1",(PyCFunction ) &Dtool_OdeCollisionEntry_get_body1_338, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeCollisionEntry_get_body1_338_comment},
  { "getBody2",(PyCFunction ) &Dtool_OdeCollisionEntry_get_body2_339, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeCollisionEntry_get_body2_339_comment},
  { "getNumContacts",(PyCFunction ) &Dtool_OdeCollisionEntry_get_num_contacts_340, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeCollisionEntry_get_num_contacts_340_comment},
  { "getContactPoint",(PyCFunction ) &Dtool_OdeCollisionEntry_get_contact_point_341, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeCollisionEntry_get_contact_point_341_comment},
  { "getContactGeom",(PyCFunction ) &Dtool_OdeCollisionEntry_get_contact_geom_342, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeCollisionEntry_get_contact_geom_342_comment},
  { "__getitem__",(PyCFunction ) &Dtool_OdeCollisionEntry_operator_343, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeCollisionEntry_operator_343_comment},
  { "isEmpty",(PyCFunction ) &Dtool_OdeCollisionEntry_is_empty_345, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeCollisionEntry_is_empty_345_comment},
  { "getClassType",(PyCFunction ) &Dtool_OdeCollisionEntry_get_class_type_346, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeCollisionEntry_get_class_type_346_comment},
  { "__nonzero__",(PyCFunction ) &Dtool_OdeCollisionEntry_operator_typecast_bool_344, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeCollisionEntry_operator_typecast_bool_344_comment},
  { "getContactPoints",(PyCFunction) &MakeSeq_OdeCollisionEntry_get_contact_points, METH_NOARGS, NULL},
  { "getContactGeoms",(PyCFunction) &MakeSeq_OdeCollisionEntry_get_contact_geoms, METH_NOARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     OdeCollisionEntry ...tp_as_number->nb_nonzero = __nonzero__
//////////////////
static int Dtool_OdeCollisionEntry_operator_typecast_bool_344__nonzero__(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_OdeCollisionEntry_operator_typecast_bool_344(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    int iresult = PyInt_AsLong(result);
    Py_DECREF(result);
    return iresult;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     OdeCollisionEntry ...tp_as_mapping->mp_subscript = __getitem__
//////////////////
static PyObject *Dtool_OdeCollisionEntry_operator_343__getitem__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_OdeCollisionEntry_operator_343(self, args, NULL);
    Py_DECREF(args);
    return result;
}

void   Dtool_PyModuleClassInit_OdeCollisionEntry(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeCollisionEntry.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeCollisionEntry\n"
          "// Description : A class used to hold information about a collision\n"
          "//               that has occurred.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_OdeCollisionEntry.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_OdeCollisionEntry.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeCollisionEntry.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeCollisionEntry.As_PyTypeObject().tp_dict);
        // tp_as_number->nb_nonzero = __nonzero__
        Dtool_OdeCollisionEntry.As_PyTypeObject().tp_as_number->nb_nonzero = &Dtool_OdeCollisionEntry_operator_typecast_bool_344__nonzero__;
        // tp_as_mapping->mp_subscript = __getitem__
        Dtool_OdeCollisionEntry.As_PyTypeObject().tp_as_mapping->mp_subscript = &Dtool_OdeCollisionEntry_operator_343__getitem__;
        if(PyType_Ready(&Dtool_OdeCollisionEntry.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeCollisionEntry)");
             printf(" Error In PyType_ReadyOdeCollisionEntry");
             return;
        }
        Py_INCREF(&Dtool_OdeCollisionEntry.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeCollisionEntry.As_PyTypeObject().tp_dict,"OdeCollisionEntry",&Dtool_OdeCollisionEntry.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeCollisionEntry.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeCollisionEntry[9],&Dtool_OdeCollisionEntry.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeCollisionEntry,OdeCollisionEntry::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeCollisionEntry.As_PyTypeObject());
        PyModule_AddObject(module, "OdeCollisionEntry",(PyObject *)&Dtool_OdeCollisionEntry.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeSurfaceParameters | OdeSurfaceParameters
//********************************************************************
PyMethodDef Dtool_Methods_OdeSurfaceParameters[]= {
  { "setMode",(PyCFunction ) &Dtool_OdeSurfaceParameters_set_mode_350, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSurfaceParameters_set_mode_350_comment},
  { "setMu",(PyCFunction ) &Dtool_OdeSurfaceParameters_set_mu_351, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSurfaceParameters_set_mu_351_comment},
  { "setMu2",(PyCFunction ) &Dtool_OdeSurfaceParameters_set_mu2_352, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSurfaceParameters_set_mu2_352_comment},
  { "setBounce",(PyCFunction ) &Dtool_OdeSurfaceParameters_set_bounce_353, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSurfaceParameters_set_bounce_353_comment},
  { "setBounceVel",(PyCFunction ) &Dtool_OdeSurfaceParameters_set_bounce_vel_354, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSurfaceParameters_set_bounce_vel_354_comment},
  { "setSoftErp",(PyCFunction ) &Dtool_OdeSurfaceParameters_set_soft_erp_355, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSurfaceParameters_set_soft_erp_355_comment},
  { "setSoftCfm",(PyCFunction ) &Dtool_OdeSurfaceParameters_set_soft_cfm_356, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSurfaceParameters_set_soft_cfm_356_comment},
  { "setMotion1",(PyCFunction ) &Dtool_OdeSurfaceParameters_set_motion1_357, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSurfaceParameters_set_motion1_357_comment},
  { "setMotion2",(PyCFunction ) &Dtool_OdeSurfaceParameters_set_motion2_358, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSurfaceParameters_set_motion2_358_comment},
  { "setSlip1",(PyCFunction ) &Dtool_OdeSurfaceParameters_set_slip1_359, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSurfaceParameters_set_slip1_359_comment},
  { "setSlip2",(PyCFunction ) &Dtool_OdeSurfaceParameters_set_slip2_360, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSurfaceParameters_set_slip2_360_comment},
  { "getMode",(PyCFunction ) &Dtool_OdeSurfaceParameters_get_mode_361, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSurfaceParameters_get_mode_361_comment},
  { "getMu",(PyCFunction ) &Dtool_OdeSurfaceParameters_get_mu_362, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSurfaceParameters_get_mu_362_comment},
  { "getMu2",(PyCFunction ) &Dtool_OdeSurfaceParameters_get_mu2_363, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSurfaceParameters_get_mu2_363_comment},
  { "getBounce",(PyCFunction ) &Dtool_OdeSurfaceParameters_get_bounce_364, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSurfaceParameters_get_bounce_364_comment},
  { "getBounceVel",(PyCFunction ) &Dtool_OdeSurfaceParameters_get_bounce_vel_365, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSurfaceParameters_get_bounce_vel_365_comment},
  { "getSoftErp",(PyCFunction ) &Dtool_OdeSurfaceParameters_get_soft_erp_366, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSurfaceParameters_get_soft_erp_366_comment},
  { "getSoftCfm",(PyCFunction ) &Dtool_OdeSurfaceParameters_get_soft_cfm_367, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSurfaceParameters_get_soft_cfm_367_comment},
  { "getMotion1",(PyCFunction ) &Dtool_OdeSurfaceParameters_get_motion1_368, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSurfaceParameters_get_motion1_368_comment},
  { "getMotion2",(PyCFunction ) &Dtool_OdeSurfaceParameters_get_motion2_369, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSurfaceParameters_get_motion2_369_comment},
  { "getSlip1",(PyCFunction ) &Dtool_OdeSurfaceParameters_get_slip1_370, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSurfaceParameters_get_slip1_370_comment},
  { "getSlip2",(PyCFunction ) &Dtool_OdeSurfaceParameters_get_slip2_371, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSurfaceParameters_get_slip2_371_comment},
  { "getClassType",(PyCFunction ) &Dtool_OdeSurfaceParameters_get_class_type_372, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSurfaceParameters_get_class_type_372_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OdeSurfaceParameters(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeSurfaceParameters.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeSurfaceParameters\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedObject._Dtool_ClassInit(NULL);
        Dtool_OdeSurfaceParameters.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedObject.As_PyTypeObject());
        Dtool_OdeSurfaceParameters.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeSurfaceParameters.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeSurfaceParameters.As_PyTypeObject().tp_dict);
        // Enum  OdeSurfaceParameters::ModeFlags;
        PyDict_SetItemString(Dtool_OdeSurfaceParameters.As_PyTypeObject().tp_dict,"MFContactMu2",PyInt_FromLong(1));
        PyDict_SetItemString(Dtool_OdeSurfaceParameters.As_PyTypeObject().tp_dict,"MFContactFDir1",PyInt_FromLong(2));
        PyDict_SetItemString(Dtool_OdeSurfaceParameters.As_PyTypeObject().tp_dict,"MFContactBounce",PyInt_FromLong(4));
        PyDict_SetItemString(Dtool_OdeSurfaceParameters.As_PyTypeObject().tp_dict,"MFContactSoftERP",PyInt_FromLong(8));
        PyDict_SetItemString(Dtool_OdeSurfaceParameters.As_PyTypeObject().tp_dict,"MFContactSoftCFM",PyInt_FromLong(16));
        PyDict_SetItemString(Dtool_OdeSurfaceParameters.As_PyTypeObject().tp_dict,"MFContactMotion1",PyInt_FromLong(32));
        PyDict_SetItemString(Dtool_OdeSurfaceParameters.As_PyTypeObject().tp_dict,"MFContactMotion2",PyInt_FromLong(64));
        PyDict_SetItemString(Dtool_OdeSurfaceParameters.As_PyTypeObject().tp_dict,"MFContactSlip1",PyInt_FromLong(128));
        PyDict_SetItemString(Dtool_OdeSurfaceParameters.As_PyTypeObject().tp_dict,"MFContactSlip2",PyInt_FromLong(256));
        PyDict_SetItemString(Dtool_OdeSurfaceParameters.As_PyTypeObject().tp_dict,"MFContactApprox0",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_OdeSurfaceParameters.As_PyTypeObject().tp_dict,"MFContactApprox11",PyInt_FromLong(4096));
        PyDict_SetItemString(Dtool_OdeSurfaceParameters.As_PyTypeObject().tp_dict,"MFContactApprox12",PyInt_FromLong(8192));
        PyDict_SetItemString(Dtool_OdeSurfaceParameters.As_PyTypeObject().tp_dict,"MFContactApprox1",PyInt_FromLong(12288));
        if(PyType_Ready(&Dtool_OdeSurfaceParameters.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeSurfaceParameters)");
             printf(" Error In PyType_ReadyOdeSurfaceParameters");
             return;
        }
        Py_INCREF(&Dtool_OdeSurfaceParameters.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeSurfaceParameters.As_PyTypeObject().tp_dict,"OdeSurfaceParameters",&Dtool_OdeSurfaceParameters.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeSurfaceParameters.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeSurfaceParameters[22],&Dtool_OdeSurfaceParameters.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeSurfaceParameters,OdeSurfaceParameters::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeSurfaceParameters.As_PyTypeObject());
        PyModule_AddObject(module, "OdeSurfaceParameters",(PyObject *)&Dtool_OdeSurfaceParameters.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeContact | OdeContact
//********************************************************************
PyMethodDef Dtool_Methods_OdeContact[]= {
  { "getSurface",(PyCFunction ) &Dtool_OdeContact_get_surface_375, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeContact_get_surface_375_comment},
  { "getGeom",(PyCFunction ) &Dtool_OdeContact_get_geom_376, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeContact_get_geom_376_comment},
  { "getFdir1",(PyCFunction ) &Dtool_OdeContact_get_fdir1_377, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeContact_get_fdir1_377_comment},
  { "setSurface",(PyCFunction ) &Dtool_OdeContact_set_surface_378, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeContact_set_surface_378_comment},
  { "setGeom",(PyCFunction ) &Dtool_OdeContact_set_geom_379, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeContact_set_geom_379_comment},
  { "setFdir1",(PyCFunction ) &Dtool_OdeContact_set_fdir1_380, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeContact_set_fdir1_380_comment},
  { "getClassType",(PyCFunction ) &Dtool_OdeContact_get_class_type_381, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeContact_get_class_type_381_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OdeContact(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeContact.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeContact\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_OdeContact.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_OdeContact.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeContact.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeContact.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OdeContact.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeContact)");
             printf(" Error In PyType_ReadyOdeContact");
             return;
        }
        Py_INCREF(&Dtool_OdeContact.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeContact.As_PyTypeObject().tp_dict,"OdeContact",&Dtool_OdeContact.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeContact.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeContact[6],&Dtool_OdeContact.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeContact,OdeContact::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeContact.As_PyTypeObject());
        PyModule_AddObject(module, "OdeContact",(PyObject *)&Dtool_OdeContact.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeContactJoint | OdeContactJoint
//********************************************************************
PyMethodDef Dtool_Methods_OdeContactJoint[]= {
  { "getClassType",(PyCFunction ) &Dtool_OdeContactJoint_get_class_type_384, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeContactJoint_get_class_type_384_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OdeContactJoint(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeContactJoint.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeContactJoint\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_OdeJoint._Dtool_ClassInit(NULL);
        Dtool_OdeContactJoint.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_OdeJoint.As_PyTypeObject());
        Dtool_OdeContactJoint.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeContactJoint.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeContactJoint.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OdeContactJoint.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeContactJoint)");
             printf(" Error In PyType_ReadyOdeContactJoint");
             return;
        }
        Py_INCREF(&Dtool_OdeContactJoint.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeContactJoint.As_PyTypeObject().tp_dict,"OdeContactJoint",&Dtool_OdeContactJoint.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeContactJoint.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeContactJoint[0],&Dtool_OdeContactJoint.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeContactJoint,OdeContactJoint::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeContactJoint.As_PyTypeObject());
        PyModule_AddObject(module, "OdeContactJoint",(PyObject *)&Dtool_OdeContactJoint.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeCylinderGeom | OdeCylinderGeom
//********************************************************************
PyMethodDef Dtool_Methods_OdeCylinderGeom[]= {
  { "setParams",(PyCFunction ) &Dtool_OdeCylinderGeom_set_params_387, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeCylinderGeom_set_params_387_comment},
  { "getRadius",(PyCFunction ) &Dtool_OdeCylinderGeom_get_radius_389, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeCylinderGeom_get_radius_389_comment},
  { "getLength",(PyCFunction ) &Dtool_OdeCylinderGeom_get_length_390, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeCylinderGeom_get_length_390_comment},
  { "getClassType",(PyCFunction ) &Dtool_OdeCylinderGeom_get_class_type_391, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeCylinderGeom_get_class_type_391_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OdeCylinderGeom(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeCylinderGeom.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeCylinderGeom\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_OdeGeom._Dtool_ClassInit(NULL);
        Dtool_OdeCylinderGeom.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_OdeGeom.As_PyTypeObject());
        Dtool_OdeCylinderGeom.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeCylinderGeom.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeCylinderGeom.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OdeCylinderGeom.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeCylinderGeom)");
             printf(" Error In PyType_ReadyOdeCylinderGeom");
             return;
        }
        Py_INCREF(&Dtool_OdeCylinderGeom.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeCylinderGeom.As_PyTypeObject().tp_dict,"OdeCylinderGeom",&Dtool_OdeCylinderGeom.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeCylinderGeom.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeCylinderGeom[3],&Dtool_OdeCylinderGeom.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeCylinderGeom,OdeCylinderGeom::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeCylinderGeom.As_PyTypeObject());
        PyModule_AddObject(module, "OdeCylinderGeom",(PyObject *)&Dtool_OdeCylinderGeom.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeFixedJoint | OdeFixedJoint
//********************************************************************
PyMethodDef Dtool_Methods_OdeFixedJoint[]= {
  { "set",(PyCFunction ) &Dtool_OdeFixedJoint_set_394, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeFixedJoint_set_394_comment},
  { "getClassType",(PyCFunction ) &Dtool_OdeFixedJoint_get_class_type_395, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeFixedJoint_get_class_type_395_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OdeFixedJoint(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeFixedJoint.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeFixedJoint\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_OdeJoint._Dtool_ClassInit(NULL);
        Dtool_OdeFixedJoint.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_OdeJoint.As_PyTypeObject());
        Dtool_OdeFixedJoint.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeFixedJoint.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeFixedJoint.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OdeFixedJoint.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeFixedJoint)");
             printf(" Error In PyType_ReadyOdeFixedJoint");
             return;
        }
        Py_INCREF(&Dtool_OdeFixedJoint.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeFixedJoint.As_PyTypeObject().tp_dict,"OdeFixedJoint",&Dtool_OdeFixedJoint.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeFixedJoint.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeFixedJoint[1],&Dtool_OdeFixedJoint.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeFixedJoint,OdeFixedJoint::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeFixedJoint.As_PyTypeObject());
        PyModule_AddObject(module, "OdeFixedJoint",(PyObject *)&Dtool_OdeFixedJoint.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeHashSpace | OdeHashSpace
//********************************************************************
PyMethodDef Dtool_Methods_OdeHashSpace[]= {
  { "setLevels",(PyCFunction ) &Dtool_OdeHashSpace_set_levels_398, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHashSpace_set_levels_398_comment},
  { "getMinLevel",(PyCFunction ) &Dtool_OdeHashSpace_get_min_level_399, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHashSpace_get_min_level_399_comment},
  { "getMaxLevel",(PyCFunction ) &Dtool_OdeHashSpace_get_max_level_400, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHashSpace_get_max_level_400_comment},
  { "getClassType",(PyCFunction ) &Dtool_OdeHashSpace_get_class_type_401, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHashSpace_get_class_type_401_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OdeHashSpace(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeHashSpace.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeHashSpace\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////c";
#endif
        // Dependent Objects   
        Dtool_OdeSpace._Dtool_ClassInit(NULL);
        Dtool_OdeHashSpace.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_OdeSpace.As_PyTypeObject());
        Dtool_OdeHashSpace.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeHashSpace.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeHashSpace.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OdeHashSpace.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeHashSpace)");
             printf(" Error In PyType_ReadyOdeHashSpace");
             return;
        }
        Py_INCREF(&Dtool_OdeHashSpace.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeHashSpace.As_PyTypeObject().tp_dict,"OdeHashSpace",&Dtool_OdeHashSpace.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeHashSpace.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeHashSpace[3],&Dtool_OdeHashSpace.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeHashSpace,OdeHashSpace::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeHashSpace.As_PyTypeObject());
        PyModule_AddObject(module, "OdeHashSpace",(PyObject *)&Dtool_OdeHashSpace.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeHinge2Joint | OdeHinge2Joint
//********************************************************************
PyMethodDef Dtool_Methods_OdeHinge2Joint[]= {
  { "setAnchor",(PyCFunction ) &Dtool_OdeHinge2Joint_set_anchor_404, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_set_anchor_404_comment},
  { "setAxis1",(PyCFunction ) &Dtool_OdeHinge2Joint_set_axis1_405, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_set_axis1_405_comment},
  { "setAxis2",(PyCFunction ) &Dtool_OdeHinge2Joint_set_axis2_406, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_set_axis2_406_comment},
  { "addTorques",(PyCFunction ) &Dtool_OdeHinge2Joint_add_torques_407, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_add_torques_407_comment},
  { "getAnchor",(PyCFunction ) &Dtool_OdeHinge2Joint_get_anchor_408, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_get_anchor_408_comment},
  { "getAnchor2",(PyCFunction ) &Dtool_OdeHinge2Joint_get_anchor2_409, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_get_anchor2_409_comment},
  { "getAxis1",(PyCFunction ) &Dtool_OdeHinge2Joint_get_axis1_410, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_get_axis1_410_comment},
  { "getAxis2",(PyCFunction ) &Dtool_OdeHinge2Joint_get_axis2_411, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_get_axis2_411_comment},
  { "getAngle1",(PyCFunction ) &Dtool_OdeHinge2Joint_get_angle1_412, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_get_angle1_412_comment},
  { "getAngle1Rate",(PyCFunction ) &Dtool_OdeHinge2Joint_get_angle1_rate_413, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_get_angle1_rate_413_comment},
  { "getAngle2Rate",(PyCFunction ) &Dtool_OdeHinge2Joint_get_angle2_rate_414, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_get_angle2_rate_414_comment},
  { "setParamLoStop",(PyCFunction ) &Dtool_OdeHinge2Joint_set_param_lo_stop_415, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_set_param_lo_stop_415_comment},
  { "setParamHiStop",(PyCFunction ) &Dtool_OdeHinge2Joint_set_param_hi_stop_416, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_set_param_hi_stop_416_comment},
  { "setParamVel",(PyCFunction ) &Dtool_OdeHinge2Joint_set_param_vel_417, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_set_param_vel_417_comment},
  { "setParamFMax",(PyCFunction ) &Dtool_OdeHinge2Joint_set_param_f_max_418, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_set_param_f_max_418_comment},
  { "setParamFudgeFactor",(PyCFunction ) &Dtool_OdeHinge2Joint_set_param_fudge_factor_419, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_set_param_fudge_factor_419_comment},
  { "setParamBounce",(PyCFunction ) &Dtool_OdeHinge2Joint_set_param_bounce_420, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_set_param_bounce_420_comment},
  { "setParamCFM",(PyCFunction ) &Dtool_OdeHinge2Joint_set_param_CFM_421, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_set_param_CFM_421_comment},
  { "setParamStopERP",(PyCFunction ) &Dtool_OdeHinge2Joint_set_param_stop_ERP_422, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_set_param_stop_ERP_422_comment},
  { "setParamStopCFM",(PyCFunction ) &Dtool_OdeHinge2Joint_set_param_stop_CFM_423, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_set_param_stop_CFM_423_comment},
  { "setParamSuspensionERP",(PyCFunction ) &Dtool_OdeHinge2Joint_set_param_suspension_ERP_424, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_set_param_suspension_ERP_424_comment},
  { "setParamSuspensionCFM",(PyCFunction ) &Dtool_OdeHinge2Joint_set_param_suspension_CFM_425, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_set_param_suspension_CFM_425_comment},
  { "getParamLoStop",(PyCFunction ) &Dtool_OdeHinge2Joint_get_param_lo_stop_426, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_get_param_lo_stop_426_comment},
  { "getParamHiStop",(PyCFunction ) &Dtool_OdeHinge2Joint_get_param_hi_stop_427, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_get_param_hi_stop_427_comment},
  { "getParamVel",(PyCFunction ) &Dtool_OdeHinge2Joint_get_param_vel_428, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_get_param_vel_428_comment},
  { "getParamFMax",(PyCFunction ) &Dtool_OdeHinge2Joint_get_param_f_max_429, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_get_param_f_max_429_comment},
  { "getParamFudgeFactor",(PyCFunction ) &Dtool_OdeHinge2Joint_get_param_fudge_factor_430, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_get_param_fudge_factor_430_comment},
  { "getParamBounce",(PyCFunction ) &Dtool_OdeHinge2Joint_get_param_bounce_431, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_get_param_bounce_431_comment},
  { "getParamCFM",(PyCFunction ) &Dtool_OdeHinge2Joint_get_param_CFM_432, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_get_param_CFM_432_comment},
  { "getParamStopERP",(PyCFunction ) &Dtool_OdeHinge2Joint_get_param_stop_ERP_433, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_get_param_stop_ERP_433_comment},
  { "getParamStopCFM",(PyCFunction ) &Dtool_OdeHinge2Joint_get_param_stop_CFM_434, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_get_param_stop_CFM_434_comment},
  { "getParamSuspensionERP",(PyCFunction ) &Dtool_OdeHinge2Joint_get_param_suspension_ERP_435, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_get_param_suspension_ERP_435_comment},
  { "getParamSuspensionCFM",(PyCFunction ) &Dtool_OdeHinge2Joint_get_param_suspension_CFM_436, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_get_param_suspension_CFM_436_comment},
  { "getClassType",(PyCFunction ) &Dtool_OdeHinge2Joint_get_class_type_437, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHinge2Joint_get_class_type_437_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OdeHinge2Joint(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeHinge2Joint.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeHinge2Joint\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_OdeJoint._Dtool_ClassInit(NULL);
        Dtool_OdeHinge2Joint.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_OdeJoint.As_PyTypeObject());
        Dtool_OdeHinge2Joint.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeHinge2Joint.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeHinge2Joint.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OdeHinge2Joint.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeHinge2Joint)");
             printf(" Error In PyType_ReadyOdeHinge2Joint");
             return;
        }
        Py_INCREF(&Dtool_OdeHinge2Joint.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeHinge2Joint.As_PyTypeObject().tp_dict,"OdeHinge2Joint",&Dtool_OdeHinge2Joint.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeHinge2Joint.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeHinge2Joint[33],&Dtool_OdeHinge2Joint.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeHinge2Joint,OdeHinge2Joint::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeHinge2Joint.As_PyTypeObject());
        PyModule_AddObject(module, "OdeHinge2Joint",(PyObject *)&Dtool_OdeHinge2Joint.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeHingeJoint | OdeHingeJoint
//********************************************************************
PyMethodDef Dtool_Methods_OdeHingeJoint[]= {
  { "setAnchor",(PyCFunction ) &Dtool_OdeHingeJoint_set_anchor_440, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHingeJoint_set_anchor_440_comment},
  { "setAnchorDelta",(PyCFunction ) &Dtool_OdeHingeJoint_set_anchor_delta_441, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHingeJoint_set_anchor_delta_441_comment},
  { "setAxis",(PyCFunction ) &Dtool_OdeHingeJoint_set_axis_442, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHingeJoint_set_axis_442_comment},
  { "addTorque",(PyCFunction ) &Dtool_OdeHingeJoint_add_torque_443, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHingeJoint_add_torque_443_comment},
  { "getAnchor",(PyCFunction ) &Dtool_OdeHingeJoint_get_anchor_444, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHingeJoint_get_anchor_444_comment},
  { "getAnchor2",(PyCFunction ) &Dtool_OdeHingeJoint_get_anchor2_445, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHingeJoint_get_anchor2_445_comment},
  { "getAxis",(PyCFunction ) &Dtool_OdeHingeJoint_get_axis_446, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHingeJoint_get_axis_446_comment},
  { "getAngle",(PyCFunction ) &Dtool_OdeHingeJoint_get_angle_447, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHingeJoint_get_angle_447_comment},
  { "getAngleRate",(PyCFunction ) &Dtool_OdeHingeJoint_get_angle_rate_448, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHingeJoint_get_angle_rate_448_comment},
  { "setParamLoStop",(PyCFunction ) &Dtool_OdeHingeJoint_set_param_lo_stop_449, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHingeJoint_set_param_lo_stop_449_comment},
  { "setParamHiStop",(PyCFunction ) &Dtool_OdeHingeJoint_set_param_hi_stop_450, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHingeJoint_set_param_hi_stop_450_comment},
  { "setParamVel",(PyCFunction ) &Dtool_OdeHingeJoint_set_param_vel_451, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHingeJoint_set_param_vel_451_comment},
  { "setParamFMax",(PyCFunction ) &Dtool_OdeHingeJoint_set_param_f_max_452, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHingeJoint_set_param_f_max_452_comment},
  { "setParamFudgeFactor",(PyCFunction ) &Dtool_OdeHingeJoint_set_param_fudge_factor_453, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHingeJoint_set_param_fudge_factor_453_comment},
  { "setParamBounce",(PyCFunction ) &Dtool_OdeHingeJoint_set_param_bounce_454, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHingeJoint_set_param_bounce_454_comment},
  { "setParamCFM",(PyCFunction ) &Dtool_OdeHingeJoint_set_param_CFM_455, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHingeJoint_set_param_CFM_455_comment},
  { "setParamStopERP",(PyCFunction ) &Dtool_OdeHingeJoint_set_param_stop_ERP_456, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHingeJoint_set_param_stop_ERP_456_comment},
  { "setParamStopCFM",(PyCFunction ) &Dtool_OdeHingeJoint_set_param_stop_CFM_457, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHingeJoint_set_param_stop_CFM_457_comment},
  { "getParamLoStop",(PyCFunction ) &Dtool_OdeHingeJoint_get_param_lo_stop_458, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHingeJoint_get_param_lo_stop_458_comment},
  { "getParamHiStop",(PyCFunction ) &Dtool_OdeHingeJoint_get_param_hi_stop_459, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHingeJoint_get_param_hi_stop_459_comment},
  { "getParamVel",(PyCFunction ) &Dtool_OdeHingeJoint_get_param_vel_460, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHingeJoint_get_param_vel_460_comment},
  { "getParamFMax",(PyCFunction ) &Dtool_OdeHingeJoint_get_param_f_max_461, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHingeJoint_get_param_f_max_461_comment},
  { "getParamFudgeFactor",(PyCFunction ) &Dtool_OdeHingeJoint_get_param_fudge_factor_462, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHingeJoint_get_param_fudge_factor_462_comment},
  { "getParamBounce",(PyCFunction ) &Dtool_OdeHingeJoint_get_param_bounce_463, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHingeJoint_get_param_bounce_463_comment},
  { "getParamCFM",(PyCFunction ) &Dtool_OdeHingeJoint_get_param_CFM_464, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHingeJoint_get_param_CFM_464_comment},
  { "getParamStopERP",(PyCFunction ) &Dtool_OdeHingeJoint_get_param_stop_ERP_465, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHingeJoint_get_param_stop_ERP_465_comment},
  { "getParamStopCFM",(PyCFunction ) &Dtool_OdeHingeJoint_get_param_stop_CFM_466, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHingeJoint_get_param_stop_CFM_466_comment},
  { "getClassType",(PyCFunction ) &Dtool_OdeHingeJoint_get_class_type_467, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeHingeJoint_get_class_type_467_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OdeHingeJoint(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeHingeJoint.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeHingeJoint\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_OdeJoint._Dtool_ClassInit(NULL);
        Dtool_OdeHingeJoint.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_OdeJoint.As_PyTypeObject());
        Dtool_OdeHingeJoint.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeHingeJoint.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeHingeJoint.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OdeHingeJoint.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeHingeJoint)");
             printf(" Error In PyType_ReadyOdeHingeJoint");
             return;
        }
        Py_INCREF(&Dtool_OdeHingeJoint.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeHingeJoint.As_PyTypeObject().tp_dict,"OdeHingeJoint",&Dtool_OdeHingeJoint.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeHingeJoint.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeHingeJoint[27],&Dtool_OdeHingeJoint.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeHingeJoint,OdeHingeJoint::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeHingeJoint.As_PyTypeObject());
        PyModule_AddObject(module, "OdeHingeJoint",(PyObject *)&Dtool_OdeHingeJoint.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeJointCollection | OdeJointCollection
//********************************************************************
PyMethodDef Dtool_Methods_OdeJointCollection[]= {
  { "assign",(PyCFunction ) &Dtool_OdeJointCollection_operator_470, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJointCollection_operator_470_comment},
  { "addJoint",(PyCFunction ) &Dtool_OdeJointCollection_add_joint_472, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJointCollection_add_joint_472_comment},
  { "removeJoint",(PyCFunction ) &Dtool_OdeJointCollection_remove_joint_473, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJointCollection_remove_joint_473_comment},
  { "addJointsFrom",(PyCFunction ) &Dtool_OdeJointCollection_add_joints_from_474, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJointCollection_add_joints_from_474_comment},
  { "removeJointsFrom",(PyCFunction ) &Dtool_OdeJointCollection_remove_joints_from_475, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJointCollection_remove_joints_from_475_comment},
  { "removeDuplicateJoints",(PyCFunction ) &Dtool_OdeJointCollection_remove_duplicate_joints_476, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJointCollection_remove_duplicate_joints_476_comment},
  { "hasJoint",(PyCFunction ) &Dtool_OdeJointCollection_has_joint_477, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJointCollection_has_joint_477_comment},
  { "clear",(PyCFunction ) &Dtool_OdeJointCollection_clear_478, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJointCollection_clear_478_comment},
  { "isEmpty",(PyCFunction ) &Dtool_OdeJointCollection_is_empty_479, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJointCollection_is_empty_479_comment},
  { "getNumJoints",(PyCFunction ) &Dtool_OdeJointCollection_get_num_joints_480, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJointCollection_get_num_joints_480_comment},
  { "getJoint",(PyCFunction ) &Dtool_OdeJointCollection_get_joint_481, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJointCollection_get_joint_481_comment},
  { "__getitem__",(PyCFunction ) &Dtool_OdeJointCollection_operator_482, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJointCollection_operator_482_comment},
  { "size",(PyCFunction ) &Dtool_OdeJointCollection_size_483, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJointCollection_size_483_comment},
  { "__iadd__",(PyCFunction ) &Dtool_OdeJointCollection_operator_484, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJointCollection_operator_484_comment},
  { "__add__",(PyCFunction ) &Dtool_OdeJointCollection_operator_485, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeJointCollection_operator_485_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { "getJoints",(PyCFunction) &MakeSeq_OdeJointCollection_get_joints, METH_NOARGS, NULL},
  { NULL, NULL }
};

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     OdeJointCollection ...tp_as_sequence->sq_length = size
//////////////////
static Py_ssize_t Dtool_OdeJointCollection_size_483size(PyObject *self)
{
    PyObject *args = Py_BuildValue("()");
    PyObject *result = Dtool_OdeJointCollection_size_483(self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
      return -1;
    }
    Py_ssize_t num = PyInt_AsSsize_t(result);
    Py_DECREF(result);
    return num;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     OdeJointCollection ...tp_as_number->nb_inplace_add = __iadd__
//////////////////
static PyObject *Dtool_OdeJointCollection_operator_484__iadd__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_OdeJointCollection_operator_484(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     OdeJointCollection ...tp_as_number->nb_add = __add__
//////////////////
static PyObject *Dtool_OdeJointCollection_operator_485__add__(PyObject *self, PyObject *one)
{
    PyObject *args = Py_BuildValue("(O)", one);
    PyObject *result = Dtool_OdeJointCollection_operator_485(self, args, NULL);
    Py_DECREF(args);
    return result;
}

//////////////////
//  A wrapper function to satisfy Python's internal calling conventions. 
//     OdeJointCollection ...tp_as_sequence->sq_item = __getitem__
//////////////////
static PyObject * Dtool_OdeJointCollection_operator_482__getitem__( PyObject * self, Py_ssize_t index)
{
    PyObject *args = Py_BuildValue("(i)", index);
    PyObject *result = Dtool_OdeJointCollection_operator_482(self, args, NULL);
    Py_DECREF(args);
    return result;
}

void   Dtool_PyModuleClassInit_OdeJointCollection(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeJointCollection.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeJointCollection\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_OdeJointCollection.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_OdeJointCollection.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeJointCollection.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeJointCollection.As_PyTypeObject().tp_dict);
        // tp_as_sequence->sq_length = size
        Dtool_OdeJointCollection.As_PyTypeObject().tp_as_sequence->sq_length = &Dtool_OdeJointCollection_size_483size;
        // tp_as_number->nb_inplace_add = __iadd__
        Dtool_OdeJointCollection.As_PyTypeObject().tp_as_number->nb_inplace_add = &Dtool_OdeJointCollection_operator_484__iadd__;
        // tp_as_number->nb_add = __add__
        Dtool_OdeJointCollection.As_PyTypeObject().tp_as_number->nb_add = &Dtool_OdeJointCollection_operator_485__add__;
        // tp_as_sequence->sq_item = __getitem__
        Dtool_OdeJointCollection.As_PyTypeObject().tp_as_sequence->sq_item = &Dtool_OdeJointCollection_operator_482__getitem__;
        if(PyType_Ready(&Dtool_OdeJointCollection.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeJointCollection)");
             printf(" Error In PyType_ReadyOdeJointCollection");
             return;
        }
        Py_INCREF(&Dtool_OdeJointCollection.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeJointCollection.As_PyTypeObject().tp_dict,"OdeJointCollection",&Dtool_OdeJointCollection.As_PyObject());
        RegisterRuntimeClass(&Dtool_OdeJointCollection,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeJointCollection.As_PyTypeObject());
        PyModule_AddObject(module, "OdeJointCollection",(PyObject *)&Dtool_OdeJointCollection.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeLMotorJoint | OdeLMotorJoint
//********************************************************************
PyMethodDef Dtool_Methods_OdeLMotorJoint[]= {
  { "setNumAxes",(PyCFunction ) &Dtool_OdeLMotorJoint_set_num_axes_488, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeLMotorJoint_set_num_axes_488_comment},
  { "setAxis",(PyCFunction ) &Dtool_OdeLMotorJoint_set_axis_489, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeLMotorJoint_set_axis_489_comment},
  { "setParam",(PyCFunction ) &Dtool_OdeLMotorJoint_set_param_490, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeLMotorJoint_set_param_490_comment},
  { "getNumAxes",(PyCFunction ) &Dtool_OdeLMotorJoint_get_num_axes_491, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeLMotorJoint_get_num_axes_491_comment},
  { "getAxis",(PyCFunction ) &Dtool_OdeLMotorJoint_get_axis_492, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeLMotorJoint_get_axis_492_comment},
  { "getParam",(PyCFunction ) &Dtool_OdeLMotorJoint_get_param_493, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeLMotorJoint_get_param_493_comment},
  { "getClassType",(PyCFunction ) &Dtool_OdeLMotorJoint_get_class_type_494, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeLMotorJoint_get_class_type_494_comment},
  { "getAxes",(PyCFunction) &MakeSeq_OdeLMotorJoint_get_axes, METH_NOARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OdeLMotorJoint(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeLMotorJoint.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeLMotorJoint\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_OdeJoint._Dtool_ClassInit(NULL);
        Dtool_OdeLMotorJoint.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_OdeJoint.As_PyTypeObject());
        Dtool_OdeLMotorJoint.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeLMotorJoint.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeLMotorJoint.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OdeLMotorJoint.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeLMotorJoint)");
             printf(" Error In PyType_ReadyOdeLMotorJoint");
             return;
        }
        Py_INCREF(&Dtool_OdeLMotorJoint.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeLMotorJoint.As_PyTypeObject().tp_dict,"OdeLMotorJoint",&Dtool_OdeLMotorJoint.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeLMotorJoint.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeLMotorJoint[6],&Dtool_OdeLMotorJoint.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeLMotorJoint,OdeLMotorJoint::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeLMotorJoint.As_PyTypeObject());
        PyModule_AddObject(module, "OdeLMotorJoint",(PyObject *)&Dtool_OdeLMotorJoint.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeNullJoint | OdeNullJoint
//********************************************************************
PyMethodDef Dtool_Methods_OdeNullJoint[]= {
  { "getClassType",(PyCFunction ) &Dtool_OdeNullJoint_get_class_type_497, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeNullJoint_get_class_type_497_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OdeNullJoint(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeNullJoint.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeNullJoint\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_OdeJoint._Dtool_ClassInit(NULL);
        Dtool_OdeNullJoint.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_OdeJoint.As_PyTypeObject());
        Dtool_OdeNullJoint.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeNullJoint.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeNullJoint.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OdeNullJoint.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeNullJoint)");
             printf(" Error In PyType_ReadyOdeNullJoint");
             return;
        }
        Py_INCREF(&Dtool_OdeNullJoint.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeNullJoint.As_PyTypeObject().tp_dict,"OdeNullJoint",&Dtool_OdeNullJoint.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeNullJoint.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeNullJoint[0],&Dtool_OdeNullJoint.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeNullJoint,OdeNullJoint::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeNullJoint.As_PyTypeObject());
        PyModule_AddObject(module, "OdeNullJoint",(PyObject *)&Dtool_OdeNullJoint.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdePlane2dJoint | OdePlane2dJoint
//********************************************************************
PyMethodDef Dtool_Methods_OdePlane2dJoint[]= {
  { "setXParam",(PyCFunction ) &Dtool_OdePlane2dJoint_set_x_param_500, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdePlane2dJoint_set_x_param_500_comment},
  { "setYParam",(PyCFunction ) &Dtool_OdePlane2dJoint_set_y_param_501, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdePlane2dJoint_set_y_param_501_comment},
  { "setAngleParam",(PyCFunction ) &Dtool_OdePlane2dJoint_set_angle_param_502, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdePlane2dJoint_set_angle_param_502_comment},
  { "getClassType",(PyCFunction ) &Dtool_OdePlane2dJoint_get_class_type_503, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdePlane2dJoint_get_class_type_503_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OdePlane2dJoint(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdePlane2dJoint.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdePlane2dJoint\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_OdeJoint._Dtool_ClassInit(NULL);
        Dtool_OdePlane2dJoint.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_OdeJoint.As_PyTypeObject());
        Dtool_OdePlane2dJoint.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdePlane2dJoint.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdePlane2dJoint.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OdePlane2dJoint.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdePlane2dJoint)");
             printf(" Error In PyType_ReadyOdePlane2dJoint");
             return;
        }
        Py_INCREF(&Dtool_OdePlane2dJoint.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdePlane2dJoint.As_PyTypeObject().tp_dict,"OdePlane2dJoint",&Dtool_OdePlane2dJoint.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdePlane2dJoint.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdePlane2dJoint[3],&Dtool_OdePlane2dJoint.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdePlane2dJoint,OdePlane2dJoint::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdePlane2dJoint.As_PyTypeObject());
        PyModule_AddObject(module, "OdePlane2dJoint",(PyObject *)&Dtool_OdePlane2dJoint.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdePlaneGeom | OdePlaneGeom
//********************************************************************
PyMethodDef Dtool_Methods_OdePlaneGeom[]= {
  { "setParams",(PyCFunction ) &Dtool_OdePlaneGeom_set_params_506, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdePlaneGeom_set_params_506_comment},
  { "getParams",(PyCFunction ) &Dtool_OdePlaneGeom_get_params_507, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdePlaneGeom_get_params_507_comment},
  { "getPointDepth",(PyCFunction ) &Dtool_OdePlaneGeom_get_point_depth_508, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdePlaneGeom_get_point_depth_508_comment},
  { "getClassType",(PyCFunction ) &Dtool_OdePlaneGeom_get_class_type_509, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdePlaneGeom_get_class_type_509_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OdePlaneGeom(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdePlaneGeom.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdePlaneGeom\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_OdeGeom._Dtool_ClassInit(NULL);
        Dtool_OdePlaneGeom.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_OdeGeom.As_PyTypeObject());
        Dtool_OdePlaneGeom.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdePlaneGeom.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdePlaneGeom.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OdePlaneGeom.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdePlaneGeom)");
             printf(" Error In PyType_ReadyOdePlaneGeom");
             return;
        }
        Py_INCREF(&Dtool_OdePlaneGeom.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdePlaneGeom.As_PyTypeObject().tp_dict,"OdePlaneGeom",&Dtool_OdePlaneGeom.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdePlaneGeom.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdePlaneGeom[3],&Dtool_OdePlaneGeom.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdePlaneGeom,OdePlaneGeom::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdePlaneGeom.As_PyTypeObject());
        PyModule_AddObject(module, "OdePlaneGeom",(PyObject *)&Dtool_OdePlaneGeom.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeQuadTreeSpace | OdeQuadTreeSpace
//********************************************************************
PyMethodDef Dtool_Methods_OdeQuadTreeSpace[]= {
  { "getClassType",(PyCFunction ) &Dtool_OdeQuadTreeSpace_get_class_type_512, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeQuadTreeSpace_get_class_type_512_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OdeQuadTreeSpace(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeQuadTreeSpace.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeQuadTreeSpace\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////c";
#endif
        // Dependent Objects   
        Dtool_OdeSpace._Dtool_ClassInit(NULL);
        Dtool_OdeQuadTreeSpace.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_OdeSpace.As_PyTypeObject());
        Dtool_OdeQuadTreeSpace.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeQuadTreeSpace.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeQuadTreeSpace.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OdeQuadTreeSpace.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeQuadTreeSpace)");
             printf(" Error In PyType_ReadyOdeQuadTreeSpace");
             return;
        }
        Py_INCREF(&Dtool_OdeQuadTreeSpace.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeQuadTreeSpace.As_PyTypeObject().tp_dict,"OdeQuadTreeSpace",&Dtool_OdeQuadTreeSpace.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeQuadTreeSpace.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeQuadTreeSpace[0],&Dtool_OdeQuadTreeSpace.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeQuadTreeSpace,OdeQuadTreeSpace::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeQuadTreeSpace.As_PyTypeObject());
        PyModule_AddObject(module, "OdeQuadTreeSpace",(PyObject *)&Dtool_OdeQuadTreeSpace.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeRayGeom | OdeRayGeom
//********************************************************************
PyMethodDef Dtool_Methods_OdeRayGeom[]= {
  { "setLength",(PyCFunction ) &Dtool_OdeRayGeom_set_length_515, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeRayGeom_set_length_515_comment},
  { "getLength",(PyCFunction ) &Dtool_OdeRayGeom_get_length_516, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeRayGeom_get_length_516_comment},
  { "set",(PyCFunction ) &Dtool_OdeRayGeom_set_517, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeRayGeom_set_517_comment},
  { "get",(PyCFunction ) &Dtool_OdeRayGeom_get_518, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeRayGeom_get_518_comment},
  { "getStart",(PyCFunction ) &Dtool_OdeRayGeom_get_start_519, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeRayGeom_get_start_519_comment},
  { "getDirection",(PyCFunction ) &Dtool_OdeRayGeom_get_direction_520, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeRayGeom_get_direction_520_comment},
  { "setParams",(PyCFunction ) &Dtool_OdeRayGeom_set_params_521, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeRayGeom_set_params_521_comment},
  { "getFirstContact",(PyCFunction ) &Dtool_OdeRayGeom_get_first_contact_523, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeRayGeom_get_first_contact_523_comment},
  { "getBackfaceCull",(PyCFunction ) &Dtool_OdeRayGeom_get_backface_cull_524, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeRayGeom_get_backface_cull_524_comment},
  { "setClosestHit",(PyCFunction ) &Dtool_OdeRayGeom_set_closest_hit_525, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeRayGeom_set_closest_hit_525_comment},
  { "getClosestHit",(PyCFunction ) &Dtool_OdeRayGeom_get_closest_hit_526, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeRayGeom_get_closest_hit_526_comment},
  { "getClassType",(PyCFunction ) &Dtool_OdeRayGeom_get_class_type_527, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeRayGeom_get_class_type_527_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OdeRayGeom(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeRayGeom.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeRayGeom\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_OdeGeom._Dtool_ClassInit(NULL);
        Dtool_OdeRayGeom.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_OdeGeom.As_PyTypeObject());
        Dtool_OdeRayGeom.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeRayGeom.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeRayGeom.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OdeRayGeom.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeRayGeom)");
             printf(" Error In PyType_ReadyOdeRayGeom");
             return;
        }
        Py_INCREF(&Dtool_OdeRayGeom.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeRayGeom.As_PyTypeObject().tp_dict,"OdeRayGeom",&Dtool_OdeRayGeom.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeRayGeom.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeRayGeom[11],&Dtool_OdeRayGeom.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeRayGeom,OdeRayGeom::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeRayGeom.As_PyTypeObject());
        PyModule_AddObject(module, "OdeRayGeom",(PyObject *)&Dtool_OdeRayGeom.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeSimpleSpace | OdeSimpleSpace
//********************************************************************
PyMethodDef Dtool_Methods_OdeSimpleSpace[]= {
  { "getClassType",(PyCFunction ) &Dtool_OdeSimpleSpace_get_class_type_530, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSimpleSpace_get_class_type_530_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OdeSimpleSpace(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeSimpleSpace.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeSimpleSpace\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////c";
#endif
        // Dependent Objects   
        Dtool_OdeSpace._Dtool_ClassInit(NULL);
        Dtool_OdeSimpleSpace.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_OdeSpace.As_PyTypeObject());
        Dtool_OdeSimpleSpace.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeSimpleSpace.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeSimpleSpace.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OdeSimpleSpace.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeSimpleSpace)");
             printf(" Error In PyType_ReadyOdeSimpleSpace");
             return;
        }
        Py_INCREF(&Dtool_OdeSimpleSpace.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeSimpleSpace.As_PyTypeObject().tp_dict,"OdeSimpleSpace",&Dtool_OdeSimpleSpace.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeSimpleSpace.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeSimpleSpace[0],&Dtool_OdeSimpleSpace.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeSimpleSpace,OdeSimpleSpace::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeSimpleSpace.As_PyTypeObject());
        PyModule_AddObject(module, "OdeSimpleSpace",(PyObject *)&Dtool_OdeSimpleSpace.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeSliderJoint | OdeSliderJoint
//********************************************************************
PyMethodDef Dtool_Methods_OdeSliderJoint[]= {
  { "setAxis",(PyCFunction ) &Dtool_OdeSliderJoint_set_axis_533, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSliderJoint_set_axis_533_comment},
  { "setAxisDelta",(PyCFunction ) &Dtool_OdeSliderJoint_set_axis_delta_534, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSliderJoint_set_axis_delta_534_comment},
  { "addForce",(PyCFunction ) &Dtool_OdeSliderJoint_add_force_535, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSliderJoint_add_force_535_comment},
  { "getPosition",(PyCFunction ) &Dtool_OdeSliderJoint_get_position_536, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSliderJoint_get_position_536_comment},
  { "getPositionRate",(PyCFunction ) &Dtool_OdeSliderJoint_get_position_rate_537, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSliderJoint_get_position_rate_537_comment},
  { "getAxis",(PyCFunction ) &Dtool_OdeSliderJoint_get_axis_538, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSliderJoint_get_axis_538_comment},
  { "setParamLoStop",(PyCFunction ) &Dtool_OdeSliderJoint_set_param_lo_stop_539, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSliderJoint_set_param_lo_stop_539_comment},
  { "setParamHiStop",(PyCFunction ) &Dtool_OdeSliderJoint_set_param_hi_stop_540, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSliderJoint_set_param_hi_stop_540_comment},
  { "setParamVel",(PyCFunction ) &Dtool_OdeSliderJoint_set_param_vel_541, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSliderJoint_set_param_vel_541_comment},
  { "setParamFMax",(PyCFunction ) &Dtool_OdeSliderJoint_set_param_f_max_542, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSliderJoint_set_param_f_max_542_comment},
  { "setParamFudgeFactor",(PyCFunction ) &Dtool_OdeSliderJoint_set_param_fudge_factor_543, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSliderJoint_set_param_fudge_factor_543_comment},
  { "setParamBounce",(PyCFunction ) &Dtool_OdeSliderJoint_set_param_bounce_544, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSliderJoint_set_param_bounce_544_comment},
  { "setParamCFM",(PyCFunction ) &Dtool_OdeSliderJoint_set_param_CFM_545, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSliderJoint_set_param_CFM_545_comment},
  { "setParamStopERP",(PyCFunction ) &Dtool_OdeSliderJoint_set_param_stop_ERP_546, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSliderJoint_set_param_stop_ERP_546_comment},
  { "setParamStopCFM",(PyCFunction ) &Dtool_OdeSliderJoint_set_param_stop_CFM_547, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSliderJoint_set_param_stop_CFM_547_comment},
  { "getParamLoStop",(PyCFunction ) &Dtool_OdeSliderJoint_get_param_lo_stop_548, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSliderJoint_get_param_lo_stop_548_comment},
  { "getParamHiStop",(PyCFunction ) &Dtool_OdeSliderJoint_get_param_hi_stop_549, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSliderJoint_get_param_hi_stop_549_comment},
  { "getParamVel",(PyCFunction ) &Dtool_OdeSliderJoint_get_param_vel_550, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSliderJoint_get_param_vel_550_comment},
  { "getParamFMax",(PyCFunction ) &Dtool_OdeSliderJoint_get_param_f_max_551, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSliderJoint_get_param_f_max_551_comment},
  { "getParamFudgeFactor",(PyCFunction ) &Dtool_OdeSliderJoint_get_param_fudge_factor_552, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSliderJoint_get_param_fudge_factor_552_comment},
  { "getParamBounce",(PyCFunction ) &Dtool_OdeSliderJoint_get_param_bounce_553, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSliderJoint_get_param_bounce_553_comment},
  { "getParamCFM",(PyCFunction ) &Dtool_OdeSliderJoint_get_param_CFM_554, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSliderJoint_get_param_CFM_554_comment},
  { "getParamStopERP",(PyCFunction ) &Dtool_OdeSliderJoint_get_param_stop_ERP_555, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSliderJoint_get_param_stop_ERP_555_comment},
  { "getParamStopCFM",(PyCFunction ) &Dtool_OdeSliderJoint_get_param_stop_CFM_556, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSliderJoint_get_param_stop_CFM_556_comment},
  { "getClassType",(PyCFunction ) &Dtool_OdeSliderJoint_get_class_type_557, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSliderJoint_get_class_type_557_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OdeSliderJoint(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeSliderJoint.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeSliderJoint\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_OdeJoint._Dtool_ClassInit(NULL);
        Dtool_OdeSliderJoint.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_OdeJoint.As_PyTypeObject());
        Dtool_OdeSliderJoint.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeSliderJoint.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeSliderJoint.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OdeSliderJoint.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeSliderJoint)");
             printf(" Error In PyType_ReadyOdeSliderJoint");
             return;
        }
        Py_INCREF(&Dtool_OdeSliderJoint.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeSliderJoint.As_PyTypeObject().tp_dict,"OdeSliderJoint",&Dtool_OdeSliderJoint.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeSliderJoint.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeSliderJoint[24],&Dtool_OdeSliderJoint.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeSliderJoint,OdeSliderJoint::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeSliderJoint.As_PyTypeObject());
        PyModule_AddObject(module, "OdeSliderJoint",(PyObject *)&Dtool_OdeSliderJoint.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeSphereGeom | OdeSphereGeom
//********************************************************************
PyMethodDef Dtool_Methods_OdeSphereGeom[]= {
  { "setRadius",(PyCFunction ) &Dtool_OdeSphereGeom_set_radius_560, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSphereGeom_set_radius_560_comment},
  { "getRadius",(PyCFunction ) &Dtool_OdeSphereGeom_get_radius_561, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSphereGeom_get_radius_561_comment},
  { "getPointDepth",(PyCFunction ) &Dtool_OdeSphereGeom_get_point_depth_562, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSphereGeom_get_point_depth_562_comment},
  { "getClassType",(PyCFunction ) &Dtool_OdeSphereGeom_get_class_type_563, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeSphereGeom_get_class_type_563_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OdeSphereGeom(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeSphereGeom.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeSphereGeom\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_OdeGeom._Dtool_ClassInit(NULL);
        Dtool_OdeSphereGeom.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_OdeGeom.As_PyTypeObject());
        Dtool_OdeSphereGeom.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeSphereGeom.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeSphereGeom.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OdeSphereGeom.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeSphereGeom)");
             printf(" Error In PyType_ReadyOdeSphereGeom");
             return;
        }
        Py_INCREF(&Dtool_OdeSphereGeom.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeSphereGeom.As_PyTypeObject().tp_dict,"OdeSphereGeom",&Dtool_OdeSphereGeom.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeSphereGeom.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeSphereGeom[3],&Dtool_OdeSphereGeom.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeSphereGeom,OdeSphereGeom::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeSphereGeom.As_PyTypeObject());
        PyModule_AddObject(module, "OdeSphereGeom",(PyObject *)&Dtool_OdeSphereGeom.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeTriMeshData | OdeTriMeshData
//********************************************************************
PyMethodDef Dtool_Methods_OdeTriMeshData[]= {
  { "destroy",(PyCFunction ) &Dtool_OdeTriMeshData_destroy_567, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeTriMeshData_destroy_567_comment},
  { "write",(PyCFunction ) &Dtool_OdeTriMeshData_write_568, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeTriMeshData_write_568_comment},
  { "writeFaces",(PyCFunction ) &Dtool_OdeTriMeshData_write_faces_569, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeTriMeshData_write_faces_569_comment},
  { "getClassType",(PyCFunction ) &Dtool_OdeTriMeshData_get_class_type_570, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeTriMeshData_get_class_type_570_comment},
  { NULL, NULL }
};

//////////////////
//  A __str__ Function
//     OdeTriMeshData
//////////////////
static PyObject *  Dtool_Str_OdeTriMeshData(PyObject * self)
{
    OdeTriMeshData * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_OdeTriMeshData,(void **)&local_this);
    if(local_this == NULL)
    {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    };
     ostringstream os;
     local_this->write(os);
     std::string ss = os.str();
     return PyString_FromStringAndSize(ss.data(),ss.length());
}
void   Dtool_PyModuleClassInit_OdeTriMeshData(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeTriMeshData.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeTriMeshData\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_TypedReferenceCount._Dtool_ClassInit(NULL);
        Dtool_OdeTriMeshData.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_TypedReferenceCount.As_PyTypeObject());
        Dtool_OdeTriMeshData.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeTriMeshData.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeTriMeshData.As_PyTypeObject().tp_dict);
        // __str__
        Dtool_OdeTriMeshData.As_PyTypeObject().tp_str = & Dtool_Str_OdeTriMeshData;
        // Enum  OdeTriMeshData::DataType;
        PyDict_SetItemString(Dtool_OdeTriMeshData.As_PyTypeObject().tp_dict,"DTFaceNormals",PyInt_FromLong(0));
        PyDict_SetItemString(Dtool_OdeTriMeshData.As_PyTypeObject().tp_dict,"DTLastTransformation",PyInt_FromLong(1));
        if(PyType_Ready(&Dtool_OdeTriMeshData.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeTriMeshData)");
             printf(" Error In PyType_ReadyOdeTriMeshData");
             return;
        }
        Py_INCREF(&Dtool_OdeTriMeshData.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeTriMeshData.As_PyTypeObject().tp_dict,"OdeTriMeshData",&Dtool_OdeTriMeshData.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeTriMeshData.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeTriMeshData[3],&Dtool_OdeTriMeshData.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeTriMeshData,OdeTriMeshData::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeTriMeshData.As_PyTypeObject());
        PyModule_AddObject(module, "OdeTriMeshData",(PyObject *)&Dtool_OdeTriMeshData.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeTriMeshGeom | OdeTriMeshGeom
//********************************************************************
PyMethodDef Dtool_Methods_OdeTriMeshGeom[]= {
  { "destroy",(PyCFunction ) &Dtool_OdeTriMeshGeom_destroy_573, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeTriMeshGeom_destroy_573_comment},
  { "setTriMeshData",(PyCFunction ) &Dtool_OdeTriMeshGeom_set_tri_mesh_data_574, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeTriMeshGeom_set_tri_mesh_data_574_comment},
  { "getTriMeshData",(PyCFunction ) &Dtool_OdeTriMeshGeom_get_tri_mesh_data_575, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeTriMeshGeom_get_tri_mesh_data_575_comment},
  { "setData",(PyCFunction ) &Dtool_OdeTriMeshGeom_set_data_576, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeTriMeshGeom_set_data_576_comment},
  { "getData",(PyCFunction ) &Dtool_OdeTriMeshGeom_get_data_577, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeTriMeshGeom_get_data_577_comment},
  { "enableTC",(PyCFunction ) &Dtool_OdeTriMeshGeom_enable_TC_578, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeTriMeshGeom_enable_TC_578_comment},
  { "isTCEnabled",(PyCFunction ) &Dtool_OdeTriMeshGeom_is_TC_enabled_579, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeTriMeshGeom_is_TC_enabled_579_comment},
  { "clearTCCache",(PyCFunction ) &Dtool_OdeTriMeshGeom_clear_TC_cache_580, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeTriMeshGeom_clear_TC_cache_580_comment},
  { "getTriangle",(PyCFunction ) &Dtool_OdeTriMeshGeom_get_triangle_581, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeTriMeshGeom_get_triangle_581_comment},
  { "getPoint",(PyCFunction ) &Dtool_OdeTriMeshGeom_get_point_582, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeTriMeshGeom_get_point_582_comment},
  { "getNumTriangles",(PyCFunction ) &Dtool_OdeTriMeshGeom_get_num_triangles_583, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeTriMeshGeom_get_num_triangles_583_comment},
  { "getClassType",(PyCFunction ) &Dtool_OdeTriMeshGeom_get_class_type_584, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeTriMeshGeom_get_class_type_584_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OdeTriMeshGeom(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeTriMeshGeom.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeTriMeshGeom\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_OdeGeom._Dtool_ClassInit(NULL);
        Dtool_OdeTriMeshGeom.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_OdeGeom.As_PyTypeObject());
        Dtool_OdeTriMeshGeom.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeTriMeshGeom.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeTriMeshGeom.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OdeTriMeshGeom.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeTriMeshGeom)");
             printf(" Error In PyType_ReadyOdeTriMeshGeom");
             return;
        }
        Py_INCREF(&Dtool_OdeTriMeshGeom.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeTriMeshGeom.As_PyTypeObject().tp_dict,"OdeTriMeshGeom",&Dtool_OdeTriMeshGeom.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeTriMeshGeom.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeTriMeshGeom[11],&Dtool_OdeTriMeshGeom.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeTriMeshGeom,OdeTriMeshGeom::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeTriMeshGeom.As_PyTypeObject());
        PyModule_AddObject(module, "OdeTriMeshGeom",(PyObject *)&Dtool_OdeTriMeshGeom.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeUniversalJoint | OdeUniversalJoint
//********************************************************************
PyMethodDef Dtool_Methods_OdeUniversalJoint[]= {
  { "setAnchor",(PyCFunction ) &Dtool_OdeUniversalJoint_set_anchor_587, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_set_anchor_587_comment},
  { "setAxis1",(PyCFunction ) &Dtool_OdeUniversalJoint_set_axis1_588, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_set_axis1_588_comment},
  { "setAxis2",(PyCFunction ) &Dtool_OdeUniversalJoint_set_axis2_589, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_set_axis2_589_comment},
  { "addTorques",(PyCFunction ) &Dtool_OdeUniversalJoint_add_torques_590, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_add_torques_590_comment},
  { "getAnchor",(PyCFunction ) &Dtool_OdeUniversalJoint_get_anchor_591, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_get_anchor_591_comment},
  { "getAnchor2",(PyCFunction ) &Dtool_OdeUniversalJoint_get_anchor2_592, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_get_anchor2_592_comment},
  { "getAxis1",(PyCFunction ) &Dtool_OdeUniversalJoint_get_axis1_593, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_get_axis1_593_comment},
  { "getAxis2",(PyCFunction ) &Dtool_OdeUniversalJoint_get_axis2_594, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_get_axis2_594_comment},
  { "getAngle1",(PyCFunction ) &Dtool_OdeUniversalJoint_get_angle1_595, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_get_angle1_595_comment},
  { "getAngle2",(PyCFunction ) &Dtool_OdeUniversalJoint_get_angle2_596, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_get_angle2_596_comment},
  { "getAngle1Rate",(PyCFunction ) &Dtool_OdeUniversalJoint_get_angle1_rate_597, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_get_angle1_rate_597_comment},
  { "getAngle2Rate",(PyCFunction ) &Dtool_OdeUniversalJoint_get_angle2_rate_598, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_get_angle2_rate_598_comment},
  { "setParamLoStop",(PyCFunction ) &Dtool_OdeUniversalJoint_set_param_lo_stop_599, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_set_param_lo_stop_599_comment},
  { "setParamHiStop",(PyCFunction ) &Dtool_OdeUniversalJoint_set_param_hi_stop_600, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_set_param_hi_stop_600_comment},
  { "setParamVel",(PyCFunction ) &Dtool_OdeUniversalJoint_set_param_vel_601, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_set_param_vel_601_comment},
  { "setParamFMax",(PyCFunction ) &Dtool_OdeUniversalJoint_set_param_f_max_602, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_set_param_f_max_602_comment},
  { "setParamFudgeFactor",(PyCFunction ) &Dtool_OdeUniversalJoint_set_param_fudge_factor_603, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_set_param_fudge_factor_603_comment},
  { "setParamBounce",(PyCFunction ) &Dtool_OdeUniversalJoint_set_param_bounce_604, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_set_param_bounce_604_comment},
  { "setParamCFM",(PyCFunction ) &Dtool_OdeUniversalJoint_set_param_CFM_605, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_set_param_CFM_605_comment},
  { "setParamStopERP",(PyCFunction ) &Dtool_OdeUniversalJoint_set_param_stop_ERP_606, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_set_param_stop_ERP_606_comment},
  { "setParamStopCFM",(PyCFunction ) &Dtool_OdeUniversalJoint_set_param_stop_CFM_607, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_set_param_stop_CFM_607_comment},
  { "getParamLoStop",(PyCFunction ) &Dtool_OdeUniversalJoint_get_param_lo_stop_608, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_get_param_lo_stop_608_comment},
  { "getParamHiStop",(PyCFunction ) &Dtool_OdeUniversalJoint_get_param_hi_stop_609, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_get_param_hi_stop_609_comment},
  { "getParamVel",(PyCFunction ) &Dtool_OdeUniversalJoint_get_param_vel_610, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_get_param_vel_610_comment},
  { "getParamFMax",(PyCFunction ) &Dtool_OdeUniversalJoint_get_param_f_max_611, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_get_param_f_max_611_comment},
  { "getParamFudgeFactor",(PyCFunction ) &Dtool_OdeUniversalJoint_get_param_fudge_factor_612, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_get_param_fudge_factor_612_comment},
  { "getParamBounce",(PyCFunction ) &Dtool_OdeUniversalJoint_get_param_bounce_613, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_get_param_bounce_613_comment},
  { "getParamCFM",(PyCFunction ) &Dtool_OdeUniversalJoint_get_param_CFM_614, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_get_param_CFM_614_comment},
  { "getParamStopERP",(PyCFunction ) &Dtool_OdeUniversalJoint_get_param_stop_ERP_615, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_get_param_stop_ERP_615_comment},
  { "getParamStopCFM",(PyCFunction ) &Dtool_OdeUniversalJoint_get_param_stop_CFM_616, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_get_param_stop_CFM_616_comment},
  { "getClassType",(PyCFunction ) &Dtool_OdeUniversalJoint_get_class_type_617, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUniversalJoint_get_class_type_617_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OdeUniversalJoint(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeUniversalJoint.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeUniversalJoint\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_OdeJoint._Dtool_ClassInit(NULL);
        Dtool_OdeUniversalJoint.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_OdeJoint.As_PyTypeObject());
        Dtool_OdeUniversalJoint.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeUniversalJoint.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeUniversalJoint.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OdeUniversalJoint.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeUniversalJoint)");
             printf(" Error In PyType_ReadyOdeUniversalJoint");
             return;
        }
        Py_INCREF(&Dtool_OdeUniversalJoint.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeUniversalJoint.As_PyTypeObject().tp_dict,"OdeUniversalJoint",&Dtool_OdeUniversalJoint.As_PyObject());
        //  Static Method getClassType
        PyDict_SetItemString(Dtool_OdeUniversalJoint.As_PyTypeObject().tp_dict,"getClassType",PyCFunction_New(&Dtool_Methods_OdeUniversalJoint[30],&Dtool_OdeUniversalJoint.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeUniversalJoint,OdeUniversalJoint::get_class_type().get_index());
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeUniversalJoint.As_PyTypeObject());
        PyModule_AddObject(module, "OdeUniversalJoint",(PyObject *)&Dtool_OdeUniversalJoint.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. OdeUtil | OdeUtil
//********************************************************************
PyMethodDef Dtool_Methods_OdeUtil[]= {
  { "getConnectingJoint",(PyCFunction ) &Dtool_OdeUtil_get_connecting_joint_619, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUtil_get_connecting_joint_619_comment},
  { "getConnectingJointList",(PyCFunction ) &Dtool_OdeUtil_get_connecting_joint_list_620, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUtil_get_connecting_joint_list_620_comment},
  { "areConnected",(PyCFunction ) &Dtool_OdeUtil_are_connected_621, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUtil_are_connected_621_comment},
  { "areConnectedExcluding",(PyCFunction ) &Dtool_OdeUtil_are_connected_excluding_622, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUtil_are_connected_excluding_622_comment},
  { "collide",(PyCFunction ) &Dtool_OdeUtil_collide_623, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUtil_collide_623_comment},
  { "collide2",(PyCFunction ) &Dtool_OdeUtil_collide2_624, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUtil_collide2_624_comment},
  { "spaceToGeom",(PyCFunction ) &Dtool_OdeUtil_space_to_geom_625, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUtil_space_to_geom_625_comment},
  { "getInfinity",(PyCFunction ) &Dtool_OdeUtil_get_infinity_626, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUtil_get_infinity_626_comment},
  { "randGetSeed",(PyCFunction ) &Dtool_OdeUtil_rand_get_seed_627, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUtil_rand_get_seed_627_comment},
  { "randSetSeed",(PyCFunction ) &Dtool_OdeUtil_rand_set_seed_628, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_OdeUtil_rand_set_seed_628_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_OdeUtil(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_OdeUtil.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : OdeUtil\n"
          "// Description : \n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_OdeUtil.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_OdeUtil.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_OdeUtil.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_OdeUtil.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_OdeUtil.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(OdeUtil)");
             printf(" Error In PyType_ReadyOdeUtil");
             return;
        }
        Py_INCREF(&Dtool_OdeUtil.As_PyTypeObject());
        PyDict_SetItemString(Dtool_OdeUtil.As_PyTypeObject().tp_dict,"OdeUtil",&Dtool_OdeUtil.As_PyObject());
        //  Static Method getConnectingJoint
        PyDict_SetItemString(Dtool_OdeUtil.As_PyTypeObject().tp_dict,"getConnectingJoint",PyCFunction_New(&Dtool_Methods_OdeUtil[0],&Dtool_OdeUtil.As_PyObject()));
        //  Static Method getConnectingJointList
        PyDict_SetItemString(Dtool_OdeUtil.As_PyTypeObject().tp_dict,"getConnectingJointList",PyCFunction_New(&Dtool_Methods_OdeUtil[1],&Dtool_OdeUtil.As_PyObject()));
        //  Static Method areConnected
        PyDict_SetItemString(Dtool_OdeUtil.As_PyTypeObject().tp_dict,"areConnected",PyCFunction_New(&Dtool_Methods_OdeUtil[2],&Dtool_OdeUtil.As_PyObject()));
        //  Static Method areConnectedExcluding
        PyDict_SetItemString(Dtool_OdeUtil.As_PyTypeObject().tp_dict,"areConnectedExcluding",PyCFunction_New(&Dtool_Methods_OdeUtil[3],&Dtool_OdeUtil.As_PyObject()));
        //  Static Method collide
        PyDict_SetItemString(Dtool_OdeUtil.As_PyTypeObject().tp_dict,"collide",PyCFunction_New(&Dtool_Methods_OdeUtil[4],&Dtool_OdeUtil.As_PyObject()));
        //  Static Method collide2
        PyDict_SetItemString(Dtool_OdeUtil.As_PyTypeObject().tp_dict,"collide2",PyCFunction_New(&Dtool_Methods_OdeUtil[5],&Dtool_OdeUtil.As_PyObject()));
        //  Static Method spaceToGeom
        PyDict_SetItemString(Dtool_OdeUtil.As_PyTypeObject().tp_dict,"spaceToGeom",PyCFunction_New(&Dtool_Methods_OdeUtil[6],&Dtool_OdeUtil.As_PyObject()));
        //  Static Method getInfinity
        PyDict_SetItemString(Dtool_OdeUtil.As_PyTypeObject().tp_dict,"getInfinity",PyCFunction_New(&Dtool_Methods_OdeUtil[7],&Dtool_OdeUtil.As_PyObject()));
        //  Static Method randGetSeed
        PyDict_SetItemString(Dtool_OdeUtil.As_PyTypeObject().tp_dict,"randGetSeed",PyCFunction_New(&Dtool_Methods_OdeUtil[8],&Dtool_OdeUtil.As_PyObject()));
        //  Static Method randSetSeed
        PyDict_SetItemString(Dtool_OdeUtil.As_PyTypeObject().tp_dict,"randSetSeed",PyCFunction_New(&Dtool_Methods_OdeUtil[9],&Dtool_OdeUtil.As_PyObject()));
        RegisterRuntimeClass(&Dtool_OdeUtil,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_OdeUtil.As_PyTypeObject());
        PyModule_AddObject(module, "OdeUtil",(PyObject *)&Dtool_OdeUtil.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..dxBody
//********************************************************************
   Dtool_PyModuleClassInit_dxBody(module);
//********************************************************************
//*** Module Init Updcall ..dxGeom
//********************************************************************
   Dtool_PyModuleClassInit_dxGeom(module);
//********************************************************************
//*** Module Init Updcall ..dxJoint
//********************************************************************
   Dtool_PyModuleClassInit_dxJoint(module);
//********************************************************************
//*** Module Init Updcall ..dxJointGroup
//********************************************************************
   Dtool_PyModuleClassInit_dxJointGroup(module);
//********************************************************************
//*** Module Init Updcall ..dxSpace
//********************************************************************
   Dtool_PyModuleClassInit_dxSpace(module);
//********************************************************************
//*** Module Init Updcall ..dxTriMeshData
//********************************************************************
   Dtool_PyModuleClassInit_dxTriMeshData(module);
//********************************************************************
//*** Module Init Updcall ..dxWorld
//********************************************************************
   Dtool_PyModuleClassInit_dxWorld(module);
//********************************************************************
//*** Module Init Updcall ..OdeWorld
//********************************************************************
   Dtool_PyModuleClassInit_OdeWorld(module);
//********************************************************************
//*** Module Init Updcall ..OdeJointGroup
//********************************************************************
   Dtool_PyModuleClassInit_OdeJointGroup(module);
//********************************************************************
//*** Module Init Updcall ..OdeJointFeedback
//********************************************************************
   Dtool_PyModuleClassInit_OdeJointFeedback(module);
//********************************************************************
//*** Module Init Updcall ..OdeJoint
//********************************************************************
   Dtool_PyModuleClassInit_OdeJoint(module);
//********************************************************************
//*** Module Init Updcall ..OdeAMotorJoint
//********************************************************************
   Dtool_PyModuleClassInit_OdeAMotorJoint(module);
//********************************************************************
//*** Module Init Updcall ..OdeBallJoint
//********************************************************************
   Dtool_PyModuleClassInit_OdeBallJoint(module);
//********************************************************************
//*** Module Init Updcall ..OdeMass
//********************************************************************
   Dtool_PyModuleClassInit_OdeMass(module);
//********************************************************************
//*** Module Init Updcall ..OdeBody
//********************************************************************
   Dtool_PyModuleClassInit_OdeBody(module);
//********************************************************************
//*** Module Init Updcall ..OdeSpace
//********************************************************************
   Dtool_PyModuleClassInit_OdeSpace(module);
//********************************************************************
//*** Module Init Updcall ..OdeGeom
//********************************************************************
   Dtool_PyModuleClassInit_OdeGeom(module);
//********************************************************************
//*** Module Init Updcall ..OdeBoxGeom
//********************************************************************
   Dtool_PyModuleClassInit_OdeBoxGeom(module);
//********************************************************************
//*** Module Init Updcall ..OdeCappedCylinderGeom
//********************************************************************
   Dtool_PyModuleClassInit_OdeCappedCylinderGeom(module);
//********************************************************************
//*** Module Init Updcall ..OdeContactGeom
//********************************************************************
   Dtool_PyModuleClassInit_OdeContactGeom(module);
//********************************************************************
//*** Module Init Updcall ..OdeCollisionEntry
//********************************************************************
   Dtool_PyModuleClassInit_OdeCollisionEntry(module);
//********************************************************************
//*** Module Init Updcall ..OdeSurfaceParameters
//********************************************************************
   Dtool_PyModuleClassInit_OdeSurfaceParameters(module);
//********************************************************************
//*** Module Init Updcall ..OdeContact
//********************************************************************
   Dtool_PyModuleClassInit_OdeContact(module);
//********************************************************************
//*** Module Init Updcall ..OdeContactJoint
//********************************************************************
   Dtool_PyModuleClassInit_OdeContactJoint(module);
//********************************************************************
//*** Module Init Updcall ..OdeCylinderGeom
//********************************************************************
   Dtool_PyModuleClassInit_OdeCylinderGeom(module);
//********************************************************************
//*** Module Init Updcall ..OdeFixedJoint
//********************************************************************
   Dtool_PyModuleClassInit_OdeFixedJoint(module);
//********************************************************************
//*** Module Init Updcall ..OdeHashSpace
//********************************************************************
   Dtool_PyModuleClassInit_OdeHashSpace(module);
//********************************************************************
//*** Module Init Updcall ..OdeHinge2Joint
//********************************************************************
   Dtool_PyModuleClassInit_OdeHinge2Joint(module);
//********************************************************************
//*** Module Init Updcall ..OdeHingeJoint
//********************************************************************
   Dtool_PyModuleClassInit_OdeHingeJoint(module);
//********************************************************************
//*** Module Init Updcall ..OdeJointCollection
//********************************************************************
   Dtool_PyModuleClassInit_OdeJointCollection(module);
//********************************************************************
//*** Module Init Updcall ..OdeLMotorJoint
//********************************************************************
   Dtool_PyModuleClassInit_OdeLMotorJoint(module);
//********************************************************************
//*** Module Init Updcall ..OdeNullJoint
//********************************************************************
   Dtool_PyModuleClassInit_OdeNullJoint(module);
//********************************************************************
//*** Module Init Updcall ..OdePlane2dJoint
//********************************************************************
   Dtool_PyModuleClassInit_OdePlane2dJoint(module);
//********************************************************************
//*** Module Init Updcall ..OdePlaneGeom
//********************************************************************
   Dtool_PyModuleClassInit_OdePlaneGeom(module);
//********************************************************************
//*** Module Init Updcall ..OdeQuadTreeSpace
//********************************************************************
   Dtool_PyModuleClassInit_OdeQuadTreeSpace(module);
//********************************************************************
//*** Module Init Updcall ..OdeRayGeom
//********************************************************************
   Dtool_PyModuleClassInit_OdeRayGeom(module);
//********************************************************************
//*** Module Init Updcall ..OdeSimpleSpace
//********************************************************************
   Dtool_PyModuleClassInit_OdeSimpleSpace(module);
//********************************************************************
//*** Module Init Updcall ..OdeSliderJoint
//********************************************************************
   Dtool_PyModuleClassInit_OdeSliderJoint(module);
//********************************************************************
//*** Module Init Updcall ..OdeSphereGeom
//********************************************************************
   Dtool_PyModuleClassInit_OdeSphereGeom(module);
//********************************************************************
//*** Module Init Updcall ..OdeTriMeshData
//********************************************************************
   Dtool_PyModuleClassInit_OdeTriMeshData(module);
//********************************************************************
//*** Module Init Updcall ..OdeTriMeshGeom
//********************************************************************
   Dtool_PyModuleClassInit_OdeTriMeshGeom(module);
//********************************************************************
//*** Module Init Updcall ..OdeUniversalJoint
//********************************************************************
   Dtool_PyModuleClassInit_OdeUniversalJoint(module);
//********************************************************************
//*** Module Init Updcall ..OdeUtil
//********************************************************************
   Dtool_PyModuleClassInit_OdeUtil(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libpandaode_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687213587,  /* file_identifier */
  "libpandaode",  /* library_name */
  "sTqO",  /* library_hash_name */
  "pandaode",  /* module_name */
  "libpandaode.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  1467  /* next_index */
};

Configure(_in_configure_libpandaode);
ConfigureFn(_in_configure_libpandaode) {
  interrogate_request_module(&_in_module_def);
}

