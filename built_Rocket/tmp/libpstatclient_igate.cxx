/*
 * This file generated by:
 * built_Rocket/bin/interrogate -srcdir panda/src/pstatclient -Ipanda/src/pstatclient -Dvolatile -Dmutable -DCPPPARSER -D__STDC__=1 -D__cplusplus -D__inline -longlong __int64 -D_X86_ -DWIN32_VC -D_WIN32 -D_MSC_VER=1500 -D_declspec(param)= -D_near -D_far -D__near -D__far -D__stdcall -DNDEBUG -oc built_Rocket/tmp/libpstatclient_igate.cxx -od built_Rocket/pandac/input/libpstatclient.in -fnames -string -refcount -assert -python-native -Sbuilt_Rocket/include/parser-inc -Ipanda/src/pstatclient -SD:\Projects\Toontown\Rocket\ttsrc\thirdparty\win-python/include -Sbuilt_Rocket/tmp -Sbuilt_Rocket/include -DMAKEPANDA= -DWANT_NATIVE_NET=1 -DBUILDING_PANDA -module panda -library libpstatclient config_pstats.h pStatClient.h pStatClientControlMessage.h pStatClientImpl.h pStatClientVersion.h pStatCollector.h pStatCollectorDef.h pStatCollectorForward.h pStatFrameData.h pStatProperties.h pStatServerControlMessage.h pStatThread.h pStatTimer.h pstatclient_composite.cxx 
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_libpstatclient
#include "py_panda.h"  

#include "atomicAdjust.h"
#include "bitArray.h"
#include "configVariableBool.h"
#include "configVariableDouble.h"
#include "configVariableInt.h"
#include "configVariableString.h"
#include "config_pstats.h"
#include "dconfig.h"
#include "lightMutex.h"
#include "lightMutexHolder.h"
#include "notifyCategoryProxy.h"
#include "numeric_types.h"
#include "pStatClient.h"
#include "pStatClientControlMessage.h"
#include "pStatClientImpl.h"
#include "pStatClientVersion.h"
#include "pStatCollector.h"
#include "pStatCollectorDef.h"
#include "pStatCollectorForward.h"
#include "pStatCollectorForwardBase.h"
#include "pStatFrameData.h"
#include "pStatProperties.h"
#include "pStatServerControlMessage.h"
#include "pStatThread.h"
#include "pStatTimer.h"
#include "pandabase.h"
#include "pmap.h"
#include "pointerTo.h"
#include "pvector.h"
#include "reMutex.h"
#include "reMutexHolder.h"
#include "referenceCount.h"
#include "thread.h"
#include "vector_int.h"
#include "weakPointerTo.h"

#undef HAVE_LONG_LONG
#undef _POSIX_C_SOURCE

#if PYTHON_FRAMEWORK
  #include "Python/Python.h"
#else
  #include "Python.h"
#endif
#ifdef HAVE_LONG_LONG
#undef HAVE_LONG_LONG
#endif 

//********************************************************************
//*** prototypes for .. Glabal
//********************************************************************
//********************************************************************
//*** prototypes for .. PStatClient
//********************************************************************
typedef  PStatClient  PStatClient_localtype;
Define_Module_Class(panda,PStatClient,PStatClient_localtype,PStatClient);
//********************************************************************
//*** prototypes for .. PStatThread
//********************************************************************
typedef  PStatThread  PStatThread_localtype;
Define_Module_Class(panda,PStatThread,PStatThread_localtype,PStatThread);
//********************************************************************
//*** prototypes for .. PStatCollector
//********************************************************************
typedef  PStatCollector  PStatCollector_localtype;
Define_Module_Class(panda,PStatCollector,PStatCollector_localtype,PStatCollector);
//********************************************************************
//*** prototypes for .. PStatCollectorForward
//********************************************************************
typedef  PStatCollectorForward  PStatCollectorForward_localtype;
Define_Module_ClassRef(panda,PStatCollectorForward,PStatCollectorForward_localtype,PStatCollectorForward);
//********************************************************************
//*** prototypes for .. Extrernal Objects 
//********************************************************************
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_PStatCollectorForwardBase;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_ReferenceCount;
IMPORT_THIS struct   Dtool_PyTypedObject Dtool_Thread;

//********************************************************************
//*** Functions for .. Global 
//********************************************************************
//********************************************************************
//*** Functions for .. PStatClient 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * static inline bool PStatClient::connect(basic_string< char > const &, int )
 * static inline bool PStatClient::connect(basic_string< char > const &, int  = (-1))
 * static inline bool PStatClient::connect(basic_string< char > const & = ((string())), int  = (-1))
 *******************************************************************/
static PyObject *Dtool_PStatClient_connect_3(PyObject *self, PyObject *args,PyObject *kwds) {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        {
          // 1-static inline bool PStatClient::connect(basic_string< char > const & = ((string())), int  = (-1))
            static char * key_word_list[] = {NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, ":connect", key_word_list))
            {
                bool return_value = PStatClient::connect();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    case(1):
        {
        {
          // 1-static inline bool PStatClient::connect(basic_string< char > const &, int  = (-1))
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:connect", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:connect", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                bool return_value = PStatClient::connect(basic_string<char>(param0_str, param0_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          // 1-static inline bool PStatClient::connect(basic_string< char > const &, int )
            char *param0_str; int param0_len;
            int param1;
            static char * key_word_list[] = {(char *)"param0", (char *)"param1", NULL};
            if (PyArg_ParseTupleAndKeywords(args,kwds, "s#i:connect", key_word_list, &param0_str, &param0_len, &param1))
            {
                bool return_value = PStatClient::connect(basic_string<char>(param0_str, param0_len), (int)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        }

        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "connect() takes 0, 1, or 2 arguments (%d given)", parameter_count + 0);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "connect()\n"
          "connect(string)\n"
          "connect(string, int)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PStatClient_connect_3_comment =
    "C++ Interface:\n"
    "connect()\n"
    "connect(string)\n"
    "connect(string, int)\n"
    "\n"
    "";
#else
static const char * Dtool_PStatClient_connect_3_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void PStatClient::disconnect(void)
 *******************************************************************/
static PyObject *Dtool_PStatClient_disconnect_4(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void PStatClient::disconnect(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":disconnect", key_word_list))
        {
            PStatClient::disconnect();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "disconnect()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PStatClient_disconnect_4_comment =
    "C++ Interface:\n"
    "disconnect()\n"
    "\n"
    "";
#else
static const char * Dtool_PStatClient_disconnect_4_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline bool PStatClient::is_connected(void)
 *******************************************************************/
static PyObject *Dtool_PStatClient_is_connected_5(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline bool PStatClient::is_connected(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":isConnected", key_word_list))
        {
            bool return_value = PStatClient::is_connected();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isConnected()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PStatClient_is_connected_5_comment =
    "C++ Interface:\n"
    "isConnected()\n"
    "\n"
    "";
#else
static const char * Dtool_PStatClient_is_connected_5_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void PStatClient::resume_after_pause(void)
 *******************************************************************/
static PyObject *Dtool_PStatClient_resume_after_pause_6(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void PStatClient::resume_after_pause(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":resumeAfterPause", key_word_list))
        {
            PStatClient::resume_after_pause();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "resumeAfterPause()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PStatClient_resume_after_pause_6_comment =
    "C++ Interface:\n"
    "resumeAfterPause()\n"
    "\n"
    "";
#else
static const char * Dtool_PStatClient_resume_after_pause_6_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void PStatClient::main_tick(void)
 *******************************************************************/
static PyObject *Dtool_PStatClient_main_tick_7(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void PStatClient::main_tick(void)
        static char * key_word_list[] = {NULL};
        if (PyArg_ParseTupleAndKeywords(args,kwds, ":mainTick", key_word_list))
        {
            PStatClient::main_tick();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "mainTick()\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PStatClient_main_tick_7_comment =
    "C++ Interface:\n"
    "mainTick()\n"
    "\n"
    "";
#else
static const char * Dtool_PStatClient_main_tick_7_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * static inline void PStatClient::thread_tick(basic_string< char > const &)
 *******************************************************************/
static PyObject *Dtool_PStatClient_thread_tick_8(PyObject *self, PyObject *args,PyObject *kwds) {
    {
      // 1-static inline void PStatClient::thread_tick(basic_string< char > const &)
        char *param0_str; int param0_len;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "s#:threadTick", key_word_list, &param0_str, &param0_len));
        else
            (PyArg_Parse(args, "s#:threadTick", &param0_str, &param0_len));
        if(!PyErr_Occurred())
        {
            PStatClient::thread_tick(basic_string<char>(param0_str, param0_len));
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "threadTick(string)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PStatClient_thread_tick_8_comment =
    "C++ Interface:\n"
    "threadTick(string)\n"
    "\n"
    "";
#else
static const char * Dtool_PStatClient_thread_tick_8_comment = NULL;
#endif

int  Dtool_Init_PStatClient(PyObject *self, PyObject *args, PyObject *kwds)
{
       PyErr_SetString(PyExc_TypeError, "Error Can Not Init Constant Class (PStatClient)");
       return -1;
}
inline void  * Dtool_UpcastInterface_PStatClient(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PStatClient)
    {
        printf("PStatClient ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PStatClient * local_this = (PStatClient *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PStatClient)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PStatClient(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PStatClient)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PStatThread 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline void PStatThread::operator =(PStatThread const &copy)
 *******************************************************************/
static PyObject *Dtool_PStatThread_operator_11(PyObject *self, PyObject *args,PyObject *kwds) {
    PStatThread * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PStatThread,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PStatThread::operator =(PStatThread const &copy)
            PyObject *param1;
            static char * key_word_list[] = {(char *)"copy", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:assign", key_word_list, &param1));
            else
                (PyArg_Parse(args, "O:assign", &param1));
            if(!PyErr_Occurred())
            {
                PStatThread *param1_this = (PStatThread *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PStatThread, 1, "PStatThread.assign", 1, coerced_ptr, report_errors);

                if (!((param1_this == NULL)))
                {
                    (local_this)->operator =(*param1_this);
                    PStatThread *return_value = local_this;
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        return (PyObject *)NULL;
                      }
#endif
                      if (PyErr_Occurred()) {
                        return (PyObject *)NULL;
                      }
                      if(return_value == NULL)
                      {
                          Py_INCREF(Py_None);
                          return Py_None;
                      }
                      return DTool_CreatePyInstance((void *)return_value,Dtool_PStatThread,false, false);
                    }
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PStatThread.assign() on a const object.");
          return (PyObject *) NULL;
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "assign(non-const PStatThread this, const PStatThread copy)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PStatThread_operator_11_comment =
    "C++ Interface:\n"
    "assign(non-const PStatThread this, const PStatThread copy)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PStatThread::Copy Assignment Operator\n"
    "//       Access: Public\n"
    "//  Description:\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PStatThread_operator_11_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PStatThread::new_frame(void)
 *******************************************************************/
static PyObject *Dtool_PStatThread_new_frame_12(PyObject *self, PyObject *args,PyObject *kwds) {
    PStatThread * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PStatThread,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PStatThread::new_frame(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":newFrame", key_word_list));
        else
            (PyArg_Parse(args, ":newFrame"));
        if(!PyErr_Occurred())
        {
            (local_this)->new_frame();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PStatThread.newFrame() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "newFrame(non-const PStatThread this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PStatThread_new_frame_12_comment =
    "C++ Interface:\n"
    "newFrame(non-const PStatThread this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PStatThread::new_frame\n"
    "//       Access: Public\n"
    "//  Description: This must be called at the start of every \"frame\",\n"
    "//               whatever a frame may be deemed to be, to accumulate\n"
    "//               all the stats that have collected so far for the\n"
    "//               thread and ship them off to the server.\n"
    "//\n"
    "//               Calling PStatClient::thread_tick() will automatically\n"
    "//               call this for any threads with the indicated sync\n"
    "//               name.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PStatThread_new_frame_12_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * Thread *PStatThread::get_thread(void) const
 *******************************************************************/
static PyObject *Dtool_PStatThread_get_thread_13(PyObject *self, PyObject *args,PyObject *kwds) {
    PStatThread * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PStatThread,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-Thread *PStatThread::get_thread(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getThread", key_word_list));
        else
            (PyArg_Parse(args, ":getThread"));
        if(!PyErr_Occurred())
        {
            Thread *return_value = ((const PStatThread*)local_this)->get_thread();
            if (return_value != (Thread *)0) {
              return_value->ref();
            }
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              if(return_value == NULL)
              {
                  Py_INCREF(Py_None);
                  return Py_None;
              }
              return DTool_CreatePyInstanceTyped((void *)return_value,Dtool_Thread,true, false, (return_value)->as_typed_object()->get_type_index());
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getThread(const PStatThread this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PStatThread_get_thread_13_comment =
    "C++ Interface:\n"
    "getThread(const PStatThread this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PStatThread::get_thread\n"
    "//       Access: Published\n"
    "//  Description: Returns the Panda Thread object associated with this\n"
    "//               particular PStatThread.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PStatThread_get_thread_13_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PStatThread::get_index(void) const
 *******************************************************************/
static PyObject *Dtool_PStatThread_get_index_14(PyObject *self, PyObject *args,PyObject *kwds) {
    PStatThread * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PStatThread,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PStatThread::get_index(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getIndex", key_word_list));
        else
            (PyArg_Parse(args, ":getIndex"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PStatThread*)local_this)->get_index();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIndex(const PStatThread this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PStatThread_get_index_14_comment =
    "C++ Interface:\n"
    "getIndex(const PStatThread this)\n"
    "\n"
    "////////////////////////////////////////////////////////////////////\n"
    "//     Function: PStatThread::get_index\n"
    "//       Access: Published\n"
    "//  Description: Returns the index number of this particular thread\n"
    "//               within the PStatClient.\n"
    "////////////////////////////////////////////////////////////////////\n"
    "";
#else
static const char * Dtool_PStatThread_get_index_14_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PStatThread::PStatThread(PStatThread const &copy)
 * inline PStatThread::PStatThread(Thread *thread, PStatClient *client)
 * inline PStatThread::PStatThread(Thread *thread, PStatClient *client = ((void *)(0)))
 *******************************************************************/
int  Dtool_Init_PStatThread(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline PStatThread::PStatThread(PStatThread const &copy)
                PyObject *param0;
                static char * key_word_list[] = {(char *)"copy", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PStatThread", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PStatThread", &param0));
                if(!PyErr_Occurred())
                {
                    PStatThread *param0_this = (PStatThread *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PStatThread, 0, "PStatThread.PStatThread", 1, NULL, true);

                    if (!((param0_this == NULL)))
                    {
                        PStatThread *return_value = new PStatThread(*param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PStatThread,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline PStatThread::PStatThread(Thread *thread, PStatClient *client = ((void *)(0)))
                PyObject *param0;
                static char * key_word_list[] = {(char *)"thread", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:PStatThread", key_word_list, &param0));
                else
                    (PyArg_Parse(args, "O:PStatThread", &param0));
                if(!PyErr_Occurred())
                {
                    Thread *param0_this = (Thread *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Thread, 0, "PStatThread.PStatThread", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PStatThread *return_value = new PStatThread(param0_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PStatThread,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // 1-inline PStatThread::PStatThread(Thread *thread, PStatClient *client)
                PyObject *param0;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"thread", (char *)"client", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "OO:PStatThread", key_word_list, &param0, &param1))
                {
                    Thread *param0_this = (Thread *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_Thread, 0, "PStatThread.PStatThread", 0, coerced_ptr, report_errors);
PStatClient *param1_this = (PStatClient *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PStatClient, 1, "PStatThread.PStatThread", 0, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)|| (param1_this == NULL)))
                    {
                        PStatThread *return_value = new PStatThread(param0_this, param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PStatThread,true,false);
                        }
                    }
                }
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PStatThread() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PStatThread(const PStatThread copy)\n"
          "PStatThread(non-const Thread thread)\n"
          "PStatThread(non-const Thread thread, non-const PStatClient client)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PStatThread(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PStatThread)
    {
        printf("PStatThread ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PStatThread * local_this = (PStatThread *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PStatThread)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PStatThread(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PStatThread)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PStatCollector 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline bool PStatCollector::is_active(void)
 * inline bool PStatCollector::is_active(PStatThread const &)
 *******************************************************************/
static PyObject *Dtool_PStatCollector_is_active_18(PyObject *self, PyObject *args,PyObject *kwds) {
    PStatCollector * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PStatCollector,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline bool PStatCollector::is_active(void)
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":isActive", key_word_list));
            else
                (PyArg_Parse(args, ":isActive"));
            if(!PyErr_Occurred())
            {
                bool return_value = (local_this)->is_active();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyInt_FromLong(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PStatCollector.isActive() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline bool PStatCollector::is_active(PStatThread const &)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"param0", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:isActive", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:isActive", &param1));
                if(!PyErr_Occurred())
                {
                    PStatThread *param1_this = (PStatThread *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PStatThread, 1, "PStatCollector.isActive", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        bool return_value = (local_this)->is_active(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyInt_FromLong(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PStatCollector.isActive() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "isActive() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "isActive(non-const PStatCollector this)\n"
          "isActive(non-const PStatCollector this, const PStatThread)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PStatCollector_is_active_18_comment =
    "C++ Interface:\n"
    "isActive(non-const PStatCollector this)\n"
    "isActive(non-const PStatCollector this, const PStatThread)\n"
    "\n"
    "";
#else
static const char * Dtool_PStatCollector_is_active_18_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline bool PStatCollector::is_started(void)
 *******************************************************************/
static PyObject *Dtool_PStatCollector_is_started_19(PyObject *self, PyObject *args,PyObject *kwds) {
    PStatCollector * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PStatCollector,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline bool PStatCollector::is_started(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":isStarted", key_word_list));
        else
            (PyArg_Parse(args, ":isStarted"));
        if(!PyErr_Occurred())
        {
            bool return_value = (local_this)->is_started();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PStatCollector.isStarted() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "isStarted(non-const PStatCollector this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PStatCollector_is_started_19_comment =
    "C++ Interface:\n"
    "isStarted(non-const PStatCollector this)\n"
    "\n"
    "";
#else
static const char * Dtool_PStatCollector_is_started_19_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PStatCollector::start(void)
 * inline void PStatCollector::start(PStatThread const &)
 * inline void PStatCollector::start(PStatThread const &, float )
 *******************************************************************/
static PyObject *Dtool_PStatCollector_start_20(PyObject *self, PyObject *args,PyObject *kwds) {
    PStatCollector * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PStatCollector,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PStatCollector::start(void)
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":start", key_word_list));
            else
                (PyArg_Parse(args, ":start"));
            if(!PyErr_Occurred())
            {
                (local_this)->start();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PStatCollector.start() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void PStatCollector::start(PStatThread const &)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"param0", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:start", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:start", &param1));
                if(!PyErr_Occurred())
                {
                    PStatThread *param1_this = (PStatThread *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PStatThread, 1, "PStatCollector.start", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->start(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PStatCollector.start() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void PStatCollector::start(PStatThread const &, float )
                PyObject *param1;
                double param2;
                static char * key_word_list[] = {(char *)"param0", (char *)"param1", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Od:start", key_word_list, &param1, &param2))
                {
                    PStatThread *param1_this = (PStatThread *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PStatThread, 1, "PStatCollector.start", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->start(*param1_this, (float)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PStatCollector.start() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "start() takes 1, 2, or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "start(non-const PStatCollector this)\n"
          "start(non-const PStatCollector this, const PStatThread)\n"
          "start(non-const PStatCollector this, const PStatThread, float)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PStatCollector_start_20_comment =
    "C++ Interface:\n"
    "start(non-const PStatCollector this)\n"
    "start(non-const PStatCollector this, const PStatThread)\n"
    "start(non-const PStatCollector this, const PStatThread, float)\n"
    "\n"
    "";
#else
static const char * Dtool_PStatCollector_start_20_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PStatCollector::stop(void)
 * inline void PStatCollector::stop(PStatThread const &)
 * inline void PStatCollector::stop(PStatThread const &, float )
 *******************************************************************/
static PyObject *Dtool_PStatCollector_stop_21(PyObject *self, PyObject *args,PyObject *kwds) {
    PStatCollector * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PStatCollector,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PStatCollector::stop(void)
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":stop", key_word_list));
            else
                (PyArg_Parse(args, ":stop"));
            if(!PyErr_Occurred())
            {
                (local_this)->stop();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PStatCollector.stop() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void PStatCollector::stop(PStatThread const &)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"param0", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:stop", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:stop", &param1));
                if(!PyErr_Occurred())
                {
                    PStatThread *param1_this = (PStatThread *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PStatThread, 1, "PStatCollector.stop", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->stop(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PStatCollector.stop() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void PStatCollector::stop(PStatThread const &, float )
                PyObject *param1;
                double param2;
                static char * key_word_list[] = {(char *)"param0", (char *)"param1", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Od:stop", key_word_list, &param1, &param2))
                {
                    PStatThread *param1_this = (PStatThread *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PStatThread, 1, "PStatCollector.stop", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->stop(*param1_this, (float)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PStatCollector.stop() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "stop() takes 1, 2, or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "stop(non-const PStatCollector this)\n"
          "stop(non-const PStatCollector this, const PStatThread)\n"
          "stop(non-const PStatCollector this, const PStatThread, float)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PStatCollector_stop_21_comment =
    "C++ Interface:\n"
    "stop(non-const PStatCollector this)\n"
    "stop(non-const PStatCollector this, const PStatThread)\n"
    "stop(non-const PStatCollector this, const PStatThread, float)\n"
    "\n"
    "";
#else
static const char * Dtool_PStatCollector_stop_21_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PStatCollector::clear_level(void)
 * inline void PStatCollector::clear_level(PStatThread const &)
 *******************************************************************/
static PyObject *Dtool_PStatCollector_clear_level_22(PyObject *self, PyObject *args,PyObject *kwds) {
    PStatCollector * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PStatCollector,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PStatCollector::clear_level(void)
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":clearLevel", key_word_list));
            else
                (PyArg_Parse(args, ":clearLevel"));
            if(!PyErr_Occurred())
            {
                (local_this)->clear_level();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PStatCollector.clearLevel() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void PStatCollector::clear_level(PStatThread const &)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"param0", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:clearLevel", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:clearLevel", &param1));
                if(!PyErr_Occurred())
                {
                    PStatThread *param1_this = (PStatThread *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PStatThread, 1, "PStatCollector.clearLevel", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->clear_level(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PStatCollector.clearLevel() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "clearLevel() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "clearLevel(non-const PStatCollector this)\n"
          "clearLevel(non-const PStatCollector this, const PStatThread)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PStatCollector_clear_level_22_comment =
    "C++ Interface:\n"
    "clearLevel(non-const PStatCollector this)\n"
    "clearLevel(non-const PStatCollector this, const PStatThread)\n"
    "\n"
    "";
#else
static const char * Dtool_PStatCollector_clear_level_22_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PStatCollector::set_level(PStatThread const &, double )
 * inline void PStatCollector::set_level(double )
 *******************************************************************/
static PyObject *Dtool_PStatCollector_set_level_23(PyObject *self, PyObject *args,PyObject *kwds) {
    PStatCollector * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PStatCollector,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PStatCollector::set_level(double )
            double param1;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:setLevel", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:setLevel", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->set_level((double)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PStatCollector.setLevel() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void PStatCollector::set_level(PStatThread const &, double )
                PyObject *param1;
                double param2;
                static char * key_word_list[] = {(char *)"param0", (char *)"param1", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Od:setLevel", key_word_list, &param1, &param2))
                {
                    PStatThread *param1_this = (PStatThread *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PStatThread, 1, "PStatCollector.setLevel", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->set_level(*param1_this, (double)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PStatCollector.setLevel() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "setLevel() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "setLevel(non-const PStatCollector this, float)\n"
          "setLevel(non-const PStatCollector this, const PStatThread, float)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PStatCollector_set_level_23_comment =
    "C++ Interface:\n"
    "setLevel(non-const PStatCollector this, float)\n"
    "setLevel(non-const PStatCollector this, const PStatThread, float)\n"
    "\n"
    "";
#else
static const char * Dtool_PStatCollector_set_level_23_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PStatCollector::add_level(PStatThread const &, double )
 * inline void PStatCollector::add_level(double )
 *******************************************************************/
static PyObject *Dtool_PStatCollector_add_level_24(PyObject *self, PyObject *args,PyObject *kwds) {
    PStatCollector * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PStatCollector,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PStatCollector::add_level(double )
            double param1;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:addLevel", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:addLevel", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->add_level((double)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PStatCollector.addLevel() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void PStatCollector::add_level(PStatThread const &, double )
                PyObject *param1;
                double param2;
                static char * key_word_list[] = {(char *)"param0", (char *)"param1", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Od:addLevel", key_word_list, &param1, &param2))
                {
                    PStatThread *param1_this = (PStatThread *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PStatThread, 1, "PStatCollector.addLevel", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->add_level(*param1_this, (double)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PStatCollector.addLevel() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "addLevel() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "addLevel(non-const PStatCollector this, float)\n"
          "addLevel(non-const PStatCollector this, const PStatThread, float)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PStatCollector_add_level_24_comment =
    "C++ Interface:\n"
    "addLevel(non-const PStatCollector this, float)\n"
    "addLevel(non-const PStatCollector this, const PStatThread, float)\n"
    "\n"
    "";
#else
static const char * Dtool_PStatCollector_add_level_24_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PStatCollector::sub_level(PStatThread const &, double )
 * inline void PStatCollector::sub_level(double )
 *******************************************************************/
static PyObject *Dtool_PStatCollector_sub_level_25(PyObject *self, PyObject *args,PyObject *kwds) {
    PStatCollector * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PStatCollector,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline void PStatCollector::sub_level(double )
            double param1;
            static char * key_word_list[] = {(char *)"param0", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "d:subLevel", key_word_list, &param1));
            else
                (PyArg_Parse(args, "d:subLevel", &param1));
            if(!PyErr_Occurred())
            {
                (local_this)->sub_level((double)param1);
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return Py_BuildValue("");
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PStatCollector.subLevel() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline void PStatCollector::sub_level(PStatThread const &, double )
                PyObject *param1;
                double param2;
                static char * key_word_list[] = {(char *)"param0", (char *)"param1", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Od:subLevel", key_word_list, &param1, &param2))
                {
                    PStatThread *param1_this = (PStatThread *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PStatThread, 1, "PStatCollector.subLevel", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        (local_this)->sub_level(*param1_this, (double)param2);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return Py_BuildValue("");
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PStatCollector.subLevel() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "subLevel() takes 2 or 3 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "subLevel(non-const PStatCollector this, float)\n"
          "subLevel(non-const PStatCollector this, const PStatThread, float)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PStatCollector_sub_level_25_comment =
    "C++ Interface:\n"
    "subLevel(non-const PStatCollector this, float)\n"
    "subLevel(non-const PStatCollector this, const PStatThread, float)\n"
    "\n"
    "";
#else
static const char * Dtool_PStatCollector_sub_level_25_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PStatCollector::add_level_now(double )
 *******************************************************************/
static PyObject *Dtool_PStatCollector_add_level_now_26(PyObject *self, PyObject *args,PyObject *kwds) {
    PStatCollector * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PStatCollector,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PStatCollector::add_level_now(double )
        double param1;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:addLevelNow", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:addLevelNow", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->add_level_now((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PStatCollector.addLevelNow() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "addLevelNow(non-const PStatCollector this, float)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PStatCollector_add_level_now_26_comment =
    "C++ Interface:\n"
    "addLevelNow(non-const PStatCollector this, float)\n"
    "\n"
    "";
#else
static const char * Dtool_PStatCollector_add_level_now_26_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PStatCollector::sub_level_now(double )
 *******************************************************************/
static PyObject *Dtool_PStatCollector_sub_level_now_27(PyObject *self, PyObject *args,PyObject *kwds) {
    PStatCollector * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PStatCollector,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PStatCollector::sub_level_now(double )
        double param1;
        static char * key_word_list[] = {(char *)"param0", NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, "d:subLevelNow", key_word_list, &param1));
        else
            (PyArg_Parse(args, "d:subLevelNow", &param1));
        if(!PyErr_Occurred())
        {
            (local_this)->sub_level_now((double)param1);
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PStatCollector.subLevelNow() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "subLevelNow(non-const PStatCollector this, float)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PStatCollector_sub_level_now_27_comment =
    "C++ Interface:\n"
    "subLevelNow(non-const PStatCollector this, float)\n"
    "\n"
    "";
#else
static const char * Dtool_PStatCollector_sub_level_now_27_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline void PStatCollector::flush_level(void)
 *******************************************************************/
static PyObject *Dtool_PStatCollector_flush_level_28(PyObject *self, PyObject *args,PyObject *kwds) {
    PStatCollector * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PStatCollector,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    if (!((Dtool_PyInstDef *)self)->_is_const) {
      // 1-inline void PStatCollector::flush_level(void)
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":flushLevel", key_word_list));
        else
            (PyArg_Parse(args, ":flushLevel"));
        if(!PyErr_Occurred())
        {
            (local_this)->flush_level();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return Py_BuildValue("");
            }
        }
    } else {
      PyErr_SetString(PyExc_TypeError,
                      "Cannot call PStatCollector.flushLevel() on a const object.");
      return (PyObject *) NULL;
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "flushLevel(non-const PStatCollector this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PStatCollector_flush_level_28_comment =
    "C++ Interface:\n"
    "flushLevel(non-const PStatCollector this)\n"
    "\n"
    "";
#else
static const char * Dtool_PStatCollector_flush_level_28_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline double PStatCollector::get_level(void)
 * inline double PStatCollector::get_level(PStatThread const &)
 *******************************************************************/
static PyObject *Dtool_PStatCollector_get_level_29(PyObject *self, PyObject *args,PyObject *kwds) {
    PStatCollector * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PStatCollector,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(0):
        {
        if (!((Dtool_PyInstDef *)self)->_is_const) {
          // 1-inline double PStatCollector::get_level(void)
            static char * key_word_list[] = {NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, ":getLevel", key_word_list));
            else
                (PyArg_Parse(args, ":getLevel"));
            if(!PyErr_Occurred())
            {
                double return_value = (local_this)->get_level();
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    return (PyObject *)NULL;
                  }
#endif
                  if (PyErr_Occurred()) {
                    return (PyObject *)NULL;
                  }
                  return PyFloat_FromDouble(return_value);
                }
            }
        } else {
          PyErr_SetString(PyExc_TypeError,
                          "Cannot call PStatCollector.getLevel() on a const object.");
          return (PyObject *) NULL;
        }

        }
        break;
    case(1):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            if (!((Dtool_PyInstDef *)self)->_is_const) {
              // 1-inline double PStatCollector::get_level(PStatThread const &)
                PyObject *param1;
                static char * key_word_list[] = {(char *)"param0", NULL};
                // Special Case to Make operator work 
                if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                    (PyArg_ParseTupleAndKeywords(args,kwds, "O:getLevel", key_word_list, &param1));
                else
                    (PyArg_Parse(args, "O:getLevel", &param1));
                if(!PyErr_Occurred())
                {
                    PStatThread *param1_this = (PStatThread *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PStatThread, 1, "PStatCollector.getLevel", 1, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        double return_value = (local_this)->get_level(*param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            return (PyObject *)NULL;
                          }
#endif
                          if (PyErr_Occurred()) {
                            return (PyObject *)NULL;
                          }
                          return PyFloat_FromDouble(return_value);
                        }
                    }
                }
            } else {
              PyErr_SetString(PyExc_TypeError,
                              "Cannot call PStatCollector.getLevel() on a const object.");
              return (PyObject *) NULL;
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "getLevel() takes 1 or 2 arguments (%d given)", parameter_count + 1);
            return (PyObject *) NULL; 
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "getLevel(non-const PStatCollector this)\n"
          "getLevel(non-const PStatCollector this, const PStatThread)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PStatCollector_get_level_29_comment =
    "C++ Interface:\n"
    "getLevel(non-const PStatCollector this)\n"
    "getLevel(non-const PStatCollector this, const PStatThread)\n"
    "\n"
    "";
#else
static const char * Dtool_PStatCollector_get_level_29_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline int PStatCollector::get_index(void) const
 *******************************************************************/
static PyObject *Dtool_PStatCollector_get_index_30(PyObject *self, PyObject *args,PyObject *kwds) {
    PStatCollector * local_this = NULL;
    DTOOL_Call_ExtractThisPointerForType(self,&Dtool_PStatCollector,(void **)&local_this);
    if(local_this == NULL) {
       PyErr_SetString(PyExc_AttributeError, "C++ object is not yet constructed, or already destructed.");
       return NULL;
    }
    {
      // 1-inline int PStatCollector::get_index(void) const
        static char * key_word_list[] = {NULL};
        // Special Case to Make operator work 
        if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
            (PyArg_ParseTupleAndKeywords(args,kwds, ":getIndex", key_word_list));
        else
            (PyArg_Parse(args, ":getIndex"));
        if(!PyErr_Occurred())
        {
            int return_value = ((const PStatCollector*)local_this)->get_index();
            if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
              // TypeError raised; continue to next overload type.
            } else {
#ifndef NDEBUG
              Notify *notify = Notify::ptr();
              if (notify->has_assert_failed()) {
                PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                notify->clear_assert_failed();
                return (PyObject *)NULL;
              }
#endif
              if (PyErr_Occurred()) {
                return (PyObject *)NULL;
              }
              return PyInt_FromLong(return_value);
            }
        }
    }

    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "getIndex(const PStatCollector this)\n"
          "");
    return (PyObject *) NULL; 
}

#ifndef NDEBUG
static const char * Dtool_PStatCollector_get_index_30_comment =
    "C++ Interface:\n"
    "getIndex(const PStatCollector this)\n"
    "\n"
    "";
#else
static const char * Dtool_PStatCollector_get_index_30_comment = NULL;
#endif

/******************************************************************
 * Python type method wrapper for
 * inline PStatCollector::PStatCollector(PStatCollector const &parent, basic_string< char > const &name)
 * inline PStatCollector::PStatCollector(basic_string< char > const &name, PStatClient *client)
 * inline PStatCollector::PStatCollector(basic_string< char > const &name, PStatClient *client = ((void *)(0)))
 *******************************************************************/
int  Dtool_Init_PStatCollector(PyObject *self, PyObject *args, PyObject *kwds)  {
    int parameter_count = 1;
    if(PyTuple_Check(args))
    {
        parameter_count = PyTuple_Size(args);
        if(kwds != NULL && PyDict_Check(kwds))
              parameter_count += PyDict_Size(kwds);
    }
    switch(parameter_count)
    {
    case(1):
        {
        {
          // 1-inline PStatCollector::PStatCollector(basic_string< char > const &name, PStatClient *client = ((void *)(0)))
            char *param0_str; int param0_len;
            static char * key_word_list[] = {(char *)"name", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "s#:PStatCollector", key_word_list, &param0_str, &param0_len));
            else
                (PyArg_Parse(args, "s#:PStatCollector", &param0_str, &param0_len));
            if(!PyErr_Occurred())
            {
                PStatCollector *return_value = new PStatCollector(basic_string<char>(param0_str, param0_len));
                if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                  // TypeError raised; continue to next overload type.
                  delete return_value;
                } else {
#ifndef NDEBUG
                  Notify *notify = Notify::ptr();
                  if (notify->has_assert_failed()) {
                    PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                    notify->clear_assert_failed();
                    delete return_value;
                    return -1;
                  }
#endif
                  if (PyErr_Occurred()) {
                    delete return_value;
                    return -1;
                  }
                  return DTool_PyInit_Finalize(self, return_value,&Dtool_PStatCollector,true,false);
                }
            }
        }

        }
        break;
    case(2):
        {
        {
          PyObject *coerced = NULL;
          PyObject **coerced_ptr = NULL;
          bool report_errors = false;
          while (true) {
            {
              // -2 inline PStatCollector::PStatCollector(basic_string< char > const &name, PStatClient *client)
                char *param0_str; int param0_len;
                PyObject *param1;
                static char * key_word_list[] = {(char *)"name", (char *)"client", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "s#O:PStatCollector", key_word_list, &param0_str, &param0_len, &param1))
                {
                    PStatClient *param1_this = (PStatClient *)DTOOL_Call_GetPointerThisClass(param1, &Dtool_PStatClient, 1, "PStatCollector.PStatCollector", 0, coerced_ptr, report_errors);

                    if (!((param1_this == NULL)))
                    {
                        PStatCollector *return_value = new PStatCollector(basic_string<char>(param0_str, param0_len), param1_this);
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PStatCollector,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            {
              // -2 inline PStatCollector::PStatCollector(PStatCollector const &parent, basic_string< char > const &name)
                PyObject *param0;
                char *param1_str; int param1_len;
                static char * key_word_list[] = {(char *)"parent", (char *)"name", NULL};
                if (PyArg_ParseTupleAndKeywords(args,kwds, "Os#:PStatCollector", key_word_list, &param0, &param1_str, &param1_len))
                {
                    PStatCollector *param0_this = (PStatCollector *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PStatCollector, 0, "PStatCollector.PStatCollector", 1, coerced_ptr, report_errors);

                    if (!((param0_this == NULL)))
                    {
                        PStatCollector *return_value = new PStatCollector(*param0_this, basic_string<char>(param1_str, param1_len));
                        Py_XDECREF(coerced);
                        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                          // TypeError raised; continue to next overload type.
                          delete return_value;
                        } else {
#ifndef NDEBUG
                          Notify *notify = Notify::ptr();
                          if (notify->has_assert_failed()) {
                            PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                            notify->clear_assert_failed();
                            delete return_value;
                            return -1;
                          }
#endif
                          if (PyErr_Occurred()) {
                            delete return_value;
                            return -1;
                          }
                          return DTool_PyInit_Finalize(self, return_value,&Dtool_PStatCollector,true,false);
                        }
                    }
                }
                PyErr_Clear(); 
            }

            if (coerced_ptr == NULL && !report_errors) {
              coerced_ptr = &coerced;
              continue;
            }
            if (!report_errors) {
              report_errors = true;
              continue;
            }
            break;
          }
          Py_XDECREF(coerced);
        }
        }
        break;
    default:
        {
            PyErr_Format(PyExc_TypeError, "PStatCollector() takes 1 or 2 arguments (%d given)", parameter_count + 0);
            return -1;
        }
        break;
    }
    if(!PyErr_Occurred()) // let error pass on 
        PyErr_SetString(PyExc_TypeError, 
          "Arguments must match one of:\n"
          "PStatCollector(string name)\n"
          "PStatCollector(string name, non-const PStatClient client)\n"
          "PStatCollector(const PStatCollector parent, string name)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PStatCollector(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PStatCollector)
    {
        printf("PStatCollector ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PStatCollector * local_this = (PStatCollector *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PStatCollector)
        return local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PStatCollector(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PStatCollector)
        return from_this;
    return (void *) NULL;
}
//********************************************************************
//*** Functions for .. PStatCollectorForward 
//********************************************************************
/******************************************************************
 * Python type method wrapper for
 * inline PStatCollectorForward::PStatCollectorForward(PStatCollector const &col)
 *******************************************************************/
int  Dtool_Init_PStatCollectorForward(PyObject *self, PyObject *args, PyObject *kwds)  {
    {
      PyObject *coerced = NULL;
      PyObject **coerced_ptr = NULL;
      bool report_errors = false;
      while (true) {
        {
          // 1-inline PStatCollectorForward::PStatCollectorForward(PStatCollector const &col)
            PyObject *param0;
            static char * key_word_list[] = {(char *)"col", NULL};
            // Special Case to Make operator work 
            if(PyTuple_Check(args) || (kwds != NULL && PyDict_Check(kwds)))
                (PyArg_ParseTupleAndKeywords(args,kwds, "O:PStatCollectorForward", key_word_list, &param0));
            else
                (PyArg_Parse(args, "O:PStatCollectorForward", &param0));
            if(!PyErr_Occurred())
            {
                PStatCollector *param0_this = (PStatCollector *)DTOOL_Call_GetPointerThisClass(param0, &Dtool_PStatCollector, 0, "PStatCollectorForward.PStatCollectorForward", 1, coerced_ptr, report_errors);

                if (!((param0_this == NULL)))
                {
                    PStatCollectorForward *return_value = new PStatCollectorForward(*param0_this);
                    return_value->ref();
                    Py_XDECREF(coerced);
                    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_TypeError)) {
                      // TypeError raised; continue to next overload type.
                      delete return_value;
                    } else {
#ifndef NDEBUG
                      Notify *notify = Notify::ptr();
                      if (notify->has_assert_failed()) {
                        PyErr_SetString(PyExc_AssertionError, notify->get_assert_error_message().c_str());
                        notify->clear_assert_failed();
                        delete return_value;
                        return -1;
                      }
#endif
                      if (PyErr_Occurred()) {
                        delete return_value;
                        return -1;
                      }
                      return DTool_PyInit_Finalize(self, return_value,&Dtool_PStatCollectorForward,true,false);
                    }
                }
            }
        }

        if (coerced_ptr == NULL && !report_errors) {
          coerced_ptr = &coerced;
          continue;
        }
        if (!report_errors) {
          report_errors = true;
          continue;
        }
        break;
      }
      Py_XDECREF(coerced);
    }
    if(!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
          "Must Match :\n"
          "PStatCollectorForward(const PStatCollector col)\n"
          "");
    return -1;
}


inline void  * Dtool_UpcastInterface_PStatCollectorForward(PyObject *self, Dtool_PyTypedObject *requested_type)
{
    Dtool_PyTypedObject *SelfType = ((Dtool_PyInstDef *)self)->_My_Type;
    if(SelfType != &Dtool_PStatCollectorForward)
    {
        printf("PStatCollectorForward ** Bad Source Type-- Requesting Conversion from %s to %s\n",((Dtool_PyInstDef *)self)->_My_Type->_name,requested_type->_name);fflush(NULL);
        return NULL;
    }
 
    PStatCollectorForward * local_this = (PStatCollectorForward *)((Dtool_PyInstDef *)self)->_ptr_to_object;
    if(requested_type == &Dtool_PStatCollectorForward)
        return local_this;
    if(requested_type == &Dtool_PStatCollectorForwardBase)
        return ( PStatCollectorForwardBase *) local_this;
    if(requested_type == &Dtool_ReferenceCount)
        return ( ReferenceCount *)( PStatCollectorForwardBase *) local_this;
    return NULL;
}
inline void  * Dtool_DowncastInterface_PStatCollectorForward(void *from_this, Dtool_PyTypedObject *from_type)
{
    if(from_this == NULL || from_type == NULL)
        return NULL;
    if(from_type == &Dtool_PStatCollectorForward)
        return from_this;
    if(from_type == &Dtool_PStatCollectorForwardBase)
    {
          PStatCollectorForwardBase* other_this = (PStatCollectorForwardBase*)from_this;
          return (PStatCollectorForward*)other_this;
    }
    if(from_type == &Dtool_ReferenceCount)
    {
          ReferenceCount* other_this = (ReferenceCount*)from_this;
          return (PStatCollectorForward*)other_this;
    }
    return (void *) NULL;
}
//********************************************************************
//*** Py Init Code For .. PStatClient | PStatClient
//********************************************************************
PyMethodDef Dtool_Methods_PStatClient[]= {
  { "connect",(PyCFunction ) &Dtool_PStatClient_connect_3, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PStatClient_connect_3_comment},
  { "disconnect",(PyCFunction ) &Dtool_PStatClient_disconnect_4, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PStatClient_disconnect_4_comment},
  { "isConnected",(PyCFunction ) &Dtool_PStatClient_is_connected_5, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PStatClient_is_connected_5_comment},
  { "resumeAfterPause",(PyCFunction ) &Dtool_PStatClient_resume_after_pause_6, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PStatClient_resume_after_pause_6_comment},
  { "mainTick",(PyCFunction ) &Dtool_PStatClient_main_tick_7, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PStatClient_main_tick_7_comment},
  { "threadTick",(PyCFunction ) &Dtool_PStatClient_thread_tick_8, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PStatClient_thread_tick_8_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PStatClient(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_PStatClient.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_PStatClient.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PStatClient.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PStatClient.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PStatClient.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PStatClient)");
             printf(" Error In PyType_ReadyPStatClient");
             return;
        }
        Py_INCREF(&Dtool_PStatClient.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PStatClient.As_PyTypeObject().tp_dict,"PStatClient",&Dtool_PStatClient.As_PyObject());
        //  Static Method connect
        PyDict_SetItemString(Dtool_PStatClient.As_PyTypeObject().tp_dict,"connect",PyCFunction_New(&Dtool_Methods_PStatClient[0],&Dtool_PStatClient.As_PyObject()));
        //  Static Method disconnect
        PyDict_SetItemString(Dtool_PStatClient.As_PyTypeObject().tp_dict,"disconnect",PyCFunction_New(&Dtool_Methods_PStatClient[1],&Dtool_PStatClient.As_PyObject()));
        //  Static Method isConnected
        PyDict_SetItemString(Dtool_PStatClient.As_PyTypeObject().tp_dict,"isConnected",PyCFunction_New(&Dtool_Methods_PStatClient[2],&Dtool_PStatClient.As_PyObject()));
        //  Static Method resumeAfterPause
        PyDict_SetItemString(Dtool_PStatClient.As_PyTypeObject().tp_dict,"resumeAfterPause",PyCFunction_New(&Dtool_Methods_PStatClient[3],&Dtool_PStatClient.As_PyObject()));
        //  Static Method mainTick
        PyDict_SetItemString(Dtool_PStatClient.As_PyTypeObject().tp_dict,"mainTick",PyCFunction_New(&Dtool_Methods_PStatClient[4],&Dtool_PStatClient.As_PyObject()));
        //  Static Method threadTick
        PyDict_SetItemString(Dtool_PStatClient.As_PyTypeObject().tp_dict,"threadTick",PyCFunction_New(&Dtool_Methods_PStatClient[5],&Dtool_PStatClient.As_PyObject()));
        RegisterRuntimeClass(&Dtool_PStatClient,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PStatClient.As_PyTypeObject());
        PyModule_AddObject(module, "PStatClient",(PyObject *)&Dtool_PStatClient.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PStatThread | PStatThread
//********************************************************************
PyMethodDef Dtool_Methods_PStatThread[]= {
  { "assign",(PyCFunction ) &Dtool_PStatThread_operator_11, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PStatThread_operator_11_comment},
  { "newFrame",(PyCFunction ) &Dtool_PStatThread_new_frame_12, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PStatThread_new_frame_12_comment},
  { "getThread",(PyCFunction ) &Dtool_PStatThread_get_thread_13, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PStatThread_get_thread_13_comment},
  { "getIndex",(PyCFunction ) &Dtool_PStatThread_get_index_14, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PStatThread_get_index_14_comment},
  { "__copy__", (PyCFunction)&copy_from_copy_constructor, METH_NOARGS, NULL},
  { "__deepcopy__", (PyCFunction)&map_deepcopy_to_copy, METH_VARARGS, NULL},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PStatThread(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PStatThread.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PStatThread\n"
          "// Description : A lightweight class that represents a single thread\n"
          "//               of execution to PStats.  It corresponds one-to-one\n"
          "//               with Panda's Thread instance.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_PStatThread.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_PStatThread.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PStatThread.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PStatThread.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PStatThread.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PStatThread)");
             printf(" Error In PyType_ReadyPStatThread");
             return;
        }
        Py_INCREF(&Dtool_PStatThread.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PStatThread.As_PyTypeObject().tp_dict,"PStatThread",&Dtool_PStatThread.As_PyObject());
        RegisterRuntimeClass(&Dtool_PStatThread,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PStatThread.As_PyTypeObject());
        PyModule_AddObject(module, "PStatThread",(PyObject *)&Dtool_PStatThread.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PStatCollector | PStatCollector
//********************************************************************
PyMethodDef Dtool_Methods_PStatCollector[]= {
  { "isActive",(PyCFunction ) &Dtool_PStatCollector_is_active_18, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PStatCollector_is_active_18_comment},
  { "isStarted",(PyCFunction ) &Dtool_PStatCollector_is_started_19, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PStatCollector_is_started_19_comment},
  { "start",(PyCFunction ) &Dtool_PStatCollector_start_20, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PStatCollector_start_20_comment},
  { "stop",(PyCFunction ) &Dtool_PStatCollector_stop_21, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PStatCollector_stop_21_comment},
  { "clearLevel",(PyCFunction ) &Dtool_PStatCollector_clear_level_22, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PStatCollector_clear_level_22_comment},
  { "setLevel",(PyCFunction ) &Dtool_PStatCollector_set_level_23, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PStatCollector_set_level_23_comment},
  { "addLevel",(PyCFunction ) &Dtool_PStatCollector_add_level_24, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PStatCollector_add_level_24_comment},
  { "subLevel",(PyCFunction ) &Dtool_PStatCollector_sub_level_25, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PStatCollector_sub_level_25_comment},
  { "addLevelNow",(PyCFunction ) &Dtool_PStatCollector_add_level_now_26, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PStatCollector_add_level_now_26_comment},
  { "subLevelNow",(PyCFunction ) &Dtool_PStatCollector_sub_level_now_27, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PStatCollector_sub_level_now_27_comment},
  { "flushLevel",(PyCFunction ) &Dtool_PStatCollector_flush_level_28, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PStatCollector_flush_level_28_comment},
  { "getLevel",(PyCFunction ) &Dtool_PStatCollector_get_level_29, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PStatCollector_get_level_29_comment},
  { "getIndex",(PyCFunction ) &Dtool_PStatCollector_get_index_30, METH_VARARGS| METH_KEYWORDS, (char *)Dtool_PStatCollector_get_index_30_comment},
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PStatCollector(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PStatCollector.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PStatCollector\n"
          "// Description : A lightweight class that represents a single element\n"
          "//               that may be timed and/or counted via stats.\n"
          "//\n"
          "//               Collectors can be used to measure two different kinds\n"
          "//               of values: elapsed time, and \"other\".\n"
          "//\n"
          "//               To measure elapsed time, call start() and stop() as\n"
          "//               appropriate to bracket the section of code you want\n"
          "//               to time (or use a PStatTimer to do this\n"
          "//               automatically).\n"
          "//\n"
          "//               To measure anything else, call set_level() and/or\n"
          "//               add_level() to set the \"level\" value associated with\n"
          "//               this collector.  The meaning of the value set for the\n"
          "//               \"level\" is entirely up to the user; it may represent\n"
          "//               the number of triangles rendered or the kilobytes of\n"
          "//               texture memory consumed, for instance.  The level set\n"
          "//               will remain fixed across multiple frames until it is\n"
          "//               reset via another set_level() or adjusted via a call\n"
          "//               to add_level().  It may also be completely removed\n"
          "//               via clear_level().\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_DTOOL_SUPPER_BASE._Dtool_ClassInit(NULL);
        Dtool_PStatCollector.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_DTOOL_SUPPER_BASE.As_PyTypeObject());
        Dtool_PStatCollector.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PStatCollector.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PStatCollector.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PStatCollector.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PStatCollector)");
             printf(" Error In PyType_ReadyPStatCollector");
             return;
        }
        Py_INCREF(&Dtool_PStatCollector.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PStatCollector.As_PyTypeObject().tp_dict,"PStatCollector",&Dtool_PStatCollector.As_PyObject());
        RegisterRuntimeClass(&Dtool_PStatCollector,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PStatCollector.As_PyTypeObject());
        PyModule_AddObject(module, "PStatCollector",(PyObject *)&Dtool_PStatCollector.As_PyTypeObject());
    }
}
//********************************************************************
//*** Py Init Code For .. PStatCollectorForward | PStatCollectorForward
//********************************************************************
PyMethodDef Dtool_Methods_PStatCollectorForward[]= {
  { NULL, NULL }
};

void   Dtool_PyModuleClassInit_PStatCollectorForward(PyObject *module)
{
    static bool initdone = false;
    if(!initdone)
    {
        initdone = true;
#ifndef NDEBUG
        // Class documentation string
        Dtool_PStatCollectorForward.As_PyTypeObject().tp_doc =
          "////////////////////////////////////////////////////////////////////\n"
          "//       Class : PStatCollectorForward\n"
          "// Description : This class serves as a cheap forward reference to a\n"
          "//               PStatCollector, so that classes that are defined\n"
          "//               before the pstats module may access the\n"
          "//               PStatCollector.\n"
          "////////////////////////////////////////////////////////////////////";
#endif
        // Dependent Objects   
        Dtool_PStatCollectorForwardBase._Dtool_ClassInit(NULL);
        Dtool_PStatCollectorForward.As_PyTypeObject().tp_bases = Py_BuildValue("(O)",&Dtool_PStatCollectorForwardBase.As_PyTypeObject());
        Dtool_PStatCollectorForward.As_PyTypeObject().tp_dict = PyDict_New();
        PyDict_SetItemString(Dtool_PStatCollectorForward.As_PyTypeObject().tp_dict,"DtoolClassDict",Dtool_PStatCollectorForward.As_PyTypeObject().tp_dict);
        if(PyType_Ready(&Dtool_PStatCollectorForward.As_PyTypeObject()) < 0)
        {
             PyErr_SetString(PyExc_TypeError, "PyType_Ready(PStatCollectorForward)");
             printf(" Error In PyType_ReadyPStatCollectorForward");
             return;
        }
        Py_INCREF(&Dtool_PStatCollectorForward.As_PyTypeObject());
        PyDict_SetItemString(Dtool_PStatCollectorForward.As_PyTypeObject().tp_dict,"PStatCollectorForward",&Dtool_PStatCollectorForward.As_PyObject());
        RegisterRuntimeClass(&Dtool_PStatCollectorForward,-1);
    }
    if(module != NULL)
    {
        Py_INCREF(&Dtool_PStatCollectorForward.As_PyTypeObject());
        PyModule_AddObject(module, "PStatCollectorForward",(PyObject *)&Dtool_PStatCollectorForward.As_PyTypeObject());
    }
}

//********************************************************************
//*** Module Object Linker .. 
//********************************************************************
static void BuildInstants(PyObject * module)
{
//********************************************************************
//*** Module Init Updcall ..PStatClient
//********************************************************************
   Dtool_PyModuleClassInit_PStatClient(module);
//********************************************************************
//*** Module Init Updcall ..PStatThread
//********************************************************************
   Dtool_PyModuleClassInit_PStatThread(module);
//********************************************************************
//*** Module Init Updcall ..PStatCollector
//********************************************************************
   Dtool_PyModuleClassInit_PStatCollector(module);
//********************************************************************
//*** Module Init Updcall ..PStatCollectorForward
//********************************************************************
   Dtool_PyModuleClassInit_PStatCollectorForward(module);
//********************************************************************
//*** Module Init Updcall ..  Externally Defined Class
//********************************************************************
}
static PyMethodDef python_simple_funcs[] = {
  //Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference,METH_VARARGS,"Used to borrow 'this' poiner ( to, from)\n Assumes no ownership"}, 
  {"Dtool_AddToDictionary", &Dtool_AddToDictionary,METH_VARARGS,"Used to Items Into a types (tp_dict)"}, 
  { NULL, NULL ,0,NULL}
};

struct LibrayDef libpstatclient_moddef = {python_simple_funcs,BuildInstants};
static InterrogateModuleDef _in_module_def = {
  1687212832,  /* file_identifier */
  "libpstatclient",  /* library_name */
  "hqKx",  /* library_hash_name */
  "panda",  /* module_name */
  "libpstatclient.in",  /* database_filename */
  (InterrogateUniqueNameDef *)0,  /* unique_names */
  0,  /* num_unique_names */
  (void **)0,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  95  /* next_index */
};

Configure(_in_configure_libpstatclient);
ConfigureFn(_in_configure_libpstatclient) {
  interrogate_request_module(&_in_module_def);
}

